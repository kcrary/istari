
File.import "bar-aux.iml";


Namespace.beginModule "Bar";


lemma "pause_type"
/
  pause :
  intersect i (a : U i) .
    a -> a
/;

introOf /i a/.
unfoldHead /pause/.
typecheck.
qed ();
recordTyping "pause_type";



define /ffix a f/
/
  pause
    (fn x . f (let next x' = x in next (pause x' x)))
    (next
       (fn x . f (let next x' = x in next (pause x' x))))
//
  intersect (i : level) .
  forall (a : U i) .
    (future a -> a) -> a
/;

introOf /i a f/.
unfold /ffix/.
goalCaseT /of _ (pause ? _) => \(fnc m => set /g/ /\m\/)\ /.
assert /g : rec t . (future t -> a)/ /Hof/.
  {
  unfold /g/.
  unrollType /rec/.
  typecheck.
  reintro /x x'/.
  unroll /pause/.
  unrollType /rec in x'/.
  typecheck.
  }
fold /g , g/.
convert /pause ap _ ap (future (rec t . (future t -> a)) -> a)/.
typecheck.
unrollType /rec/.
reflexivity.
qed ();



val unroll_ffix = makeReduction1
/
ffix a f --> f (next (ffix a f)) ;
unfolding ffix letnext
unrolling pause
/;

Database.setUnroll (parseConstant /ffix/) (Reduction.user1 unroll_ffix);
writeRegistry /unroll_ffix/ /reduction1/ unroll_ffix;



define /bar a/
/
  rec t . a % future t
//
  intersect i . U i -> U i
/;

inference.
introOf /i/.
unfoldHead /bar/.
typecheck.
qed ();

val bar = parseConstant /bar/;



lemma "bar_unroll" 
/
  forall (i : level) (a : U i) . bar a = (a % future (bar a)) : type
/;

intro /i a/.
unrollType /bar/.
reflexivity.
qed ();

val bar_unroll = parseConstant /bar_unroll/;



define /now {a} x/
/
  inl x
//
  intersect i .
  forall (a : U i) .
    a -> bar a
/;

inference.
introOf /i a x/.
unfold /now/.
rewrite /-> bar_unroll/.
typecheck.
qed ();

val now = parseConstant /now/;



define /laterf {a} x/
/
  inr x
//
  intersect i .
  forall (a : U i) .
    future (bar a) -> bar a
/;

inference.
introOf /i a x/.
unfold /laterf/.
rewrite /-> bar_unroll/.
typecheck.
qed ();

val laterf = parseConstant /laterf/;



define /later {a} x/
/
  laterf (next x)
//
  intersect i .
  forall (a : U i) .
    bar a -> bar a
/;

inference.
introOf /i a x/.
unfold /later/.
typecheck.
qed ();



define /bindbar {a b} x f/
/
  ffix (bar a -> bar b)
    (fn g x .
       (case x of
        | inl y . f y
        | inr y .
            let next g' = g
            in
            let next y' = y
            in
              inr (next (g' y'))))
    x
//
  intersect i .
  forall (a b : U i) .
    bar a
    -> (a -> bar b)
    -> bar b
/;

inference.
introOf /i a b x f/.
unfold /bindbar/.
so /bar_unroll i a/ /Heq/.
typecheck.
unrollType /bar/.
typecheck.
qed ();

val bindbar = parseConstant /bindbar/;



reductions 
/
bindbar _ _ (now _ x) f --> f x ;
bindbar a b (later _ x) f --> later b (bindbar a b x f) ;
bindbar a b (laterf _ x) f --> let next y = x in later b (bindbar a b y f) ;
unfolding letnext bindbar now later laterf
unrolling ffix
/;



define /bindbart {a} x b/
/
  ffix bogus
    (fn g x .
       (case x of
        | inl y . b y
        | inr y .
            let next g' = g
            in
            let next y' = y
            in
              future (g' y')))
    x
//
  intersect i .
  forall (a : U i) .
    bar a 
    -> (a -> U i)
    -> U i
/;

inference.
introOf /i a x b/.
unfold /bindbart/.
unfold /ffix/.
fold /ffix 
        (bar a -> U i)
        (fn g x .
           (case x of
            | inl y . b y
            | inr y .
                let next g' = g
                in
                let next y' = y
                in
                  future (g' y')))
        x/.
typecheck.
unrollType /bar/.
typecheck.
qed ();

val bindbart = parseConstant /bindbart/;



reductions
/
  bindbart _ (now _ x) b --> b x ;
  bindbart a (later _ x) b --> future (bindbart a x b) ;
  bindbart a (laterf _ x) b --> let next y = x in future (bindbart a y b) ;
  unfolding letnext bindbart now later laterf
  unrolling ffix
/;



writeRegistry /AfterBindbarEnv/
  /[constant constant]/
  (Collapse (bindbar, bindbart));
structure Nothing = AfterBindbar ();
grammaron Bar;



lemma "bar_subtype"
/
  forall i (a b : U i) .
    a <: b
    -> bar a <: bar b
/;

inference.
intro /i a b Hsub/.
apply /ffix/.
intro /Hsubbar x/.
rewrite /-> bar_unroll in x in concl/.
destruct /x/ /x | [x]/.
  {
  typecheck.
  }

  {
  destruct /Hsubbar/ /[Hsubbar]/.
  (* The typechecker won't find Hsubbar because it's in the future when we start.
     We need to do this in two stages so it refreshes its table after moving into
     the future.
  *)
  fold /manual x/.
  typecheck.
  typecheck.
  }
qed ();

val bar_subtype = parseConstant /bar_subtype/;



define /bfix {a} f/
/
  ffix (bar a) (fn x . f (inr x))
//
  intersect i .
  forall (a : U i) .
    (bar a -> bar a) -> bar a
/;

inference.
introOf /i a f/.
unfold /bfix/.
typecheck.
unrollType /bar/.
typecheck.
qed ();



(* At this point we'd like to follow the development in Smith [1988]
   and define a termination predicate.  Alas, we cannot.  Istari's
   step-indexed semantics is unable to express liveness properties
   such as termination.  If it could express termination, we would be
   able to draw a contradiction, because the fixed-point typing rule
   above (bfix_type) does not have Smith's admissibility requirement.
   (See Smith [1988], theorem 60.)
*)



lemma "bar_induction"
/
  forall i (a : U i) (P : bar a -> U i) .
    (forall (x : a) . P (now x))
    -> (forall (xf : future (bar a)) .
          let next x = xf
          in
            future (P x) -> P (laterf xf))
    -> forall (x : bar a) . P x
/;

inference.
intro /i a P Hbase Hind/.
apply /ffix ap i/.
intro /IH x/.
unrollType /bar in x/.
destruct /x/ /x | [x]/.
  {
  fold /now x/.
  apply /Hbase/.
  }

  {
  fold /laterf _/.
  apply /Hind (next x)/.
  destruct /IH/ /[IH]/.
  split.
  apply /IH/ >> auto.
  }
qed ();

val bar_induction = parseConstant /bar_induction/;



writeRegistry /AfterBarAllEnv/
  /[constant constant constant constant constant constant]/
  (Collapse (bar, bar_unroll, now, laterf, bar_subtype, bar_induction));


endModule ();
