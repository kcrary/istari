
File.import "bar-aux.iml";


Namespace.beginModule "Bar";


lemma "pause_type"
/
  pause :
  intersect i (a : U i) .
    a -> a
/;

introOf /i a/.
unfoldHead /pause/.
typecheck.
qed ();
recordTyping "pause_type";



define /ffix a f/
/
  pause
    (fn x . f (let next x' = x in next (pause x' x)))
    (next
       (fn x . f (let next x' = x in next (pause x' x))))
//
  intersect (i : level) .
  forall (a : U i) .
    (future a -> a) -> a
/;

introOf /i a f/.
unfold /ffix/.
goalCase /of _ (pause ? _) => \(fnc m => set /g/ /\m\/)\ /.
assert /g : rec t . (future t -> a)/ /Hof/.
  {
  unfold /g/.
  unrollType /rec/.
  typecheck.
  reintro /x x'/.
  unroll /pause/.
  unrollType /rec in x'/.
  typecheck.
  }
fold /g , g/.
convert /pause ap _ ap (future (rec t . (future t -> a)) -> a)/.
typecheck.
unrollType /rec in Hof/.
auto.
qed ();



val unroll_ffix = makeReduction1
/
ffix a f --> f (next (ffix a f)) ;
unfolding ffix letnext
unrolling pause
/;

Database.setUnroll (parseConstant /ffix/) (Reduction.user1 unroll_ffix);
Registry.write (parseIdent /unroll_ffix/) (Registry.fromUreduction1 unroll_ffix);



define /bar a/
/
  rec t . a % future t
//
  intersect i . U i -> U i
/;

inference.
introOf /i/.
unfoldHead /bar/.
typecheck.
qed ();



lemma "bar_unroll" 
/
  forall (i : level) (a : U i) . bar a = (a % future (bar a)) : type
/;

intro /i a/.
unrollType /bar/.
qed ();



define /now {a} x/
/
  inl x
//
  intersect i .
  forall (a : U i) .
    a -> bar a
/;

inference.
introOf /i a x/.
unfold /now/.
rewrite /-> bar_unroll/.
typecheck.
qed ();



define /later {a} x/
/
  inr (next x)
//
  intersect i .
  forall (a : U i) .
    bar a -> bar a
/;

inference.
introOf /i a x/.
unfold /later/.
rewrite /-> bar_unroll/.
typecheck.
qed ();



defineRaw /bindbar {a b} x f/
/
  ffix (bar a -> bar b)
    (fn g x .
       (case x of
        | inl y . f y
        | inr y .
            let next g' = g
            in
            let next y' = y
            in
              inr (next (g' y'))))
    x
/;



grammaron Bar;
structure Nothing = AfterBindbar ();



lemma "bindbar_type"
/
  ` bindbar :
  intersect i .
  forall (a b : U i) .
    bar a
    -> (a -> bar b)
    -> bar b
/;

inference.
introOf /i a b x f/.
unfold /bindbar/.
so /bar_unroll i a/ /Heq/.
typecheck.
unrollType /bar/.
typecheck.
qed ();
recordTyping "bindbar_type";



reductions 
/
bindbar _ _ (now _ x) f --> f x ;
bindbar a b (later _ x) f --> later b (` bindbar a b x f) ;
unfolding letnext bindbar now later
unrolling ffix
/;



define /bfix {a} f/
/
  ffix (bar a) (fn x . f (inr x))
//
  intersect i .
  forall (a : U i) .
    (bar a -> bar a) -> bar a
/;

inference.
introOf /i a f/.
unfold /bfix/.
typecheck.
unrollType /bar/.
typecheck.
qed ();



(* At this point we'd like to follow the development in Smith [1988]
   and define a termination predicate.  Alas, we cannot.  Istari's
   step-indexed semantics is unable to express liveness properties
   such as termination.  If it could express termination, we would be
   able to draw a contradiction, because the fixed-point typing rule
   above (bfix_type) does not have Smith's admissibility requirement.
   (See Smith [1988], theorem 60.)
*)

Namespace.endModule ();
