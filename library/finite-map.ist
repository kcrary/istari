
File.import "bool-load.iml";
File.import "decidable-load.iml";
File.import "function-load.iml";
File.import "kindlike-load.iml";
File.import "list-load.iml";
File.import "logic-load.iml";
File.import "option-load.iml";

openModule /Bool/;
openModule /Option/;
openModule /List/;

aliasModule /F/ /Function/;
aliasModule /K/ /Kindlike/;

beginModule "FiniteMap";


(* Generic finite maps *)
beginModule "Class";


define /FiniteMap i A B T emp look upd rem/
/
  (forall f g .
     (forall a . look f a = look g a : option B)
     -> f = g : T)
  &
  (forall a a' . Decidable.decidable (a = a' : A))
  &
  (forall a . look emp a = None : option B)
  &
  (forall f a b . look (upd f a b) a = Some b : option B)
  &
  (forall f a b a' . a != a' : A -> look (upd f a b) a' = look f a' : option B)
  &
  (forall f a . look (rem f a) a = None : option B)
  &
  (forall f a a' . a != a' : A -> look (rem f a) a' = look f a' : option B)
  &
  unit
//
  forall i (A B : U i) (T : U i) .
    T
    -> (T -> A -> option B)
    -> (T -> A -> B -> T)
    -> (T -> A -> T)
    -> U i
/;

unfold /FiniteMap/.
inference.
typecheck.
qed ();



lemma "FiniteMap_ext"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f g .
         (forall a . look f a = look g a : option B)
         -> f = g : T
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 0/.
qed ();



lemma "FiniteMap_eq_decidable"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall a a' . Decidable.decidable (a = a' : A)
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 1/.
qed ();



lemma "FiniteMap_look_emp"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall a . look emp a = None : option B
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 2/.
qed ();



lemma "FiniteMap_look_upd"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a b . look (upd f a b) a = Some b : option B
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 3/.
qed ();



lemma "FiniteMap_look_upd_neq"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a b a' . a != a' : A -> look (upd f a b) a' = look f a' : option B
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 4/.
qed ();



lemma "FiniteMap_look_rem"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a . look (rem f a) a = None : option B
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 5/.
qed ();



lemma "FiniteMap_look_rem_neq"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a a' . a != a' : A -> look (rem f a) a' = look f a' : option B
/;

inference.
intro /i A B T emp look upd rem H/.
exact /H ## 6/.
qed ();



lemma "FiniteMap_upd_upd"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a b b' .
         upd (upd f a b) a b' = upd f a b' : T
/;

inference.
intro /i A B T emp look upd rem (ext dec _ look_upd look_upd_neq _) f a b b'/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_upd at 0 0/.
  auto.
  }

  {
  rewrite /-> look_upd_neq at 1 0/ >> auto.
  }
qed ();



lemma "FiniteMap_upd_upd_neq"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a b a' b' .
         a != a' : A
         -> upd (upd f a b) a' b' = upd (upd f a' b') a b : T
/;

inference.
intro /i A B T emp look upd rem (ext dec _ look_upd look_upd_neq _) f a b a' b' Hneqa/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/ >> so /dec a' x/ /Heq' | Hneq'/.
  {
  subst /a a'/.
  so /Hneqa ()/ /0/.
  }

  {
  subst /x/.
  rewrite /-> look_upd_neq/ >> auto.
  rewrite /-> look_upd at 0 0/.
  auto.
  }

  {
  subst /x/.
  rewrite /-> look_upd_neq at 1/ >> auto.
  rewrite /-> look_upd at 0 0/.
  auto.
  }

  {
  rewrite /-> look_upd_neq at all/ >> auto.
  }
qed ();



lemma "FiniteMap_rem_emp"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall a . rem emp a = emp : T
/;

inference.
intro /i A B T emp look upd rem (ext dec look_emp _ _ look_rem look_rem_neq _) a/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_rem/.
  rewrite /-> look_emp/.
  auto.
  }

  {
  rewrite /-> look_rem_neq/ >> auto.
  }
qed ();



lemma "FiniteMap_rem_upd"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a b . rem (upd f a b) a = rem f a : T
/;

inference.
intro /i A B T emp look upd rem (ext dec _ _ look_upd_neq look_rem look_rem_neq _) f a b/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_rem at 0 0/.
  auto.
  }

  {
  rewrite /-> look_rem_neq at 0 0/ >> auto.
  }
qed ();



lemma "FiniteMap_rem_upd_neq"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a b a' . a != a' : A -> rem (upd f a b) a' = upd (rem f a') a b : T
/;

inference.
intro /i A B T emp look upd rem (ext dec _ look_upd look_upd_neq look_rem look_rem_neq _) f a b a' Hneqa/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_rem_neq/.
    {
    contrapositive /Hneqa/.
    auto.
    }
  rewrite /-> look_upd at 0 0/.
  auto.
  }
so /dec a' x/ /Heq | Hneq'/.
  {
  subst /x/.
  rewrite /-> look_rem/.
  rewrite /-> look_upd_neq/ >> auto.
  }
rewrite /-> look_rem_neq/ >> auto.
rewrite /-> look_upd_neq at 0 0/ >> auto.
qed ();



lemma "FiniteMap_rem_absent"
/
  forall i A B T emp look upd rem .
    FiniteMap i A B T emp look upd rem
    -> forall f a .
         look f a = None : option B
         -> rem f a = f : T
/;

inference.
intro /i A B T emp look upd rem (ext dec _ _ _ look_rem look_rem_neq _) f a Hnone/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_rem/.
  rewrite /-> Hnone/.
  auto.
  }

  {
  rewrite /-> look_rem_neq/ >> auto.
  }
qed ();



define /FiniteMapMerge i A B T emp look upd rem mer/
/
  FiniteMap i A B T emp look upd rem
  &
  (forall f g a b . look f a = Some b : option B -> look (mer f g) a = Some b : option B)
  &
  (forall f g a . look f a = None : option B -> look (mer f g) a = look g a : option B)
  &
  unit
//
  forall i (A B : U i) (T : U i) .
    T
    -> (T -> A -> option B)
    -> (T -> A -> B -> T)
    -> (T -> A -> T)
    -> (T -> T -> T)
    -> U i
/;

unfold /FiniteMapMerge/.
inference.
typecheck.
qed ();



lemma "FiniteMapMerge_look_mer_left"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f g a b . look f a = Some b : option B -> look (mer f g) a = Some b : option B
/;

inference.
intro /i A B T emp look upd rem mer H/.
exact /H ## 1/.
qed ();



lemma "FiniteMapMerge_look_mer_right"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f g a . look f a = None : option B -> look (mer f g) a = look g a : option B
/;

inference.
intro /i A B T emp look upd rem mer H/.
exact /H ## 2/.
qed ();



lemma "FiniteMapMerge_mer_emp_left"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f . mer emp f = f : T
/;

inference.
intro /i A B T emp look upd rem mer ((ext dec look_emp _) look_mer_left look_mer_right _) f/.
apply /ext/.
intro /x/.
rewrite /-> look_mer_right/ >> auto.
qed ();



lemma "FiniteMapMerge_mer_emp_right"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f . mer f emp = f : T
/;

inference.
intro /i A B T emp look upd rem mer ((ext dec look_emp _) look_mer_left look_mer_right _) f/.
apply /ext/.
intro /x/.
setEq /Z/ /look f x/ /_/ /HeqZ/.
symmetryIn /HeqZ/.
destruct /Z/ /{| b}/.
  {
  rewrite /-> look_mer_right/ >> auto.
  rewrite /-> HeqZ/.
  apply /look_emp/.
  }

  {
  rewrite /-> look_mer_left _ _ x b/ >> auto.
  }
qed ();



lemma "FiniteMapMerge_upd_mer_left"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f g a b . 
         upd (mer f g) a b = mer (upd f a b) g : T
/;

inference.
intro /i A B T emp look upd rem mer ((ext dec _ look_upd look_upd_neq _) look_mer_left look_mer_right _) f g a b/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_upd/.
  rewrite /-> look_mer_left _ _ a b/ >> auto.
  }

  {
  rewrite /-> look_upd_neq/ >> auto.
  setEq /Z/ /look f x/ /_/ /HeqZ/.
  symmetryIn /HeqZ/.
  destruct /Z/ /{| b'}/.
    {
    rewrite /-> look_mer_right at 0 0/ >> auto.
    rewrite /-> look_upd_neq/ >> auto.
    }

    {
    rewrite /-> look_mer_left _ _ x b' at 0 0/ >> auto.
    rewrite /-> look_upd_neq/ >> auto.
    }
  }
qed ();



lemma "FiniteMapMerge_upd_mer_right"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f g a b . 
         look f a = None : option B
         -> upd (mer f g) a b = mer f (upd g a b) : T
/;

inference.
intro /i A B T emp look upd rem mer ((ext dec _ look_upd look_upd_neq _) look_mer_left look_mer_right _) f g a b Hmiss/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_mer_right/ >> auto.
  rewrite /-> look_upd at 0 0/.
  auto.
  }

  {
  setEq /Z/ /look f x/ /_/ /HeqZ/.
  symmetryIn /HeqZ/.
  destruct /Z/ /{| b'}/.
    {
    rewrite /-> look_mer_right/ >> auto.
    rewrite /-> look_upd_neq at 0 0/ >> auto.
    }

    {
    rewrite /-> look_mer_left _ _ x b'/ >> auto.
    rewrite /-> look_upd_neq/ >> auto.
    }
  }
qed ();



lemma "FiniteMapMerge_rem_mer"
/
  forall i A B T emp look upd rem mer .
    FiniteMapMerge i A B T emp look upd rem mer
    -> forall f g a .
         rem (mer f g) a = mer (rem f a) (rem g a) : T
/;

inference.
intro /i A B T emp look upd rem mer ((ext dec _ _ _ look_rem look_rem_neq _) look_mer_left look_mer_right _) f g a/.
apply /ext/.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_rem/.
  rewrite /-> look_mer_right/ >> auto.
  }

  {
  rewrite /-> look_rem_neq/ >> auto.
  setEq /Z/ /look f x/ /_/ /HeqZ/.
  symmetryIn /HeqZ/.
  destruct /Z/ /{| b}/.
    {
    rewrite /-> look_mer_right at 0 0/ >> auto.
    rewrite /-> look_rem_neq/ >> auto.
    }

    {
    rewrite /-> look_mer_left _ _ x b at 0 0/ >> auto.
    rewrite /-> look_rem_neq/ >> auto.
    }
  }
qed ();

           

endModule ();  (* Class *)
openModule /Class/;


beginModule "Factory";


(* Generic finite maps minus extensionality *)

define /PreFiniteMap i A B T emp look upd rem/
/
  (forall a a' . Decidable.decidable (a = a' : A))
  &
  (forall a . look emp a = None : option B)
  &
  (forall f a b . look (upd f a b) a = Some b : option B)
  &
  (forall f a b a' . a != a' : A -> look (upd f a b) a' = look f a' : option B)
  &
  (forall f a . look (rem f a) a = None : option B)
  &
  (forall f a a' . a != a' : A -> look (rem f a) a' = look f a' : option B)
  &
  unit
//
  forall i (A B : U i) (T : U i) .
    T
    -> (T -> A -> option B)
    -> (T -> A -> B -> T)
    -> (T -> A -> T)
    -> U i
/;

unfold /PreFiniteMap/.
inference.
typecheck.
qed ();



(* quotient pre-finite-map *)
define /qpfm A B T look/
/
  quotient (f g : T) .
  forall (a : A) . look f a = look g a : option B
//
  intersect i . forall (A B T : U i) . (T -> A -> option B) -> U i
/;

inference.
introOf /i A B T look/.
unfold /qpfm/.
typecheck >> auto.
reintro /f g h Hfg Hgh/.
intro /a/.
transitivity /look g a/ >> auto.
qed ();



lemma "quotient_emp"
/
  forall i A B T emp look upd rem .
    PreFiniteMap i A B T emp look upd rem
    -> emp : qpfm A B T look
/;

inference.
intro /i A B T emp look upd rem _/.
infer /qpfm A B T look/ /Hof/.
unfold /qpfm in Hof in concl/.
typecheck >> auto.
qed ();



lemma "quotient_look"
/
  forall i A B T emp look upd rem .
    PreFiniteMap i A B T emp look upd rem
    -> look : qpfm A B T look -> A -> option B
/;

inference.
intro /i A B T emp look upd rem _/.
introOf /f/.
destruct /f/ /[f g Hfg]/.
introEq /a/.
apply /Hfg/.
qed ();



lemma "quotient_upd"
/
  forall i A B T emp look upd rem .
    PreFiniteMap i A B T emp look upd rem
    -> upd : qpfm A B T look -> A -> B -> qpfm A B T look
/;

inference.
intro /i A B T emp look upd rem (dec _ look_upd look_upd_neq _)/.
infer /qpfm A B T look/ /Hofq/.
unfold /qpfm in Hofq/.
assert /upd : T -> A -> B -> qpfm A B T look/ /Hof/.
  {
  introOf /f a b/.
  infer /qpfm A B T look/ /Hof/.
  unfold /qpfm/.
  typecheck >> auto.
  }
introOf /f/.
destruct /f/ /[f g Hfg]/.
inferSpine /Hof/ /__ f/ /Hoff/.
inferSpine /Hof/ /__ g/ /Hofg/.
introEq /a b/.
unfold /qpfm/.
extensionality.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_upd at 0 0/.
  auto.
  }

  {
  rewrite /-> look_upd_neq at 0 0/ >> auto.
  }
qed ();



lemma "quotient_rem"
/
  forall i A B T emp look upd rem .
    PreFiniteMap i A B T emp look upd rem
    -> rem : qpfm A B T look -> A -> qpfm A B T look
/;

inference.
intro /i A B T emp look upd rem (dec _ _ _ look_rem look_rem_neq _)/.
infer /qpfm A B T look/ /Hofq/.
unfold /qpfm in Hofq/.
assert /rem : T -> A -> qpfm A B T look/ /Hof/.
  {
  introOf /f a/.
  infer /qpfm A B T look/ /Hof/.
  unfold /qpfm/.
  typecheck >> auto.
  }
introOf /f/.
destruct /f/ /[f g Hfg]/.
inferSpine /Hof/ /__ f/ /Hoff/.
inferSpine /Hof/ /__ g/ /Hofg/.
introEq /a/.
unfold /qpfm/.
extensionality.
intro /x/.
so /dec a x/ /Heq | Hneq/.
  {
  subst /x/.
  rewrite /-> look_rem at 0 0/.
  auto.
  }

  {
  rewrite /-> look_rem_neq at 0 0/ >> auto.
  }
qed ();



lemma "FiniteMap_qpfm"
/
  forall i A B T emp look upd rem .
    PreFiniteMap i A B T emp look upd rem
    -> FiniteMap i A B (qpfm A B T look) emp look upd rem
/;

inference.
intro /i A B T emp look upd rem Hpfm/.
so /Hpfm/ /dec look_emp look_upd look_upd_neq look_rem look_rem_neq _/.
unfold /FiniteMap/.
infer /qpfm A B T look/ /Hofq/.
unfold /qpfm in Hofq/.
so /quotient_look _# 8 Hpfm/ /Hoflook/.
so /quotient_upd _# 8 Hpfm/ /Hofupd/.
so /quotient_rem _# 8 Hpfm/ /Hofrem/.
splitn 7.
  {
  intro /f g/.
  introRaw /Hfg/.
    {
    typecheck1 >> auto.
    reintro /a/.
    inferSpine /Hoflook/ /__ f a/ /Hoflookfa/.
    inferSpine /Hoflook/ /__ g a/ /Hoflookga/.
    typecheck.
    }
  infer /f/ /Hoff/.
  infer /g/ /Hofg/.
  destruct /f/ /[f]/.
  destruct /g/ /[g]/.
  unfold /qpfm in concl in Hoff in Hofg/.
  extensionality.
  exact /Hfg/.
  }

  {
  hyp /dec/.
  }

  {
  intro /a/.
  apply /look_emp/.
  }

  {
  intro /f a b/.
  inferSpine /Hofupd/ /__ f a b/ /Hofupdfab/.
  inferSpineRaw /Hoflook/ /__ (upd f a b) a/ /Hoflookupd/ >> auto.
  destruct /f/ /[f]/.
  unhide.
  apply /look_upd/.
  }

  {
  intro /f a b a' Hneq/.
  inferSpine /Hofupd/ /__ f a b/ /Hofupdfab/.
  inferSpineRaw /Hoflook/ /__ (upd f a b) a'/ /Hoflookupd/ >> auto.
  inferSpine /Hoflook/ /__ f a'/ /Hoflookfa'/.
  destruct /f/ /[f]/.
  unhide.
  apply /look_upd_neq/ >> auto.
  }

  {
  intro /f a/.
  inferSpine /Hofrem/ /__ f a/ /Hofremfa/.
  inferSpineRaw /Hoflook/ /__ (rem f a) a/ /Hoflookrem/ >> auto.
  destruct /f/ /[f]/.
  unhide.
  apply /look_rem/.
  }

  {
  intro /f a a' Hneq/.
  inferSpine /Hofrem/ /__ f a/ /Hofremfa/.
  inferSpineRaw /Hoflook/ /__ (rem f a) a'/ /Hoflookrem/ >> auto.
  inferSpine /Hoflook/ /__ f a'/ /Hoflookfa'/.
  destruct /f/ /[f]/.
  unhide.
  apply /look_rem_neq/ >> auto.
  }

  {
  split.
  }
qed ();



define /PreFiniteMapMerge i A B T emp look upd rem mer/
/
  PreFiniteMap i A B T emp look upd rem
  &
  (forall f g a b . look f a = Some b : option B -> look (mer f g) a = Some b : option B)
  &
  (forall f g a . look f a = None : option B -> look (mer f g) a = look g a : option B)
  &
  unit
//
  forall i (A B : U i) (T : U i) .
    T
    -> (T -> A -> option B)
    -> (T -> A -> B -> T)
    -> (T -> A -> T)
    -> (T -> T -> T)
    -> U i
/;

unfold /PreFiniteMapMerge/.
inference.
typecheck.
qed ();



lemma "quotient_mer"
/
  forall i A B T emp look upd rem mer .
    PreFiniteMapMerge i A B T emp look upd rem mer
    -> mer : qpfm A B T look -> qpfm A B T look -> qpfm A B T look
/;

inference.
intro /i A B T emp look upd rem mer ((dec _) look_mer_left look_mer_right _)/.
infer /qpfm A B T look/ /Hofq/.
unfold /qpfm in Hofq/.
introOf /f/.
destruct /f/ /[f f' Hf]/.
extensionality.
reintro /g/.
destruct /g/ /[g g' Hg]/.
unfold /qpfm/.
extensionality.
intro /x/.
setEq /Z/ /look f x/ /_/ /HeqZ/.
symmetryIn /HeqZ/.
destruct /Z/ /{| b}/.
  {
  rewrite /-> look_mer_right at 0 0/ >> auto.
  rewrite /<- Hf/ >> auto.
  }

  {
  rewrite /-> look_mer_left _ _ x b at 0 0/ >> auto.
  rewrite /<- Hf/ >> auto.
  }
qed ();



lemma "FiniteMapMerge_qpfm"
/
  forall i A B T emp look upd rem mer .
    PreFiniteMapMerge i A B T emp look upd rem mer
    -> FiniteMapMerge i A B (qpfm A B T look) emp look upd rem mer
/;

inference.
intro /i A B T emp look upd rem mer Hpfmm/.
so /Hpfmm/ /Hpfm look_mer_left look_mer_right _/.
unfold /FiniteMapMerge/.
infer /qpfm A B T look/ /Hofq/.
unfold /qpfm in Hofq/.
so /quotient_look _# 8 Hpfm/ /Hoflook/.
so /quotient_mer _# 9 Hpfmm/ /Hofmer/.
splitn 3 >> auto.
  {
  apply /FiniteMap_qpfm/ >> auto.
  }

  {
  intro /f g a b/.
  inferSpine /Hofmer/ /__ f g/ /Hofmerfg/.
  inferSpineRaw /Hoflook/ /__ (mer f g) a/ /Hoflookmer/ >> auto.
  inferSpine /Hoflook/ /__ f a/ /Hoflookfa/.
  destruct /f/ /[f]/.
  destruct /g/ /[g]/.
  intro /Hlook/.
  unhide.
  apply /look_mer_left/ >> auto.
  }

  {
  intro /f g a/.
  inferSpine /Hofmer/ /__ f g/ /Hofmerfg/.
  inferSpineRaw /Hoflook/ /__ (mer f g) a/ /Hoflookmer/ >> auto.
  inferSpine /Hoflook/ /__ f a/ /Hoflookfa/.
  inferSpine /Hoflook/ /__ g a/ /Hoflookga/.
  destruct /f/ /[f]/.
  destruct /g/ /[g]/.
  intro /Hlook/.
  unhide.
  apply /look_mer_right/ >> auto.
  }
qed ();



endModule ();  (* Factory *)
openModule /Factory/;



(* Simple finite maps *)

define /eqtest A/
/
  { e : A -> A -> bool | forall (x y : A) . x = y : A <-> istrue (e x y) }
//
  intersect i . U i -> U i
/;

inference.
unfold /eqtest/.
typecheck.
qed ();



beginModule "Impl";


define /list_iter_inv mnil mcons l/
/
  list_iter Miscellaneous.bogus Miscellaneous.bogus mnil mcons l
//
  intersect i (a b : U i) .
    b
    -> (a -> list a -> b -> b)
    -> list a -> b
/;

inference.
introOf /i a b mnil mcons l/.
unfold /list_iter_inv/.
sinduction /l/.
reintro /IH/.
destruct /l/ /| h t/ >> reduce // >> auto.
fold /manual (list_iter _ _ _ _ _)/.
typecheck.
apply /IH/.
apply /cons_subterm/.
qed ();



reductions
/
  list_iter_inv mnil mcons (nil) --> mnil ;
  list_iter_inv mnil mcons (cons h t) --> mcons h t (list_iter_inv mnil mcons t) ;

  unfolding list_iter_inv
/;



define /pre_finite_map A B/
/
  eqtest A & { l : list (A & B) | Forall_dist (fn x y . x #1 != y #1 : A) l }
//
  intersect i . U i -> U i -> U i
/;

inference.
unfold /pre_finite_map/.
typecheck.
qed ();



define /pre_empty A B e/
/
  (e, nil)
//
  intersect i . forall (A B : U i) . 
    eqtest A -> pre_finite_map A B
/;

inference.
unfold /pre_empty, pre_finite_map/.
typecheck.
split.
apply /Forall_dist_nil/.
qed ();



define /pre_lookup A B f a/
/
  list_iter_inv
    None
    (fn h t r . if f #1 a (h #1) then Some (h #2) else r)
    (f #2)
//
  intersect i . forall (A B : U i) . pre_finite_map A B -> A -> option B
/;

inference.
introOf /i A B f a/.
unfold /pre_lookup/.
unfold /pre_finite_map in f/.
typecheck.
qed ();



define /pre_update A B f a b/
/
  (f #1,
   list_iter_inv
     ((a, b) :: nil)
     (fn h t r . if f #1 a (h #1) then (a, b) :: t else h :: r)
     (f #2))
//
  intersect i . forall (A B : U i) . pre_finite_map A B -> A -> B -> pre_finite_map A B
/;

inference.
introOf /i A B f a b/.
unfold /pre_update/.
unfold /pre_finite_map in f in concl/.
destruct /f/ /e (l Hl)/.
reduce //.
typecheck >> auto.
destruct /e/ /e He/.
split.
revert /Hl/.
induction /l/ >> auto.
  {
  intro /_/.
  apply /Forall_dist_cons/.
    {
    apply /Forall_nil/.
    }

    {
    apply /Forall_dist_nil/.
    }
  }

  {
  intro /(a' b') l IH Hdist/ >> auto.
  reduce //.
  rewrite /-> Forall_dist_cons_iff in Hdist/.
  reduce /Hdist/.
  destruct /Hdist/ /Hallneq Hdist/.
  boolCase /e a a'/ /Heq/.
    {
    rewrite /<- He in Heq/.
    subst /a'/.
    apply /Forall_dist_cons/ >> auto.
    }

    {
    apply /Forall_dist_cons/ >> auto.
    reduce //.
    clear /IH Hdist/.
    revert /Hallneq/.
    induction /l/.
      {
      intro /_/.
      apply /Forall_cons/.
      1:{
        apply /Forall_nil/.
        }
      reduce //.
      rewrite /<- He in Heq/.
      contrapositive /Heq/ >> auto.
      }

      {
      intro /(a'' b'') l IH Hallneq/.
      reduce //.
      rewrite /-> Forall_cons_iff in Hallneq/.
      reduce /Hallneq/.
      destruct /Hallneq/ /Hneq Hallneq/.
      boolCase /e a a''/ /Heq'/.
        {
        apply /Forall_cons/ >> auto.
        reduce //.
        rewrite /<- He in Heq'/.
        subst /a''/.
        auto.
        }

        {
        apply /Forall_cons/ >> auto.
        }
      }
    }
  }
qed ();



define /pre_remove A B f a/
/
  (f #1,
   list_iter_inv
     nil
     (fn h t r . if f #1 a (h #1) then t else h :: r)
     (f #2))
//
  intersect i . forall (A B : U i) . pre_finite_map A B -> A -> pre_finite_map A B
/;

inference.
introOf /i A B f a/.
unfold /pre_remove, pre_finite_map in f in concl/.
typecheck.
destruct /f/ /(e He) (l Hl)/.
reduce //.
split.
revert /Hl/.
induction /l/ >> auto.
intro /(a' b') l IH Hdist/ >> auto.
reduce //.
rewrite /-> Forall_dist_cons_iff in Hdist/.
reduce /Hdist/.
destruct /Hdist/ /Hallneq Hdist/.
boolCase /e a a'/ /Heq/ >> auto.
apply /Forall_dist_cons/ >> auto.
reduce //.
clear /IH Hdist Heq/.
revert /Hallneq/.
induction /l/ >> auto.
intro /(a'' b'') t IH Hallneq/ >> auto.
reduce //.
rewrite /-> Forall_cons_iff in Hallneq/.
reduce /Hallneq/.
destruct /Hallneq/ /Hneq Hallneq/.
boolCase /e a a''/ /Heq/ >> auto.
apply /Forall_cons/ >> auto.
qed ();



define /pre_merge A B f g/
/
  list_iter_inv
    g
    (fn h _ r . pre_update A B r (h #1) (h #2))
    (f #2)
//
  intersect i . forall (A B : U i) . pre_finite_map A B -> pre_finite_map A B -> pre_finite_map A B
/;

inference.
introOf /i A B f g/.
unfold /pre_merge/.
destruct /f/ /_ f/.
reduce //.
destruct /f/ /f _/.
typecheck.
qed ();



lemma "PreFiniteMap_pre_finite_map"
/
  forall i (A B : U i) (e : eqtest A) .
    PreFiniteMap i A B (pre_finite_map A B) 
      (pre_empty A B e) 
      (pre_lookup A B)
      (pre_update A B)
      (pre_remove A B)
/;

inference.
intro /i A B e0/.
unfold /PreFiniteMap/.
splitn 6 >> auto.
  {
  intro /a a'/.
  destruct /e0/ /[e He]/.
  exactRaw /if e a a' then inl () else inr (fn _ . ())/.
  boolCase /e a a'/ /Heq/ >> unfold /Decidable.decidable/.
    {
    typecheck.
    apply /He/ >> auto.
    }

    {
    rewrite /<- He in Heq/.
    typecheck.
    reintro /Heq'/.
    so /Heq Heq'/ /0/.
    }
  }

  {
  intro /a/.
  unfold /pre_empty, pre_lookup/.
  auto.
  }

  {
  intro /f a b/.
  unfold /pre_update, pre_lookup/.
  destruct /f/ /[e He] [f _]/.
  reduce //.
  induction /f/ >> auto.
    {
    boolEq true /e a a/ >> auto.
    }
  intro /(a' b') f IH/ >> auto.
  reduce //.
  boolCase /e a a'/ /Heq/ >> auto.
    {
    boolEq true /e a a/ >> auto.
    }
  boolEq false /e a a'/ >> auto.
  }

  {
  intro /f a b a' Hneq/.
  unfold /pre_update, pre_lookup at 0 0/.
  destruct /f/ /[e He] [f _]/.
  reduce //.
  unhide.
  induction /f/ >> auto.
    {
    boolEq false /e a' a/ >> auto.
    contrapositive /Hneq/.
    auto.
    }
  intro /(a'' b'') f IH/ >> auto.
  reduce //.
  boolCase /e a a''/ /Heq/.
    {
    rewrite /<- He in Heq/.
    subst /a''/.
    boolEq false /e a' a/ >> auto.
    contrapositive /Hneq/ >> auto.
    }
  boolCase /e a' a''/ /Heq'/ >> auto.
  }

  {
  intro /f a/.
  unfold /pre_remove, pre_lookup/.
  destruct /f/ /[e He] [f Hf]/.
  reduce //.
  unhide.
  revert /Hf/.
  induction /f/ >> auto.
  intro /(a' b') f IH Hdist/.
  reduce //.
  rewrite /-> Forall_dist_cons_iff in Hdist/.
  reduce /Hdist/.
  destruct /Hdist/ /Hallneq Hdist/.
  boolCase /e a a'/ /Heq/.
    {
    rewrite /<- He in Heq/.
    subst /a'/.
    clear /IH Hdist/.
    revert /Hallneq/.
    induction /f/ >> auto.
    intro /(a'' b'') f IH Hallneq/.
    reduce //.
    rewrite /-> Forall_cons_iff in Hallneq/.
    reduce /Hallneq/.
    destruct /Hallneq/ /Hneq Hallneq/.
    boolEq false /e a a''/.
      {
      rewrite /<- He/.
      auto.
      }
    apply /IH/ >> auto.
    }
  
    {
    boolEq false /e a a'/ >> auto.
    }
  }

  {
  intro /f a a' Hneq/.
  unfold /pre_remove, pre_lookup at all/.
  destruct /f/ /[e He] [f _]/.
  reduce //.
  unhide.
  induction /f/ >> auto.
  intro /(a'' b'') f IH/.
  reduce //.
  boolCase /e a a''/ /Heq/ >> auto.
  rewrite /<- He in Heq/.
  subst /a''/.
  boolEq false /e a' a/ >> auto.
  contrapositive /Hneq/ >> auto.
  }
qed ();



lemma "PreFiniteMapMerge_pre_finite_map"
/
  forall i (A B : U i) (e : eqtest A) .
    PreFiniteMapMerge i A B (pre_finite_map A B) 
      (pre_empty A B e) 
      (pre_lookup A B)
      (pre_update A B)
      (pre_remove A B)
      (pre_merge A B)
/;

inference.
intro /i A B e0/.
unfold /PreFiniteMapMerge/.
so /PreFiniteMap_pre_finite_map i A B e0/ /Hpfm/.
splitn 3 >> auto.
  {
  intro /f g a b Hlook/.
  destruct /f/ /[e He] [f _]/.
  unhide.
  unfold /pre_lookup in Hlook, pre_merge/.
  reduce /Hlook concl/.
  revert /Hlook/.
  induction /f/.
    {
    intro /H/.
    injection /H/.
    }
  intro /(a' b') f IH/.
  reduce //.
  boolCase /e a a'/ /Heq/.
    {
    intro /H/.
    injection /H/.
    rewrite /<- He in Heq/.
    subst /a' b'/.
    destruct /Hpfm/ /_ _ Hlook_upd _/.
    apply /Hlook_upd/.
    }

    {
    intro /Hlook/.
    rewrite /<- He in Heq/.
    destruct /Hpfm/ /_ _ _ Hlook_upd_neq _/.
    rewrite /-> Hlook_upd_neq/.
      {
      contrapositive /Heq/ >> auto.
      }
    apply /IH/ >> auto.
    }
  }

  {
  intro /f g a Hlook/.
  destruct /f/ /[e He] [f _]/.
  unhide.
  unfold /pre_lookup in Hlook, pre_merge/.
  reduce /Hlook concl/.
  revert /Hlook/.
  induction /f/ >> auto.
  intro /(a' b') f IH/.
  reduce //.
  boolCase /e a a'/ /Heq/.
    {
    intro /H/.
    injection /H/.
    }
  intro /Hlook/.
  rewrite /<- He in Heq/.
  destruct /Hpfm/ /_ _ _ Hlook_upd_neq _/.
  rewrite /-> Hlook_upd_neq/.
    {
    contrapositive /Heq/ >> auto.
    }
  apply /IH/ >> auto.
  }
qed ();



endModule ();  (* Impl *)
openModule /Impl/;



define /finite_map A B/
/
  qpfm A B (pre_finite_map A B) (pre_lookup A B)
//
  intersect i . U i -> U i -> U i
/;

inference.
unfold /finite_map/.
typecheck.
qed ();
  


lemma "finite_map_impl_eq_decidable"
/
  intersect i . forall (A B : U i) . finite_map A B -> forall a a' . Decidable.decidable (a = a' : A)
/;

inference.
intro /i A B f/.
assert /f #1 : { e : A -> A -> bool | forall (x y : A) . x = y : A <-> istrue (e x y) }/ /Hof/.
  {
  destruct /f/ /[f g Hfg]/.
  destruct /f/ /[e He] f/.
  destruct /g/ /[e' He'] g/.
  reduce //.
  unhide.
  extensionality >> auto.
  introEq /x y/.
  apply /iff_eq_bool/.
  auto.
  }
RuleTactic.setElim (Term.evar ()) (Term.evar ()) (parseCurr /f #1/).
1:{
  hyp /Hof/.
  }
typechecker ();
reintro /Hf/.
assert /f #1 : A -> A -> bool/ /Hof'/.
  {
  RuleTactic.setWeakenOf (Term.evar ()).
  exact /Hof/.
  }
clear /Hof/.
intro /a a'/.
inferSpine /Hof'/ /__ a a'/ /Hof''/.
exactRaw /if f #1 a a' then inl () else inr (fn _ . ())/.
boolCase /f #1 a a'/ /Heq/.
  {
  unfold /Decidable.decidable/.
  typecheck.
  apply /Hf/ >> auto.
  }

  {
  rewrite /<- Hf in Heq/.
  unfold /Decidable.decidable/.
  typecheck.
  reintro /Heq'/.
  so /Heq Heq'/ /0/.
  }
qed ();



lemma "finite_map_impl_eqtest"
/
  intersect i . forall (A B : U i) .
    finite_map A B -> eqtest A
/;

inference.
intro /i A B f/.
so /finite_map_impl_eq_decidable _# 2 f/ /dec/.
unfold /eqtest/.
exists /fn x y . (case dec x y of | inl _ . true | inr _ . false)/.
intro /x y/.
reduce //.
generalize /dec x y/ /_/ /X/.
destruct /X/ /Heq | Hneq/.
  {
  reduce //.
  split >> autoWith /istrue_true/.
  }

  {
  reduce //.
  split.
    {
    intro /Heq/.
    so /Hneq Heq/ /0/.
    }

    {
    intro /Hfalse/.
    so /not_istrue_false Hfalse/ /0/.
    }
  }
qed ();



define /empty/
/
  pre_empty
//
  intersect i . forall (A B : U i) . 
    eqtest A -> finite_map A B
/;

inference.
introOf /i A B e/.
unfold /empty, finite_map/.
exact /quotient_emp _# 8 (PreFiniteMap_pre_finite_map i A B e)/.
qed ();

Database.setImplicits (parseConstant /empty/) 2;



define /lookup/
/
  pre_lookup
//
  intersect i . forall (A B : U i) . finite_map A B -> A -> option B
/;

inference.
introOf /i A B f a/.
so /finite_map_impl_eqtest A B f/ /e/.
unfold /lookup, finite_map in f/.
so /quotient_look _# 8 (PreFiniteMap_pre_finite_map i A B e)/ /Hof/.
inferSpine /Hof/ /__ f a/ /Hof'/.
hyp /Hof'/.
qed ();

Database.setImplicits (parseConstant /lookup/) 2;



define /update/
/
  pre_update
//
  intersect i . forall (A B : U i) . finite_map A B -> A -> B -> finite_map A B
/;

inference.
introOf /i A B f a b/.
so /finite_map_impl_eqtest A B f/ /e/.
unfold /update, finite_map in f in concl/.
so /quotient_upd _# 8 (PreFiniteMap_pre_finite_map i A B e)/ /Hof/.
inferSpine /Hof/ /__ f a b/ /Hof'/.
hyp /Hof'/.
qed ();

Database.setImplicits (parseConstant /update/) 2;



define /remove/
/
  pre_remove
//
  intersect i . forall (A B : U i) . finite_map A B -> A -> finite_map A B
/;

inference.
introOf /i A B f a/.
so /finite_map_impl_eqtest A B f/ /e/.
unfold /remove, finite_map in f in concl/.
so /quotient_rem _# 8 (PreFiniteMap_pre_finite_map i A B e)/ /Hof/.
inferSpine /Hof/ /__ f a/ /Hof'/.
hyp /Hof'/.
qed ();

Database.setImplicits (parseConstant /remove/) 2;



lemma "FiniteMap_finite_map"
/
  forall i (A B : U i) (e : eqtest A) .
    FiniteMap i A B (finite_map A B) 
      (`empty A B e) 
      (`lookup A B)
      (`update A B)
      (`remove A B)
/;

inference.
intro /i A B e/.
unfold /finite_map, empty, lookup, update, remove/.
apply /FiniteMap_qpfm/.
apply /PreFiniteMap_pre_finite_map/.
qed ();



lemma "FiniteMap_finite_map'"
/
  forall i (A B : U i) (f : finite_map A B) .
    FiniteMap i A B (finite_map A B) 
      (`empty A B (finite_map_impl_eqtest A B f))
      (`lookup A B)
      (`update A B)
      (`remove A B)
/;

inference.
intro /i A B f/.
infer /finite_map_impl_eqtest A B f/ /Hof/.
apply /FiniteMap_finite_map/.
qed ();



lemma "finite_map_ext"
/
  forall i (A B : U i) f g .
    (forall (a : A) . lookup f a = lookup g a : option B)
    -> f = g : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMap_ext _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "lookup_empty"
/
  forall i (A B : U i) e (a : A) .
    lookup (empty e) a = None : option B
/;

inference.
intro /i A B e/.
apply /FiniteMap_look_emp _# 4 (empty e) lookup update remove/.
apply /FiniteMap_finite_map/.
qed ();



lemma "lookup_update"
/
  forall i (A B : U i) (f : finite_map A B) a b .
    lookup (update f a b) a = Some b : option B
/;

inference.
intro /i A B f/.
exact /FiniteMap_look_upd _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "lookup_update_neq"
/
  forall i (A B : U i) f a b a' .
    a != a' : A -> lookup (update f a b) a' = lookup f a' : option B
/;

inference.
intro /i A B f/.
infer /finite_map_impl_eqtest A B f/ /Hof/.
exact /FiniteMap_look_upd_neq _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "lookup_remove"
/
  forall i (A B : U i) (f : finite_map A B) a .
    lookup (remove f a) a = None : option B
/;

inference.
intro /i A B f/.
exact /FiniteMap_look_rem _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "lookup_remove_neq"
/
  forall i (A B : U i) f a a' .
    a != a' : A
    -> lookup (remove f a) a' = lookup f a' : option B
/;

inference.
intro /i A B f/.
exact /FiniteMap_look_rem_neq _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "update_update"
/
  forall i (A B : U i) f a b b' .
    update (update f a b) a b' = update f a b' : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMap_upd_upd _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "update_update_neq"
/
  forall i (A B : U i) f a b a' b' .
    a != a' : A
    -> update (update f a b) a' b' = update (update f a' b') a b : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMap_upd_upd_neq _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "remove_empty"
/
  forall i (A B : U i) e a .
    remove (empty e) a = empty e : finite_map A B
/;

inference.
intro /i A B e/.
exact /FiniteMap_rem_emp _# 4 (empty e) lookup update remove (FiniteMap_finite_map _# 3 e)/.
qed ();



lemma "remove_update"
/
  forall i (A B : U i) f a b .
    remove (update f a b) a = remove f a : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMap_rem_upd _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "remove_update_neq"
/
  forall i (A B : U i) f a b a' . 
    a != a' : A 
    -> remove (update f a b) a' = update (remove f a') a b : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMap_rem_upd_neq _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



lemma "remove_absent"
/
  forall i (A B : U i) f a .
    lookup f a = None : option B
    -> remove f a = f : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMap_rem_absent _# 4 (empty _) lookup update remove (FiniteMap_finite_map' _# 3 f) f/.
qed ();



define /merge/
/
  pre_merge
//
  intersect i . forall (A B : U i) . finite_map A B -> finite_map A B -> finite_map A B
/;

inference.
introOf /i A B f g/.
so /finite_map_impl_eqtest A B f/ /e/.
unfold /merge, finite_map in f in g in concl/.
so /quotient_mer _# 9 (PreFiniteMapMerge_pre_finite_map i A B e)/ /Hof/.
inferSpine /Hof/ /__ f g/ /Hof'/.
hyp /Hof'/.
qed ();

Database.setImplicits (parseConstant /merge/) 2;



lemma "FiniteMapMerge_finite_map"
/
  forall i (A B : U i) (e : eqtest A) .
    FiniteMapMerge i A B (finite_map A B) 
      (`empty A B e) 
      (`lookup A B)
      (`update A B)
      (`remove A B)
      (`merge A B)
/;

inference.
intro /i A B e/.
unfold /finite_map, empty, lookup, update, remove, merge/.
apply /FiniteMapMerge_qpfm/.
apply /PreFiniteMapMerge_pre_finite_map/.
qed ();



lemma "FiniteMapMerge_finite_map'"
/
  forall i (A B : U i) (f : finite_map A B) .
    FiniteMapMerge i A B (finite_map A B) 
      (`empty A B (finite_map_impl_eqtest A B f))
      (`lookup A B)
      (`update A B)
      (`remove A B)
      (`merge A B)
/;

inference.
intro /i A B f/.
apply /FiniteMapMerge_finite_map/.
qed ();



lemma "lookup_merge_left"
/
  forall i (A B : U i) f g (a : A) b .
    lookup f a = Some b : option B
    -> lookup (merge f g) a = Some b : option B
/;

inference.
intro /i A B f/.
exact /FiniteMapMerge_look_mer_left _# 4 (empty _) lookup update remove merge (FiniteMapMerge_finite_map' _# 3 f) f/.
qed ();



lemma "lookup_merge_right"
/
  forall i (A B : U i) f g (a : A) .
    lookup f a = None : option B -> lookup (merge f g) a = lookup g a : option B
/;

inference.
intro /i A B f/.
exact /FiniteMapMerge_look_mer_right _# 4 (empty _) lookup update remove merge (FiniteMapMerge_finite_map' _# 3 f) f/.
qed ();



lemma "merge_empty_left"
/
  forall i (A B : U i) e f . merge (empty e) f = f : finite_map A B
/;

inference.
intro /i A B e/.
exact /FiniteMapMerge_mer_emp_left _# 4 (empty e) lookup update remove merge (FiniteMapMerge_finite_map _# 4)/.
qed ();



lemma "merge_empty_right"
/
  forall i (A B : U i) e f . merge f (empty e) = f : finite_map A B
/;

inference.
intro /i A B e/.
exact /FiniteMapMerge_mer_emp_right _# 4 (empty e) lookup update remove merge (FiniteMapMerge_finite_map _# 4)/.
qed ();



lemma "update_merge_left"
/
  forall i (A B : U i) f g a b .
    update (merge f g) a b = merge (update f a b) g : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMapMerge_upd_mer_left _# 4 (empty _) lookup update remove merge (FiniteMapMerge_finite_map' _# 3 f) f/.
qed ();

  

lemma "update_merge_right"
/
  forall i (A B : U i) f g a b .
    lookup f a = None : option B
    -> update (merge f g) a b = merge f (update g a b) : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMapMerge_upd_mer_right _# 4 (empty _) lookup update remove merge (FiniteMapMerge_finite_map' _# 3 f) f/.
qed ();



lemma "remove_merge"
/
  forall i (A B : U i) f g a .
    remove (merge f g) a = merge (remove f a) (remove g a) : finite_map A B
/;

inference.
intro /i A B f/.
exact /FiniteMapMerge_rem_mer _# 4 (empty _) lookup update remove merge (FiniteMapMerge_finite_map' _# 3 f) f/.
qed ();



(* Membership *)

define /member {A B} f a/
/
  exists (b : B) . lookup f a = Some b : option B
//
  intersect i . forall (A B : U i) . finite_map A B -> A -> U i
/;

inference.
unfold /member/.
typecheck.
qed ();



lemma "not_member_iff_lookup_none"
/
  forall i (A B : U i) (f : finite_map A B) a .
    not (member f a) <-> lookup f a = None : option B
/;

inference.
intro /i A B f a/.
split.
  {
  intro /Hnotmem/.
  unfold /member in Hnotmem/.
  setEq /Z/ /lookup f a/ /_/ /Heq/.
  symmetryIn /Heq/.
  destruct /Z/ /{| b}/ >> auto.
  so /Hnotmem __/ /0/.
  exists /b/ >> auto.
  }

  {
  intro /Hnone (b Heq)/.
  rewrite /-> Hnone in Heq/.
  injection /Heq/.
  }
qed ();



lemma "remove_absent'"
/
  forall i (A B : U i) f a .
    not (member f a)
    -> remove f a = f : finite_map A B
/;

inference.
intro /i A B f a Hnonmem/.
apply /remove_absent/ >> auto.
apply /not_member_iff_lookup_none/ >> auto.
qed ();



lemma "lookup_merge_left'"
/
  forall i (A B : U i) f g (a : A) .
    member f a
    -> lookup (merge f g) a = lookup f a : option B
/;

inference.
intro /i A B f g a (b Heq)/.
rewrite /-> Heq/.
apply /lookup_merge_left/ >> auto.
qed ();



lemma "lookup_merge_right'"
/
  forall i (A B : U i) f g (a : A) .
    not (member f a)
    -> lookup (merge f g) a = lookup g a : option B
/;

inference.
intro /i A B f g a Hnotmem/.
rewrite /-> lookup_merge_right/ >> auto.
apply /not_member_iff_lookup_none/ >> auto.
qed ();



lemma "decidable_member"
/
  forall i (A B : U i) (f : finite_map A B) a .
    Decidable.decidable (member f a)
/;

inference.
intro /i A B f a/.
unfold /member/.
generalize /lookup f a/ /_/ /X/.
destruct /X/ /{| b}/.
  {
  right.
  intro /(b' Heq)/.
  injection /Heq/.
  }

  {
  left.
  exists /b/.
  reflexivity.
  }
qed ();



(* Map *)

beginModule "MapImpl";


define /pre_map A B C g f/
/
  (f #1,
   (fnind comp : list [(A & B)] -> list (A & C) of
    | nil . nil
    | cons h t . (h #1, g (h #1) (h #2)) :: comp t) (f #2))
//
  intersect i . forall (A B C : U i) . (A -> B -> C) -> pre_finite_map A B -> pre_finite_map A C
/;

inference.
introOf /i A B C g f/.
destruct /f/ /e (f Hdist)/.
unhide.
unfold /pre_map, pre_finite_map at all/.
reduce //.
typecheck.
split.
induction /Hdist/.
  {
  apply /Forall_dist_nil/.
  }
intro /(a b) f Hallneq _ IH/.
reduce //.
apply /Forall_dist_cons/ >> auto.
clear /IH/.
induction /Hallneq/.
  {
  apply /Forall_nil/.
  }
intro /(a' b') f Hneq _ IH/.
reduce //.
apply /Forall_cons/ >> auto.
qed ();



lemma "pre_lookup_pre_map"
/
  forall i (A B C : U i) (g : A -> B -> C) (f : pre_finite_map A B) (a : A) .
    pre_lookup A C (pre_map A B C g f) a
    = Option.map (g a) (pre_lookup A B f a)
    : option C
/;

inference.
intro /i A B C g f a/.
destruct /f/ /e (f _)/.
unfold /pre_map, pre_lookup at all/.
induction /f/ >> auto.
intro /(a' b) f IH/.
reduce //.
boolCase /e a a'/ /Heq/ >> auto.
destruct /e/ /e He/.
compat.
compat.
symmetry.
apply /He/ >> auto.
qed ();


endModule ();
openModule /MapImpl/;



defineVary /map {A B C} h f/ /map'/
/
  pre_map A B C h f
//
  intersect i . forall (A B C : U i) . (A -> B -> C) -> finite_map A B -> finite_map A C
/;

inference.
introOf /i A B C h f/.
unfold /map'/.
destruct /f/ /[f g Hfg]/.
unfold /finite_map/.
infer /qpfm A C (pre_finite_map A C) (pre_lookup A C)/ /Hof/.
unfold /qpfm in Hof in concl/.
extensionality.
intro /a/.
rewrite /-> pre_lookup_pre_map at 0 0/.
compat >> auto.
qed ();



lemma "lookup_map"
/
  forall i (A B C : U i) (g : A -> B -> C) (f : finite_map A B) a .
    lookup (map g f) a
    = Option.map (g a) (lookup f a)
    : option C
/;

inference.
intro /i A B C g f a/.
assert /\Prover.currentConcl ()\ : type/ /Hof/.
  {
  typecheck.
  }
destruct /f/ /[f]/.
unhide.
unfold /lookup at all, map at all/.
apply /pre_lookup_pre_map/.
qed ();



lemma "map_identity"
/
  forall i (A B : U i) f .
    map (fn _ x . x) f = f : finite_map A B
/;

inference.
intro /i A B f/.
apply /finite_map_ext/.
intro /a/.
rewrite /-> lookup_map/.
rewrite /-> Option.map_identity/.
reflexivity.
qed ();



lemma "map_compose"
/
  forall i (A B C D : U i) (g : A -> C -> D) (h : A -> B -> C) f .
    map g (map h f) = map (fn x y . g x (h x y)) f : finite_map A D
/;

inference.
intro /i A B C D g h f/.
apply /finite_map_ext/.
intro /a/.
rewrite /-> lookup_map at all/.
rewrite /-> Option.map_compose/.
reflexivity.
qed ();



lemma "map_empty"
/
  forall i (A B C : U i) (g : A -> B -> C) e .
    map g (empty e) = empty e : finite_map A C
/;

inference.
intro /i A B C g e/.
apply /finite_map_ext/.
intro /a/.
rewrite /-> lookup_map/.
rewrite /-> lookup_empty at 0 0/.
reduce //.
reflexivity.
qed ();



lemma "map_update"
/
  forall i (A B C : U i) (g : A -> B -> C) f a b .
    map g (update f a b) = update (map g f) a (g a b) : finite_map A C
/;

inference.
intro /i A B C g f a b/.
apply /finite_map_ext/.
intro /a'/.
rewrite /-> lookup_map/.
so /finite_map_impl_eq_decidable _# 2 f a a'/ /Heq | Hneq/.
  {
  subst /a'/.
  rewrite /-> lookup_update at 0 0/.
  reduce //.
  reflexivity.
  }

  {
  rewrite /-> lookup_update_neq at 0 0/ >> auto.
  rewrite /-> lookup_map/.
  reflexivity.
  }
qed ();



lemma "map_remove"
/
  forall i (A B C : U i) (g : A -> B -> C) f a .
    map g (remove f a) = remove (map g f) a : finite_map A C
/;

inference.
intro /i A B C g f a/.
apply /finite_map_ext/.
intro /a'/.
rewrite /-> lookup_map/.
so /finite_map_impl_eq_decidable _# 2 f a a'/ /Heq | Hneq/.
  {
  subst /a'/.
  rewrite /-> lookup_remove at 0 0/.
  reflexivity.
  }

  {
  rewrite /-> lookup_remove_neq at 0 0/ >> auto.
  rewrite /-> lookup_map/.
  reflexivity.
  }
qed ();



lemma "map_merge"
/
  forall i (A B C : U i) (g : A -> B -> C) f f' .
    map g (merge f f') = merge (map g f) (map g f') : finite_map A C
/;

inference.
intro /i A B C g f f'/.
apply /finite_map_ext/.
intro /a/.
setEq /X/ /lookup f a/ /_/ /Hlook/.
symmetryIn /Hlook/.
rewrite /-> lookup_map/.
destruct /X/ /{| b}/.
  {
  rewrite /-> lookup_merge_right/ >> auto.
  rewrite /-> lookup_merge_right/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook/.
    reflexivity.
    }
  rewrite /-> lookup_map/.
  reflexivity.
  }

  {
  rewrite /-> lookup_merge_left _# 6 b/ >> auto.
  rewrite /-> lookup_merge_left _# 6 (g a b)/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook/.
    reflexivity.
    }
  reflexivity.
  }
qed ();



lemma "member_map"
/
  forall i (A B C : U i) a (g : A -> B -> C) f .
    member (map g f) a <-> member f a
/;

inference.
intro /i A B C a g f/.
unfold /member at 0 0/.
split.
  {
  intro /(c Hlook)/.
  rewrite /-> lookup_map in Hlook/.
  revert /Hlook/.
  remember /lookup f a/ /_/ /X/ /Hlook/.
  symmetryIn /Hlook/.
  destruct /X/ /{| b}/.
    {
    intro /H/.
    reduce /H/.
    injection /H/.
    }
  intro /Heq/.
  reduce /Heq/.
  injection /Heq/.
  subst /c/.
  exists /b/.
  auto.
  }

  {
  intro /(b Hlook)/.
  exists /g a b/.
  rewrite /-> lookup_map/.
  rewrite /-> Hlook/.
  reflexivity.
  }
qed ();



(* Combination (symmetric merge) *)

define /combine {A B} f g h/
/
  merge
    (map
       (fn a b .
          (case lookup g a : option of
           | None . b
           | Some b' . h a b b'))
       f)
    g
//
  intersect i . forall (A B : U i) .
    finite_map A B -> finite_map A B -> (A -> B -> B -> B) -> finite_map A B
/;

inference.
unfold /combine/.
typecheck.
qed ();



lemma "combine_transpose"
/
  forall i (A B : U i) f g h .
    combine f g h = combine g f (fn a b b' . h a b' b) : finite_map A B
/;

inference.
intro /i A B f g h/.
apply /finite_map_ext/.
intro /a/.
unfold /combine at 0 0/.
setEq /X/ /lookup f a/ /_/ /Hlook/.
setEq /Y/ /lookup g a/ /_/ /Hlook'/.
symmetryIn /Hlook/.
symmetryIn /Hlook'/.
destruct /X/ /{| b}/ >> destruct /Y/ /{| b'}/.
  {
  rewrite /-> lookup_merge_right/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook/.
    auto.
    }
  rewrite /-> lookup_merge_right/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook'/.
    auto.
    }
  rewrite /-> Hlook, -> Hlook'/.
  auto.
  }

  {
  rewrite /-> lookup_merge_right/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook/.
    auto.
    }
  rewrite /-> lookup_merge_left _# 6 b'/ >> auto.
  rewrite /-> lookup_map/.
  reduce //.
  rewrite /-> Hlook, -> Hlook'/.
  reduce //.
  auto.
  }

  {
  rewrite /-> lookup_merge_left _# 6 b/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook/.
    reduce //.
    rewrite /-> Hlook'/.
    reduce //.
    auto.
    }
  rewrite /-> lookup_merge_right/.
    {
    rewrite /-> lookup_map/.
    reduce //.
    rewrite /-> Hlook, -> Hlook'/.
    reduce //.
    auto.
    }
  auto.
  }

  {
  rewrite /-> lookup_merge_left _# 6 (h a b b')/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook/.
    reduce //.
    rewrite /-> Hlook'/.
    reduce //.
    auto.
    }
  rewrite /-> lookup_merge_left _# 6 (h a b b')/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlook'/.
    reduce //.
    rewrite /-> Hlook/.
    reduce //.
    auto.
    }
  auto.
  }
qed ();



lemma "lookup_combine_right"
/
  forall i (A B : U i) f g h (a : A) .
    lookup f a = None : option B
    -> lookup (combine f g h) a = lookup g a : option B
/;

inference.
intro /i A B f g h a Hlook/.
unfold /combine/.
rewrite /-> lookup_merge_right/ >> auto.
rewrite /-> lookup_map/.
rewrite /-> Hlook/ >> auto.
qed ();



lemma "lookup_combine_left"
/
  forall i (A B : U i) f g h (a : A) .
    lookup g a = None : option B
    -> lookup (combine f g h) a = lookup f a : option B
/;

inference.
intro /i A B f g h a Hlook/.
rewrite /-> combine_transpose/.
apply /lookup_combine_right/ >> auto.
qed ();



lemma "lookup_combine_both"
/
  forall i (A B : U i) f g h (a : A) b b' .
    lookup f a = Some b : option B
    -> lookup g a = Some b' : option B
    -> lookup (combine f g h) a = Some (h a b b') : option B
/;

inference.
intro /i A B f g h a b b' Hlookf Hlookg/.
unfold /combine/.
rewrite /-> lookup_merge_left _# 6 (h a b b')/ >> auto.
rewrite /-> lookup_map/.
rewrite /-> Hlookf/.
reduce //.
rewrite /-> Hlookg/.
auto.
qed ();



lemma "combine_empty_left"
/
  forall i (A B : U i) e f h .
    combine (empty e) f h = f : finite_map A B
/;

inference.
intro /i A B e f h/.
apply /finite_map_ext/.
intro /a/.
rewrite /-> lookup_combine_right/ >> auto.
apply /lookup_empty/.
qed ();



lemma "combine_empty_right"
/
  forall i (A B : U i) e f h .
    combine f (empty e) h = f : finite_map A B
/;

inference.
intro /i A B e f h/.
rewrite /-> combine_transpose/.
rewrite /-> combine_empty_left/.
reflexivity.
qed ();



lemma "combine_update_left_absent"
/
  forall i (A B : U i) f g h a b .
    lookup g a = None : option B
    -> combine (update f a b) g h = update (combine f g h) a b : finite_map A B
/;

inference.
intro /i A B f g h a b Hlookg/.
apply /finite_map_ext/.
intro /a'/.
so /finite_map_impl_eq_decidable _# 2 f a a'/ /Heq | Hneq/.
  {
  subst /a'/.
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_update at 0 0/.
  auto.
  }
rewrite /-> lookup_update_neq/ >>> [auto, idtac].
setEq /X/ /lookup g a'/ /_/ /Hlookg'/.
symmetryIn /Hlookg'/.
destruct /X/ /{| c'}/.
  {
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_update_neq/ >> auto.
  }
setEq /X/ /lookup f a'/ /_/ /Hlookf'/.
symmetryIn /Hlookf'/.
destruct /X/ /{| c}/.
  {
  rewrite /-> lookup_combine_right/.
    {
    rewrite /-> lookup_update_neq/ >> auto.
    }
  rewrite /-> lookup_combine_right/ >> auto.
  }
rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  {
  rewrite /-> lookup_update_neq/ >> auto.
  }

  {
  rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  }
qed ();



lemma "combine_update_right_absent"
/
  forall i (A B : U i) f g h a b .
    lookup f a = None : option B
    -> combine f (update g a b) h = update (combine f g h) a b : finite_map A B
/;

inference.
intro /i A B f g h a b Hlook/.
rewrite /-> combine_transpose at 0 1/.
apply /combine_update_left_absent/ >> auto.
qed ();



lemma "combine_update_left_present"
/
  forall i (A B : U i) f g h a b b' .
    lookup g a = Some b' : option B
    -> combine (update f a b) g h = update (combine f g h) a (h a b b') : finite_map A B
/;

inference.
intro /i A B f g h a b b' Hlookg/.
apply /finite_map_ext/.
intro /a'/.
so /finite_map_impl_eq_decidable _# 2 f a a'/ /Heq | Hneq/.
  {
  subst /a'/.
  rewrite /-> lookup_combine_both _# 7 b b'/ >> auto.
    {
    rewrite /-> lookup_update/ >> auto.
    }
  rewrite /-> lookup_update/.
  auto.
  }
rewrite /-> lookup_update_neq/ >>> [auto, idtac].
setEq /X/ /lookup g a'/ /_/ /Hlookg'/.
symmetryIn /Hlookg'/.
destruct /X/ /{| c'}/.
  {
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_update_neq/ >> auto.
  }
setEq /X/ /lookup f a'/ /_/ /Hlookf'/.
symmetryIn /Hlookf'/.
destruct /X/ /{| c}/.
  {
  rewrite /-> lookup_combine_right/.
    {
    rewrite /-> lookup_update_neq/ >> auto.
    }
  rewrite /-> lookup_combine_right/ >> auto.
  }
rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  {
  rewrite /-> lookup_update_neq/ >> auto.
  }

  {
  rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  }
qed ();



lemma "combine_update_right_present"
/
  forall i (A B : U i) f g h a b b' .
    lookup f a = Some b' : option B
    -> combine f (update g a b) h = update (combine f g h) a (h a b' b) : finite_map A B
/;

inference.
intro /i A B f g h a b b' Hlook/.
rewrite /-> combine_transpose at 0 1/.
apply /combine_update_left_present/ >> auto.
qed ();



lemma "combine_remove_left_absent"
/
  forall i (A B : U i) f g h a .
    lookup g a = None : option B
    -> combine (remove f a) g h = remove (combine f g h) a : finite_map A B
/;

inference.
intro /i A B f g h a Hlookg/.
apply /finite_map_ext/.
intro /a'/.
so /finite_map_impl_eq_decidable _# 2 f a a'/ /Heq | Hneq/.
  {
  subst /a'/.
  rewrite /-> lookup_remove/.
  rewrite /-> lookup_combine_right/ >> auto.
  apply /lookup_remove/.
  }
rewrite /-> lookup_remove_neq/ >>> [auto, idtac].
setEq /X/ /lookup g a'/ /_/ /Hlookg'/.
symmetryIn /Hlookg'/.
destruct /X/ /{| c'}/.
  {
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_remove_neq/ >> auto.
  }
setEq /X/ /lookup f a'/ /_/ /Hlookf'/.
symmetryIn /Hlookf'/.
destruct /X/ /{| c}/.
  {
  rewrite /-> lookup_combine_right/.
    {
    rewrite /-> lookup_remove_neq/ >> auto.
    }
  rewrite /-> lookup_combine_right/ >> auto.
  }
rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  {
  rewrite /-> lookup_remove_neq/ >> auto.
  }
rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
qed ();



lemma "combine_remove_right_absent"
/
  forall i (A B : U i) f g h a .
    lookup f a = None : option B
    -> combine f (remove g a) h = remove (combine f g h) a : finite_map A B
/;

inference.
intro /i A B f g h a Hlookg/.
rewrite /-> combine_transpose at 0 1/.
apply /combine_remove_left_absent/ >> auto.
qed ();



lemma "combine_remove_left_present"
/
  forall i (A B : U i) f g h a b .
    lookup g a = Some b : option B
    -> combine (remove f a) g h = update (combine f g h) a b : finite_map A B
/;

inference.
intro /i A B f g h a b' Hlookg/.
apply /finite_map_ext/.
intro /a'/.
so /finite_map_impl_eq_decidable _# 2 f a a'/ /Heq | Hneq/.
  {
  subst /a'/.
  rewrite /-> lookup_combine_right/.
    {
    rewrite /-> lookup_remove/ >> auto.
    }
  rewrite /-> lookup_update/.
  auto.
  }
rewrite /-> lookup_update_neq/ >>> [auto, idtac].
setEq /X/ /lookup g a'/ /_/ /Hlookg'/.
symmetryIn /Hlookg'/.
destruct /X/ /{| c'}/.
  {
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_remove_neq/ >> auto.
  }
setEq /X/ /lookup f a'/ /_/ /Hlookf'/.
symmetryIn /Hlookf'/.
destruct /X/ /{| c}/.
  {
  rewrite /-> lookup_combine_right/.
    {
    rewrite /-> lookup_remove_neq/ >> auto.
    }
  rewrite /-> lookup_combine_right/ >> auto.
  }
rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  {
  rewrite /-> lookup_remove_neq/ >> auto.
  }

  {
  rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
  }
qed ();



lemma "combine_remove_right_present"
/
  forall i (A B : U i) f g h a b .
    lookup f a = Some b : option B
    -> combine f (remove g a) h = update (combine f g h) a b : finite_map A B
/;

inference.
intro /i A B f g h a b Hlookg/.
rewrite /-> combine_transpose at 0 1/.
apply /combine_remove_left_present/ >> auto.
qed ();



lemma "map_combine"
/
  forall i (A B C : U i) (k : A -> B -> C) f g h h' .
    (forall a b b' . k a (h a b b') = h' a (k a b) (k a b') : C)
    -> map k (combine f g h) = combine (map k f) (map k g) h' : finite_map A C
/;

inference.
intro /i A B C k f g h h' Hcommute/.
apply /finite_map_ext/.
intro /a/.
rewrite /-> lookup_map/.
setEq /X/ /lookup g a/ /_/ /Hlookg/.
symmetryIn /Hlookg/.
destruct /X/ /{| c'}/.
  {
  rewrite /-> lookup_combine_left/ >>> [auto, idtac].
  rewrite /-> lookup_combine_left/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlookg/ >> auto.
    }
  rewrite /-> lookup_map/ >> auto.
  }
setEq /X/ /lookup f a/ /_/ /Hlookf/.
symmetryIn /Hlookf/.
destruct /X/ /{| c}/.
  {
  rewrite /-> lookup_combine_right/ >>> [auto, idtac].
  rewrite /-> lookup_combine_right/.
    {
    rewrite /-> lookup_map/.
    rewrite /-> Hlookf/ >> auto.
    }
  rewrite /-> lookup_map/ >> auto.
  }
rewrite /-> lookup_combine_both _# 7 c c'/ >> auto.
rewrite /-> lookup_combine_both _# 7 (k a c) (k a c')/.
  {
  rewrite /-> lookup_map/.
  rewrite /-> Hlookf/ >> auto.
  }

  {
  rewrite /-> lookup_map/.
  rewrite /-> Hlookg/ >> auto.
  }
reduce //.
compat.
apply /Hcommute/.
qed ();



(* Finite domain *)

lemma "finite_map_domain_quotient"
/
  forall i (A B : U i) (f : finite_map A B) .
    quotient
      (L L' : { L : list A | forall (a : A) . member f a <-> In A a L }) .
      forall (a : A) . In A a L <-> In A a L'
/;

inference.
intro /i A B f/.
exactRaw /List.map (fn x . x #1) (f #2)/.
unfold /member, lookup/.
destruct /f/ /[f g Hfg]/.
  {
  typecheck1 >> auto.
  typecheck1 >> auto.
  split.
    {
    intro /Hiff a/.
    rewrite /<- Hiff/.
    rewrite /-> Hfg/.
    reflexivity.
    }

    {
    intro /Hiff a/.
    rewrite /<- Hiff/.
    rewrite /-> Hfg/.
    reflexivity.
    }
  }
assert /forall (f : pre_finite_map A B) a . (exists (b : B) . pre_lookup A B f a = Some b : option B) <-> In A a (List.map (fn x . x #1) (f #2))/ /Hprop/.
  {
  clear /f g Hfg/.
  inference.
  intro /f a/.
  split.
    {
    intro /(b Heq)/.
    destruct /f/ /[e He] [f _]/.
    reduce //.
    revert /Heq/.
    unfold /pre_lookup/.
    induction /f/.
      {
      intro /H/.
      injection /H/.
      }

      {
      intro /(a' b') f IH/.
      reduce //.
      boolCase /e a a'/ /Heq/.
        {
        intro /_/.
        left.
        unhide.
        apply /He/ >> auto.
        }

        {
        intro /H/.
        right.
        apply /IH/ >> auto.
        }
      }
    }

    {
    destruct /f/ /[e He] [f _]/.
    unfold /pre_lookup/.
    reduce //.
    induction /f/.
      {
      intro /0/.
      }

      {
      intro /(a' b') f IH/.
      reduce //.
      intro /(Heq | H)/.
        {
        subst /a'/.
        boolEq true /e a a/ >> auto.
        existsAuto.
        }

        {
        boolCase /e a a'/ /Heq/.
          {
          existsAuto.
          }
          
          {
          apply /IH/ >> auto.
          }
        }
      }
    }
  }
extensionalityRaw.
  {
  typecheck.
    {
    intro /?/.
    symmetry.
    auto.
    }

    {
    intro /?/.
    transitivity /_/ >> auto.
    }
  }

  {
  typecheck.
  split.
  apply /Hprop/.
  }

  {
  typecheck.
  split.
  rewrite /-> Hfg h within h _/.
  apply /Hprop/.
  }

  {
  intro /a/.
  rewrite /<- Hprop f a/.
  rewrite /<- Hprop g a/.
  rewrite /-> Hfg/.
  reflexivity.
  }
qed ();



lemma "finite_map_domain_squash"
/
  forall i (A B : U i) (f : finite_map A B) .
    { exists (L : list A) . forall (a : A) . member f a <-> In A a L }
/;

inference.
intro /i A B f/.
so /finite_map_domain_quotient _# 3 f/ /L/.
destruct /L/ /[L]/.
destruct /L/ /[L HL]/.
split.
existsAuto.
qed ();



(* Miscellaneous *)

lemma "equipollent_finite_map"
/
  forall i (A B C : U i) .
    F.equipollent B C
    -> F.equipollent (finite_map A B) (finite_map A C)
/;

intro /i A B C Hequi/.
unfold /F.equipollent in Hequi in concl/.
destruct /Hequi/ /f g Hgf Hfg/.
exists /fn m . map (fn _ b . f b) m/.
unfold /F.bijective/.
exists /fn m . map (fn _ c . g c) m/.
split.
  {
  intro /m/.
  apply /finite_map_ext/.
  reduce //.
  intro /a/.
  rewrite /-> lookup_map at 0 0/.
  rewrite /-> Option.map_compose/.
  reduce //.
  rewrite /-> Hgf within _/.
  apply /Option.map_identity/.
  }

  {
  intro /m/.
  apply /finite_map_ext/.
  reduce //.
  intro /a/.
  rewrite /-> lookup_map at 0 0/.
  rewrite /-> Option.map_compose/.
  reduce //.
  rewrite /-> Hfg within _/.
  apply /Option.map_identity/.
  }
qed ();



lemma "subpollent_finite_map"
/
  forall i (A B C : U i) .
    F.subpollent B C
    -> F.subpollent (finite_map A B) (finite_map A C)
/;

intro /i A B C Hsub/.
unfold /F.subpollent in Hsub in concl/.
destruct /Hsub/ /f g Hgf/.
exists /fn m . map (fn _ b . f b) m/.
unfold /F.split_injective/.
exists /fn m . map (fn _ c . g c) m/.
intro /m/.
apply /finite_map_ext/.
reduce //.
intro /a/.
rewrite /-> lookup_map at 0 0/.
rewrite /-> Option.map_compose/.
reduce //.
rewrite /-> Hgf within _/.
apply /Option.map_identity/.
qed ();



lemma "finite_map_subtype"
/
  forall i (A B C : U i) . B <: C -> finite_map A B <: finite_map A C
/;

inference.
intro /i A B C HsubBC/.
assert /pre_finite_map A B <: pre_finite_map A C/ /HsubABC/.
  {
  unfold /pre_finite_map at 0 0/.
  intro /(e (l Hdist))/.
  typecheck.
  split.
  induction /Hdist/.
    {
    apply /Forall_dist_nil/.
    }
  intro /(a b) l Hall _ IH/.
  apply /Forall_dist_cons/ >> auto.
  reduce //.
  clear /IH/.
  induction /Hall/.
    {
    apply /Forall_nil/.
    }
  intro /(a' b') l Hneq _ IH/.
  apply /Forall_cons/ >> auto.
  }
intro /m/.
infer /finite_map A C/ /Hof/.
unfold /finite_map in m in concl in Hof/.
unfold /qpfm in m in concl in Hof/.
destruct /m/ /[m1 m2 Hm]/.
RuleTactic.quotientIntroEq >> auto.
intro /a/.
subsume /option B/ >> auto.
assert /forall (m : pre_finite_map A B) . pre_lookup A B m a = pre_lookup A C m a : option B/ /H/.
  {
  clear /m1 m2 Hm Hof/.
  intro /m/.
  unfold /pre_finite_map in m/.
  destruct /m/ /e m/.
  unfold /pre_lookup at 0 0/.
  reduce //.
  destruct /m/ /m _/.
  sinduction /m/.
  reintro /IH/.
  destruct /m/ /| (a' b) m/.
    {
    reduce //.
    reflexivity.
    }
  reduce //.
  boolCase /e a a'/ /Heq/ >>> [auto, idtac].
  apply /IH/.
  apply /List.cons_subterm/.
  }
transitivity /pre_lookup A B m1 a/.
  {
  symmetry.
  apply /H/.
  }
transitivity /pre_lookup A B m2 a/ >> auto.
qed ();



(* Impredicative quantification *)

lemma "kindlike_finite_map"
/
  forall i (A : U i) (B : U (1 + i)) .
    B
    -> K.kindlike i B
    -> K.kindlike i (finite_map A B)
/;

inference.
intro /i A B b0 Hkind/.
apply /K.kindlike_subpollent _ _ (finite_map A unit & (A -> B))/.
1:{
  apply /K.kindlike_prod/.
    {
    apply /K.kindlike_degenerate/.
    }

    {
    apply /K.kindlike_arrow_right/ >> auto.
    }
  }
unfold /F.subpollent/.
exists /fn f . (map (fn _ _ . ()) f, (fn a . option_case (lookup f a) b0 (fn b . b)))/.
unfold /F.split_injective/.
exists /fn p . map (fn a _ . p #2 a) (p #1)/.
intro /f/.
reduce //.
apply /finite_map_ext/.
intro /a/.
rewrite /-> lookup_map at 0 0/.
rewrite /-> Option.map_compose/.
reduce //.
remember /lookup f a/ /_/ /X/ /Hlook/.
destruct /X/ /{| b}/ >> auto.
qed ();


endModule ();
