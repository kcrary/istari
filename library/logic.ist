
Ctrl.use "logic-aux.iml";


Namespace.beginModule "Logic";


define /not P/
/
  P -> void
//
  intersect i .
    U i
    -> U i
/;

inference.
introOf /i P/.
unfold /not/.
typecheck.
qed ();


Constant.setOpacity (parseConstant /not/) Constant.SOFT;


lemma "not_inhabitant"
/
  forall i (P : U i) . not P -> (fn _ . ()) : not P
/;

inference.
intro /i P Hnot/.
introOf /H/.
so /Hnot H/ /0/.
qed ();



lemma "not_compat_arrow"
/
  forall i (P P' : U i) .
    (P -> P')
    -> (not P' -> not P)
/;

inference.
intro /i P P' Himp Hnot H/.
apply /Hnot/.
apply /Himp/.
hyp /H/.
qed ();



define /iff P Q/
/
  (P -> Q) & (Q -> P)
//
  intersect i .
    U i
    -> U i
    -> U i
/;

inference.
introOf /i P Q/.
unfold /iff/.
typecheck.
qed ();


Constant.setOpacity (parseConstant /iff/) Constant.SOFT;


lemma "iff_refl"
/
  forall i (P : U i) .
    P <-> P
/;

inference.
intro /i P/.
split >> auto.
qed ();



lemma "iff_symm"
/
  forall i (P Q : U i) .
    P <-> Q
    -> Q <-> P
/;

inference.
intro /i P Q H/.
destruct /H/ /H H'/.
split >> auto.
qed ();



lemma "iff_trans"
/
  forall i (P Q R : U i) .
    P <-> Q
    -> Q <-> R
    -> P <-> R
/;

inference.
intro /i P Q R HPQ HQR/.
destruct /HPQ/ /HPQ HQP/.
destruct /HQR/ /HQR HRQ/.
split >> intro /?/ >> auto.
qed ();



lemma "iff_compat"
/
  forall i (P P' Q Q' : U i) .
    P <-> P'
    -> Q <-> Q'
    -> (P <-> Q) <-> (P' <-> Q')
/;

inference.
intro /i P P' Q Q' (Hp Hp') (Hq Hq')/.
split.
  {
  intro /(Hpq Hqp)/.
  auto.
  }

  {
  intro /(Hpq Hqp)/.
  auto.
  }
qed ();



lemma "iff_compat_1"
/
  forall i (P P' Q : U i) .
    P <-> P'
    -> (P <-> Q) <-> (P' <-> Q)
/;

inference.
intro /i P P' Q H/.
apply /iff_compat/ >> auto.
qed ();



lemma "iff_compat_2"
/
  forall i (P Q Q' : U i) .
    Q <-> Q'
    -> (P <-> Q) <-> (P <-> Q')
/;

inference.
intro /i P Q Q' H/.
apply /iff_compat/ >> auto.
qed ();



lemma "not_compat_iff"
/
  forall i (P P' : U i) .
    P <-> P'
    -> (not P <-> not P')
/;

inference.
intro /i P P' Hiff/.
split.
  {
  intro /H/.
  apply /not_compat_arrow _ _ P/ >> auto.
  exact /Hiff #2/.
  }

  {
  intro /H/.
  apply /not_compat_arrow _ _ P'/ >> auto.
  exact /Hiff #1/.
  }
qed ();



structure Nothing = AfterIff ();
