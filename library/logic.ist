
File.import "logic-aux.iml";


Namespace.beginModule "Logic";


define /not P/
/
  P -> void
//
  intersect i .
    U i
    -> U i
/;

inference.
introOf /i P/.
unfold /not/.
typecheck.
qed ();


Constant.setOpacity (parseConstant /not/) Constant.SOFT;


lemma "not_inhabitant"
/
  forall i (P : U i) . not P -> (fn _ . ()) : not P
/;

inference.
intro /i P Hnot/.
introOf /H/.
so /Hnot H/ /0/.
qed ();



lemma "not_compat_arrow"
/
  forall i (P P' : U i) .
    (P -> P')
    -> (not P' -> not P)
/;

inference.
intro /i P P' Himp Hnot H/.
apply /Hnot/.
apply /Himp/.
hyp /H/.
qed ();



define /iff P Q/
/
  (P -> Q) & (Q -> P)
//
  intersect i .
    U i
    -> U i
    -> U i
/;

inference.
introOf /i P Q/.
unfold /iff/.
typecheck.
qed ();


Constant.setOpacity (parseConstant /iff/) Constant.SOFT;


lemma "iff_refl"
/
  forall i (P : U i) .
    P <-> P
/;

inference.
intro /i P/.
split >> auto.
qed ();



lemma "iff_symm"
/
  forall i (P Q : U i) .
    P <-> Q
    -> Q <-> P
/;

inference.
intro /i P Q H/.
destruct /H/ /H H'/.
split >> auto.
qed ();



lemma "iff_trans"
/
  forall i (P Q R : U i) .
    P <-> Q
    -> Q <-> R
    -> P <-> R
/;

inference.
intro /i P Q R HPQ HQR/.
destruct /HPQ/ /HPQ HQP/.
destruct /HQR/ /HQR HRQ/.
split >> intro /?/ >> auto.
qed ();



lemma "iff_compat"
/
  forall i (P P' Q Q' : U i) .
    P <-> P'
    -> Q <-> Q'
    -> (P <-> Q) <-> (P' <-> Q')
/;

inference.
intro /i P P' Q Q' (Hp Hp') (Hq Hq')/.
split.
  {
  intro /(Hpq Hqp)/.
  auto.
  }

  {
  intro /(Hpq Hqp)/.
  auto.
  }
qed ();



lemma "iff_compat_1"
/
  forall i (P P' Q : U i) .
    P <-> P'
    -> (P <-> Q) <-> (P' <-> Q)
/;

inference.
intro /i P P' Q H/.
apply /iff_compat/ >> auto.
qed ();



lemma "iff_compat_2"
/
  forall i (P Q Q' : U i) .
    Q <-> Q'
    -> (P <-> Q) <-> (P <-> Q')
/;

inference.
intro /i P Q Q' H/.
apply /iff_compat/ >> auto.
qed ();



lemma "not_compat_iff"
/
  forall i (P P' : U i) .
    P <-> P'
    -> (not P <-> not P')
/;

inference.
intro /i P P' Hiff/.
split.
  {
  intro /H/.
  apply /not_compat_arrow _ _ P/ >> auto.
  exact /Hiff #2/.
  }

  {
  intro /H/.
  apply /not_compat_arrow _ _ P'/ >> auto.
  exact /Hiff #1/.
  }
qed ();



lemma "prod_compat_iff"
/
  forall i (P P' Q Q' : U i) .
    P <-> P'
    -> Q <-> Q'
    -> P & Q <-> P' & Q'
/;

inference.
intro /i P P' Q Q' Hp Hq/.
split.
  {
  intro /(H H')/.
  (split >>> [apply /Hp/ , apply /Hq/]) >> auto.
  }

  {
  intro /(H H')/.
  (split >>> [apply /Hp/ , apply /Hq/]) >> auto.
  }
qed ();



lemma "sum_compat_iff"
/
  forall i (P P' Q Q' : U i) .
    P <-> P'
    -> Q <-> Q'
    -> P % Q <-> P' % Q'
/;

inference.
intro /i P P' Q Q' Hp Hq/.
split.
  {
  (intro /(H | H)/ >>> [left >> apply /Hp/, right >> apply /Hq/]) >> auto.
  }

  {
  (intro /(H | H)/ >>> [left >> apply /Hp/, right >> apply /Hq/]) >> auto.
  }
qed ();



structure Nothing = AfterIff ();



lemma "prod_commute"
/
  forall i (P Q : U i) . P & Q <-> Q & P
/;

inference.
intro /i P Q/.
split >> intro /(? ?)/ >> auto.
qed ();



lemma "prod_assoc"
/
  forall i (P Q R : U i) . (P & Q) & R <-> P & (Q & R)
/;

inference.
intro /i P Q R/.
split.
  {
  intro /((? ?) ?)/.
  auto.
  }

  {
  intro /(? (? ?))/.
  auto.
  }
qed ();



lemma "prod_id_l"
/
  forall i (P : U i) . unit & P <-> P
/;

inference.
intro /i P/.
split.
  {
  intro /(_ H)/.
  auto.
  }

  {
  intro /H/.
  auto.
  }
qed ();



lemma "prod_id_r"
/
  forall i (P : U i) . P & unit <-> P
/;

inference.
intro /i P/.
rewrite /-> prod_commute/.
apply /prod_id_l/.
qed ();



lemma "prod_ann_l"
/
  forall i (P : U i) . void & P <-> void
/;

inference.
intro /i P/.
split.
  {
  intro /(0 _)/.
  }

  {
  intro /0/.
  }
qed ();



lemma "prod_ann_r"
/
  forall i (P : U i) . P & void <-> void
/;

inference.
intro /i P/.
rewrite /-> prod_commute/.
apply /prod_ann_l/.
qed ();



lemma "sum_commute"
/
  forall i (P Q : U i) . P % Q <-> Q % P
/;

inference.
intro /i P Q/.
split >> intro /(? | ?)/ >> auto.
qed ();



lemma "sum_assoc"
/
  forall i (P Q R : U i) . (P % Q) % R <-> P % (Q % R)
/;

inference.
intro /i P Q R/.
split.
  {
  intro /((? | ?) | ?)/ >> auto.
  }

  {
  intro /(? | (? | ?))/ >> auto.
  }
qed ();



lemma "sum_id_l"
/
  forall i (P : U i) . void % P <-> P
/;

inference.
intro /i P/.
split.
  {
  intro /(0 | H)/.
  auto.
  }

  {
  intro /H/.
  auto.
  }
qed ();



lemma "sum_id_r"
/
  forall i (P : U i) . P % void <-> P
/;

inference.
intro /i P/.
rewrite /-> sum_commute/.
apply /sum_id_l/.
qed ();



lemma "sum_ann_l"
/
  forall i (P : U i) . unit % P <-> unit
/;

inference.
intro /i P/.
split >> auto.
qed ();



lemma "sum_ann_r"
/
  forall i (P : U i) . P % unit <-> unit
/;

inference.
intro /i P/.
rewrite /-> sum_commute/.
apply /sum_ann_l/.
qed ();



lemma "true_iff_unit"
/
  forall i (P : U i) . P -> P <-> unit
/;

inference.
intro /i P H/.
split >> auto.
qed ();



lemma "false_iff_void"
/
  forall i (P : U i) . not P -> P <-> void
/;

inference.
intro /i P H/.
split >> auto.
intro /0/.
qed ();



lemma "eq_refl"
/
  forall i (a : U i) (x : a) . x = x : a
/;

inference.
intro /i a x/.
reflexivity.
qed ();


lemma "eq_symm"
/
  forall i (a : U i) (x y : a) . x = y : a -> y = x : a
/;

inference.
intro /i a x y H/.
auto.
qed ();



lemma "eq_symm_iff"
/
  forall i (a : U i) (x y : a) . x = y : a <-> y = x : a
/;

inference.
intro /i a x y/ >> split >> auto.
qed ();



lemma "eq_trans"
/
  forall i (a : U i) (x y z : a) . x = y : a -> y = z : a -> x = z : a
/;

inference.
intro /i a x y z Hxy Hyz/.
transitivity /y/ >> auto.
qed ();
