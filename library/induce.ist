
openModule /Partial/;
openModule /Acc/;


beginModule "Induce";



define /approx {a b} f g/
/
  forall (x : a) . halts (f x) -> f x = g x : partial (b x)
//
  intersect i . forall (a : U i) (b : a -> U i) .
    (partial (forall (x : a) . partial (b x)))
    -> (partial (forall (x : a) . partial (b x)))
    -> U i
/;

unfold /approx/.
typecheck.
qed ();



define /induce {a b} f x y/
/
  forall (g : partial (forall (x : a) . partial (b x))) .
    approx g (fix f)
    -> halts (f g y)
    -> halts (g x)
//
  intersect i . forall (a : U i) (b : a -> U i) .
    (partial (forall (x : a) . partial (b x)) -> partial (forall (x : a) . partial (b x)))
    -> (forall (x : a) . admiss (b x))
    -g> a -> a -> U (1 + i)
/;

inference.
introOf /i a b f Hadmiss/.
assert /fix f : partial (forall (x : a) . partial (b x))/ /Hoffix/.
  {
  RuleTactic.fixpointInductionOf >> auto.
  RuleTactic.forallAdmiss >> auto.
  RuleTactic.partialAdmiss.
  auto.
  }
assert /forall (z : a) . fix f z : partial (b z)/ /Hof/.
  {
  inference.
  intro /z/.
  inferSpine /Hoffix/ /__ z/ /H/.
  hyp /H/.
  }
unfold /induce/.
typecheck.
qed ();



lemma "induce_well_founded"
/
  forall i (a : U i) (b : a -> U i) (f : partial (forall (x : a) . partial (b x)) -> partial (forall (x : a) . partial (b x))) .
    uptype a
    -> (forall (x : a) . admiss (b x))
    -> (forall g g' . approx g g' -> approx (f g) (f g'))
    -> forall (x : a) . halts (fix f x) -> Acc a (induce f) x
/;

inference.
intro /i a b f Ha Hb Hmono/.
assert /fix f : partial (forall (x : a) . partial (b x))/ /Hoffix/.
  {
  RuleTactic.fixpointInductionOf >> auto.
  RuleTactic.forallAdmiss >> auto.
  RuleTactic.partialAdmiss.
  auto.
  }
assert /forall (z : a) . fix f z : partial (b z)/ /Hof/.
  {
  inference.
  intro /z/.
  inferSpine /Hoffix/ /__ z/ /H/.
  hyp /H/.
  }
assert /forall (x : a) . halts (fix f x) -> Acc a (induce f) x & fix f x = fix f x : partial (b x)/ /H/.
1:{
  intro /x Hhalt/.
  apply /H/ >> auto.
  }
abstractOverAt /fix f/ /concl/ /0 1/.
goalCaseT
  /| ? @ _ =>
     \(fnc p =>
         apply /fixpoint_induction (lsucc i) (forall (x : a) . partial (b x)) \p\ f/ >> auto)\
  /.
  {
  RuleTactic.forallAdmiss >> auto.
  RuleTactic.partialAdmiss.
  auto.
  }

  {
  reduce //.
  RuleTactic.forallPadmissDomainClosed (parseCurr /a/) >> auto.
  RuleTactic.arrowPadmissDomainHalts (parseCurr /additional` _ . (b x)/) >> auto.
  RuleTactic.prodPadmiss.
    {
    Partiality.proveAdmiss.
    }

    {
    RuleTactic.eqPadmiss >> auto.
    RuleTactic.padmissClosed (Term.evar ()) >> auto.
    RuleTactic.partialAdmiss.
    auto.
    }
  }

(* base case *)
{
reduce //.
intro /g Hif x Hhaltgx/.
termination /Hhaltgx/.
apply /Hif/ >> auto.
}

(* inductive case *)
{
reduce //.
intro /g IH x Hhaltfgx/.
split.
  {
  apply /Acc_intro/.
  intro /y Hyx/.
  apply /IH/.
  unfold /induce in Hyx/.
  apply /Hyx g/ >> auto.
  }

  {
  unroll /fix/.
  witness /Hmono g (fix f) __ x Hhaltfgx/.
  intro /y Hhalt/.
  apply /IH/ >> auto.
  }
}
qed ();



endModule ();
