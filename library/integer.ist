
File.import "acc-load.iml";
File.import "nat-load.iml";
File.import "logic-load.iml";
File.import "bool-load.iml";
File.import "decidable-load.iml";
File.import "partial-load.iml";
File.import "stable-load.iml";

File.import "integer-aux.iml";

Namespace.beginModule "Integer";


aliasExport /eqzb/ Prim.eqzb;
aliasExport /leqzb/ Prim.leqzb;
aliasExport /negz/ Prim.negz;
aliasExport /plusz/ Prim.plusz;
aliasExport /timesz/ Prim.timesz;


(* Built-in:

definerecRaw /nat_to_integer n/
/
  nat_case n
    z`0
    (fn n' . plusz (`z 1) (nat_to_integer n'))
/;

definerecRaw /integer_to_nat x/
/
  if leqzb x z`0 then
    zero
  else
    succ (integer_to_nat (plusz z`-1 x))
/;


*)

aliasExport /nat_to_integer/ Prim.nat_to_integer;
aliasExport /integer_to_nat/ Prim.integer_to_nat;



lemma "integer_type"
/
  integer : U 0
/;

typecheck.
qed ();
Define.recordTyping "integer_type";



defineRaw /leqz x y/
/
  Bool.istrue (leqzb x y)
/;

val leqz = parseConstant /leqz/;


defineRaw /ltz x y/
/
  leqz (plusz z`1 x) y
/;

val ltz = parseConstant /ltz/;


defineRaw /minusz x y/
/
  plusz x (negz y)
/;

val minusz = parseConstant /minusz/;

Define.registerNative 0 2 (Define.unfold1 minusz 2);


writeRegistry /AfterLtzEnv/
  /[constant constant constant]/
  (Collapse (leqz, ltz, minusz));
structure Nothing = AfterLtz ();



(* Integers defined as a quotient over products of natural numbers *)

beginModule "Def";



(* Built-in:

define /Integer/
/
  quotient (a b : nat & nat) . a #1 + b #2 = a #2 + b #1 : nat
//
  U 0
/;
*)

aliasExport /Integer/ Prim.cInteger;



(* Built-in:

define /Plusz a b/
/
  (a #1 + b #1 , a #2 + b #2)
//
  Integer -> Integer -> Integer
/;
*)

aliasExport /Plusz/ Prim.cPlusz;



(* Built-in:

define /Negz a/
/
  (a #2 , a #1)
//
  Integer -> Integer
/;
*)

aliasExport /Negz/ Prim.cNegz;



(* Built-in:

define /Timesz a b/
/
  (a #1 * b #1 + a #2 * b #2 , a #1 * b #2 + a #2 * b #1)
//
  Integer -> Integer -> Integer
/;
*)

aliasExport /Timesz/ Prim.cTimesz;



(* Built-in:

define /Eqzb a b/
/
  Nat.eqb (a #1 + b #2) (a #2 + b #1)
//
  Integer -> Integer -> bool
/;
*)

Namespace.aliasExport (parseIdent /Eqzb/) Prim.cEqzb;



(* Built-in:

define /Leqzb a b/
/
  Nat.leqb (a #1 + b #2) (a #2 + b #1)
//
  Integer -> Integer -> bool
/;
*)

aliasExport /Leqzb/ Prim.cLeqzb;



lemma "diff_trans"
/
  forall (a a' b b' c c' : nat) .
    a + b' = a' + b : nat
    -> b + c' = b' + c : nat
    -> a + c' = a' + c : nat
/;

intro /a a' b b' c c' Hab Hbc/.
apply /Nat.plus_cancel_r _ _ (b + b')/.
rewrite /-> Nat.plus_commute b b'/.
rewrite /-> Nat.plus_assoc/.
rewrite /-> Nat.plus_commute at 1/.
rewrite /-> Nat.plus_assoc at 1/.
rewrite /-> Nat.plus_commute c (b + b')/.
rewrite /<- Nat.plus_assoc at all/.
rewrite /-> Nat.plus_assoc/.
rewrite /-> Nat.plus_assoc at 1/.
compat >> auto.
qed ();



lemma "Integer_type"
/
  Integer : U 0
/;

unfold /Integer/.
typecheck.
  {
  reintro /H/.
  symmetry.
  rewrite /-> Nat.plus_commute at 0 1/.
  hyp /H/.
  }

  {
  reintro /p q r Hpq Hqr/.
  apply /diff_trans/ >> auto.
  }
qed ();
Define.recordTyping "Integer_type";



ConstantTable.insert DestructInternal.destructTactics (parseConstant /Integer/)
  DestructInternal.destUserQuotient;



lemma "Integer_of"
/
  forall (a b : nat) .
    (a , b) : Integer
/;

inference.
intro /a b/.
infer /Integer/ /Htype/.
unfold /Integer in Htype/.
unfold /Integer/.
typecheck.
reduce //.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "Integer_subtype"
/
  (nat & nat) <: Integer
/;

intro /(a b)/.
apply /Integer_of/.
qed ();



lemma "Integer_eq"
/
  forall a b c d .
    a + d = b + c : nat
    -> (a , b) = (c , d) : Integer
/;

inference.
intro /a b c d Heq/.
infer /Integer/ /Htype/.
unfold /Integer in Htype/.
unfold /Integer/.
extensionality.
reduce //.
auto.
qed ();



define /Zeroz/
/
  (0 , 0)
//
  Integer
/;

unfold /Zeroz/.
apply /Integer_of/.
qed ();



define /Onez/
/
  (1 , 0)
//
  Integer
/;

unfold /Onez/.
apply /Integer_of/.
qed ();



lemma "neq_Zeroz_Onez"
/
  Zeroz = Onez : Integer -> void
/;

intro /Heq/.
unfold /Integer in Heq/.
unfold /Zeroz in Heq , Onez in Heq/.
injection /Heq/.
reintro /Heq'/.
unhide.
reduce /Heq'/.
exact /Nat.eq_0_succ_not _ Heq'/.
qed ();



lemma "Plusz_type"
/
  Plusz : Integer -> Integer -> Integer
/;

introOf /p q/.
unfold /Plusz/.
reduce //.
unfold /Integer in p , Integer in q/.
destruct /p/ /[(p1 p2) (p1' p2') Hp]/.
reduce /Hp/.
destruct /q/ /[(q1 q2) (q1' q2') Hq]/.
reduce /Hq/.
reduce //.
apply /Integer_eq/.
so /Nat.plus_compat _# 4 Hp Hq/ /H/.
clear /Hp Hq/.
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /<- Nat.plus_assoc at all/.
rewrite /-> Nat.plus_assoc at 1/.
rewrite /-> Nat.plus_commute at 2/.
rewrite /<- Nat.plus_assoc/.
rewrite /-> Nat.plus_assoc at 3/.
rewrite /-> Nat.plus_commute at 5/.
rewrite /<- Nat.plus_assoc/.
hyp /H/.
qed ();
Define.recordTyping "Plusz_type";



lemma "Negz_type"
/
  Negz : Integer -> Integer
/;

introOf /p/.
unfold /Negz/.
reduce //.
unfold /Integer in p/.
destruct /p/ /[(p1 p2) (p1' p2') Hp]/.
reduce /Hp concl/.
apply /Integer_eq/.
symmetry.
hyp /Hp/.
qed ();
Define.recordTyping "Negz_type";



lemma "plus_swap"
/
  forall (m n p : nat) .
    m + n + p = m + p + n : nat
/;

intro /m n p/.
rewrite /-> Nat.plus_assoc at 0 0/.
rewrite /-> Nat.plus_commute at 1/.
reflexivity.
qed ();



lemma "Timesz_type"
/
  Timesz : Integer -> Integer -> Integer
/;

introOf /p q/.
unfold /Timesz/.
unfold /Integer in p in q/.
destruct /p/ /[(a b) (a' b') Hab]/.
reduce /Hab/.
destruct /q/ /[(c d) (c' d') Hcd]/.
reduce /Hcd concl/.
apply /Integer_eq/.
rewrite /<- Nat.plus_assoc at all/.
rewrite /-> Nat.plus_commute in Hab at 1/.
rewrite /-> Nat.plus_commute in Hcd at 1/.
so /Nat.times_compat _# 4 Hab Hcd/ /H1/.
symmetryIn /Hcd/.
so /Nat.times_compat _# 4 Hab Hcd/ /H2/.
rewrite /-> Nat.times_dist_plus_l in H1 at all in H2 at all/.
rewrite /-> Nat.times_dist_plus_r in H1 at all in H2 at all/.
so /Nat.plus_compat _# 4 H1 H2/ /H/.
clear /H1 H2/.
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /-> plus_swap in H at 3 2 1 0/.
rewrite /-> plus_swap in H at 5 4 3 2 1/.
rewrite /-> plus_swap in H at 7/.
rewrite /-> Nat.plus_assoc in H at 0 5/.
so /Nat.plus_cancel_r_eq _# 4 H __/ /H'/.
  {
  rewrite /<- Nat.times_dist_plus_l at all/.
  apply /Nat.times_compat/ >> auto.
  }
clear /H/ >> rename /H'/ /H/.
rewrite /-> plus_swap in H at 1/.
rewrite /-> plus_swap in H at 5 4/.
rewrite /-> plus_swap in H at 7 6 5/.
rewrite /-> Nat.plus_assoc in H at 0 3/.
so /Nat.plus_cancel_r_eq _# 4 H __/ /H'/.
  {
  rewrite /<- Nat.times_dist_plus_l at all/.
  apply /Nat.times_compat/ >> auto.
  }
clear /H/ >> rename /H'/ /H/.
rewrite /-> plus_swap in H at 0 1/.
rewrite /-> plus_swap at 0 1/.
rewrite /-> plus_swap at 3/.
rewrite /-> Nat.plus_commute at 5/.
rewrite /-> plus_swap in H at 2 3/.
rewrite /-> plus_swap at 3/.
so /Nat.plus_compat _# 4 H (Logic.eq_refl _ _ (b * d + a' * d' + a * d + b' * d'))/ /H'/.
clear /H/ >> rename /H'/ /H/.
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /-> plus_swap in H at 3 4/.
rewrite /-> plus_swap in H at 2 3/.
rewrite /-> plus_swap in H at 7 8 9 10/.
rewrite /-> plus_swap in H at 6 7 8 9/.
rewrite /-> Nat.plus_assoc in H at 2 1 0/.
rewrite /-> Nat.plus_assoc in H at 7 6 5/.
witness /Nat.plus_cancel_r_eq _# 4 H __/.
clear /H/.
rewrite /-> Nat.plus_commute at 2/.
rewrite /-> plus_swap at 1/.
rewrite /<- Nat.times_dist_plus_r/.
rewrite /-> Nat.plus_assoc at 0/.
rewrite /<- Nat.times_dist_plus_r/.
rewrite /-> Hcd/.
rewrite /<- Nat.times_dist_plus_l/.
rewrite /-> Nat.plus_commute at 4/.
rewrite /<- plus_swap at 0 1/.
rewrite /<- Nat.times_dist_plus_r/.
rewrite /-> Nat.plus_assoc at 0/.
rewrite /<- Nat.times_dist_plus_r/.
rewrite /-> Hcd/.
rewrite /<- Nat.times_dist_plus_l/.
rewrite /<- Hab/.
reflexivity.
qed ();
Define.recordTyping "Timesz_type";



lemma "Eqzb_type"
/
  Eqzb : Integer -> Integer -> bool
/;

introOf /p q/.
unfold /Eqzb/.
unfold /Integer in p , Integer in q/.
destruct /p/ /[(p1 p2) (p1' p2') Hp]/.
reduce /Hp/.
destruct /q/ /[(q1 q2) (q1' q2') Hq]/.
reduce /Hq/.
reduce //.
rewrite /<- Bool.iff_eq_bool/.
rewrite /-> Nat.istrue_eqb at all/.
symmetryIn /Hp/.
so /Nat.plus_compat _# 4 Hp Hq/ /H/.  
rewrite /-> Nat.plus_commute in H at 1 2 4 5/.
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /-> Nat.plus_assoc in H at 1 2/.
rewrite /-> Nat.plus_commute in H at 2 5/.
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /-> Nat.plus_assoc in H at 0 1/.
split.
  {
  intro /Heq/.
  moveBefore /Heq/ /H/.
  rewrite /<- Heq in H/.
  apply /Nat.plus_cancel_r _ _ (p1 + q2)/.
  hyp /H/.
  }
  
  {
  intro /Heq/.
  moveBefore /Heq/ /H/.
  rewrite /<- Heq in H/.
  apply /Nat.plus_cancel_l _ _ (p1' + q2')/.
  symmetry.
  hyp /H/.
  }
qed ();
Define.recordTyping "Eqzb_type";



lemma "istrue_Eqzb"
/
  forall a b . Bool.istrue (Eqzb a b) <-> a = b : Integer
/;

inference.
intro /a b/.
split.
  {
  intro /Heq/.
  infer /a/ /Hofa/.
  destruct /a/ /[(a a') Ha]/.
  destruct /b/ /[(b b') Hb]/.
  unfold /Eqzb in Heq/.
  rewrite /-> Nat.istrue_eqb in Heq/.
  apply /Integer_eq/.
  hyp /Heq/.
  }

  {
  intro /Heq/.
  subst /b/.
  destruct /a/ /[a Heq]/.
  unfold /Eqzb/.
  unhide.
  rewrite /-> Nat.istrue_eqb/.
  hyp /Heq/.
  }
qed ();



lemma "Leqzb_type"
/
  Leqzb : Integer -> Integer -> bool
/;

introOf /p q/.
unfold /Leqzb/.
unfold /Integer in p , Integer in q/.
destruct /p/ /[(p1 p2) (p1' p2') Hp]/.
reduce /Hp/.
destruct /q/ /[(q1 q2) (q1' q2') Hq]/.
reduce /Hq/.
reduce //.
rewrite /<- Bool.iff_eq_bool/.
rewrite /-> Nat.istrue_leqb at all/.
symmetryIn /Hp/.
so /Nat.plus_compat _# 4 Hp Hq/ /H/.  
rewrite /-> Nat.plus_commute in H at 1 2 4 5/.
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /-> Nat.plus_assoc in H at 1 2/.
rewrite /-> Nat.plus_commute in H at 2 5/.
rewrite /<- Nat.plus_assoc in H at all/.
split.
  {
  intro /Hleq/.
  apply /Nat.plus_cancel_leq_leq_r _ _ (p2 + q1) (p1 + q2)/ >> auto.
  apply /Nat.leq_refl_eq/.
  rewrite /<- Nat.plus_assoc at all/.
  hyp /H/.
  }

  {
  intro /Hleq/.
  apply /Nat.plus_cancel_leq_leq_l (p2' + q1') (p1' + q2')/ >> auto.
  apply /Nat.leq_refl_eq/.
  rewrite /<- Nat.plus_assoc at all/.
  symmetry.
  hyp /H/.
  }
qed ();
Define.recordTyping "Leqzb_type";



define /Leqz a b/
/
  Bool.istrue (Leqzb a b)
//
  Integer -> Integer -> U 0
/;

unfold /Leqz/.
typecheck.
qed ();



define /Ltz a b/
/
  Leqz (Plusz Onez a) b
//
  Integer -> Integer -> U 0
/;

unfold /Ltz/.
typecheck.
qed ();



lemma "Leqz_inhabitant"
/
  forall (a b : Integer) . Leqz a b -> () : Leqz a b
/;

intro /p q H/.
unfold /Leqz in H in concl/.
apply /Bool.istrue_inhabitant/ >> auto.
qed ();



ConstantTable.insert TypecheckInternal.trivialIntroTactics (parseConstant /Leqz/)
  (Backchain.applyPriority /Leqz_inhabitant/);



lemma "Leqz_Zeroz_Onez"
/
  Leqz Zeroz Onez
/;

unfold /Zeroz , Onez , Leqz , Leqzb/.
reduce //.
unroll /Nat.leqb/.
reduce //.
apply /Bool.istrue_true/.
qed ();



lemma "Leqz_refl"
/
  forall a . Leqz a a
/;

inference.
intro /p/.
destruct /p/ /[p]/.
so /Integer_subtype/ /?/.
unhide.
unfold /Leqz/.
unfold /Leqzb/.

(* Why isn't testRewrite unifying variables?? *)
testRewrite /-> Nat.istrue_leqb/;

rewrite /-> Nat.istrue_leqb/.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "Leqz_trans"
/
  forall a b c . Leqz a b -> Leqz b c -> Leqz a c
/;

inference.
intro /p q r Hpq Hqr/.
infer /p/ /Hofp/.
infer /r/ /Hofr/.
destruct /p/ /[(p1 p2)]/.
destruct /q/ /[(q1 q2)]/.
destruct /r/ /[(r1 r2)]/.
unfold /Leqz in Hpq in Hqr in concl/.
unfold /Leqzb in Hpq in Hqr in concl/.
reduce /Hpq Hqr concl/.
rewrite /-> Nat.istrue_leqb in Hpq in Hqr in concl/.
clear /Hofp Hofr/.
so /Nat.plus_leq _# 4 Hpq Hqr/ /H/.
apply /Nat.plus_cancel_leq_r _ _ (q1 + q2)/.
rewrite /<- Nat.plus_assoc at all/.
rewrite /-> Nat.plus_assoc at 0 0 0 0/.
rewrite /-> Nat.plus_commute at 1 2 4/.
rewrite /<- Nat.plus_assoc in concl at all in H at all/.
hyp /H/.
qed ();



lemma "Leqz_antisymm"
/
  forall a b . Leqz a b -> Leqz b a -> a = b : Integer
/;

inference.
intro /p q Hpq Hqp/.
so /Integer_of/ /Hof/.
destruct /p/ /[(p1 p2)]/.
destruct /q/ /[(q1 q2)]/.
apply /Integer_eq/.
unfold /Leqz in Hpq in Hqp/.
unfold /Leqzb in Hpq in Hqp/.
rewrite /-> Nat.istrue_leqb in Hpq in Hqp/.
rewrite /-> Nat.plus_commute in Hqp at 0 1/.
apply /Nat.leq_antisymm/ >> auto.
qed ();



lemma "Plusz_id_l"
/
  forall a . Plusz Zeroz a = a : Integer
/;

inference.
intro /p/.
so /Integer_of/ /Hof/.
destruct /p/ /[(p1 p2)]/.
unfold /Zeroz , Plusz/.
reduce //.
reflexivity.
qed ();



lemma "Plusz_commute"
/
  forall a b . Plusz a b = Plusz b a : Integer
/;

inference.
intro /a b/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Plusz at all/.
reduce //.
apply /Integer_eq/.
rewrite /-> Nat.plus_commute at 0 1 2/.
reflexivity.
qed ();



lemma "Plusz_assoc"
/
  forall a b c . Plusz (Plusz a b) c = Plusz a (Plusz b c) : Integer
/;

inference.
intro /a b c/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
destruct /c/ /[(c c')]/.
unfold /Plusz at all/.
reduce //.
apply /Integer_eq/.
rewrite /-> Nat.plus_commute/.
rewrite /<- Nat.plus_assoc at all/.
reflexivity.
qed ();



lemma "Plusz_inverse_l"
/
  forall a . Plusz (Negz a) a = Zeroz : Integer
/;

inference.
intro /a/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
unfold /Zeroz at all , Negz at all , Plusz at all/.
reduce //.
apply /Integer_eq/.
rewrite /-> Nat.plus_0_r at all/.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "Negz_invol"
/
  forall a . Negz (Negz a) = a : Integer
/;

inference.
intro /a/.
infer /a/ /Hofa/.
destruct /a/ /[(a a')]/.
unfold /Negz at all/.
reflexivity.
qed ();



lemma "Negz_Plusz"
/
  forall a b . Negz (Plusz a b) = Plusz (Negz a) (Negz b) : Integer
/;

inference.
intro /a b/.
infer /a/ /Hofa/.
infer /b/ /Hofb/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Plusz at all , Negz at all/.
reduce //.
reflexivityRaw.
apply /Integer_of/.
qed ();



lemma "Plusz_Leqz"
/
  forall (a a' b b' : Integer) . Leqz a a' -> Leqz b b' -> Leqz (Plusz a b) (Plusz a' b')
/;

intro /a a' b b' Ha Hb/.
infer /a/ /Hofa/.
infer /a'/ /Hofa'/.
infer /b/ /Hofb/.
infer /b'/ /Hofb'/.
destruct /a/ /[(a1 a2)]/.
destruct /a'/ /[(a1' a2')]/.
destruct /b/ /[(b1 b2)]/.
destruct /b'/ /[(b1' b2')]/.
unfold /Plusz at all/.
reduce //.
unfold /Leqz in Ha in Hb in concl/.
unfold /Leqzb in Ha in Hb in concl/.
reduce /Ha Hb concl/.
rewrite /-> Nat.istrue_leqb in Ha in Hb in concl/.
clear /Hofa Hofa' Hofb Hofb'/.
so /Nat.plus_leq _# 4 Ha Hb/ /H/.
rewrite /<- Nat.plus_assoc in H at all in concl at all/.
rewrite /-> Nat.plus_assoc at 1 2/.
rewrite /-> Nat.plus_commute at 2 5/.
rewrite /<- Nat.plus_assoc at all/.
hyp /H/.
qed ();



lemma "Negz_Leqz"
/
  forall a b . Leqz a b -> Leqz (Negz b) (Negz a)
/;

inference.
intro /a b H/.
infer /a/ /Hofa/.
infer /b/ /Hofb/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Negz at all , Leqz in H in concl , Leqzb in H in concl/.
reduce /H concl/.
rewrite /-> Nat.istrue_leqb in H in concl/.
rewrite /-> Nat.plus_commute at 0 1/.
hyp /H/.
qed ();



lemma "Timesz_id_l"
/
  forall a . Timesz Onez a = a : Integer
/;

inference.
intro /p/.
so /Integer_of/ /Hof/.
destruct /p/ /[(p1 p2)]/.
unfold /Onez , Timesz/.
reduce //.
rewrite /-> Nat.plus_0_r at all/.
reflexivity.
qed ();



lemma "Timesz_ann_l"
/
  forall a . Timesz Zeroz a = Zeroz : Integer
/;

inference.
intro /p/.
so /Integer_of/ /Hof/.
destruct /p/ /[(p1 p2)]/.
unfold /Zeroz at all , Timesz/.
reduce //.
reflexivity.
qed ();



lemma "Timesz_commute"
/
  forall a b . Timesz a b = Timesz b a : Integer
/;

inference.
intro /a b/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Timesz at all/.
reduce //.
rewrite /-> Nat.times_commute at 0 1 2 3/.
rewrite /-> Nat.plus_commute at 3/.
reflexivity.
qed ();



lemma "Timesz_assoc"
/
  forall a b c . Timesz (Timesz a b) c = Timesz a (Timesz b c) : Integer
/;

inference.
intro /a b c/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
destruct /c/ /[(c c')]/.
unfold /Timesz at all/.
reduce //.
rewrite /-> Nat.times_dist_plus_l at all/.
rewrite /-> Nat.times_dist_plus_r at all/.
rewrite /<- Nat.times_assoc at all/.
rewrite /<- Nat.plus_assoc at all/.
rewrite /-> plus_swap at 1 0 3 2/.
reflexivity.
qed ();



lemma "Timesz_dist_Plusz_r"
/
  forall a b c . Timesz a (Plusz b c) = Plusz (Timesz a b) (Timesz a c) : Integer
/;

inference.
intro /a b c/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
destruct /c/ /[(c c')]/.
unfold /Plusz at all , Timesz at all/.
reduce //.
rewrite /-> Nat.times_dist_plus_r at all/.
rewrite /<- Nat.plus_assoc at all/.
rewrite /-> plus_swap at 1 3/.
reflexivity.
qed ();



lemma "Negz_dist_Timesz_l"
/
  forall a b . Negz (Timesz a b) = Timesz (Negz a) b : Integer
/;

inference.
intro /a b/.
so /Integer_of/ /Hof/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Negz at all , Timesz at all/.
reduce //.
rewrite /-> Nat.plus_commute at 0 1/.
reflexivity.
qed ();



lemma "Timesz_Leqz"
/
  forall (a a' b b' : Integer) .
    Leqz Zeroz a
    -> Leqz Zeroz b
    -> Leqz a a'
    -> Leqz b b'
    -> Leqz (Timesz a b) (Timesz a' b')
/;

intro /a c b d Ha Hb Hac Hbd/.
infer /a/ /Hofa/.
infer /b/ /Hofb/.
infer /c/ /Hofc/.
infer /d/ /Hofd/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
destruct /c/ /[(c c')]/.
destruct /d/ /[(d d')]/.
unfold /Timesz at all/.
unfold /Zeroz in Ha in Hb/.
unfold /Leqz in Ha in Hb in Hac in Hbd in concl/.
unfold /Leqzb in Ha in Hb in Hac in Hbd in concl/.
reduce /Ha Hb Hac Hbd concl/.
rewrite /-> Nat.istrue_leqb in Ha in Hb in Hac in Hbd in concl/.
clear /Hofa Hofb Hofc Hofd/.
rewrite /<- Nat.plus_assoc at all/.
so /Nat.plus_cancel_leq_leq_l _# 4 Hac Ha/ /Hc/.
so /Nat.plus_cancel_leq_leq_l _# 4 Hbd Hb/ /Hd/.
so /Nat.minus_leq _# 4 Hac (Nat.leq_refl (a' + c'))/ /Hac'/.
rewrite /-> Nat.plus_commute in Hac' at 1/.
rewrite /<- Nat.minus_assoc in Hac' at all/.
rewrite /-> Nat.plus_minus_swap in Hac' at 1/ >> auto.
rewrite /-> Nat.plus_minus_cancel_r in Hac'/.
rewrite /-> Nat.minus_self in Hac'/.
reduce /Hac'/.
so /Nat.minus_leq _# 4 Hbd (Nat.leq_refl (b' + d'))/ /Hbd'/.
rewrite /-> Nat.plus_commute in Hbd' at 1/.
rewrite /<- Nat.minus_assoc in Hbd' at all/.
rewrite /-> Nat.plus_minus_swap in Hbd' at 1/ >> auto.
rewrite /-> Nat.plus_minus_cancel_r in Hbd'/.
rewrite /-> Nat.minus_self in Hbd'/.
reduce /Hbd'/.
so /Nat.times_leq _# 4 Hac' Hbd'/ /H/.
rewrite /-> Nat.times_dist_minus_l in H at all/.
rewrite /-> Nat.times_dist_minus_r in H at all/.
so /Nat.plus_leq _# 4 H (Nat.leq_refl ((a' * b - a' * b') + (c' * d - c' * d')))/ /H'/.
renameOver /H'/ /H/.
rewrite /<- Nat.plus_assoc in H/.
rewrite /-> Nat.minus_plus_cancel in H/.
  {
  rewrite /<- Nat.times_dist_minus_r at all/.
  apply /Nat.times_leq/ >> auto.
  }
rewrite /-> Nat.plus_commute in H at 2/.
rewrite /<- Nat.plus_assoc in H/.
rewrite /-> Nat.minus_plus_cancel in H/.
  {
  rewrite /<- Nat.times_dist_minus_r at all/.
  apply /Nat.times_leq/ >> auto.
  }
rewrite /<- Nat.plus_minus_assoc in H at all/.
  {
  rewrite /<- Nat.times_dist_minus_r at all/.
  apply /Nat.times_leq/ >> auto.
  }

  {
  rewrite /<- Nat.times_dist_minus_r at all/.
  apply /Nat.times_leq/ >> auto.
  }
so /Nat.plus_leq _# 4 H (Nat.leq_refl (((c' * d') + (a * b')) + ((a' * b') + (c * d'))))/ /H'/.
renameOver /H'/ /H/.
rewrite /<- Nat.plus_assoc in H at 0 1/.
rewrite /-> Nat.minus_plus_cancel in H/.
  {
  apply /Nat.leq_trans _ (c' * d)/.
    {
    rewrite /<- Nat.times_dist_minus_r at all/.
    apply /Nat.times_leq/ >> auto.
    }
  apply /Nat.plus_leq_r/.
  }
rewrite /-> plus_swap in H at 1/.
rewrite /-> Nat.minus_plus_cancel in H/.
  {
  rewrite /<- Nat.times_dist_minus_r at all/.
  apply /Nat.times_leq/ >> auto.
  }
rewrite /-> Nat.plus_commute in H at 5/.
rewrite /<- Nat.plus_assoc in H at 1 2/.
rewrite /-> Nat.minus_plus_cancel in H/.
  {
  apply /Nat.leq_trans _ (a' * b)/.
    {
    rewrite /<- Nat.times_dist_minus_r at all/.
    apply /Nat.times_leq/ >> auto.
    }
  apply /Nat.plus_leq_r/.
  }
rewrite /-> plus_swap in H at 2/.
rewrite /-> Nat.minus_plus_cancel in H/.
  {
  rewrite /<- Nat.times_dist_minus_r at all/.
  apply /Nat.times_leq/ >> auto.
  }
rewrite /<- Nat.plus_assoc in H at all/.
rewrite /-> plus_swap in H at 1 0 2 3/.
rewrite /-> Nat.plus_commute in H at 5/.
rewrite /-> plus_swap in H at 3/.
hyp /H/.
qed ();



lemma "not_Leqz"
/
  forall a b . not (Leqz a b) <-> Ltz b a
/;

inference.
intro /a b/.
unfold /Ltz/.
unfold /Leqz at all/.
infer /a/ /Hofa/.
infer /b/ /Hofb/.
split.
  {
  intro /H/.
  destruct /a/ /[(a a')]/.
  destruct /b/ /[(b b')]/.
  unfold /Leqzb in H in concl/.
  unfold /Onez at all , Plusz at all/.
  reduce /H concl/.
  rewrite /-> Nat.istrue_leqb in H in concl/.
  fold /_ < _/.
  apply /Nat.not_leq/.
  rewrite /-> Nat.plus_commute at 0 1/.
  hyp /H/.
  }

  {
  intro /H/.
  destruct /a/ /[(a a')]/.
  destruct /b/ /[(b b')]/.
  unfold /Leqzb in H in concl/.
  unfold /Onez in H at all , Plusz in H at all/.
  reduce /H concl/.
  rewrite /-> Nat.istrue_leqb in H in concl/.
  fold /_ < _ in H/.
  rewrite /-> Nat.not_leq/.
  rewrite /-> Nat.plus_commute at 0 1/.
  hyp /H/.
  }
qed ();
  


define /Integer_to_nat a/
/
  a #1 - a #2
//
  Integer -> nat
/;

introOf /a/.
unfold /Integer_to_nat/.
destruct /a/ /[(a a') (b b') Hab]/.
reduce /in Hab in concl/.
so /Nat.minus_compat _ _ (a' + b') (a' + b') Hab ()/ /H/.
rewrite /-> Nat.plus_commute in H at 1 2/.
rewrite /<- Nat.minus_assoc in H at all/.
rewrite /-> Nat.plus_minus_cancel_r in H at all/.
hyp /H/.
qed ();



lemma "Integer_to_nat_plus"
/
  forall a b .
    Leqz Zeroz a
    -> Leqz Zeroz b
    -> Integer_to_nat (Plusz a b) = Integer_to_nat a + Integer_to_nat b : nat
/;

inference.
intro /a b Hposa Hposb/.
infer /a/ /Hofa/.
infer /b/ /Hofb/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Plusz at all/.
reduce //.
unfold /Integer_to_nat at all/.
reduce //.
unfold /Leqz in Hposa in Hposb/.
unfold /Leqzb in Hposa in Hposb/.
unfold /Zeroz in Hposa at all in Hposb at all/.
reduce /in Hposa in Hposb/.
rewrite /-> Nat.istrue_leqb in Hposa in Hposb/.
clear /Hofa Hofb/.
rewrite /<- Nat.minus_assoc/.
rewrite /-> Nat.plus_minus_swap/ >> auto.
rewrite /<- Nat.plus_minus_assoc/ >> auto.
qed ();



lemma "Integer_to_nat_mono"
/
  forall a b .
    Leqz a b
    -> Integer_to_nat a <= Integer_to_nat b
/;

inference.
intro /a b Hab/.
infer /a/ /Hofa/.
infer /b/ /Hofb/.
destruct /a/ /[(a a')]/.
destruct /b/ /[(b b')]/.
unfold /Integer_to_nat at all/.
reduce //.
unfold /Leqz in Hab , Leqzb in Hab/.
reduce /Hab/.
rewrite /-> Nat.istrue_leqb in Hab/.
so /Nat.minus_leq _ _ (a' + b') (a' + b') Hab ()/ /H/ >> auto.
rewrite /-> Nat.plus_commute in H at 1 2/.
rewrite /<- Nat.minus_assoc in H at all/.
rewrite /-> Nat.plus_minus_cancel_r in H at all/.
hyp /H/.
qed ();



lemma "Integer_to_nat_mono_lt"
/
  forall a b .
    Leqz Zeroz a
    -> Ltz a b
    -> Integer_to_nat a < Integer_to_nat b
/;

inference.
intro /a b Hpos Hab/.
unfold /Ltz in Hab/.
unfold /Nat.lt/.
rewrite /succ (Integer_to_nat a) = Integer_to_nat (Plusz Onez a) : nat/.
  {
  rewrite /-> Integer_to_nat_plus/ >> auto.
    {
    unfold /Onez , Zeroz/.
    unfold /Leqz , Leqzb/.
    reduce //.
    unroll /Nat.leqb/.
    reduce //.
    apply /Bool.istrue_true/.
    }
  unfold /Onez , Integer_to_nat at 1/.
  reflexivity.
  }
apply /Integer_to_nat_mono/ >> auto.
qed ();



endModule ();

openModule /Def/;

beginModule "Iso";



(* Built-in:

defineRaw /defToInteger x/
/
  plusz (nat_to_integer (x #1)) (negz (nat_to_integer (x #2)))
/;


defineRaw /integerToDef x/
/
  if leqzb z`0 x then
    (integer_to_nat x , 0)
  else
    (0 , integer_to_nat (negz x))
/;

*)



aliasExport /integer_from_Integer/ Prim.integer_from_Integer;
aliasExport /integer_to_Integer/ Prim.integer_to_Integer;


Database.setUnroll Prim.nat_to_integer
  (Reduction.trans
     [DefineInternal.recUnroller Prim.nat_to_integer,
      Reduction.beta 1]);

Database.setUnroll Prim.integer_to_nat 
  (Reduction.trans
     [DefineInternal.recUnroller Prim.integer_to_nat,
      Reduction.beta 1]);



reductions
/
  nat_to_integer (zero) --> z`0 ;
  nat_to_integer (succ n) --> plusz z`1 (nat_to_integer n) ;
  unrolling nat_to_integer
/;

Define.registerNative 0 1 (Define.unroll1 Prim.integer_to_nat 1);



(* Now we read off the axioms that relate native integers to defined integers. *)

lemma "integer_to_Integer_type"
/
  integer_to_Integer : integer -> Integer
/;

Tactic.refine Rule.integerToDefType.
qed ();
Define.recordTyping "integer_to_Integer_type";



lemma "integer_from_Integer_type"
/
  integer_from_Integer : Integer -> integer
/;

Tactic.refine Rule.integerFromDefType.
qed ();
Define.recordTyping "integer_from_Integer_type";



lemma "integer_isomorphism_prim"
/
  (fn x . integer_from_Integer (integer_to_Integer x)) = (fn x . x) : (integer -> integer)
/;

Tactic.refine Rule.integerIsomorphism1.
qed ();



lemma "Integer_isomorphism_prim"
/
  (fn x . integer_to_Integer (integer_from_Integer x)) = (fn x . x) : (Integer -> Integer)
/;

Tactic.refine Rule.integerIsomorphism2.
qed ();



lemma "plusz_spec_prim"
/
  plusz = (fn x y . integer_from_Integer (Plusz (integer_to_Integer x) (integer_to_Integer y)))
  : (integer -> integer -> integer)
/;

Tactic.refine Rule.pluszSpec.
qed ();



lemma "negz_spec_prim"
/
  negz = (fn x . integer_from_Integer (Negz (integer_to_Integer x)))
  : (integer -> integer)
/;

Tactic.refine Rule.negzSpec.
qed ();



lemma "timesz_spec_prim"
/
  timesz = (fn x y . integer_from_Integer (Timesz (integer_to_Integer x) (integer_to_Integer y)))
  : (integer -> integer -> integer)
/;

Tactic.refine Rule.timeszSpec.
qed ();



lemma "eqzb_spec_prim"
/
  eqzb = (fn x y . Eqzb (integer_to_Integer x) (integer_to_Integer y))
  : (integer -> integer -> bool)
/;

Tactic.refine Rule.eqzbSpec.
qed ();



lemma "leqzb_spec_prim"
/
  leqzb = (fn x y . Leqzb (integer_to_Integer x) (integer_to_Integer y))
  : (integer -> integer -> bool)
/;

Tactic.refine Rule.leqzbSpec.
qed ();



lemma "integer_isomorphism"
/
  forall x . integer_from_Integer (integer_to_Integer x) = x : integer
/;

inference.
intro /x/.
change /concl/ /(fn x . integer_from_Integer (integer_to_Integer x)) x = (fn x . x) x : _/.
decompEq 1 /integer -> integer/ >> attempt reflexivity.
apply /integer_isomorphism_prim/.
qed ();



lemma "Integer_isomorphism"
/
  forall x . integer_to_Integer (integer_from_Integer x) = x : Integer
/;

inference.
intro /x/.
change /concl/ /(fn x . integer_to_Integer (integer_from_Integer x)) x = (fn x . x) x : _/.
decompEq 1 /Integer -> Integer/ >> attempt reflexivity.
apply /Integer_isomorphism_prim/.
qed ();



val of_from_eq =
  goalCaseT
  / of ? ? =>
    \(fnc a m =>
        let
          val n = Term.evar ()
        in
          assert /\m\ = \n\ : \a\/ /?/
          >>> [
              idtac,

              unfold /of/
              >>
              transitivity (ETerm.literal (Term.Sub (n, Term.shift1)))
              >>> [
                  Tactic.refine (Rule.hypothesis 0),

                  symmetry >>
                  Tactic.refine (Rule.hypothesis 0)
                  ]
              ]
        end)\
  /;



lemma "plusz_type"
/
  plusz : integer -> integer -> integer
/;

of_from_eq.
exact /plusz_spec_prim/.
qed ();
Define.recordTyping "plusz_type";



lemma "negz_type"
/
  negz : integer -> integer
/;

of_from_eq.
exact /negz_spec_prim/.
qed ();
Define.recordTyping "negz_type";



lemma "minusz_type"
/
  minusz : integer -> integer -> integer
/;

introOf /a b/.
unfold /minusz/.
typecheck.
qed ();
Define.recordTyping "minusz_type";



lemma "timesz_type"
/
  timesz : integer -> integer -> integer
/;

of_from_eq.
exact /timesz_spec_prim/.
qed ();
Define.recordTyping "timesz_type";



lemma "eqzb_type"
/
  eqzb : integer -> integer -> bool
/;

of_from_eq.
exact /eqzb_spec_prim/.
qed ();
Define.recordTyping "eqzb_type";



lemma "leqzb_type"
/
  leqzb : integer -> integer -> bool
/;

of_from_eq.
exact /leqzb_spec_prim/.
qed ();
Define.recordTyping "leqzb_type";



lemma "leqz_type"
/
  leqz : integer -> integer -> U 0
/;

unfold /leqz/.
typecheck.
qed ();
Define.recordTyping "leqz_type";



lemma "ltz_type"
/
  ltz : integer -> integer -> U 0
/;

unfold /ltz/.
typecheck.
qed ();
Define.recordTyping "ltz_type";



lemma "plusz_spec"
/
  forall x y .
    plusz x y = integer_from_Integer (Plusz (integer_to_Integer x) (integer_to_Integer y))
    : integer
/;

inference.
intro /x y/.
change /concl/ /_ = (fn x y . integer_from_Integer (Plusz (integer_to_Integer x) (integer_to_Integer y))) x y : _/.
decompEq 2 /integer -> integer -> integer/ >> attempt reflexivity.
apply /plusz_spec_prim/.
qed ();



lemma "negz_spec"
/
  forall x .
    negz x = integer_from_Integer (Negz (integer_to_Integer x)) : integer
/;

inference.
intro /x/.
change /concl/ /_ = (fn x . integer_from_Integer (Negz (integer_to_Integer x))) x : _/.
decompEq 1 /integer -> integer/ >> attempt reflexivity.
apply /negz_spec_prim/.
qed ();



lemma "timesz_spec"
/
  forall x y .
    timesz x y = integer_from_Integer (Timesz (integer_to_Integer x) (integer_to_Integer y))
    : integer
/;

inference.
intro /x y/.
change /concl/ /_ = (fn x y . integer_from_Integer (Timesz (integer_to_Integer x) (integer_to_Integer y))) x y : _/.
decompEq 2 /integer -> integer -> integer/ >> attempt reflexivity.
apply /timesz_spec_prim/.
qed ();



lemma "eqzb_spec"
/
  forall x y .
    eqzb x y = Eqzb (integer_to_Integer x) (integer_to_Integer y) : bool
/;

inference.
intro /x y/.
change /concl/ /_ = (fn x y . Eqzb (integer_to_Integer x) (integer_to_Integer y)) x y : _/.
decompEq 2 /integer -> integer -> bool/ >> attempt reflexivity.
apply /eqzb_spec_prim/.
qed ();



lemma "leqzb_spec"
/
  forall x y .
    leqzb x y = Leqzb (integer_to_Integer x) (integer_to_Integer y) : bool
/;

inference.
intro /x y/.
change /concl/ /_ = (fn x y . Leqzb (integer_to_Integer x) (integer_to_Integer y)) x y : _/.
decompEq 2 /integer -> integer -> bool/ >> attempt reflexivity.
apply /leqzb_spec_prim/.
qed ();



lemma "integer_to_Integer_zero"
/
  integer_to_Integer z`0 = Zeroz : Integer
/;

unfold /Zeroz/.
unfold /integer_to_Integer/.
unroll /integer_to_nat/.
reduce //.
apply /Integer_eq/.
reduce //.
reflexivity.
qed ();



lemma "integer_to_Integer_one"
/
  integer_to_Integer z`1 = Onez : Integer
/;

unfold /Onez/.
unfold /integer_to_Integer/.
unroll /integer_to_nat at 0 0/.
reduce //.
apply /Integer_eq/.
reduce //.
reflexivity.
qed ();



lemma "leqz_spec"
/
  forall a b . leqz a b <-> Leqz (integer_to_Integer a) (integer_to_Integer b)
/;

inference.
intro /a b/.
unfold /leqz , Leqz/.
rewrite /-> Bool.iff_eq_bool/.
rewrite /-> leqzb_spec/.
reflexivity.
qed ();



lemma "ltz_spec"
/
  forall a b . ltz a b <-> Ltz (integer_to_Integer a) (integer_to_Integer b)
/;

inference.
intro /a b/.
unfold /ltz , Ltz/.
rewrite /-> plusz_spec , -> leqz_spec/.
rewrite /-> Integer_isomorphism/.
rewrite /-> integer_to_Integer_one/.
reflexivity.
qed ();



lemma "integer_from_Integer_zero"
/
  integer_from_Integer Zeroz = z`0 : integer
/;

unfold /Zeroz , integer_from_Integer/.
reflexivity.
qed ();



lemma "integer_from_Integer_one"
/
  integer_from_Integer Onez = z`1 : integer
/;

unfold /Onez , integer_from_Integer/.
reflexivity.
qed ();



Namespace.endModule ();

Namespace.openModule (parseLongident /Iso/);



lemma "neq_0_1"
/
  z`0 = z`1 : integer -> void
/;

intro /H/.
apply /neq_Zeroz_Onez/.
rewrite /<- Integer_isomorphism Zeroz/.
rewrite /<- Integer_isomorphism Onez/.
compat.
rewrite /<- integer_isomorphism z`0 in H/.
rewrite /<- integer_isomorphism z`1 in H/.
rewrite /<- integer_from_Integer_zero in H/.
rewrite /<- integer_from_Integer_one in H/.
rewrite /-> Integer_isomorphism in H at all/.
hyp /H/.
qed ();



(* Plus and Negation *)

lemma "plusz_commute"
/
  forall a b . a +z b = b +z a : integer
/;

inference.
intro /a b/.
rewrite /-> plusz_spec at all/.
rewrite /-> Plusz_commute/.
reflexivity.
qed ();



lemma "plusz_assoc"
/
  forall a b c . (a +z b) +z c = a +z (b +z c) : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
rewrite /-> Plusz_assoc at all/.
reflexivity.
qed ();



lemma "plusz_id_l"
/
  forall a . z`0 +z a = a : integer
/;

inference.
intro /a/.
rewrite /-> plusz_spec/.
rewrite /-> integer_to_Integer_zero/.
rewrite /-> Plusz_id_l/.
rewrite /-> integer_isomorphism/.
reflexivity.
qed ();



lemma "plusz_id_r"
/
  forall a . a +z z`0 = a : integer
/;

inference.
intro /a/.
rewrite /-> plusz_commute/.
apply /plusz_id_l/.
qed ();



lemma "plusz_inverse_l"
/
  forall a . ~z a +z a = z`0 : integer
/;

inference.
intro /a/.
rewrite /-> plusz_spec/.
rewrite /-> negz_spec/.
rewrite /-> Integer_isomorphism/.
rewrite /-> Plusz_inverse_l/.
rewrite /-> integer_from_Integer_zero/.
reflexivity.
qed ();



lemma "plusz_inverse_r"
/
  forall a . a +z ~z a = z`0 : integer
/;

inference.
intro /a/.
rewrite /-> plusz_commute/.
apply /plusz_inverse_l/.
qed ();



lemma "negz_invol"
/
  forall a . ~z (~z a) = a : integer
/;

inference.
intro /a/.
rewrite /-> negz_spec at all/.
rewrite /-> Integer_isomorphism/.
rewrite /-> Negz_invol/.
apply /integer_isomorphism/.
qed ();



lemma "negz_plusz"
/
  forall a b . ~z (a +z b) = ~z a +z ~z b : integer
/;

inference.
intro /a b/.
rewrite /-> negz_spec at all/.
rewrite /-> plusz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
rewrite /-> Negz_Plusz/.
reflexivity.
qed ();



lemma "plusz_cancel_l"
/
  forall a b c .
    c +z a = c +z b : integer
    -> a = b : integer
/;

intro /a b c Heq/.
rewrite /<- plusz_id_l a , <- plusz_id_l b/.
rewrite /<- plusz_inverse_l c at all/.
rewrite /-> plusz_assoc at all/.
compat >> auto.
qed ();



lemma "plusz_cancel_r"
/
  forall a b c .
    a +z c = b +z c : integer
    -> a = b : integer
/;

intro /a b c Heq/.
rewrite /-> plusz_commute in Heq at 0 1/.
apply /plusz_cancel_l/ >> auto.
qed ();



lemma "plusz_shift_r"
/
  forall a b c .
    a +z b = c : integer
    <->
    a = c +z ~z b : integer
/;

inference.
intro /a b c/.
split.
  {
  intro /H/.
  apply /plusz_cancel_r _ _ b/.
  rewrite /-> plusz_assoc/.
  rewrite /-> plusz_inverse_l/.
  rewrite /-> plusz_id_r/.
  auto.
  }

  {
  intro /H/.
  apply /plusz_cancel_r _ _ (~z b)/.
  rewrite /-> plusz_assoc/.
  rewrite /-> plusz_inverse_r/.
  rewrite /-> plusz_id_r/.
  auto.
  }
qed ();



lemma "plusz_shift_l"
/
  forall a b c .
    a = b +z c : integer
    <->
    ~z b +z a = c : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
rewrite /-> eq_symm_iff at 0 1/.
apply /plusz_shift_r/.
qed ();



lemma "plusz_shift_lr"
/
  forall a b c .
    a +z b = c : integer
    <->
    b = ~z a +z c : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_shift_r/.
qed ();



lemma "plusz_shift_rl"
/
  forall a b c .
    a = b +z c : integer
    <->
    a +z ~z c = b : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_shift_l/.
qed ();



lemma "plusz_compat"
/
  forall a a' b b' .
    a = a' : integer
    -> b = b' : integer
    -> a +z b = a' +z b' : integer
/;

inference.
intro /a a' b b' Ha Hb/.
subst /a'/.
subst /b'/.
reflexivity.
qed ();



lemma "negz_compat"
/
  forall a a' . a = a' : integer -> negz a = negz a' : integer
/;

inference.
intro /a a' Ha/.
subst /a'/.
reflexivity.
qed ();



lemma "neq_0_neg1"
/
  z`0 = z`-1 : integer -> void
/;

intro /H1/.
so /negz_compat _ _ H1/ /H2/.
reduce /H2/.
apply /neq_0_1/ >> auto.
qed ();



(* Inequalities *)

lemma "leqz_inhabitant"
/
  forall a b . a <z= b -> () : a <z= b
/;

inference.
unfold /leqz at all/.
intro /a b Hle/.
typecheck.
qed ();

val leqz_inhabitant = parseConstant /leqz_inhabitant/;



lemma "ltz_inhabitant"
/
  forall a b . a <z b -> () : a <z b
/;

inference.
unfold /ltz at all/.
intro /a b Hlt/.
apply /leqz_inhabitant/ >> auto.
qed ();

val ltz_inhabitant = parseConstant /ltz_inhabitant/;



writeRegistry /AfterLeqzInhabitantEnv/
  /[constant constant constant constant]/
  (Collapse (leqz, ltz, leqz_inhabitant, ltz_inhabitant));
structure Nothing = AfterLeqzInhabitant ();



lemma "leqz_0_1"
/
  z`0 <z= z`1
/;

unfold /leqz/.
reduce //.
apply /Bool.istrue_true/.
qed ();



lemma "ltz_0_1"
/
  z`0 <z z`1
/;

unfold /ltz , leqz/.
reduce //.
apply /Bool.istrue_true/.
qed ();



lemma "leqz_neg1_0"
/
  z`-1 <z z`0
/;

unfold /ltz , leqz/.
reduce //.
apply /Bool.istrue_true/.
qed ();



lemma "ltz_neg1_0"
/
  z`-1 <z z`0
/;

unfold /ltz , leqz/.
reduce //.
apply /Bool.istrue_true/.
qed ();



lemma "leqz_refl"
/
  forall a . a <z= a
/;

inference.
intro /a/.
rewrite /-> leqz_spec/.
apply /Leqz_refl/.
qed ();

val leqz_refl = parseConstant /leqz_refl/;



lemma "leqz_refl_eq"
/
  forall a b . a = b : integer -> a <z= b
/;

inference.
intro /a b Heq/.
subst /b/.
apply /leqz_refl/.
qed ();



lemma "leqz_trans"
/
  forall a b c . a <z= b -> b <z= c -> a <z= c
/;

inference.
intro /a b c Hab Hbc/.
rewrite /-> leqz_spec in Hab in Hbc in concl/.
apply /Leqz_trans/ >> auto.
qed ();

val leqz_trans = parseConstant /leqz_trans/;



lemma "leqz_antisymm"
/
  forall a b . a <z= b -> b <z= a -> a = b : integer
/;

inference.
intro /a b Hab Hba/.
rewrite /-> leqz_spec in Hab in Hba/.
rewrite /<- integer_isomorphism a , <- integer_isomorphism b/.
compat.
apply /Leqz_antisymm/ >> auto.
qed ();



lemma "plusz_leqz"
/
  forall a a' b b' . a <z= a' -> b <z= b' -> a +z b <z= a' +z b'
/;

inference.
intro /a a' b b' Ha Hb/.
rewrite /-> leqz_spec in Ha in Hb in concl/.
rewrite /-> plusz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
apply /Plusz_Leqz/ >> auto.
qed ();

val plusz_leqz = parseConstant /plusz_leqz/;



lemma "plusz_cancel_leqz_l"
/
  forall a b c . c +z a <z= c +z b -> a <z= b
/;

inference.
intro /a b c Hle/.
so /plusz_leqz _# 4 (leqz_refl (~z c)) Hle/ /H/.
rewrite /<- plusz_assoc in H at all/.
rewrite /-> plusz_inverse_l in H at all/.
rewrite /-> plusz_id_l in H at all/.
hyp /H/.
qed ();



lemma "plusz_cancel_leqz_r"
/
  forall a b c . a +z c <z= b +z c -> a <z= b
/;

inference.
intro /a b c Hle/.
rewrite /-> plusz_commute in Hle at 0 1/.
apply /plusz_cancel_leqz_l/ >> auto.
qed ();



lemma "leqz_implication"
/
  forall a a' b b' . a' <z= a -> b <z= b' -> a <z= b -> a' <z= b'
/;

inference.
intro /a a' b b' Ha Hb Hab/.
apply /leqz_trans/ >> auto.
apply /leqz_trans/ >> auto.
qed ();

val leqz_implication = parseConstant /leqz_implication/;



lemma "ltz_impl_leqz"
/
  forall a b . a <z b -> a <z= b
/;

inference.
intro /a b H/.
unfold /ltz in H/.
rewrite /<- plusz_id_l a/.
apply /leqz_trans/ >> auto.
apply /plusz_leqz/.
  {
  apply /leqz_0_1/.
  }

  {
  apply /leqz_refl/.
  }
qed ();



lemma "ltz_succ"
/
  forall a . a <z z`1 +z a
/;

inference.
intro /a/.
unfold /ltz/.
apply /leqz_refl/.
qed ();



lemma "leqz_succ"
/
  forall a . a <z= z`1 +z a
/;

inference.
intro /a/.
apply /ltz_impl_leqz/.
apply /ltz_succ/.
qed ();



lemma "ltz_irrefl"
/
  forall a . a <z a -> void
/;

inference.
intro /a H/.
unfold /ltz in H/.
apply /neq_0_1/.
apply /leqz_antisymm/.
  {
  unfold /leqz/.
  reduce //.
  apply /Bool.istrue_true/.
  }

  {
  apply /plusz_cancel_leqz_r _ _ a/.
  rewrite /-> plusz_id_l/.
  hyp /H/.
  }
qed ();



lemma "ltz_trans"
/
  forall a b c . a <z b -> b <z c -> a <z c
/;

inference.
intro /a b c Hab Hbc/.
unfold /ltz in Hab in Hbc in concl/.
apply /leqz_trans/ >> auto.
apply /leqz_trans/ >> auto.
rewrite /<- plusz_id_l b/.
apply /plusz_leqz/.
  {
  apply /leqz_0_1/.
  }

  {
  apply /leqz_refl/.
  }
qed ();



lemma "leqz_ltz_trans"
/
  forall a b c . a <z= b -> b <z c -> a <z c
/;

inference.
intro /a b c Hab Hbc/.
unfold /ltz in Hbc in concl/.
apply /leqz_trans/ >> auto.
apply /plusz_leqz/ >> auto.
apply /leqz_refl/.
qed ();



lemma "ltz_leqz_trans"
/
  forall a b c . a <z b -> b <z= c -> a <z c
/;

inference.
intro /a b c Hab Hbc/.
unfold /ltz in Hab in concl/.
apply /leqz_trans/ >> auto.
qed ();



lemma "plusz_cancel_leqz_leqz_l"
/
  forall a a' b b' .
    a +z b <z= a' +z b'
    -> a' <z= a
    -> b <z= b'
/;

inference.
intro /a a' b b' Hle Hlea/.
so /leqz_trans _# 3 Hle (plusz_leqz _# 4 Hlea (leqz_refl _))/ /H/.
apply /plusz_cancel_leqz_l/ >> auto.
qed ();



lemma "plusz_cancel_leqz_leqz_r"
/
  forall a a' b b' .
    a +z b <z= a' +z b'
    -> b' <z= b
    -> a <z= a'
/;

inference.
intro /a a' b b' Hle Hleb/.
rewrite /-> plusz_commute in Hle at 0 1/.
apply /plusz_cancel_leqz_leqz_l/ >> auto.
qed ();



lemma "plusz_shift_leqz_l"
/
  forall a b c .
    a <z= b +z c
    <->
    ~z b +z a <z= c
/;

inference.
intro /a b c/.
split.
  {
  intro /H/.
  apply /plusz_cancel_leqz_l _ _ b/.
  rewrite /<- plusz_assoc/.
  rewrite /-> plusz_inverse_r/.
  rewrite /-> plusz_id_l/.
  auto.
  }

  {
  intro /H/.
  apply /plusz_cancel_leqz_l _ _ (~z b)/.
  rewrite /<- plusz_assoc/.
  rewrite /-> plusz_inverse_l/.
  rewrite /-> plusz_id_l/.
  auto.
  }
qed ();



lemma "plusz_shift_leqz_r"
/
  forall a b c .
    a +z b <z= c
    <->
    a <z= c +z ~z b
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
rewrite /-> plusz_shift_leqz_l/.
rewrite /-> negz_invol/.
reflexivity.
qed ();



lemma "plusz_shift_leqz_lr"
/
  forall a b c .
    a +z b <z= c
    <->
    b <z= ~z a +z c
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_shift_leqz_r/.
qed ();



lemma "plusz_shift_leqz_rl"
/
  forall a b c .
    a <z= b +z c
    <-> a +z ~z c <z= b
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_shift_leqz_l/.
qed ();



lemma "plusz_ltz_l"
/
  forall a a' b b' . a <z a' -> b <z= b' -> a +z b <z a' +z b'
/;

inference.
intro /a a' b b' Ha Hb/.
unfold /ltz in Ha in concl/.
rewrite /<- plusz_assoc/.
apply /plusz_leqz/ >> auto.
qed ();



lemma "plusz_ltz_r"
/
  forall a a' b b' . a <z= a' -> b <z b' -> a +z b <z a' +z b'
/;

inference.
intro /a a' b b' Ha Hb/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_ltz_l/ >> auto.
qed ();



lemma "plusz_ltz"
/
  forall a a' b b' . a <z a' -> b <z b' -> a +z b <z a' +z b'
/;

inference.
intro /a a' b b' Ha Hb/.
apply /plusz_ltz_l/ >> auto.
apply /ltz_impl_leqz/ >> auto.
qed ();



lemma "plusz_cancel_ltz_l"
/
  forall a b c . c +z a <z c +z b -> a <z b
/;

inference.
intro /a b c Hlt/.
so /plusz_ltz_r _# 4 (leqz_refl (~z c)) Hlt/ /H/.
rewrite /<- plusz_assoc in H at all/.
rewrite /-> plusz_inverse_l in H at all/.
rewrite /-> plusz_id_l in H at all/.
hyp /H/.
qed ();



lemma "plusz_cancel_ltz_r"
/
  forall a b c . a +z c <z b +z c -> a <z b
/;

inference.
intro /a b c Hle/.
rewrite /-> plusz_commute in Hle at 0 1/.
apply /plusz_cancel_ltz_l/ >> auto.
qed ();



lemma "plusz_shift_ltz_l"
/
  forall a b c .
    a <z b +z c
    <->
    ~z b +z a <z c
/;

inference.
intro /a b c/.
unfold /ltz at all/.
rewrite /-> plusz_shift_leqz_l/.
rewrite /<- plusz_assoc at all/.
rewrite /-> plusz_commute at 1/.
reflexivity.
qed ();



lemma "plusz_shift_ltz_r"
/
  forall a b c .
    a +z b <z c
    <->
    a <z c +z ~z b
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
rewrite /-> plusz_shift_ltz_l/.
rewrite /-> negz_invol/.
reflexivity.
qed ();



lemma "plusz_shift_ltz_lr"
/
  forall a b c .
    a +z b <z c
    <->
    b <z ~z a +z c
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_shift_ltz_r/.
qed ();



lemma "plusz_shift_ltz_rl"
/
  forall a b c .
    a <z b +z c
    <-> a +z ~z c <z b
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1/.
apply /plusz_shift_ltz_l/.
qed ();



lemma "negz_leqz"
/
  forall a b . a <z= b -> ~z b <z= ~z a
/;

inference.
intro /a b H/.
rewrite /-> negz_spec at 0 0/.
rewrite /-> leqz_spec/.
rewrite /-> Integer_isomorphism at all/.
apply /Negz_Leqz/.
rewrite /<- leqz_spec/.
hyp /H/.
qed ();

val negz_leqz = parseConstant /negz_leqz/;



lemma "negz_leqz'"
/
  forall a b . ~z b <z= ~z a -> a <z= b
/;

inference.
intro /a b H/.
so /negz_leqz _ _ H/ /H'/.
rewrite /-> negz_invol in H' at all/.
hyp /H'/.
qed ();



lemma "negz_ltz"
/
  forall a b . a <z b -> ~z b <z ~z a
/;

inference.
intro /a b Hab/.
unfold /ltz in Hab in concl/.
rewrite /<- plusz_id_l (~z a)/.
rewrite /<- plusz_inverse_r (z`1)/.
rewrite /--> plusz_assoc/.
apply /plusz_leqz/.
  {
  apply /leqz_refl/.
  }
change /concl/ /_ <z= ~z z`1 +z _/.
rewrite /<-- negz_plusz/.
apply /negz_leqz/.
hyp /Hab/.
qed ();



lemma "negz_ltz'"
/
  forall a b . ~z b <z ~z a -> a <z b
/;

inference.
intro /a b H/.
so /negz_ltz _ _ H/ /H'/.
rewrite /-> negz_invol in H' at all/.
hyp /H'/.
qed ();


lemma "not_leqz"
/
  forall a b . not (a <z= b) <-> b <z a
/;

inference.
intro /a b/.
rewrite /-> leqz_spec , -> ltz_spec/.
apply /not_Leqz/.
qed ();



lemma "not_ltz"
/
  forall a b . not (a <z b) <-> b <z= a
/;

inference.
intro /a b/.
unfold /ltz/.
rewrite /-> not_leqz/.
unfold /ltz/.
split.
  {
  intro /H/.
  apply /plusz_cancel_leqz_l/ >> auto.
  }

  {
  intro /H/.
  apply /plusz_leqz/ >> auto.
  apply /leqz_refl/.
  }
qed ();



lemma "ltz_from_leqz_neq"
/
  forall a b . a <z= b -> not (a = b : integer) -> a <z b
/;

inference.
intro /a b Hab Hneq/.
rewrite /<- not_leqz/.
intro /Hba/.
witness /Hneq __/.
apply /leqz_antisymm/ >> auto.
qed ();



lemma "ltz_as_leqz_l"
/
  forall a b .
    a <z b <-> z`1 +z a <z= b
/;

inference.
intro /a b/.
unfold /ltz/.
reflexivity.
qed ();



lemma "ltz_as_leqz_r"
/
  forall a b .
    a <z b <-> a +z z`1 <z= b
/;

inference.
intro /a b/.
rewrite /-> plusz_commute/.
apply /ltz_as_leqz_l/.
qed ();



lemma "leqz_as_ltz_l"
/
  forall a b .
    a <z= b <-> a <z z`1 +z b
/;

inference.
intro /a b/.
unfold /ltz/.
split.
  {
  intro /H/.
  apply /plusz_leqz/ >> auto.
  apply /leqz_refl/.
  }

  {
  intro /H/.
  apply /plusz_cancel_leqz_l/ >> auto.
  }
qed ();



lemma "leqz_as_ltz_r"
/
  forall a b .
    a <z= b <-> a <z b +z z`1
/;

inference.
intro /a b/.
rewrite /-> plusz_commute/.
apply /leqz_as_ltz_l/.
qed ();



(* Effective comparisons *)

lemma "istrue_eqzb"
/
  forall a b . Bool.istrue (eqzb a b) <-> a = b : integer
/;

inference.
intro /a b/.
rewrite /-> eqzb_spec/.
rewrite /-> istrue_Eqzb/.
split.
  {
  intro /Heq/.
  rewrite /<- integer_isomorphism a , <- integer_isomorphism b/.
  compat.
  auto.
  }

  {
  intro /Heq/.
  subst /b/.
  reflexivity.
  }
qed ();

val istrue_eqzb = parseConstant /istrue_eqzb/;



lemma "istrue_leqzb"
/
  forall a b . Bool.istrue (leqzb a b) <-> a <z= b
/;

inference.
intro /a b/.
unfold /leqz/.
reflexivity.
qed ();

val istrue_leqzb = parseConstant /istrue_leqzb/;



define /ltzb a b/
/
  leqzb (z`1 +z a) b
//
  integer -> integer -> bool
/;

unfold /ltzb/.
typecheck.
qed ();

val ltzb = parseConstant /ltzb/;

Define.registerNative 0 2 (Define.unfold1 ltzb 2);



lemma "istrue_ltzb"
/
  forall a b . Bool.istrue (ltzb a b) <-> a <z b
/;

inference.
intro /a b/.
unfold /ltzb , ltz/.
rewrite /-> istrue_leqzb/.
reflexivity.
qed ();

val istrue_ltzb = parseConstant /istrue_ltzb/;



define /neqzb a b/
/
  Bool.notb (eqzb a b)
//
  integer -> integer -> bool
/;

unfold /neqzb/.
typecheck.
qed ();

val neqzb = parseConstant /neqzb/;

Define.registerNative 0 2 (Define.unfold1 neqzb 2);



lemma "istrue_neqzb"
/
  forall a b .
    Bool.istrue (neqzb a b) <-> a != b : integer
/;

inference.
intro /a b/.
unfold /neqzb , neq/.
rewrite /-> Bool.istrue_notb/.
rewrite /-> istrue_eqzb/.
reflexivity.
qed ();

val istrue_neqzb = parseConstant /istrue_neqzb/;



writeRegistry /AfterIstrueNeqzbEnv/
  /[constant constant constant constant constant constant]/
  (Collapse (ltzb, neqzb, istrue_eqzb, istrue_leqzb, istrue_ltzb, istrue_neqzb));
structure Nothing = AfterIstrueNeqzb ();



lemma "notb_eqzb"
/
  forall a b . Bool.notb (eqzb a b) = neqzb a b : bool
/;

inference.
intro /a b/.
unfold /neqzb/.
reflexivity.
qed ();



lemma "notb_neqzb"
/
  forall a b . Bool.notb (neqzb a b) = eqzb a b : bool
/;

inference.
intro /a b/.
unfold /neqzb/.
apply /Bool.notb_invol/.
qed ();



lemma "notb_leqzb"
/
  forall a b . Bool.notb (leqzb a b) = ltzb b a : bool
/;

inference.
intro /a b/.
apply /Bool.iff_eq_bool/.
rewrite /-> Bool.istrue_notb , -> istrue_leqzb , -> istrue_ltzb/.
apply /not_leqz/.
qed ();



lemma "notb_ltzb"
/
  forall a b . Bool.notb (ltzb a b) = leqzb b a : bool
/;

inference.
intro /a b/.
rewrite /<- notb_leqzb/.
apply /Bool.notb_invol/.
qed ();



(* Induction *)

define /smaller a b/
/
  (b <z a & a <z= z`0) % (a <z b & z`0 <z= a)
//
  integer -> integer -> U 0
/;

unfold /smaller/.
typecheck.
qed ();



lemma "smaller_well_founded"
/
  forall a . Acc.Acc integer smaller a
/;

inference.
set /f/ /fn x . 
           if leqzb z`0 x then 
             Integer_to_nat (integer_to_Integer x)
           else
             Integer_to_nat (integer_to_Integer (negz x))/.
assert /forall (x : integer) . f x : nat/ /Hof/.
  {
  intro /x/.
  unfold /f/.
  typecheck.
  }
assert /forall (n : nat) (a : integer) . 
          f a = n : nat
          -> Acc.Acc integer smaller a/ /H/.
1:{
  intro /a/.
  apply /H/.
    {
    reflexivity.
    }
  typecheck.
  }
assert /forall x y . 
          z`0 <z= x 
          -> x <z y
          -> Integer_to_nat (integer_to_Integer x) < Integer_to_nat (integer_to_Integer y)/ /Hprop/.
  {
  inference.
  clear /f Hof/.
  intro /a b Hb Hab/.
  apply /Integer_to_nat_mono_lt/.
    {
    rewrite /-> leqz_spec in Hb/.
    unfold /integer_to_Integer in Hb at 0/.
    unroll /integer_to_nat in Hb/.
    reduce /Hb/.
    fold /Zeroz in Hb/.
    hyp /Hb/.
    }
  rewrite /-> ltz_spec in Hab/.
  exact /Hab/.
  }
intro /n/.
sinduction /n/.
reintro /IH/.
intro /a Heq/.
moveBefore /a/ /n/.
subst /n/.
apply /Acc.Acc_intro/.
intro /b Hba/.
apply /IH/.
1:{
  reflexivity.
  }
typechecker ();
clear /IH/.
unfold /smaller in Hba/.
destruct /Hba/ /Hab Hneg | Hba Hpos/.
  {
  subst /f/.
  reduce //.
  boolCase /leqzb z`0 a/ /Heq/.
    {
    so /ltz_leqz_trans _# 3 Hab (leqz_trans _# 3 Hneg Heq)/ /H/.
    so /ltz_irrefl _ H/ /0/.
    }
  clear /Heq/.
  boolCase /leqzb z`0 b/ /Heq/.
    {
    so /leqz_antisymm _ _ Hneg Heq/ /H/.
    subst /b/.
    apply /Hprop/ >> auto.
    apply /negz_ltz'/.
    reduce //.
    rewrite /-> negz_invol/.
    hyp /Hab/.
    }
  apply /Hprop/.
    {
    apply /negz_leqz'/.
    rewrite /-> negz_invol/.
    reduce //.
    auto.
    }
  apply /negz_ltz/.
  auto.
  }

  {
  subst /f/.
  reduce //.
  boolCase /leqzb z`0 a/ /Heq/.
  1:{
    rewrite /-> not_leqz in Heq/.
    so /leqz_ltz_trans _# 3 Hpos (ltz_trans _# 3 Hba Heq)/ /H/.
    so /ltz_irrefl _ H/ /0/.
    }
  reduce //.
  clear /Heq/.
  boolCase /leqzb z`0 b/ /Heq/.
  1:{
    rewrite /-> not_leqz in Heq/.
    so /leqz_ltz_trans _# 3 Hpos Heq/ /H/.
    so /ltz_irrefl _ H/ /0/.
    }
  reduce //.
  apply /Hprop/ >> auto.
  }
qed ();

val smaller_well_founded = parseConstant /smaller_well_founded/;



Constant.setOpacity (parseConstant /smaller/) Constant.FIRM;



definerec /integer_iter P hz hm hp a/
/
  if eqzb z`0 a then
    hz
  else if leqzb z`0 a then
    hp (z`-1 +z a) () (integer_iter P hz hm hp (z`-1 +z a))
  else
    hm (z`1 +z a) () (integer_iter P hz hm hp (z`1 +z a))
//
  intersect i .
    forall (P : integer -> U i) .
      P z`0
      -> (forall (a : integer) . leqz a z`0 -> P a -> P (z`-1 +z a))
      -> (forall (a : integer) . leqz z`0 a -> P a -> P (z`1 +z a))
      -> forall (a : integer) . P a
/;

inference.
introOf /i P hz hm hp a/.
so /smaller_well_founded a/ /Hacc/.
sinduction /Hacc/.
reintro /IH/.
unroll /integer_iter/.
boolCase /eqzb z`0 a/ /Heq/.
  {
  subst /a/.
  reduce //.
  hypof.
  }
rename /Heq/ /Hneq/.
boolCase /leqzb z`0 a/ /Heq/.
  {
  rename /Heq/ /Hpos/.
  reduce //.
  assert /z`0 <z= z`-1 +z a/ /Hleq/.
    {
    rewrite /<- not_ltz/.
    intro /H/.
    apply /Hneq/.
    apply /leqz_antisymm/ >> auto.
    unfold /ltz in H/.
    rewrite /<- plusz_assoc in H/.
    reduce /H/.
    rewrite /-> plusz_id_l in H/.
    hyp /H/.
    }
  typecheck.
    {
    rewrite /<- plusz_assoc/.
    reduce //.
    rewrite /-> plusz_id_l/.
    reflexivity.
    }
  apply /IH/.
  right >> split >> auto.
  unfold /ltz/.
  rewrite /<- plusz_assoc/.
  reduce //.
  rewrite /-> plusz_id_l/.
  apply /leqz_refl/.
  }

  {
  rewrite /-> not_leqz in Heq/.
  rename /Heq/ /Hlt/.
  assert /z`1 +z a <z= z`0/ /Hleq/.
    {
    rewrite /<- not_ltz/.
    intro /H/.
    apply /Hneq/.
    apply /leqz_antisymm/.
      {
      unfold /ltz in H/.
      apply /plusz_cancel_leqz_l _ _ z`1/ >> auto.
      }

      {
      apply /ltz_impl_leqz/ >> auto.
      }
    }
  reduce //.
  typecheck.
    {
    rewrite /<- plusz_assoc/.
    reduce //.
    rewrite /-> plusz_id_l/.
    reflexivity.
    }
  apply /IH/.
  left >> split >> auto.
  unfold /ltz/.
  apply /plusz_leqz/ >> autoWith /leqz_refl/.
  }
qed ();

val integer_iter = parseConstant /integer_iter/;



writeRegistry /AfterIntegerIterEnv/
  /[constant constant]/
  (Collapse (smaller_well_founded, integer_iter));
structure Nothing = AfterIntegerIter ();



(* Relation to natural numbers *)

lemma "nat_to_integer_type"
/
  nat_to_integer : nat -> integer
/;

introOf /n/.
sinduction /n/.
reintro /IH/.
destruct /n/ /| n/.
  {
  reduce //.
  typecheck.
  }

  {
  reduce //.
  typecheck.
  apply /IH/.
  apply /Nat.lt_succ/.
  }
qed ();
Define.recordTyping "nat_to_integer_type";



lemma "integer_to_nat_type"
/
  integer_to_nat : integer -> nat
/;

introOf /a/.
sinduction /a/.
reintro /IH/.
unroll /integer_to_nat/.
boolCase /leqzb a z`0/ /Heq/.
  {
  reduce //.
  typecheck.
  }
reduce //.
typecheck1.
apply /IH/.
rewrite /-> not_leqz in Heq/.
right >> split.
  {
  unfold /ltz/.
  rewrite /<- plusz_assoc/.
  reduce //.
  rewrite /-> plusz_id_l/.
  apply /leqz_refl/.
  }

  {
  unfold /ltz in Heq/.
  reduce /Heq/.
  so /plusz_leqz _# 4 Heq (leqz_refl z`-1)/ /H/.
  reduce /H/.
  rewrite /-> plusz_commute/.
  hyp /H/.
  }
qed ();
Define.recordTyping "integer_to_nat_type";



lemma "nat_to_integer_nonneg"
/
  forall n . z`0 <z= nat_to_integer n
/;

inference.
intro /n/.
induction /n/.

(* 0 *)
{
apply /leqz_refl/.
}

(* succ *)
{
intro /n IH/.
so /plusz_leqz _# 4 leqz_0_1 IH/ /H/.
reduce /H/.
hyp /H/.
}
qed ();



lemma "nat_to_integer_mono"
/
  forall m n . m <= n -> nat_to_integer m <z= nat_to_integer n
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n _/.
apply /nat_to_integer_nonneg/.
}

(* succ *)
{
intro /m IH n Hmn/.
destruct /n/ /| n/.
  {
  so /Nat.leq_succ_0_not _ Hmn/ /0/.
  }
reduce //.
apply /plusz_leqz/.
  {
  apply /leqz_refl/.
  }
apply /IH/.
apply /Nat.leq_succ_invert/.
hyp /Hmn/.
}
qed ();



lemma "nat_to_integer_mono_lt"
/
  forall m n . m < n -> nat_to_integer m <z nat_to_integer n
/;

inference.
unfold /Nat.lt , ltz/.
intro /m n Hmn/.
so /nat_to_integer_mono _ _ Hmn/ /H/.
reduce /H/.
hyp /H/.
qed ();



lemma "nat_to_integer_inv"
/
  forall n . integer_to_nat (nat_to_integer n) = n : nat
/;

inference.
intro /n/.
induction /n/.

(* 0 *)
{
reflexivity.
}

(* succ *)
{
intro /n IH/.
unroll /integer_to_nat/.
boolCase /leqzb _ _/ /Heq/.
  {
  fold /ltz _ _ in Heq/.
  rewrite /<- not_leqz in Heq/.
  exfalso.
  apply /Heq/.
  apply /nat_to_integer_nonneg/.
  }
reduce //.
rewrite /<- plusz_assoc/.
reduce //.
rewrite /-> plusz_id_l/.
compat.
exact /IH/.
}
qed ();



lemma "integer_to_nat_inv"
/
  forall a . z`0 <z= a -> nat_to_integer (integer_to_nat a) = a : integer
/;

inference.
intro /a/.
induction /a/.

(* 0 *)
{
intro /_/.
reflexivity.
}

(* neg *)
{
intro /a Hneg _ Hpos/.
so /plusz_leqz _# 4 (leqz_refl z`1) (leqz_trans _# 3 Hneg Hpos)/ /H/.
rewrite /<- plusz_assoc in H/.
reduce /H/.
rewrite /-> plusz_id_l in H/.
fold /ltz _ _ in H/.
so /ltz_irrefl _ H/ /0/.
}

(* pos *)
{
intro /a Hpos IH _/.
unroll /integer_to_nat/.
fold /ltzb a z`0/.
boolCase /ltzb a z`0/ /Heq/.
  {
  rewrite /<- not_leqz in Heq/.
  so /Heq Hpos/ /0/.
  }
reduce //.
compat.
rewrite /<- plusz_assoc/.
reduce //.
rewrite /-> plusz_id_l/.
apply /IH/.
hyp /Hpos/.
}
qed ();



lemma "integer_to_nat_nonpos"
/
  forall a .
    a <z= z`0
    -> integer_to_nat a = 0 : nat
/;

inference.
intro /a Ha/.
unroll /integer_to_nat/.
boolCase /leqzb a z`0/ /H/.
  {
  reflexivity.
  }
so /H Ha/ /0/.
qed ();



lemma "integer_to_nat_neg"
/
  forall a .
    a <z z`0
    -> integer_to_nat a = 0 : nat
/;

inference.
intro /a Ha/.
apply /integer_to_nat_nonpos/.
apply /ltz_impl_leqz/ >> auto.
qed ();



lemma "succ_to_integer"
/
  forall n . nat_to_integer (succ n) = z`1 +z nat_to_integer n : integer
/;

inference.
intro /n/.
reduce //.
reflexivity.
qed ();



lemma "plus_to_integer"
/
  forall m n . nat_to_integer (m + n) = nat_to_integer m +z nat_to_integer n : integer
/;

inference.
intro /a b/.
induction /a/.

(* 0 *)
{
rewrite /-> plusz_id_l/.
reflexivity.
}

(* succ *)
{
intro /a IH/.
rewrite /-> plusz_assoc/.
compat.
hyp /IH/.
}
qed ();



lemma "plusz_to_nat"
/
  forall a b . 
    z`0 <z= a 
    -> z`0 <z= b
    -> integer_to_nat (a +z b) = integer_to_nat a + integer_to_nat b : nat
/;

inference.
intro /a b Ha Hb/.
rewrite /<- integer_to_nat_inv a/ >> auto.
rewrite /<- integer_to_nat_inv b/ >> auto.
rewrite /<- plus_to_integer/.
rewrite /-> nat_to_integer_inv/.
reflexivity.
qed ();



lemma "integer_to_nat_zero"
/
  integer_to_nat z`0 = 0 : nat
/;

unroll /integer_to_nat/.
reduce //.
reflexivity.
qed ();



lemma "integer_to_nat_succ"
/
  forall a . z`0 <z= a -> integer_to_nat (z`1 +z a) = succ (integer_to_nat a) : nat
/;

inference.
intro /a Ha/.
rewrite /-> plusz_to_nat/ >> autoWith /leqz_0_1/.
qed ();



lemma "integer_to_nat_mono"
/
  forall a b .
    a <z= b
    -> integer_to_nat a <= integer_to_nat b
/;

inference.
intro /a/.
induction /a/.

(* 0 *)
{
intro /b _/.
unroll /integer_to_nat/.
reduce //.
apply /Nat.leq_0_min/.
}

(* neg *)
{
intro /a Hneg IH b _/.
rewrite /-> integer_to_nat_neg/.
1:{
  apply /Nat.leq_0_min/.
  }
apply /leqz_ltz_trans _ (z`-1 +z z`0)/.
  {
  apply /plusz_leqz z`-1 z`-1 a z`0/ >> auto.
  apply /leqz_refl/.
  }
reduce //.
apply /ltz_neg1_0/.
}

(* pos *)
{
intro /a Hpos IH b Hab/.
rewrite /-> integer_to_nat_succ/ >> auto.
rewrite /<- plusz_id_l b/.
convert /(z`1 +z z`-1) +z b/.
rewrite /--> plusz_assoc/.
assert /a <z= z`-1 +z b/ /Hab'/.
  {
  rewrite /<- plusz_id_l a/.
  convert /z`-1 +z z`1/.
  rewrite /--> plusz_assoc/.
  apply /plusz_leqz/ >> autoWith /leqz_refl/.
  }
rewrite /-> integer_to_nat_succ/.
  {
  apply /leqz_trans/ >> auto.
  }
apply /Nat.leq_succ_succ/.
apply /IH/ >> auto.
}
qed ();



lemma "integer_to_nat_mono_lt"
/
  forall a b .
    z`0 <z= a
    -> a <z b
    -> integer_to_nat a < integer_to_nat b
/;

inference.
unfold /Nat.lt , ltz/.
intro /a b Ha Hab/.
so /integer_to_nat_mono _ _ Hab/ /H/.
unroll /integer_to_nat in H/.
revert /H/.
boolCase /leqzb (z`1 +z a) z`0/ /Hc/.
  {
  so /leqz_trans _# 3 Hc Ha/ /H/.
  fold /a <z a in H/.
  so /ltz_irrefl _ H/ /0/.
  }
intro /H/.
rewrite /<- plusz_assoc in H/.
reduce /H/.
rewrite /-> plusz_id_l in H/.
hyp /H/.
qed ();



lemma "pred_to_integer"
/
  forall n . 
    0 < n
    -> nat_to_integer (Nat.pred n) = z`-1 +z nat_to_integer n : integer
/;

inference.
intro /n Hlt/.
destruct /n/ /| n/.
  {
  so /Nat.lt_irrefl _ Hlt/ /0/.
  }
reduce //.
rewrite /<- plusz_assoc/.
reduce //.
rewrite /-> plusz_id_l/.
reflexivity.
qed ();



lemma "minus_to_integer"
/
  forall m n . 
    n <= m
    -> nat_to_integer (m - n) = nat_to_integer m -z nat_to_integer n : integer
/;

inference.
unfold /minusz/.
intro /m n/.
revert /m/.
induction /n/.

(* 0 *)
{
intro /m _/.
rewrite /-> plusz_id_r/.
reflexivity.
}

(* succ *)
{
intro /m IH n Hleq/.
destruct /n/ /| n/.
  {
  so /Nat.leq_succ_0_not _ Hleq/ /0/.
  }
reduce //.
rewrite /-> negz_plusz/.
reduce //.
rewrite /<- plusz_assoc/.
rewrite /-> plusz_commute at 1/.
rewrite /<- plusz_assoc/.
reduce //.
rewrite /-> plusz_id_l/.
apply /IH/.
apply /Nat.leq_succ_invert/.
hyp /Hleq/.
}
qed ();



lemma "minusz_to_nat"
/
  forall a b .
    z`0 <z= b
    -> b <z= a
    -> integer_to_nat (a -z b) = integer_to_nat a - integer_to_nat b : nat
/;

inference.
intro /a b Hb Hba/.
rewrite /<- integer_to_nat_inv a/.
  {
  apply /leqz_trans/ >> auto.
  }
rewrite /<- integer_to_nat_inv b/ >> auto.
rewrite /<- minus_to_integer/.
  {
  apply /integer_to_nat_mono/ >> auto.
  }
rewrite /-> nat_to_integer_inv/.
reflexivity.
qed ();



lemma "eqb_to_integer"
/
  forall m n .
    Nat.eqb m n = eqzb (nat_to_integer m) (nat_to_integer n) : bool
/;

inference.
intro /m n/.
boolCase /Nat.eqb m n/ /H/.
  {
  subst /m/.
  boolEq true /eqzb (nat_to_integer n) (nat_to_integer n)/ >> auto.
  }

  {
  boolEq false /eqzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  contrapositive /H/.
  rewrite /<- nat_to_integer_inv m , <- nat_to_integer_inv n/.
  compat >> auto.
  }
qed ();



lemma "eqzb_to_nat"
/
  forall a b .
    z`0 <z= a
    -> z`0 <z= b
    -> eqzb a b = Nat.eqb (integer_to_nat a) (integer_to_nat b) : bool
/;

inference.
intro /a b Ha Hb/.
rewrite /-> eqb_to_integer at all/.
compat >> symmetry >> apply /integer_to_nat_inv/ >> auto.
qed ();



lemma "leqb_to_integer"
/
  forall m n .
    Nat.leqb m n = leqzb (nat_to_integer m) (nat_to_integer n) : bool
/;

inference.
intro /m n/.
boolCase /Nat.leqb m n/ /H/.
  {
  boolEq true /leqzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  apply /nat_to_integer_mono/ >> auto.
  }

  {
  boolEq false /leqzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  contrapositive /H/.
  rewrite /<- nat_to_integer_inv m , <- nat_to_integer_inv n/.
  apply /integer_to_nat_mono/ >> auto.
  }
qed ();



lemma "leqzb_to_nat"
/
  forall a b .
    z`0 <z= a
    -> z`0 <z= b
    -> leqzb a b = Nat.leqb (integer_to_nat a) (integer_to_nat b) : bool
/;

inference.
intro /a b Ha Hb/.
rewrite /-> leqb_to_integer at all/.
compat >> symmetry >> apply /integer_to_nat_inv/ >> auto.
qed ();



lemma "ltb_to_integer"
/
  forall m n .
    Nat.ltb m n = ltzb (nat_to_integer m) (nat_to_integer n) : bool
/;

inference.
intro /m n/.
boolCase /Nat.ltb m n/ /H/.
  {
  boolEq true /ltzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  apply /nat_to_integer_mono_lt/ >> auto.
  }

  {
  boolEq false /ltzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  contrapositive /H/.
  rewrite /<- nat_to_integer_inv m , <- nat_to_integer_inv n/.
  apply /integer_to_nat_mono_lt/ >> auto.
  apply /nat_to_integer_nonneg/.
  }
qed ();



lemma "ltzb_to_nat"
/
  forall a b .
    z`0 <z= a
    -> z`0 <z= b
    -> ltzb a b = Nat.ltb (integer_to_nat a) (integer_to_nat b) : bool
/;

inference.
intro /a b Ha Hb/.
rewrite /-> ltb_to_integer at all/.
compat >> symmetry >> apply /integer_to_nat_inv/ >> auto.
qed ();



lemma "neqb_to_integer"
/
  forall m n .
    Nat.neqb m n = neqzb (nat_to_integer m) (nat_to_integer n) : bool
/;

inference.
intro /m n/.
boolCase /Nat.neqb m n/ /H/.
  {
  boolEq true /neqzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  contrapositive /H/.
  rewrite /<- nat_to_integer_inv m , <- nat_to_integer_inv n/.
  compat >> auto.
  }

  {
  boolEq false /neqzb (nat_to_integer m) (nat_to_integer n)/ >> auto.
  contrapositive /H/.
  contrapositive /H/.
  compat >> auto.
  }
qed ();



lemma "neqzb_to_nat"
/
  forall a b .
    z`0 <z= a
    -> z`0 <z= b
    -> neqzb a b = Nat.neqb (integer_to_nat a) (integer_to_nat b) : bool
/;

inference.
intro /a b Ha Hb/.
rewrite /-> neqb_to_integer at all/.
compat >> symmetry >> apply /integer_to_nat_inv/ >> auto.
qed ();



(* Decidability *)

lemma "eq_integer_decide"
/
  forall (a b : integer) . Decidable.decidable (a = b : integer)
/;

intro /a b/.
apply /Decidable.decidable_from_bool _ _ (eqzb a b)/.
apply /istrue_eqzb/.
qed ();



lemma "neq_integer_decide"
/
  forall (a b : integer) . Decidable.decidable (a != b : integer)
/;

intro /a b/.
unfold /neq/.
apply /Decidable.decidable_not/.
apply /Decidable.decidable_from_bool _ _ (eqzb a b)/.
apply /istrue_eqzb/.
qed ();



lemma "leqz_decide"
/
  forall (a b : integer) . Decidable.decidable (a <z= b)
/;

intro /a b/.
apply /Decidable.decidable_from_bool _ _ (leqzb a b)/.
apply /istrue_leqzb/.
qed ();

  

lemma "ltz_decide"
/
  forall (a b : integer) . Decidable.decidable (a <z b)
/;

intro /a b/.
apply /Decidable.decidable_from_bool _ _ (ltzb a b)/.
apply /istrue_ltzb/.
qed ();



lemma "eq_integer_stable"
/
  forall (a b : integer) . Stable.stable (a = b : integer)
/;

intro /a b/.
apply /Stable.decidable_impl_stable/.
apply /eq_integer_decide/.
qed ();
  


lemma "neq_integer_stable"
/
  forall (a b : integer) . Stable.stable (a != b : integer)
/;

intro /a b/.
apply /Stable.decidable_impl_stable/.
apply /neq_integer_decide/.
qed ();



lemma "leqz_stable"
/
  forall (a b : integer) . Stable.stable (a <z= b)
/;

intro /a b/.
apply /Stable.decidable_impl_stable/.
apply /leqz_decide/.
qed ();
  


lemma "ltz_stable"
/
  forall (a b : integer) . Stable.stable (a <z b)
/;

intro /a b/.
apply /Stable.decidable_impl_stable/.
apply /ltz_decide/.
qed ();
  


lemma "leqz_iff_ltz_or_eq"
/
  forall a b . a <z= b <-> a <z b % a = b : integer
/;

inference.
intro /a b/.
split.
  {
  intro /Hleq/.
  so /eq_integer_decide a b/ /Heq | Hneq/ >> auto.
  left.
  apply /ltz_from_leqz_neq/ >> auto.
  }

  {
  intro /(Hlt | Heq)/.
    {
    apply /ltz_impl_leqz/ >> auto.
    }

    {
    apply /leqz_refl_eq/ >> auto.
    }
  }
qed ();



lemma "integer_trichotomy"
/
  forall (a b : integer) . a <z b % a = b : integer % b <z a
/;

intro /m n/.
setEq /b/ /eqzb m n/ /bool/ /Heq/.
symmetryIn /Heq/.
destruct /b/ /|/.
  {
  rewrite /<- Bool.istrue_iff_eq_true in Heq/.
  rewrite /-> istrue_eqzb in Heq/.
  right >> left.
  hyp /Heq/.
  }
rewrite /<- Bool.not_istrue_iff_eq_false in Heq/.
rewrite /-> istrue_eqzb in Heq/.
setEq /b/ /ltzb m n/ /bool/ /Hlt/.
symmetryIn /Hlt/.
destruct /b/ /|/.
  {
  rewrite /<- Bool.istrue_iff_eq_true in Hlt/.
  rewrite /-> istrue_ltzb in Hlt/.
  left.
  hyp /Hlt/.
  }
rewrite /<- Bool.not_istrue_iff_eq_false in Hlt/.
rewrite /-> istrue_ltzb in Hlt/.
right >> right.
rewrite /-> not_ltz in Hlt/.
apply /ltz_from_leqz_neq/ >> auto.
intro /H/ >> witness /Heq __/.
symmetry.
auto.
qed ();



lemma "integer_dichotomy"
/
  forall (a b : integer) . a <z= b % b <z a
/;

intro /m n/.
so /integer_trichotomy m n/ /H | H | H/.
  {
  left.
  apply /ltz_impl_leqz/ >> auto.
  }

  {
  left.
  apply /leqz_refl_eq/ >> auto.
  }

  {
  right.
  auto.
  }
qed ();



lemma "integer_dichotomy_weak"
/
  forall a b . a <z= b % b <z= a
/;

inference.
intro /a b/.
so /integer_dichotomy a b/ /Hab | Hnab/ >> autoWith /ltz_impl_leqz/.
qed ();



lemma "integer_dichotomy_neq"
/
  forall (a b : integer) .
    a != b : integer
    -> a <z b % b <z a
/;

intro /a b Hneq/.
so /integer_trichotomy a b/ /H | H | H/ >> auto.
so /Hneq __/ /0/.
hyp /H/.
qed ();



(* Multiplication *)

lemma "timesz_commute"
/
  forall a b . a *z b = b *z a : integer
/;

inference.
intro /a b/.
rewrite /-> timesz_spec at all/.
rewrite /-> Timesz_commute/.
reflexivity.
qed ();



lemma "timesz_assoc"
/
  forall a b c . (a *z b) *z c = a *z (b *z c) : integer
/;

inference.
intro /a b c/.
rewrite /-> timesz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
rewrite /-> Timesz_assoc at all/.
reflexivity.
qed ();



lemma "timesz_id_l"
/
  forall a . z`1 *z a = a : integer
/;

inference.
intro /a/.
rewrite /-> timesz_spec/.
rewrite /-> integer_to_Integer_one/.
rewrite /-> Timesz_id_l/.
rewrite /-> integer_isomorphism/.
reflexivity.
qed ();



lemma "timesz_id_r"
/
  forall a . a *z z`1 = a : integer
/;

inference.
intro /a/.
rewrite /-> timesz_commute/.
apply /timesz_id_l/.
qed ();



lemma "timesz_ann_l"
/
  forall a . z`0 *z a = z`0 : integer
/;

inference.
intro /a/.
rewrite /-> timesz_spec/.
rewrite /-> integer_to_Integer_zero/.
rewrite /-> Timesz_ann_l/.
apply /integer_from_Integer_zero/.
qed ();



lemma "timesz_ann_r"
/
  forall a . a *z z`0 = z`0 : integer
/;

inference.
intro /a/.
rewrite /-> timesz_commute/.
apply /timesz_ann_l/.
qed ();



lemma "timesz_dist_plusz_r"
/
  forall a b c . a *z (b +z c) = a *z b +z a *z c : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_spec at all/.
rewrite /-> timesz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
rewrite /-> Timesz_dist_Plusz_r/.
reflexivity.
qed ();



lemma "timesz_dist_plusz_l"
/
  forall a b c . (a +z b) *z c = a *z c +z b *z c : integer
/;

inference.
intro /a b c/.
rewrite /-> timesz_commute at 0 1 2/.
apply /timesz_dist_plusz_r/.
qed ();



lemma "negz_dist_timesz_l"
/
  forall a b . ~z (a *z b) = ~z a *z b : integer
/;

inference.
intro /a b/.
rewrite /-> timesz_spec at all/.
rewrite /-> negz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
rewrite /-> Negz_dist_Timesz_l/.
reflexivity.
qed ();



lemma "negz_dist_timesz_r"
/
  forall a b . ~z (a *z b) = a *z ~z b : integer
/;

inference.
intro /a b/.
rewrite /-> timesz_commute at 0 1/.
apply /negz_dist_timesz_l/.
qed ();



lemma "negz_as_timesz"
/
  forall a . ~z a = z`-1 *z a : integer
/;

inference.
intro /a/.
rewrite /<- timesz_id_l a/.
rewrite /-> negz_dist_timesz_l/.
reduce //.
reflexivity.
qed ();



lemma "timesz_compat"
/
  forall a a' b b' .
    a = a' : integer
    -> b = b' : integer
    -> a *z b = a' *z b' : integer
/;

inference.
intro /a a' b b' Ha Hb/.
subst /a'/.
subst /b'/.
reflexivity.
qed ();



lemma "timesz_leqz"
/
  forall a a' b b' . 
    z`0 <z= a
    -> z`0 <z= b
    -> a <z= a' 
    -> b <z= b'
    -> a *z b <z= a' *z b'
/;

inference.
intro /a a' b b' Hposa Hposb Ha Hb/.
rewrite /-> leqz_spec in Hposa in Hposb in Ha in Hb in concl/.
rewrite /-> timesz_spec at all/.
rewrite /-> Integer_isomorphism at all/.
rewrite /-> integer_to_Integer_zero in Hposa in Hposb/.
apply /Timesz_Leqz/ >> auto.
qed ();



aliasExport /timesz_leqz_pos_pos/ /timesz_leqz/;


lemma "timesz_leqz_neg_neg"
/
  forall a a' b b' . 
    a' <z= z`0
    -> b' <z= z`0
    -> a <z= a' 
    -> b <z= b'
    -> a' *z b' <z= a *z b
/;

inference.
intro /a a' b b' Hnega Hnegb Ha Hb/.
apply /negz_leqz'/.
apply /negz_leqz'/.
rewrite /-> negz_dist_timesz_l at 0 1/.
rewrite /-> negz_dist_timesz_r at all/.
apply /timesz_leqz/.
  {
  apply /negz_leqz'/.
  rewrite /-> negz_invol/.
  autoWith /leqz_trans/.
  }

  {
  apply /negz_leqz'/.
  rewrite /-> negz_invol/.
  autoWith /leqz_trans/.
  }

  {
  apply /negz_leqz/ >> auto.
  }

  {
  apply /negz_leqz/ >> auto.
  }
qed ();



lemma "timesz_leqz_pos_neg"
/
  forall a a' b b' . 
    z`0 <z= a
    -> b' <z= z`0
    -> a <z= a' 
    -> b <z= b'
    -> a' *z b <z= a *z b'
/;

inference.
intro /a a' b b' Hposa Hnegb Ha Hb/.
apply /negz_leqz'/.
rewrite /-> negz_dist_timesz_r at all/.
apply /timesz_leqz/ >> auto.
  {
  apply /negz_leqz'/.
  rewrite /-> negz_invol/.
  autoWith /leqz_trans/.
  }

  {
  apply /negz_leqz/ >> auto.
  }
qed ();



lemma "timesz_leqz_neg_pos"
/
  forall a a' b b' . 
    a' <z= z`0
    -> z`0 <z= b
    -> a <z= a' 
    -> b <z= b'
    -> a *z b' <z= a' *z b
/;

inference.
intro /a a' b b' Hnega Hposb Ha Hb/.
rewrite /-> timesz_commute at 0 1/.
apply /timesz_leqz_pos_neg/ >> auto.
qed ();



lemma "timesz_leqz_l"
/
  forall a b b' .
    z`0 <z= a
    -> b <z= b'
    -> a *z b <z= a *z b'
/;

intro /a b b' Hposa Hb/.
so /integer_dichotomy z`0 b/ /Hposb | Hnpos/.
  {
  apply /timesz_leqz/ >> auto.
  apply /leqz_refl/.
  }
so /ltz_impl_leqz _ _ Hnpos/ /Hnegb/ >> clear /Hnpos/.
so /integer_dichotomy b' z`0/ /Hnegb' | Hnneg/.
  {
  apply /negz_leqz'/.
  rewrite /-> negz_dist_timesz_r at all/.
  apply /timesz_leqz/ >> autoWith /leqz_refl/.
    {
    apply /negz_leqz'/.
    rewrite /-> negz_invol/.
    auto.
    }
  apply /negz_leqz/ >> auto.
  }
so /ltz_impl_leqz _ _ Hnneg/ /Hposb'/ >> clear /Hnneg/.
apply /leqz_trans _ z`0/.
  {
  rewrite /<- timesz_ann_r a/.
  apply /negz_leqz'/.
  rewrite /-> negz_dist_timesz_r at all/.
  apply /timesz_leqz/ >> autoWith /leqz_refl/.
  apply /negz_leqz'/.
  rewrite /-> negz_invol/.
  auto.
  }

  {
  rewrite /<- timesz_ann_r a/.
  apply /timesz_leqz/ >> autoWith /leqz_refl/.
  }
qed ();



lemma "timesz_leqz_r"
/
  forall a a' b .
    z`0 <z= b
    -> a <z= a'
    -> a *z b <z= a' *z b
/;

inference.
intro /a a' b Hpos Ha/.
rewrite /-> timesz_commute at 0 1/.
apply /timesz_leqz_l/ >> auto.
qed ();



lemma "timesz_leqz_l_neg"
/
  forall a b b' .
    a <z= z`0
    -> b <z= b'
    -> a *z b' <z= a *z b
/;

inference.
intro /a b b' Hneg Hb/.
apply /negz_leqz'/.
rewrite /-> negz_dist_timesz_l at all/.
apply /timesz_leqz_l/ >> auto.
apply /negz_leqz'/.
rewrite /-> negz_invol/.
auto.
qed ();



lemma "timesz_leqz_r_neg"
/
  forall a a' b .
    b <z= z`0
    -> a <z= a'
    -> a' *z b <z= a *z b
/;

inference.
intro /a a' b Hneg Ha/.
rewrite /-> timesz_commute at 0 1/.
apply /timesz_leqz_l_neg/ >> auto.
qed ();



lemma "times_to_integer"
/
  forall m n . nat_to_integer (m * n) = nat_to_integer m *z nat_to_integer n : integer
/;

inference.
intro /m n/.
induction /m/.

(* 0 *)
{
rewrite /-> timesz_ann_l/.
reflexivity.
}

(* succ *)
{
intro /m IH/.
rewrite /-> timesz_dist_plusz_l/.
rewrite /-> timesz_id_l/.
rewrite /-> plus_to_integer/.
compat >> auto.
}
qed ();



lemma "timesz_to_nat"
/
  forall a b .
    z`0 <z= a
    -> z`0 <z= b
    -> integer_to_nat (a *z b) = integer_to_nat a * integer_to_nat b : nat
/;

inference.
intro /a b Ha Hb/.
rewrite /<- nat_to_integer_inv (_ * _)/.
compat.
rewrite /-> times_to_integer/.
rewrite /-> integer_to_nat_inv at all/ >> auto.
qed ();



lemma "timesz_ltz_zero"
/
  forall a b .
    z`0 <z a
    -> z`0 <z b
    -> z`0 <z a *z b
/;

inference.
inference.
unfold /ltz at all/.
intro /a b Ha Hb/.
so /timesz_leqz _# 4 __ __ Ha Hb/ /H/ >> autoWith /leqz_0_1/.
qed ();



aliasExport /timesz_ltz_zero_pos_pos/ /timesz_ltz_zero/;



lemma "timesz_ltz_zero_pos_neg"
/
  forall a b .
    z`0 <z a
    -> b <z z`0
    -> a *z b <z z`0
/;

inference.
intro /a b Ha Hb/.
apply /negz_ltz'/.
reduce //.
rewrite /-> negz_as_timesz/.
rewrite /-> timesz_commute at 1/.
rewrite /<- timesz_assoc/.
rewrite /<- negz_as_timesz/.
apply /timesz_ltz_zero/ >> auto.
apply /negz_ltz'/.
rewrite /-> negz_invol/.
auto.
qed ();



lemma "timesz_ltz_zero_neg_pos"
/
  forall a b .
    a <z z`0
    -> z`0 <z b
    -> a *z b <z z`0
/;

inference.
intro /a b Ha Hb/.
rewrite /-> timesz_commute/.
apply /timesz_ltz_zero_pos_neg/ >> auto.
qed ();



lemma "timesz_ltz_zero_neg_neg"
/
  forall a b .
    a <z z`0
    -> b <z z`0
    -> z`0 <z a *z b
/;

inference.
intro /a b Ha Hb/.
apply /negz_ltz'/.
apply /negz_ltz'/.
reduce //.
rewrite /-> negz_as_timesz at all/.
rewrite /<- timesz_assoc at 1/.
rewrite /<- negz_as_timesz at 1/.
rewrite /-> timesz_commute at 1/.
rewrite /<- timesz_assoc/.
rewrite /<- negz_as_timesz/.
apply /timesz_ltz_zero/ >> apply /negz_ltz'/ >> rewrite /-> negz_invol/ >> auto.
qed ();



lemma "integer_integral_domain"
/
  forall a b .
    a *z b = z`0 : integer
    -> a = z`0 : integer % b = z`0 : integer
/;

inference.
intro /a b Heq/.
so /integer_trichotomy a z`0/ /Hnega | Hzero | Hposa/ >> auto.
  {
  so /integer_trichotomy b z`0/ /Hnegb | Hzero | Hposb/ >> auto.
    {
    exfalso.
    apply /ltz_irrefl z`0/.
    rewrite /<- Heq at 1/.
    apply /timesz_ltz_zero_neg_neg/ >> auto.
    }

    {
    exfalso.
    apply /ltz_irrefl z`0/.
    rewrite /<- Heq /.
    apply /timesz_ltz_zero_neg_pos/ >> auto.
    }
  }

  {
  so /integer_trichotomy b z`0/ /Hnegb | Hzero | Hposb/ >> auto.
    {
    exfalso.
    apply /ltz_irrefl z`0/.
    rewrite /<- Heq/.
    apply /timesz_ltz_zero_pos_neg/ >> auto.
    }

    {
    exfalso.
    apply /ltz_irrefl z`0/.
    rewrite /<- Heq at 1/.
    apply /timesz_ltz_zero/ >> auto.
    }
  }
qed ();



lemma "timesz_ltz_zero_invert"
/
  forall a b .
    z`0 <z a *z b
    -> (a <z z`0 & b <z z`0) % (z`0 <z a & z`0 <z b)
/;

inference.
intro /a b Hab/.
so /integer_trichotomy a z`0/ /Ha | Ha | Ha/.
  {
  left.
  split >> auto.
  so /integer_trichotomy b z`0/ /Hb | Hb | Hb/ >> auto.
    {
    subst /b/.
    rewrite /-> timesz_ann_r in Hab/.
    so /ltz_irrefl _ Hab/ /0/.
    }

    {
    so /timesz_ltz_zero_neg_pos _ _ Ha Hb/ /H/.
    so /ltz_irrefl _ (ltz_trans _# 3 Hab H)/ /0/.
    }
  }

  {
  subst /a/.
  rewrite /-> timesz_ann_l in Hab/.
  so /ltz_irrefl _ Hab/ /0/.
  }

  {
  right.
  split >> auto.
  so /integer_trichotomy b z`0/ /Hb | Hb | Hb/ >> auto.
    {
    so /timesz_ltz_zero_pos_neg _ _ Ha Hb/ /H/.
    so /ltz_irrefl _ (ltz_trans _# 3 Hab H)/ /0/.
    }

    {
    subst /b/.
    rewrite /-> timesz_ann_r in Hab/.
    so /ltz_irrefl _ Hab/ /0/.
    }
  }
qed ();



lemma "timesz_ltz_l"
/
  forall a b b' .
    z`0 <z a
    -> b <z b'
    -> a *z b <z a *z b'
/;

inference.
intro /a b b' Ha Hb/.
unfold /ltz in Hb in concl/.
so /timesz_leqz_l _ _ _ (ltz_impl_leqz _ _ Ha) Hb/ /H/.
rewrite /-> timesz_dist_plusz_r in H/.
witness /leqz_trans _# 3 __ H/.
apply /plusz_leqz/ >> autoWith /leqz_refl/.
rewrite /-> timesz_id_r/.
unfold /ltz in Ha/.
hyp /Ha/.
qed ();



lemma "timesz_ltz_r"
/
  forall a a' b .
    z`0 <z b
    -> a <z a'
    -> a *z b <z a' *z b
/;

inference.
intro /a a' b Hb Ha/.
rewrite /-> timesz_commute at 0 1/.
apply /timesz_ltz_l/ >> auto.
qed ();



lemma "timesz_cancel_leqz_l"
/
  forall a b c .
    z`0 <z c
    -> c *z a <z= c *z b
    -> a <z= b
/;

inference.
intro /a b c Hpos Hleq/.
so /integer_dichotomy a b/ /H | Hba/ >> auto.
exfalso.
so /timesz_ltz_l _# 3 Hpos Hba/ /H/.
so /ltz_irrefl _ (ltz_leqz_trans _# 3 H Hleq)/ /0/.
qed ();



lemma "timesz_cancel_leqz_r"
/
  forall a b c .
    z`0 <z c
    -> a *z c <z= b *z c
    -> a <z= b
/;

inference.
intro /a b c Hc Hleq/.
rewrite /-> timesz_commute in Hleq at 0 1/.
apply /timesz_cancel_leqz_l/ >> auto.
qed ();



lemma "timesz_cancel_leqz_l_remainder"
/
  forall a b c r .
    z`0 <z c
    -> r <z c
    -> c *z a <z= c *z b +z r
    -> a <z= b
/;

inference.
intro /a b c r Hpos Hr Hleq/.
so /integer_dichotomy a b/ /H | Hba/ >> auto.
exfalso.
unfold /ltz in Hba/.
so /timesz_leqz_l _# 3 (ltz_impl_leqz _ _ Hpos) Hba/ /Hbac/.
rewrite /-> timesz_dist_plusz_r in Hbac/.
rewrite /-> timesz_id_r in Hbac/.
rewrite /-> plusz_commute in Hbac/.
apply /ltz_irrefl (c *z a)/.
apply /leqz_ltz_trans/ >> auto.
apply /ltz_leqz_trans/ >> auto.
apply /plusz_ltz_r/ >> autoWith /leqz_refl/.
qed ();



lemma "timesz_cancel_leqz_r_remainder"
/
  forall a b c r .
    z`0 <z c
    -> r <z c
    -> a *z c <z= b *z c +z r
    -> a <z= b
/;

inference.
intro /a b c r Hpos Hr Hleq/.
rewrite /-> timesz_commute in Hleq at 0 1/.
apply /timesz_cancel_leqz_l_remainder/ >> auto.
qed ();



(* Minimum/Maximum *)

define /minz a b/
/
  if leqzb a b then a else b
//
  integer -> integer -> integer
/;

unfold /minz/.
typecheck.
qed ();

Define.registerNative 0 2 (Define.unfold1 (parseConstant /minz/) 2);



define /maxz a b/
/
  if leqzb a b then b else a
//
  integer -> integer -> integer
/;

unfold /maxz/.
typecheck.
qed ();

Define.registerNative 0 2 (Define.unfold1 (parseConstant /maxz/) 2);



lemma "negz_minz"
/
  forall a b . ~z (minz a b) = maxz (~z a) (~z b) : integer
/;

inference.
intro /a b/.
unfold /minz , maxz/.
boolCase /leqzb a b/ /Hab/ >> boolCase /leqzb (~z a) (~z b)/ /Hba/ >> attempt reflexivity.
  {
  reduce //.
  compat.
  apply /leqz_antisymm/ >> auto.
  apply /negz_leqz'/ >> auto.
  }

  {
  rewrite /-> not_leqz in Hab/.
  rewrite /-> not_leqz in Hba/.
  so /negz_ltz' _ _ Hba/ /Hba'/.
  so /ltz_irrefl _ (ltz_trans _ _ _ Hba' Hab)/ /0/.
  }
qed ();



lemma "maxz_as_minz"
/
  forall a b . maxz a b = ~z (minz (~z a) (~z b)) : integer
/;

inference.
intro /a b/.
rewrite /-> negz_minz/.
rewrite /-> negz_invol at all/.
reflexivity.
qed ();



lemma "negz_maxz"
/
  forall a b . ~z (maxz a b) = minz (~z a) (~z b) : integer
/;

inference.
intro /a b/.
rewrite /-> maxz_as_minz/.
rewrite /-> negz_invol/.
reflexivity.
qed ();



lemma "minz_as_maxz"
/
  forall a b . minz a b = ~z (maxz (~z a) (~z b)) : integer
/;

inference.
intro /a b/.
rewrite /-> negz_maxz/.
rewrite /-> negz_invol at all/.
reflexivity.
qed ();



lemma "minz_commute"
/
  forall a b . minz a b = minz b a : integer
/;

inference.
intro /a b/.
unfold /minz at all/.
boolCase /leqzb a b/ /Hab/ >> boolCase /leqzb b a/ /Hba/ >> attempt reflexivity.
  {
  apply /leqz_antisymm/ >> auto.
  }

  {
  so /Hab __/ /0/.
  rewrite /-> not_leqz in Hba/.
  apply /ltz_impl_leqz/ >> auto.
  }
qed ();



lemma "maxz_commute"
/
  forall a b . maxz a b = maxz b a : integer
/;

inference.
intro /a b/.
rewrite /-> maxz_as_minz at all/.
compat.
apply /minz_commute/.
qed ();



lemma "minz_assoc"
/
  forall a b c . minz (minz a b) c = minz a (minz b c) : integer
/;

inference.
intro /a b c/.
unfold /minz at all/.
boolCase /leqzb b c/ /Hbc/ >> reduce // >> boolCase /leqzb a b/ /Hab/ >> attempt reflexivity >> reduce //.
  {
  boolCase /leqzb a c/ /Hac/.
    {
    reflexivity.
    }
  so /Hac __/ /0/.
  apply /leqz_trans/ >> auto.
  }

  {
  boolCase /leqzb b c/ /Hbc'/.
    {
    reflexivity.
    }
  so /Hbc' Hbc/ /0/.
  }

  {
  boolCase /leqzb b c/ /Hbc'/.
    {
    so /Hbc Hbc'/ /0/.
    }
  boolCase /leqzb a c/ /Hac/.
  1:{
    reflexivity.
    }
  rewrite /-> not_leqz in Hbc/.
  rewrite /-> not_leqz in Hab/.
  apply /leqz_antisymm/ >> auto.
  apply /ltz_impl_leqz/.
  apply /ltz_trans/ >> auto.
  }
qed ();



lemma "maxz_assoc"
/
  forall a b c . maxz (maxz a b) c = maxz a (maxz b c) : integer
/;

inference.
intro /a b c/.
rewrite /-> maxz_as_minz at all/.
rewrite /-> negz_invol at all/.
compat.
apply /minz_assoc/.
qed ();



lemma "minz_leq_l"
/
  forall a b . minz a b <z= a
/;

inference.
intro /a b/.
unfold /minz/.
boolCase /leqzb a b/ /Hab/.
  {
  apply /leqz_refl/.
  }
rewrite /-> not_leqz in Hab/.
apply /ltz_impl_leqz/ >> auto.
qed ();



lemma "minz_leq_r"
/
  forall a b . minz a b <z= b
/;

inference.
intro /a b/.
rewrite /-> minz_commute/.
apply /minz_leq_l/.
qed ();



lemma "maxz_leq_l"
/
  forall a b . a <z= maxz a b
/;

inference.
intro /a b/.
rewrite /-> maxz_as_minz/.
apply /negz_leqz'/.
rewrite /-> negz_invol/.
apply /minz_leq_l/.
qed ();



lemma "maxz_leq_r"
/
  forall a b . b <z= maxz a b
/;

inference.
intro /a b/.
rewrite /-> maxz_commute/.
apply /maxz_leq_l/.
qed ();



lemma "minz_glb"
/
  forall a b c . c <z= a -> c <z= b -> c <z= minz a b
/;

inference.
intro /a b c Ha Hb/.
unfold /minz/.
boolCase /leqzb a b/ /Hab/ >> auto.
qed ();



lemma "maxz_lub"
/
  forall a b c . a <z= c -> b <z= c -> maxz a b <z= c
/;

inference.
intro /a b c Ha Hb/.
unfold /maxz/.
boolCase /leqzb a b/ /Hab/ >> auto.
qed ();

  

lemma "minz_eq_l"
/
  forall a b . a <z= b -> minz a b = a : integer
/;

inference.
intro /a b Hab/.
unfold /minz/.
boolCase /leqzb a b/ /H/ >> attempt reflexivity.
rewrite /-> not_leqz in H/.
so /ltz_irrefl _ (leqz_ltz_trans _ _ _ Hab H)/ /0/.
qed ();



lemma "minz_eq_r"
/
  forall a b . b <z= a -> minz a b = b : integer
/;

inference.
intro /a b Hba/.
rewrite /-> minz_commute/.
apply /minz_eq_l/ >> auto.
qed ();



lemma "maxz_eq_l"
/
  forall a b . b <z= a -> maxz a b = a : integer
/;

inference.
intro /a b H/.
rewrite /-> maxz_as_minz/.
rewrite /-> minz_eq_l/.
  {
  apply /negz_leqz/ >> auto.
  }
apply /negz_invol/.
qed ();



lemma "maxz_eq_r"
/
  forall a b . a <z= b -> maxz a b = b : integer
/;

inference.
intro /a b H/.
rewrite /-> maxz_commute/.
apply /maxz_eq_l/ >> auto.
qed ();



lemma "minz_idem"
/
  forall a . minz a a = a : integer
/;

inference.
intro /a/.
rewrite /-> minz_eq_l/ >> auto.
apply /leqz_refl/.
qed ();



lemma "maxz_idem"
/
  forall a . maxz a a = a : integer
/;

inference.
intro /a/.
rewrite /-> maxz_eq_l/ >> auto.
apply /leqz_refl/.
qed ();



lemma "minz_dist_maxz_l"
/
  forall a b c . minz (maxz a b) c = maxz (minz a c) (minz b c) : integer
/;

inference.
intro /a b c/.
revert /a b/.
assert /forall a b . a <z= b -> minz (maxz a b) c = maxz (minz a c) (minz b c) : integer/ /H/.
  {
  inference.
  intro /a b Hab/.
  rewrite /-> maxz_eq_r a b/ >> auto.
  so /integer_dichotomy_weak b c/ /Hbc | Hcb/.
    {
    rewrite /-> minz_eq_l b c at all/ >> auto.
    rewrite /-> minz_eq_l a c/ >> autoWith /leqz_trans/.
    rewrite /-> maxz_eq_r/ >> auto.
    }

    {
    rewrite /-> minz_eq_r b c at all/ >> auto.
    so /integer_dichotomy_weak a c/ /Hac | Hca/.
      {
      rewrite /-> minz_eq_l/ >> auto.
      rewrite /-> maxz_eq_r/ >> auto.
      }

      {
      rewrite /-> minz_eq_r/ >> auto.
      symmetry.
      apply /maxz_idem/.
      }
    }
  }
intro /a b/.
so /integer_dichotomy_weak a b/ /Hab | Hba/.
  {
  apply /H/ >> auto.
  }

  {
  rewrite /-> maxz_commute at 0 1/.
  apply /H/ >> auto.
  }
qed ();



lemma "minz_dist_maxz_r"
/
  forall a b c . minz a (maxz b c) = maxz (minz a b) (minz a c) : integer
/;

inference.
intro /a b c/.
rewrite /-> minz_commute at 0 1 2/.
apply /minz_dist_maxz_l/.
qed ();



lemma "maxz_dist_minz_l"
/
  forall a b c . maxz (minz a b) c = minz (maxz a c) (maxz b c) : integer
/;

inference.
intro /a b c/.
rewrite /-> minz_as_maxz at all/.
rewrite /-> maxz_as_minz at 4 3 0/.
rewrite /-> negz_invol at all/.
compat.
apply /minz_dist_maxz_l/.
qed ();



lemma "maxz_dist_minz_r"
/
  forall a b c . maxz a (minz b c) = minz (maxz a b) (maxz a c) : integer
/;

inference.
intro /a b c/.
rewrite /-> maxz_commute at 0 1 2/.
apply /maxz_dist_minz_l/.
qed ();



lemma "plusz_dist_minz_r"
/
  forall a b c . a +z minz b c = minz (a +z b) (a +z c) : integer
/;

inference.
intro /a b c/.
so /integer_dichotomy_weak b c/ /Hbc | Hcb/.
  {
  rewrite /-> minz_eq_l/ >> auto.
  rewrite /-> minz_eq_l/ >> auto.
  apply /plusz_leqz/ >> auto.
  apply /leqz_refl/.
  }

  {
  rewrite /-> minz_eq_r/ >> auto.
  rewrite /-> minz_eq_r/ >> auto.
  apply /plusz_leqz/ >> auto.
  apply /leqz_refl/.
  }
qed ();



lemma "plusz_dist_minz_l"
/
  forall a b c . minz a b +z c = minz (a +z c) (b +z c) : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1 2/.
apply /plusz_dist_minz_r/.
qed ();



lemma "plusz_dist_maxz_r"
/
  forall a b c . a +z maxz b c = maxz (a +z b) (a +z c) : integer
/;

inference.
intro /a b c/.
so /integer_dichotomy_weak b c/ /Hbc | Hcb/.
  {
  rewrite /-> maxz_eq_r/ >> auto.
  rewrite /-> maxz_eq_r/ >> auto.
  apply /plusz_leqz/ >> auto.
  apply /leqz_refl/.
  }

  {
  rewrite /-> maxz_eq_l/ >> auto.
  rewrite /-> maxz_eq_l/ >> auto.
  apply /plusz_leqz/ >> auto.
  apply /leqz_refl/.
  }
qed ();



lemma "plusz_dist_maxz_l"
/
  forall a b c . maxz a b +z c = maxz (a +z c) (b +z c) : integer
/;

inference.
intro /a b c/.
rewrite /-> plusz_commute at 0 1 2/.
apply /plusz_dist_maxz_r/.
qed ();



lemma "min_to_integer"
/
  forall m n . nat_to_integer (Nat.min m n) = minz (nat_to_integer m) (nat_to_integer n) : integer
/;

inference.
assert /forall m n . m <= n -> nat_to_integer (Nat.min m n) = minz (nat_to_integer m) (nat_to_integer n) : integer/ /H/.
  {
  inference.
  intro /m n Hmn/.
  rewrite /-> Nat.min_eq_l/ >> auto.
  rewrite /-> minz_eq_l/ >> auto.
  apply /nat_to_integer_mono/ >> auto.
  }
intro /m n/.
so /Nat.nat_dichotomy_weak m n/ /Hmn | Hnm/ >> auto.
rewrite /-> Nat.min_commute/.
rewrite /-> minz_commute/.
apply /H/ >> auto.
qed ();



lemma "max_to_integer"
/
  forall m n . nat_to_integer (Nat.max m n) = maxz (nat_to_integer m) (nat_to_integer n) : integer
/;

inference.
assert /forall m n . n <= m -> nat_to_integer (Nat.max m n) = maxz (nat_to_integer m) (nat_to_integer n) : integer/ /H/.
  {
  inference.
  intro /m n Hmn/.
  rewrite /-> Nat.max_eq_l/ >> auto.
  rewrite /-> maxz_eq_l/ >> auto.
  apply /nat_to_integer_mono/ >> auto.
  }
intro /m n/.
so /Nat.nat_dichotomy_weak m n/ /Hmn | Hnm/ >> auto.
rewrite /-> Nat.max_commute/.
rewrite /-> maxz_commute/.
apply /H/ >> auto.
qed ();



lemma "minz_to_nat"
/
  forall a b . integer_to_nat (minz a b) = Nat.min (integer_to_nat a) (integer_to_nat b) : nat
/;

inference.
assert /forall a b . a <z= b -> integer_to_nat (minz a b) = Nat.min (integer_to_nat a) (integer_to_nat b) : nat/ /H/.
  {
  inference.
  intro /a b Hab/.
  rewrite /-> minz_eq_l/ >> auto.
  rewrite /-> Nat.min_eq_l/ >> auto.
  apply /integer_to_nat_mono/ >> auto.
  }
intro /a b/.
so /integer_dichotomy_weak a b/ /Hab | Hba/ >> auto.
rewrite /-> minz_commute/.
rewrite /-> Nat.min_commute/.
apply /H/ >> auto.
qed ();



lemma "maxz_to_nat"
/
  forall a b . integer_to_nat (maxz a b) = Nat.max (integer_to_nat a) (integer_to_nat b) : nat
/;

inference.
assert /forall a b . a <z= b -> integer_to_nat (maxz a b) = Nat.max (integer_to_nat a) (integer_to_nat b) : nat/ /H/.
  {
  inference.
  intro /a b Hab/.
  rewrite /-> maxz_eq_r/ >> auto.
  rewrite /-> Nat.max_eq_r/ >> auto.
  apply /integer_to_nat_mono/ >> auto.
  }
intro /a b/.
so /integer_dichotomy_weak a b/ /Hab | Hba/ >> auto.
rewrite /-> maxz_commute/.
rewrite /-> Nat.max_commute/.
apply /H/ >> auto.
qed ();



lemma "integer_total"
/
  Partial.total integer
/;

unfold /Partial.total/.
exists /()/.
intro /x/.
RuleTactic.integerTotal.
hypof.
qed ();

val integer_total = parseConstant /integer_total/;




writeRegistry /AfterIntegerAllEnv/
  /[constant constant constant constant constant constant constant constant constant]/
  (Collapse (leqz, ltz, minusz, leqz_refl, leqz_trans, plusz_leqz, negz_leqz, leqz_implication, integer_total));


endModule ();
