
Namespace.beginModule "Acc";


Namespace.alias (parseIdent /Acc/) Prim.acc;


defineRaw /preacc A R/
/
  mu t . (exists (x : A) . forall (y : A) . R y x -> t)
/;



lemma "preacc_type"
/
  preacc :
  intersect i .
  forall (A : U i) .
    (A -> A -> U i)
    -> U i
/;

inference.
introOf /i A R/.
unfold /preacc/.
typecheck.
qed ();
recordTyping "preacc_type";



defineRaw /wf A R a x/
/
  fix
    (fn wf' a x .
       exists (_ : x = a #1 : A) .
         forall (y : A) (r : R y x) .
           wf' (a #2 y r) y)
    a x
/;



(* Wf recurses on only the last two arguments, so we don't get a nice
   unrolling reduction automatically, so build one.

   (We're committed the code for wf by the built-in Acc constant.)
*)

structure R = Reduction;
structure AR = AutoReduce;

val wf = parseConstant /wf/;

val m =
  parseLTerm /` exists (eq 3 0 (1 #1))
                  (fn . ` forall 4 
                            (fn . ` forall (4 0 2)
                                      (fn . wf 6 5 (4 #2 1 0) 1)))/;

val unroll_wf = 
  AR.new1 true
    [(wf, [R.unfold])]
    [(Prim.fix, R.user1 Prim.unroll_fix)]
    wf 4 m;

Database.setUnroll (parseConstant /wf/) (R.user1 unroll_wf);



lemma "wf_type"
/
  wf :
  intersect i .
  forall (A : U i) (R : A -> A -> U i) .
    preacc A R -> A -> U i
/;

inference.
introOf /i A R a x/.
revert /x/.
unfold /preacc in a/.
induct /a/.
reintro /u a Hu IH/.
intro /x/.
destruct /a/ /x' f/.
unroll /wf/.
typecheck.
qed ();
recordTyping "wf_type";



(* The built-in Acc doesn't use preacc and wf, so we'll rig something up
   to make it appear that it does.
*)

val preacc = parseConstant /preacc/;
val acc = parseConstant /Acc/;

val m = parseLTerm /` exists (preacc 2 1) (fn . wf 3 2 0 1)/;

val unfold_acc =
  R.user1 $
  AR.new1 true
    [(wf, [R.unfold]), (preacc, [R.unfold]), (acc, [R.unfold])]
    [(Prim.fix, R.user1 Prim.unroll_fix)]
    acc 3 m;



(*
If it weren't built-in:

defineRaw /Acc A R x/
/
  exists (a : preacc A R) . wf A R a x
/;

*)



lemma "Acc_type"
/
  Acc :
  intersect i .
  forall (A : U i) (R : A -> A -> U i) .
    A -> U i
/;

inference.
introOf /i A R x/.
reduceUsing /\unfold_acc\/.
typecheck.
qed ();
recordTyping "Acc_type";



lemma "Acc_intro"
/
  forall i (A : U i) (R : A -> A -> U i) (x : A) .
    (forall (y : A) . R y x -> Acc A R y)
    -> Acc A R x
/;

inference.
intro /i A R x Hacc/.
reduceUsing /\unfold_acc\ in Hacc in concl/.
exists /(x , (fn y r . Hacc y r #1))/.
  {
  unrollType /preacc/.
  typecheck.
  }
unroll /wf/.
exists /()/.
intro /y r/.
exact /Hacc y r #2/.
qed ();



lemma "Acc_elim"
/
  forall i (A : U i) (R : A -> A -> U i) (x y : A) .
    Acc A R x
    -> R y x
    -> Acc A R y
/;

inference.
intro /i A R x y Hacc Hyx/.
reduceUsing /\unfold_acc\ in Hacc in concl/.
destruct /Hacc/ /a w/.
unrollType /preacc in a/.
destruct /a/ /x' f/.
unroll /wf in w/.
destruct /w/ /Heq Hwf/.
exists /f y Hyx/.
apply /Hwf/.
qed ();



Constant.setOpacity (parseConstant /Acc/) Constant.OPAQUE;



Namespace.endModule ();
