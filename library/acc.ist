
Namespace.beginModule "Acc";


Namespace.alias (parseIdent /Acc/) Prim.acc;


define /preacc A R/
/
  mu t . (exists (x : A) . forall (y : A) . R y x -> t)
/;



lemma "preacc_type"
/
  preacc :
  intersect i .
  forall (A : U i) .
    (A -> A -> U i)
    -> U i
/;

inference.
introOf /i A R/.
unfold /preacc/.
typecheck.
qed ();
recordTyping "preacc_type";



define /wf A R a x/
/
  fix
    (fn wf' a x .
       exists (_ : x = a #1 : A) .
         forall (y : A) (r : R y x) .
           wf' (a #2 y r) y)
    a x
/;



(* Wf recurses on only the last two arguments, so we don't get a nice
   unrolling reduction automatically, so build one.

   (We're committed the code for wf by the built-in Acc constant.)
*)

structure P = ReductionProver;
structure R = Reduction;

P.start (parseLTerm /wf 3 2 1 0/);
P.unfold ();
P.beta 4;
P.user1 Prim.unroll_fix;
P.beta 3;
val (_, r1) = P.done ();

val m = parseLTerm /` exists (eq 3 0 (1 #1)) 
                        (fn . ` forall 4 
                                  (fn . ` forall (4 0 2)
                                            (fn . wf 6 5 (4 #2 1 0) 1)))/;
P.start m;
P.enter [2, 0, 2, 0, 2, 0];
P.unfold ();
P.beta 4;
P.leave ();
val (_, r2) = P.done ();

val unroll_wf = R.new1 (parseConstant /wf/) 4 m r1 r2;
Database.setUnroll (parseConstant /wf/) (R.user1 unroll_wf);



lemma "wf_type"
/
  wf :
  intersect i .
  forall (A : U i) (R : A -> A -> U i) .
    preacc A R -> A -> U i
/;

inference.
introOf /i A R a x/.
revert /x/.
unfold /preacc in a/.
induct /a/.
reintro /u a Hu IH/.
intro /x/.
destruct /a/ /x' f/.
unroll /wf/.
typecheck.
qed ();
recordTyping "wf_type";



(* The built-in Acc doesn't use preacc and wf, so we'll rig something up
   to make it appear that it does.
*)

P.start (parseLTerm /Acc 2 1 0/);
P.unfold ();
P.beta 3;
val (_, r1) = P.done ();

val m = parseLTerm /` exists (preacc 2 1) (fn . wf 3 2 0 1)/;
P.start m;
P.enter [1];
P.unfold ();
P.beta 2;
P.leave ();
P.enter [2, 0];
P.unfold ();
P.beta 4;
P.leave ();
val (_, r2) = P.done ();

val unfold_acc = R.user1 $ R.new1 (parseConstant /Acc/) 3 m r1 r2;



(*
If it weren't built-in:

define /Acc A R x/
/
  exists (a : preacc A R) . wf A R a x
/;

*)



lemma "Acc_type"
/
  Acc :
  intersect i .
  forall (A : U i) (R : A -> A -> U i) .
    A -> U i
/;

inference.
introOf /i A R x/.
reduceUsing /\unfold_acc\/.
typecheck.
qed ();
recordTyping "Acc_type";



lemma "Acc_intro"
/
  forall i (A : U i) (R : A -> A -> U i) (x : A) .
    (forall (y : A) . R y x -> Acc A R y)
    -> Acc A R x
/;

inference.
intro /i A R x Hacc/.
reduceUsing /\unfold_acc\ in Hacc in concl/.
exists /(x , (fn y r . Hacc y r #1))/.
  {
  unrollType /preacc/.
  typecheck.
  }
unroll /wf/.
exists /()/.
intro /y r/.
exact /Hacc y r #2/.
qed ();



lemma "Acc_elim"
/
  forall i (A : U i) (R : A -> A -> U i) (x y : A) .
    Acc A R x
    -> R y x
    -> Acc A R y
/;

inference.
intro /i A R x y Hacc Hyx/.
reduceUsing /\unfold_acc\ in Hacc in concl/.
destruct /Hacc/ /a w/.
unrollType /preacc in a/.
destruct /a/ /x' f/.
unroll /wf in w/.
destruct /w/ /Heq Hwf/.
exists /f y Hyx/.
apply /Hwf/.
qed ();



Constant.setOpacity (parseConstant /Acc/) Constant.OPAQUE;



Namespace.endModule ();

File.save "acc.isto";
