
Ctrl.use "list-aux.iml";

Ctrl.use "acc-load.iml";
Ctrl.use "nat-load.iml";
Ctrl.use "datatype-load.iml";


Namespace.beginModule "List";


typedef
/
  datatype
    intersect (i : level) .
    forall (a : U i) .
    U i
  of
    list : type =
    | nil : list
    | cons : a -> list -> list
/;



Database.setImplicits (parseConstant /nil/) 1;
Database.setImplicits (parseConstant /cons/) 1;



structure Nothing = AfterList ();



defineRaw /list_case {a b} l mnil mcons/
/
  list_iter a (fn _ . b) mnil (fn h t _ . mcons h t) l
/;



reductions
/
  list_case _ _ (nil _) z _ --> z ;
  list_case _ _ (cons _ h t) _ s --> s h t ;
  unfolding list_case
/;



lemma "list_case_type"
/
  ` list_case :
  intersect (i : level) .
  forall (a b : U i) .
     list a 
     -> b 
     -> (a -> list a -> b)
     -> b
/;

introOf /i a b l mnil mcons/.
destruct /l/ /| h t/.

(* nil *)
{
reduce //.
hypof.
}

(* cons *)
{
reduce //.
typecheck.
}
qed ();
recordTyping "list_case_type";



defineRaw /append {a} l1 l2/
/
  list_iter a (fn _ . list a) l2 (fn h _ t . ` cons a h t) l1
/;



lemma "append_type"
/
  ` append :
  intersect (i : level) .
  forall (a : U i) .
     list a -> list a -> list a
/;

unfoldHead /append/.
typecheck.
qed ();
recordTyping "append_type";



reductions
/
  append _ (nil _) l --> l ;
  append a (cons _ h t) l --> ` cons a h (` append a t l) ;
  unfolding append
/;



lemma "append_id_l"
/
  forall (i : level) (a : U i) (l : list a) .
    ` append a (` nil a) l = l : list a
/;

intro /i a l/.
reflexivity.
qed ();



lemma "append_id_r"
/
  forall (i : level) (a : U i) (l : list a) .
    append l nil = l : list a
/;

inference.
intro /i a l/.
iterate /l/.

(* nil *)
{
reflexivity.
}

(* cons *)
{
intro /h t IH/.
compat.
hyp /IH/.
}
qed ();



lemma "append_assoc"
/
  forall (i : level) (a : U i) (l1 l2 l3 : list a) .
    append (append l1 l2) l3 = append l1 (append l2 l3) : list a
/;

inference.
intro /i a l1 l2 l3/.
iterate /l1/.

(* nil *)
{
reduce //.
reflexivity.
}

(* cons *)
{
intro /h t IH/.
compat.
hyp /IH/.
}
qed ();



definerec /length {a} l/
/
  list_case l 0 (fn _ t . succ (length a t))
//
  intersect (i : level) .
  forall (a : U i) . list a -> nat
/;

inference.
introOf /i a l/.
revert /l/.
assert /
  forall (s : list_skel a) (l : list a) .
    list_strip l = s : list_skel a
    -> length a l : nat
/ /H/.
1:{
  intro /l/.
  apply /H (list_strip l)/.
  auto.
  }
intro /s/.
so /list_subterm_well_founded _ a s/ /Hwf/.
induct /Hwf/.
reintro /IH/.
intro /l Heq/.
destruct /l/ /| h t/.
  {
  unroll /length/.
  typecheck.
  }

  {
  unroll /length/.
  typecheck1.
  apply /IH (list_strip t)/ >> auto.
  moveBefore /h t/ /s/.
  subst /s/.
  apply /cons_subterm/.
  }
qed ();



reductions
/
  length _ (nil _) --> 0 ;
  length a (cons _ _ t) --> succ (` length a t) ;
  unrolling length
/;



lemma "length_append"
/
  forall i (a : U i) (l1 l2 : list a) .
    length (append l1 l2) = length l1 + length l2 : nat
/;

inference.
intro /i a l1 l2/.
iterate /l1/.

(* nil *)
{
auto.
}

(* cons *)
{
intro /h t IH/.
compat.
hyp /IH/.
}
qed ();



Namespace.endModule ();
