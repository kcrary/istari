
Ctrl.use "list-aux.iml";

Ctrl.use "acc-load.iml";
Ctrl.use "nat-load.iml";
Ctrl.use "datatype-load.iml";


Namespace.beginModule "List";


typedef
/
  datatype
    intersect (i : level) .
    forall (a : U i) .
    U i
  of
    list : type =
    | nil : list
    | cons : a -> list -> list
/;



Database.setImplicits (parseConstant /nil/) 1;
Database.setImplicits (parseConstant /cons/) 1;



structure Nothing = AfterList ();



defineRaw /list_case {a b} l mnil mcons/
/
  list_iter a (fn _ . b) mnil (fn h t _ . mcons h t) l
/;



reductions
/
  list_case _ _ (nil _) z _ --> z ;
  list_case _ _ (cons _ h t) _ s --> s h t ;
  unfolding list_case
/;



lemma "list_case_type"
/
  ` list_case :
  intersect (i : level) .
  forall (a b : U i) .
     list a 
     -> b 
     -> (a -> list a -> b)
     -> b
/;

introOf /i a b l mnil mcons/.
destruct /l/ /| h t/.

(* nil *)
{
reduce //.
hypof.
}

(* cons *)
{
reduce //.
typecheck.
}
qed ();
recordTyping "list_case_type";



defineRaw /append {a} l1 l2/
/
  list_iter a (fn _ . list a) l2 (fn h _ t . ` cons a h t) l1
/;



lemma "append_type"
/
  ` append :
  intersect (i : level) .
  forall (a : U i) .
     list a -> list a -> list a
/;

unfoldHead /append/.
typecheck.
qed ();
recordTyping "append_type";



reductions
/
  append _ (nil _) l --> l ;
  append a (cons _ h t) l --> ` cons a h (` append a t l) ;
  unfolding append
/;



(* For illustrative purposes. *)
definerecRaw /appendrec {a} l1 l2/
/
  ` list_case a (list a) l1 l2 (fn h t . ` cons a h (appendrec a t l2))
/;



reductions
/
  appendrec _ (nil _) l --> l ;
  appendrec a (cons _ h t) l --> ` cons a h (` appendrec a t l) ;
  unrolling appendrec
/;



lemma "appendrec_type"
/
  ` appendrec :
  intersect i .
  forall (a : U i) .
     list a -> list a -> list a
/;

inference.
introOf /i a l1 l2/.
assert /list_strip l1 = list_strip l1 : list_skel a/ /Heq/.
  {
  reflexivity.
  }
revert /Heq/.
generalizeAt /list_strip l1/ /_/ /1/ /sk/.
revert /l1/.
so /list_subterm_well_founded _ _ sk/ /Hacc/.
induct /Hacc/.
reintro /IH/.
intro /l1 Heq/.
destruct /l1/ /| h t/.

(* nil *)
{
reduce //.
hypof.
}

(* cons *)
{
reduce //.
typecheck.
apply /IH (list_strip t)/.
  {
  moveBefore /h t/ /sk/.
  subst /sk/.
  apply /cons_subterm/.
  }

  {
  reflexivity.
  }
}
qed ();
recordTyping "appendrec_type";



lemma "append_id_l"
/
  forall (i : level) (a : U i) (l : list a) .
    ` append a (` nil a) l = l : list a
/;

intro /i a l/.
reflexivity.
qed ();



lemma "append_id_r"
/
  forall (i : level) (a : U i) (l : list a) .
    append l nil = l : list a
/;

inference.
intro /i a l/.
iterate /l/.

(* nil *)
{
reflexivity.
}

(* cons *)
{
intro /h t IH/.
compat.
hyp /IH/.
}
qed ();



lemma "append_assoc"
/
  forall (i : level) (a : U i) (l1 l2 l3 : list a) .
    append (append l1 l2) l3 = append l1 (append l2 l3) : list a
/;

inference.
intro /i a l1 l2 l3/.
iterate /l1/.

(* nil *)
{
reduce //.
reflexivity.
}

(* cons *)
{
intro /h t IH/.
compat.
hyp /IH/.
}
qed ();



defineRaw /length {a} l/
/
  list_iter a (fn _ . nat) 0 (fn _ _ n . succ n) l
/;



reductions
/
  length _ (nil _) --> 0 ;
  length a (cons _ _ t) --> succ (` length a t) ;
  unfolding length
/;



lemma "length_type"
/
  ` length :
  intersect i .
  forall (a : U i) .
    list a -> nat
/;

inference.
introOf /i a l/.
unfold /length/.
typecheck.
qed ();
recordTyping "length_type";



lemma "length_append"
/
  forall i (a : U i) (l1 l2 : list a) .
    length (append l1 l2) = length l1 + length l2 : nat
/;

inference.
intro /i a l1 l2/.
iterate /l1/.

(* nil *)
{
auto.
}

(* cons *)
{
intro /h t IH/.
compat.
hyp /IH/.
}
qed ();



Namespace.endModule ();
