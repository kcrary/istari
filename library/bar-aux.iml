
structure ParseBar =
   struct

      structure R = CheckpointedRef
      structure T = ETerm

      val bindbar : Constant.constant R.dest = R.dest ()

      fun parseBind x m n = T.apply4 (R.read bindbar) T.evar T.evar m (T.lam (SOME x) n)

   end


grammardef Bar

   rule Term(0) ::= "bindbar" Ident "=" Term(1) "in" Term(0) => ParseBar.parseBind

   reserved "bindbar" : Ident

end


functor AfterBindbar () :> sig end =
   struct

      val Collapse (bindbar) =
         readRegistry /Bar.AfterBindbarEnv/
            /[constant]/

      structure U = Show.Unparsing

      val () =
         ConstantTable.insert U.unparsingTable bindbar
         (4, 0, ref true,
          U.wrap
             (U.apply4 bindbar U.wild U.wild U.show (U.lam U.show))
             (fn ((), (), m, (x, n)) =>
                 U.append [
                          U.string "bindbar ",
                          U.string x,
                          U.string " =",
                          U.break 1,
                          m 1,
                          U.string " in",
                          U.break 1,
                          n 0
                          ]))

      val () =
         U.reserved :=
         SymbolSet.insert (!U.reserved) (Symbol.fromValue "bindbar")

   end


functor AfterBarAll () :> sig end =
   struct

      val Collapse (bar, bar_subtype) =
         readRegistry /Bar.AfterBarAllEnv/
            /[constant constant]/

      val () =
         List.app Registry.delete
            (parseLongidents
                /Bar.AfterBindbarEnv
                 Bar.AfterBarAllEnv/)

      val () =
         Constant2Table.insert TypecheckInternal.subtypeTactics (bar, bar)
            (Backchain.applyRaw /\Term.Const bar_subtype\/)

   end
