
File.import "acc-load.iml";
File.import "logic-load.iml";
File.import "bool-load.iml";
File.import "decidable-load.iml";
File.import "stable-load.iml";
openModule /Acc/;
openModule /Logic/;
openModule /Bool/;

File.import "nat-aux.iml";

beginModule "Nat";


Namespace.aliasExport (parseIdent /nat/) Prim.nat;
Namespace.aliasExport (parseIdent /zero/) Prim.zero;
Namespace.aliasExport (parseIdent /succ/) Prim.succ;
Namespace.aliasExport (parseIdent /nat_case/) Prim.nat_case;


lemma "nat_type"
/
  nat : U 0
/;

typecheck.
qed ();
recordTyping "nat_type";



(* Primitives *)

lemma "nat_case_type"
/
  nat_case :
  intersect i (a : U i) .
    nat
    -> a
    -> (nat -> a)
    -> a
/;

introOf /i a n hz hs/.
destruct /n/ /| n/.
  {
  reduce //.
  hypof.
  }

  {
  reduce //.
  typecheck.
  }
qed ();
recordTyping "nat_case_type";



definerecRaw /nat_iter P hz hs n/
/
  nat_case n hz (fn n' . hs n' (nat_iter P hz hs n'))
/;

val nat_iter = parseConstant /nat_iter/;



reductions
/
nat_iter _ z _ (zero) --> z ;
nat_iter a z s (succ n) --> s n (nat_iter a z s n) ;
unrolling nat_iter
/;



writeRegistry /AfterNatEnv/
  /[constant]/ 
  (Collapse (nat_iter));
structure NatTactic = AfterNat ();
open NatTactic;



lemma "nat_iter_type"
/
  nat_iter :
  intersect i .
    forall (P : nat -> U i) .
      P zero
      -> (forall (n : nat) . P n -> P (succ n))
      -> forall (n : nat) . P n
/;

introOf /i P hz hs n/.
natPrimInduction.
  {
  reduce //.
  hypof.
  }

  {
  reintro /u n Hu IH/.
  reduce //.
  typecheck.
  }
qed ();
recordTyping "nat_iter_type";




(* Equality *)

lemma "eq_0_succ_not"
/
  forall n . 0 = succ n : nat -> void
/;

inference.
intro /n Heq/.
assert /unit/ /H/ >>> [split, idtac].
rewrite /unit = void : U 0 in H/.
  {
  let
    val m = Prover.parseCurr /fn x . nat_case x unit (fn _ . void)/
    val p = Prover.parseCurr /0/
    val q = Prover.parseCurr /succ n/
    val a = Prover.parseCurr /nat/
  in
    Tactic.refine (Rule.arrowElimEq a (Term.evar ()) m m p q)
  end.
    {
    reflexivity.
    }
    
    {
    hyp /Heq/.
    }
  }
hyp /H/.
qed ();



lemma "eq_succ_0_not"
/
  forall n . succ n = 0 : nat -> void
/;

inference.
intro /n H/.
apply /eq_0_succ_not _/.
  {
  symmetry.
  hyp /H/.
  }
typecheck.
qed ();



lemma "succ_inj"
/
  forall m n . succ m = succ n : nat -> m = n : nat
/;

inference.
intro /m n Heq/.
let
  val m = Prover.parseCurr /fn x . nat_case x 0 (fn y . y)/
  val p = Prover.parseCurr /succ m/
  val q = Prover.parseCurr /succ n/
  val a = Prover.parseCurr /nat/
in
  Tactic.refine (Rule.arrowElimEq a (Term.evar ()) m m p q)
end.
  {
  reflexivity.
  }

  {
  hyp /Heq/.
  }
qed ();




(* Inequality *)

definerecRaw /leq m n/
/
  nat_case m
    unit
    (fn m' .
       nat_case n
         void
         (fn n' . leq m' n'))
/;

val leq = parseConstant /leq/;


defineRaw /lt m n/
/
  leq (succ m) n
/;

val lt = parseConstant /lt/;



writeRegistry /AfterLeqEnv/
  /[constant constant]/
  (Collapse (leq, lt));
structure Nothing = AfterLeq ();



lemma "leq_type"
/
  leq :
  nat -> nat -> U 0
/;

introOf /m n/.
revert /n/.
natPrimInduction.

(* 0 *)
{
intro /n/.
unroll /leq/.
reduce //.
typecheck.
}

(* succ *)
{
reintro /u m Hu IH/.
intro /n/.
unroll /leq/.
reduce //.
destruct /n/ /| n/.
  {
  reduce //.
  typecheck.
  }

  {
  reduce //.
  apply /IH/.
  }
}
qed ();
recordTyping "leq_type";



lemma "lt_type"
/
  lt :
  nat -> nat -> U 0
/;

introOf /m n/.
unfold /lt/.
typecheck.
qed ();
recordTyping "lt_type";



lemma "leq_inhabitant"
/
  forall m n .
    m <= n
    -> () : m <= n
/;

inference.
intro /m/.
natPrimInduction.

(* 0 *)
{
intro /n _/.
unroll /leq/.
reduce //.
typecheck.
}

(* succ *)
{
reintro /u m Hu IH/.
intro /n Hleq/.
destruct /n/ /| n/.
  {
  unroll /leq in Hleq/.
  reduce /Hleq/.
  destruct /Hleq/ /0/.
  }
unroll /leq in Hleq in concl/.
reduce /Hleq concl/.
apply /IH/.
auto.
}
qed ();

val leq_inhabitant = parseConstant /leq_inhabitant/;



lemma "lt_inhabitant"
/
  forall m n .
    m < n
    -> () : m < n
/;

inference.
unfold /lt at all/.
intro /m n H/.
apply /leq_inhabitant/.
hyp /H/.
qed ();

val lt_inhabitant = parseConstant /lt_inhabitant/;



writeRegistry /AfterLeqInhabitantEnv/
  /[constant constant constant constant]/
  (Collapse (leq, lt, leq_inhabitant, lt_inhabitant));
structure Nothing = AfterLeqInhabitant ();



lemma "leq_0_min"
/
  forall n . leq 0 n
/;

inference.
intro /n/.
unroll /leq/.
reduce //.
split.
qed ();



lemma "leq_succ_0_not"
/
  forall n .
    succ n <= 0
    -> void
/;

inference.
intro /n H/.
unroll /leq in H/.
reduce /H/.
hyp /H/.
qed ();



lemma "leq_succ_succ"
/
  forall m n .
    m <= n
    -> succ m <= succ n
/;

inference.
intro /m n H/.
unroll /leq/ >> reduce //.
hyp /H/.
qed ();

val leq_succ_succ = parseConstant /leq_succ_succ/;



lemma "leq_succ_invert"
/
  forall m n .
    succ m <= succ n
    -> m <= n
/;

inference.
intro /m n H/.
unroll /leq in H/ >> reduce /H/.
hyp /H/.
qed ();



lemma "leq_succ"
/
  forall n .
    n <= succ n
/;

inference.
intro /n/.
induction /n/ >> autoWith /leq_0_min leq_succ_succ/.
qed ();



lemma "leq_refl"
/
  forall n . n <= n
/;

inference.
intro /n/.
induction /n/ >> autoWith /leq_0_min leq_succ_succ/.
qed ();

val leq_refl = parseConstant /leq_refl/;



lemma "leq_refl_eq"
/
  forall m n .
    m = n : nat
    -> m <= n
/;

inference.
intro /m n Heq/.
subst /n/.
apply /leq_refl/.
qed ();



lemma "leq_trans"
/
  forall m n p .
    m <= n
    -> n <= p
    -> m <= p
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p _ _/.
apply /leq_0_min/.
}

(* succ *)
{
intro /m IH n p Hmn Hnp/.
destruct /n/ /| n/.
  {
  so /leq_succ_0_not _ Hmn/ /0/.
  }
so /leq_succ_invert _ _ Hmn/ /Hmn'/.
destruct /p/ /| p/.
  {
  so /leq_succ_0_not _ Hnp/ /0/.
  }
so /leq_succ_invert _ _ Hnp/ /Hnp'/.
apply /leq_succ_succ/.
exact /IH _ _ Hmn' Hnp'/.
}
qed ();

val leq_trans = parseConstant /leq_trans/;



lemma "leq_antisymm"
/
  forall m n .
    m <= n
    -> n <= m
    -> m = n : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n Hmn Hnm/.
destruct /n/ /| n/.
  {
  reflexivity.
  }

  {
  so /leq_succ_0_not _ Hnm/ /0/.
  }
}

(* succ *)
{
intro /m IH n Hmn Hnm/.
destruct /n/ /| n/.
  {
  so /leq_succ_0_not _ Hmn/ /0/.
  }

  {
  compat.
  so /leq_succ_invert _ _ Hmn/ /Hmn'/.
  so /leq_succ_invert _ _ Hnm/ /Hnm'/.
  exact /IH _ Hmn' Hnm'/.
  }
}
qed ();



lemma "leq_implication"
  / forall (m m' n n' : nat) .
      leq m' m
      -> leq n n'
      -> leq m n
      -> leq m' n' /;

intro /m m' n n' Hm Hn H/.
apply /leq_trans _ m/.
  {
  hyp /Hm/.
  }
apply /leq_trans _ n/.
  {
  hyp /H/.
  }
hyp /Hn/.
qed ();

val leq_implication = parseConstant /leq_implication/;



lemma "lt_impl_leq"
/
  forall m n .
    m < n
    -> m <= n
/;

inference.
intro /m n Hmn/.
unfold /lt in Hmn/.
apply /leq_trans _ (succ m)/.
  {
  apply /leq_succ/.
  }

  {
  hyp /Hmn/.
  }
qed ();



lemma "lt_succ_succ"
/
  forall m n . m < n -> succ m < succ n
/;

inference.
unfold /lt at all/.
intro /m n H/.
apply /leq_succ_succ/.
hyp /H/.
qed ();



lemma "lt_succ_invert"
/
  forall m n .
    succ m < succ n
    -> m < n
/;

inference.
intro /m n H/.
unfold /lt/.
apply /leq_succ_invert/.
fold /lt _ _/.
hyp /H/.
qed ();



lemma "lt_succ"
/
  forall n . lt n (succ n)
/;

inference.
intro /n/.
unfold /lt/.
apply /leq_refl/.
qed ();



lemma "lt_irrefl"
/
  forall n .
    n < n
    -> void
/;

inference.
intro /n/.
unfold /lt/.
induction /n/.

(* 0 *)
{
intro /H/.
so /leq_succ_0_not _ H/ /0/.
}

(* succ *)
{
intro /n IH H/.
apply /IH/.
apply /leq_succ_invert/.
auto.
}
qed ();



lemma "lt_trans"
/
  forall m n p .
    m < n
    -> n < p
    -> m < p
/;

inference.
unfold /lt at all/.
intro /m n p Hmn Hnp/.
apply /leq_trans _ n/.
  {
  hyp /Hmn/.
  }
apply /leq_trans _ (succ n)/.
  {
  apply /leq_succ/.
  }

  {
  hyp /Hnp/.
  }
qed ();



lemma "leq_lt_trans"
/
  forall m n p .
    m <= n
    -> n < p
    -> m < p
/;

inference.
intro /m n p Hmn Hnp/.
unfold /lt in Hnp in concl/.
witness /leq_trans _ _ _ __ Hnp/.
apply /leq_succ_succ/.
auto.
qed ();



lemma "lt_leq_trans"
/
  forall m n p .
    m < n
    -> n <= p
    -> m < p
/;

inference.
intro /m n p Hmn Hnp/.
unfold /lt in Hmn in concl/.
withTypecheck $ apply /leq_trans/ >> auto.
qed ();



lemma "lt_0_succ"
/
  forall n . 0 < succ n
/;

inference.
intro /n/.
unfold /lt/.
apply /leq_succ_succ/.
apply /leq_0_min/.
qed ();



lemma "lt_0_not"
/
  forall n . n < 0 -> void
/;

inference.
intro /n H/.
so /lt_leq_trans _# 3 H (leq_0_min n)/ /H'/.
so /lt_irrefl _ H'/ /0/.
qed ();



lemma "not_leq"
/
  forall m n . not (m <= n) <-> n < m
/;

inference.
intro /m n/.
split.
  {
  revert /n/.
  induction /m/.
    {
    intro /n Hn/.
    exfalso.
    apply /Hn/.
    apply /leq_0_min/.
    }

    {
    intro /m IH n Hn/.
    destruct /n/ /| n/.
      {
      apply /lt_0_succ/.
      }
    apply /lt_succ_succ/.
    apply /IH/.
    intro /H/.
    apply /Hn/.
    apply /leq_succ_succ/ >> auto.
    }
  }

  {
  revert /n/.
  induction /m/.
    {
    intro /n Hn/.
    so /lt_0_not _ Hn/ /0/.
    }
    
    {
    intro /m IH n Hn/.
    intro /H/.
    destruct /n/ /| n/.
      {
      so /leq_succ_0_not _ H/ /0/.
      }
    so /leq_succ_invert _ _ H/ /H'/.
    revert /H'/.
    apply /IH/.
    apply /lt_succ_invert/.
    hyp /Hn/.
    }
  }
qed ();



lemma "not_lt"
/
  forall m n . not (m < n) <-> n <= m
/;

inference.
intro /m n/.
unfold /lt/.
rewrite /-> not_leq/.
unfold /lt/.
split.
  {
  intro /H/.
  apply /leq_succ_invert/.
  hyp /H/.
  }

  {
  intro /H/.
  apply /leq_succ_succ/.
  hyp /H/.
  }
qed ();



lemma "lt_from_leq_neq"
/
  forall m n . m <= n -> not (m = n : nat) -> m < n
/;

inference.
intro /m n Hmn Hneq/.
rewrite /<- not_leq/.
intro /Hnm/.
witness /Hneq __/.
apply /leq_antisymm/ >> auto.
qed ();



lemma "lt_well_founded"
/
  forall n . Acc nat lt n
/;

inference.
intro /n/.
assert /forall m . m <= n -> Acc nat lt m/ /H/.
1:{
  apply /H/.
  apply /leq_refl/.
  }
natPrimInduction.

(* 0 *)
{
intro /m Hm/.
apply /Acc_intro/.
intro /p Hp/.
unfold /lt in Hp/.
so /leq_succ_0_not _ (leq_trans _ _ _ Hp Hm)/ /0/.
}

(* succ *)
{
reintro /u n Hu IH/.
intro /m Hm/.
apply /Acc_intro/.
intro /p Hp/.
apply /IH n/.
unfold /lt in Hp/.
apply /leq_succ_invert/.
exact /leq_trans _ _ _ Hp Hm/.
}
qed ();

val lt_well_founded = parseConstant /lt_well_founded/;



writeRegistry /AfterLtWellFoundedEnv/
  /[constant]/
  (Collapse (lt_well_founded));
structure Nothing = AfterLtWellFounded ();



(* Operations *)

(*
Built-in:

definerecRaw /plus m n/
/
  nat_case m
    n
    (fn m' . succ (plus m' n))
/;
*)

Namespace.aliasExport (parseIdent /plus/) Prim.plus;

Database.setUnroll Prim.plus
  (Reduction.trans
     [DefineInternal.recUnroller Prim.plus,
      Reduction.beta 2]);



defineRaw /pred n/
/
  nat_case n
    0
    (fn n' . n')
/;



definerecRaw /minus m n/
/
  nat_case n
    m
    (fn n' . minus (pred m) n')
/;

val minus = parseConstant /minus/;



(*
Built-in:

definerecRaw /times m n/
/
  nat_case m
    0
    (fn m' . plus n (times m' n))
/;
*)

aliasExport /times/ Prim.times;

Database.setUnroll Prim.times
  (Reduction.trans
     [DefineInternal.recUnroller Prim.times,
      Reduction.beta 2]);



writeRegistry /AfterTimesEnv/
  /[constant]/
  (Collapse (minus));
structure Nothing = AfterTimes ();



reductions
/
  plus (zero) n --> n ;
  plus (succ m) n --> succ (plus m n) ;
  pred (zero) --> zero ;
  pred (succ n) --> n ;
  minus m (zero) --> m ;
  minus m (succ n) --> minus (pred m) n ;
  unrolling plus minus
  unfolding pred
/;



(* Addition and Subtraction *)

lemma "plus_type"
/
  plus : nat -> nat -> nat
/;

introOf /m n/.
sinduction /m/.
reintro /IH/.
destruct /m/ /| m/.
  {
  reduce //.
  hypof.
  }

  {
  reduce //.
  typecheck1.
  apply /IH/.
  apply /lt_succ/.
  }
qed ();
recordTyping "plus_type";



lemma "pred_type"
/
  pred : nat -> nat
/;

introOf /n/.
destruct /n/ /| n/.
  {
  reduce //.
  typecheck.
  }
reduce //.
typecheck.
qed ();
recordTyping "pred_type";



lemma "minus_type"
/
  minus : nat -> nat -> nat
/;

introOf /m n/.
revert /m/.
sinduction /n/.
reintro /IH/.
intro /m/.
destruct /n/ /| n/.
  {
  reduce //.
  typecheck.
  }
reduce //.
apply /IH/.
apply /lt_succ/.
qed ();
recordTyping "minus_type";



lemma "plus_0_l"
/
  forall n . 0 + n = n : nat
/;

inference.
intro /n/.
reflexivity.
qed ();



lemma "plus_0_r"
/
  forall n . n + 0 = n : nat
/;

inference.
intro /n/.
induction /n/.
  {
  reflexivity.
  }

  {
  intro /n IH/.
  compat.
  hyp /IH/.
  }
qed ();



lemma "plus_assoc"
/
  forall m n p . (m + n) + p = m + (n + p) : nat
/;

inference.
intro /m n p/.
induction /m/.

{
reflexivity.
}

{
intro /m IH/.
compat.
hyp /IH/.
}
qed ();



lemma "plus_shift_r"
/
  forall m n .
    m + succ n = succ (m + n) : nat
/;

inference.
intro /m n/.
induction /m/.

{
reflexivity.
}

{
intro /m IH/.
compat.
hyp /IH/.
}
qed ();



lemma "plus_commute"
/
  forall m n .
    m + n = n + m : nat
/;

inference.
intro /m/.
induction /m/.

{
intro /n/.
symmetry.
apply /plus_0_r/.
}

{
intro /m IH n/.
rewrite /-> plus_shift_r/.
compat.
apply /IH/.
}
qed ();



lemma "plus_leq_l"
/
  forall m n . m <= m + n
/;

inference.
intro /m n/.
induction /m/.
  {
  apply /leq_0_min/.
  }
intro /m IH/.
apply /leq_succ_succ/.
hyp /IH/.
qed ();



lemma "plus_leq_r"
/
  forall m n . n <= m + n
/;

inference.
intro /m n/.
rewrite /-> plus_commute/.
apply /plus_leq_l/.
qed ();



lemma "plus_leq"
/
  forall m m' n n' .
    m <= m'
    -> n <= n'
    -> m + n <= m' + n'
/;

inference.
intro /m/.
induction /m/.
  {
  intro /m' n n' _ H/.
  apply /leq_trans _ n'/ >>> [hyp /H/, apply /plus_leq_r/].
  }
intro /m IH m' n n' Hm Hn/.
destruct /m'/ /| m'/.
  {
  so /leq_succ_0_not _ Hm/ /0/.
  }
reduce //.
apply /leq_succ_succ/.
apply /IH/ >>> [idtac, hyp /Hn/].
apply /leq_succ_invert/.
hyp /Hm/.
qed ();

val plus_leq = parseConstant /plus_leq/;



lemma "plus_lt_r"
/
  forall m n . 
    0 < n
    -> m < m + n
/;

inference.
intro /m n Hn/.
induction /m/.

{
hyp /Hn/.
}

{
intro /m IH/.
apply /lt_succ_succ/.
hyp /IH/.
}
qed ();



lemma "plus_minus_cancel_l"
/
  forall m n . m + n - m = n : nat
/;

inference.
intro /m n/.
induction /m/.

(* 0 *)
{
reflexivity.
}

(* succ *)
{
intro /m IH/.
hyp /IH/.
}
qed ();



lemma "plus_minus_cancel_r"
/
  forall m n . m + n - n = m : nat
/;

inference.
intro /m n/.
rewrite /-> plus_commute/.
apply /plus_minus_cancel_l/.
qed ();



lemma "plus_cancel_r"
/
  forall (m n p : nat) .
    m + p = n + p : nat
    -> m = n : nat
/;

intro /m n p Heq/.
rewrite /<- plus_minus_cancel_r m p/.
rewrite /<- plus_minus_cancel_r n p/.
compat.
hyp /Heq/.
qed ();



lemma "plus_cancel_l"
/
  forall (m n p : nat) .
    p + m = p + n : nat
    -> m = n : nat
/;

intro /m n p Heq/.
apply /plus_cancel_r _ _ p/.
rewrite /-> plus_commute at 0 1/.
hyp /Heq/.
qed ();



lemma "plus_cancel_l_eq"
/
  forall (m n p q : nat) .
    m + n = p + q : nat
    -> m = p : nat
    -> n = q : nat
/;

intro /m n p q Heq Hmp/.
subst /p/.
apply /plus_cancel_l/ >> auto.
qed ();



lemma "plus_cancel_r_eq"
/
  forall (m n p q : nat) .
    m + n = p + q : nat
    -> n = q : nat
    -> m = p : nat
/;

intro /m n p q Heq Hnq/.
subst /q/.
apply /plus_cancel_r/ >> auto.
qed ();



lemma "minus_plus_cancel"
/
  forall m n .
    n <= m
    -> m - n + n = m : nat
/;

inference.
intro /m n/.
revert /m/.
induction /n/.
  {
  intro /m _/.
  apply /plus_0_r/.
  }
intro /n IH m Hleq/.
destruct /m/ /| m/.
  {
  so /leq_succ_0_not _ Hleq/ /0/.
  }
reduce //.
rewrite /-> plus_shift_r/.
compat.
apply /IH/.
apply /leq_succ_invert/.
hyp /Hleq/.
qed ();



lemma "minus_0_l"
/
  forall n . 0 - n = 0 : nat
/;

inference.
intro /n/.
induction /n/.
  {
  reflexivity.
  }

  {
  intro /n IH/.
  hyp /IH/.
  }
qed ();



lemma "minus_0_r"
/
  forall n . n - 0 = n : nat
/;

inference.
intro /n/.
reflexivity.
qed ();



lemma "minus_proper"
/
  forall m n . m <= n -> m - n = 0 : nat
/;

inference.
intro /m/.
induction /m/.
  {
  intro /n _/.
  apply /minus_0_l/.
  }
intro /m IH n Hleq/.
destruct /n/ /| n/.
  {
  so /leq_succ_0_not m Hleq/ /0/.
  }
reduce //.
apply /IH/.
apply /leq_succ_invert/.
hyp /Hleq/.
qed ();



lemma "minus_assoc"
/
  forall m n p . (m - n) - p = m - (n + p) : nat
/;

inference.
intro /m n/.
revert /m/.
induction /n/.
  {
  intro /m p/.
  reflexivity.
  }
intro /n IH m p/.
destruct /m/ /| m/.
  {
  reduce //.
  rewrite /-> minus_0_l at all/.
  reflexivity.
  }
reduce //.
apply /IH/.
qed ();



lemma "minus_succ"
/
  forall m n . succ m - succ n = m - n : nat
/;

inference.
intro /m n/.
revert /m/.
induction /n/.
  {
  intro /m/.
  reflexivity.
  }
intro /n IH m/.
destruct /m/ /| m/.
  {
  reduce //.
  reflexivity.
  }
reduce //.
apply /IH/.
qed ();



lemma "pred_leq"
/
  forall n . pred n <= n
/;

inference.
intro /n/.
destruct /n/ /| n/.
  {
  reduce //.
  apply /leq_refl/.
  }

  {
  reduce //.
  apply /leq_succ/.
  }
qed ();



lemma "minus_leq_l"
/
  forall m n . m - n <= m
/;

inference.
intro /m n/.
revert /m/.
induction /n/.
  {
  intro /m/.
  apply /leq_refl/.
  }
intro /n IH m/.
destruct /m/ /| m/.
  {
  reduce //.
  rewrite /-> minus_0_l/.
  apply /leq_0_min/.
  }
reduce //.
apply /leq_trans _ m/.
  {
  apply /IH/.
  }

  {
  apply /leq_succ/.
  }
qed ();



lemma "minus_leq"
/
  forall m m' n n' .
    m <= m'
    -> n' <= n
    -> m - n <= m' - n'
/;

inference.
intro /m m' n/.
revert /m m'/.
induction /n/.
  {
  intro /m m' n' Hm Hn/.
  destruct /n'/ /| n'/.
    {
    hyp /Hm/.
    }

    {
    so /leq_succ_0_not _ Hn/ /0/.
    }
  }
intro /n IH m m' n' Hm Hn/.
destruct /m/ /| m/.
  {
  reduce //.
  rewrite /-> minus_0_l/.
  apply /leq_0_min/.
  }
reduce //.
destruct /n'/ /| n'/.
  {
  reduce //.
  apply /leq_trans _ (succ m)/ >>> [idtac, hyp /Hm/].
  apply /leq_trans _ m/ >>> [idtac, apply /leq_succ/].
  apply /minus_leq_l/.
  }
destruct /m'/ /| m'/.
  {
  so /leq_succ_0_not _ Hm/ /0/.
  }
reduce //.
apply /IH/.
  {
  apply /leq_succ_invert/.
  hyp /Hm/.
  }

  {
  apply /leq_succ_invert/.
  hyp /Hn/.
  }
qed ();

val minus_leq = parseConstant /minus_leq/;



lemma "plus_cancel_leq_r"
/
  forall m n p .
    m + p <= n + p
    -> m <= n
/;

inference.
intro /m n p Hleq/.
rewrite /<- plus_minus_cancel_r m p/.
rewrite /<- plus_minus_cancel_r n p/.
apply /minus_leq/ >> auto.
apply /leq_refl/.
qed ();



lemma "plus_cancel_leq_l"
/
  forall m n p .
    p + m <= p + n
    -> m <= n
/;

inference.
intro /m n p Hleq/.
rewrite /-> plus_commute in Hleq at 0 1/.
apply /plus_cancel_leq_r/ >> auto.
qed ();



lemma "plus_cancel_leq_leq_l"
/
  forall m m' n n' .
    m + n <= m' + n'
    -> m' <= m
    -> n <= n'
/;

inference.
intro /m m' n n' Hle Hlem/.
apply /plus_cancel_leq_l _ _ m/.
apply /leq_trans/ >> auto.
apply /plus_leq/ >> auto.
apply /leq_refl/.
qed ();



lemma "plus_cancel_leq_leq_r"
/
  forall m m' n n' .
    m + n <= m' + n'
    -> n' <= n
    -> m <= m'
/;

inference.
intro /m m' n n' Hle Hlem/.
rewrite /-> plus_commute in Hle at 0 1/.
apply /plus_cancel_leq_leq_l/ >> auto.
qed ();



lemma "minus_self"
/
  forall n . n - n = 0 : nat
/;

inference.
intro /n/.
apply /minus_proper/.
apply /leq_refl/.
qed ();



lemma "minus_succ_l_leq"
/
  forall m n . succ m - n <= succ (m - n)
/;

inference.
intro /m n/.
revert /m/.
induction /n/.
  {
  intro /m/.
  apply /leq_refl/.
  }
intro /n IH m/.
destruct /m/ /| m/.
  {
  reduce //.
  rewrite /-> minus_0_l/.
  apply /leq_0_min/.
  }
reduce //.
apply /IH/.
qed ();



lemma "minus_succ_l_eq"
/
  forall m n .
    n <= m
    -> succ m - n = succ (m - n) : nat
/;

inference.
intro /m n/.
revert /m/.
induction /n/.
  {
  intro /m _/.
  reflexivity.
  }
intro /n IH m Hleq/.
destruct /m/ /| m/.
  {
  so /leq_succ_0_not _ Hleq/ /0/.
  }
reduce //.
apply /IH/.
apply /leq_succ_invert/.
hyp /Hleq/.
qed ();



lemma "plus_minus_swap"
/
  forall m n p .
    p <= m
    -> m + n - p = m - p + n : nat
/;

inference.
intro /m n p Hpm/.
revert /m n Hpm/.
induction /p/.

(* 0 *)
{
intro /m n _/.
reflexivity.
}

(* succ *)
{
intro /p IH m n Hpm/.
destruct /m/ /| m/.
  {
  so /leq_succ_0_not _ Hpm/ /0/.
  }
reduce //.
apply /IH/.
apply /leq_succ_invert/.
auto.
}
qed ();



lemma "plus_minus_assoc"
/
  forall m n p .
    p <= n
    -> m + n - p = m + (n - p) : nat
/;

inference.
intro /m n p Hpn/.
rewrite /-> plus_commute/.
rewrite /-> plus_minus_swap/ >> auto.
rewrite /-> plus_commute/.
reflexivity.
qed ();



lemma "minus_swap"
/
  forall m n p . m - n - p = m - p - n : nat
/;

inference.
intro /m n p/.
rewrite /-> minus_assoc at all/.
rewrite /-> plus_commute/.
reflexivity.
qed ();



lemma "plus_minus_assoc_swap"
/
  forall m n p .
    n <= p
    -> m + n - p = m - (p - n) : nat
/;

inference.
intro /m n p Hnp/.
rewrite /-> plus_commute/.
revert /n Hnp/.
induction /p/.
  {
  intro /n Hn/.
  rewrite /-> minus_0_l/.
  rewrite /-> minus_0_r/.
  destruct /n/ /| n/.
    {
    reflexivity.
    }

    {
    so /leq_succ_0_not _ Hn/ /0/.
    }
  }
intro /p IH n Hnp/.
destruct /n/ /| n/.
  {
  reduce //.
  reflexivity.
  }
reduce //.
apply /IH/.
apply /leq_succ_invert/ >> auto.
qed ();



lemma "minus_plus_assoc"
/
  forall m n p . 
    p <= n 
    -> n <= m
    -> m - n + p = m - (n - p) : nat
/;

inference.
intro /m n p Hpn Hnm/.
rewrite /<- plus_minus_assoc_swap/ >> auto.
symmetry.
apply /plus_minus_swap/ >> auto.
qed ();



lemma "plus_compat"
/
  forall m m' n n' .
    m = m' : nat
    -> n = n' : nat
    -> m + n = m' + n' : nat
/;

inference.
intro /m m' n n' Hm Hn/.
compat >> auto.
qed ();



lemma "minus_compat"
/
  forall m m' n n' .
    m = m' : nat
    -> n = n' : nat
    -> m - n = m' - n' : nat
/;

inference.
intro /m m' n n' Hm Hn/.
compat >> auto.
qed ();



(* Multiplication *)

reductions
/
  times (zero) _ --> zero ;
  times (succ m) n --> plus n (times m n) ;
  unrolling times
/;



lemma "times_type"
/
  times : nat -> nat -> nat
/;

introOf /m n/.
sinduction /m/.
reintro /IH/.
destruct /m/ /| m/.
  {
  reduce //.
  typecheck.
  }
reduce //.
typecheck.
apply /IH/.
apply /lt_succ/.
qed ();
recordTyping "times_type";



lemma "times_0_l"
/
  forall (n : nat) . 0 * n = 0 : nat
/;

intro /n/.
reflexivity.
qed ();



lemma "times_0_r"
/
  forall n . n * 0 = 0 : nat
/;

inference.
intro /n/.
induction /n/.
  {
  reflexivity.
  }

  {
  intro /n IH/.
  hyp /IH/.
  }
qed ();



lemma "times_1_l"
/
  forall (n : nat) . 1 * n = n : nat
/;

intro /n/.
reduce //.
rewrite /-> plus_0_r/.
reflexivity.
qed ();



lemma "times_1_r"
/
  forall n . n * 1 = n : nat
/;

inference.
intro /n/.
induction /n/.
  {
  reflexivity.
  }
intro /n IH/.
compat.
hyp /IH/.
qed ();



lemma "times_dist_succ_r"
/
  forall m n . m * (succ n) = m + m * n : nat
/;

inference.
intro /m n/.
induction /m/.
  {
  reflexivity.
  }
intro /m IH/.
compat.
rewrite /-> IH/.
rewrite /<- plus_assoc at all/.
rewrite /-> plus_commute at 1/.
reflexivity.
qed ();



lemma "times_commute"
/
  forall m n . m * n = n * m : nat
/;

inference.
intro /m n/.
induction /m/.

(* 0 *)
{
rewrite /-> times_0_r/.
reflexivity.
}

(* succ *)
{
intro /m IH/.
rewrite /-> times_dist_succ_r/.
rewrite /-> IH/.
reflexivity.
}
qed ();



lemma "times_dist_plus_l"
/
  forall m n p . (m + n) * p = m * p + n * p : nat
/;

inference.
intro /m n p/.
induction /m/.
  {
  reflexivity.
  }
intro /m IH/.
rewrite /-> plus_assoc/.
compat.
hyp /IH/.
qed ();




lemma "times_dist_plus_r"
/
  forall m n p . m * (n + p) = m * n + m * p : nat
/;

inference.
intro /m n p/.
rewrite /-> times_commute at 0 1 2/.
apply /times_dist_plus_l/.
qed ();



lemma "times_assoc"
/
  forall m n p . (m * n) * p = m * (n * p) : nat
/;

inference.
intro /m n p/.
induction /m/.

(* 0 *)
{
reflexivity.
}

(* succ *)
{
intro /m IH/.
rewrite /-> times_dist_plus_l/.
rewrite /-> IH/.
reflexivity.
}
qed ();



lemma "times_compat"
/
  forall m m' n n' .
    m = m' : nat
    -> n = n' : nat
    -> m * n = m' * n' : nat
/;

inference.
intro /m m' n n' Hm Hn/.
compat >> auto.
qed ();



lemma "times_leq"
/
  forall m m' n n' .
    m <= m'
    -> n <= n'
    -> m * n <= m' * n'
/;

inference.
intro /m/.
induction /m/.
  {
  intro /m' n n' _ _/.
  apply /leq_0_min/.
  }
intro /m IH m' n n' Hmm Hn/.
destruct /m'/ /| m'/.
  {
  so /leq_succ_0_not _ Hmm/ /0/.
  }
so /leq_succ_invert _ _ Hmm/ /Hm/.
reduce //.
apply /plus_leq/ >> auto.
qed ();

val times_leq = parseConstant /times_leq/;



lemma "times_dist_pred_l"
/
  forall m n . pred m * n = m * n - n : nat
/;

inference.
intro /m p/.
destruct /m/ /| m/.
  {
  reduce //.
  rewrite /-> minus_0_l/.
  reflexivity.
  }
reduce //.
rewrite /-> plus_commute/.
rewrite /-> plus_minus_cancel_r/.
reflexivity.
qed ();



lemma "times_dist_pred_r"
/
  forall m n . m * pred n = m * n - m : nat
/;

inference.
intro /m n/.
rewrite /-> times_commute at 0 1/.
apply /times_dist_pred_l/.
qed ();



lemma "times_dist_minus_l"
/
  forall m n p . (m - n) * p = m * p - n * p : nat
/;

inference.
intro /m n p/.
revert /m/.
induction /n/.
  {
  intro /m/.
  reflexivity.
  }
intro /n IH m/.
rewrite /-> IH/.
rewrite /-> times_dist_pred_l/.
apply /minus_assoc/.
qed ();



lemma "times_dist_minus_r"
/
  forall m n p . m * (n - p) = m * n - m * p : nat
/;

inference.
intro /m n p/.
rewrite /-> times_commute at 0 1 2/.
apply /times_dist_minus_l/.
qed ();



lemma "nat_integral_domain"
/
  forall m n . 
    m * n = 0 : nat 
    -> m = 0 : nat % n = 0 : nat
/;

inference.
intro /m n Heq/.
destruct /m/ /| m/.
  {
  left >> auto.
  }
destruct /n/ /| n/.
  {
  right >> auto.
  }
reduce /Heq/.
symmetryIn /Heq/.
so /eq_0_succ_not _ Heq/ /0/.
qed ();



(* Minimum *)

definerec /min m n/
/
  nat_case m
    0
    (fn m' .
       nat_case n
         0
         (fn n' . succ (min m' n')))
//
  nat -> nat -> nat
/;

introOf /m n/.
revert /n/.
sinduction /m/.
reintro /IH/.
destruct /m/ /| m/.

(* 0 *)
{
intro /n/.
unroll /min/.
reduce //.
typecheck.
}

(* succ *)
{
intro /n/.
destruct /n/ /| n/.
  {
  unroll /min/.
  reduce //.
  typecheck.
  }
unroll /min/.
reduce //.
typecheck1.
apply /IH/.
apply /lt_succ/.
}
qed ();

val min = parseConstant /min/;



lemma "min_commute"
/
  forall m n . min m n = min n m : nat
/;

inference.
intro /m/.
induction /m/.
  {
  intro /n/.
  unroll /min at 0 1/.
  reduce //.
  destruct /n/ /| n/ >> reduce // >> auto.
  }
intro /m IH n/.
destruct /n/ /| n/.
  {
  unroll /min at 0 1/.
  reduce //.
  auto.
  }
unroll /min at 0 1/.
reduce //.
compat.
apply /IH/.
qed ();



lemma "min_assoc"
/
  forall m n p . min (min m n) p = min m (min n p) : nat
/;

inference.
intro /m/.
induction /m/.
  {
  intro /n p/.
  unroll /min at 1 0 2/.
  reduce //.
  reflexivity.
  }
intro /m IH n p/.
destruct /n/ /| n/.
  {
  unroll /min at 1 0 3 2/.
  reduce //.
  reflexivity.
  }
unroll /min at 1 0 3 2/.
reduce //.
destruct /p/ /| p/ >> reduce // >> auto.
qed ();



lemma "min_ann_l"
/
  forall n . min 0 n = 0 : nat
/;

inference.
intro /n/.
unroll /min/ >> reduce //.
reflexivity.
qed ();



lemma "min_ann_r"
/
  forall n . min n 0 = 0 : nat
/;

inference.
intro /n/.
unroll /min/.
destruct /n/ /| n/ >> reduce // >> reflexivity.
qed ();



lemma "min_succ"
/
  forall m n . min (succ m) (succ n) = succ (min m n) : nat
/;

inference.
intro /m n/.
unroll /min/ >> reduce //.
reflexivity.
qed ();



lemma "min_leq_l"
/
  forall m n . min m n <= m
/;

inference.
intro /m/.
induction /m/.

(* zero *)
{
intro /n/.
rewrite /-> min_ann_l/.
apply /leq_0_min/.
}

(* succ *)
{
intro /m IH n/.
destruct /n/ /| n/.
  {
  rewrite /-> min_ann_r/.
  apply /leq_0_min/.
  }
rewrite /-> min_succ/.
apply /leq_succ_succ/.
apply /IH/.
}
qed ();



lemma "min_leq_r"
/
  forall m n . min m n <= n
/;

inference.
intro /m n/.
rewrite /-> min_commute/.
apply /min_leq_l/.
qed ();



lemma "min_glb"
/
  forall m n p .
    p <= m
    -> p <= n
    -> p <= min m n
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p Hmp _/.
rewrite /-> min_ann_l/.
hyp /Hmp/.
}

(* succ *)
{
intro /m IH n p Hmp Hnp/.
destruct /n/ /| n/.
  {
  rewrite /-> min_ann_r/.
  hyp /Hnp/.
  }
destruct /p/ /| p/.
  {
  apply /leq_0_min/.
  }
rewrite /-> min_succ/.
apply /leq_succ_succ/.
apply /IH/.
  {
  apply /leq_succ_invert/.
  hyp /Hmp/.
  }

  {
  apply /leq_succ_invert/.
  hyp /Hnp/.
  }
}
qed ();



lemma "min_leq"
/
  forall m m' n n' .
    m <= m'
    -> n <= n'
    -> min m n <= min m' n'
/;

inference.
intro /m m' n n' Hm Hn/.
apply /min_glb/ >> autoWith /min_leq_l min_leq_r leq_trans/.
qed ();

val min_leq = parseConstant /min_leq/;



lemma "min_eq_r"
/
  forall m n .
    n <= m
    -> min m n = n : nat
/;

inference.
intro /m n Hnm/.
apply /leq_antisymm/.
  {
  apply /min_leq_r/.
  }

  {
  apply /min_glb/.
    {
    hyp /Hnm/.
    }

    {
    apply /leq_refl/.
    }
  }
qed ();



lemma "min_eq_l"
/
  forall m n .
    m <= n
    -> min m n = m : nat
/;

inference.
intro /m n Hmn/.
rewrite /-> min_commute/.
apply /min_eq_r/ >> auto.
qed ();



lemma "min_idem"
/
  forall n . min n n = n : nat
/;

inference.
intro /n/.
apply /min_eq_l/.
apply /leq_refl/.
qed ();



lemma "plus_dist_min_r"
/
  forall m n p . m + min n p = min (m + n) (m + p) : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p/.
reflexivity.
}

(* succ *)
{
intro /m IH n p/.
rewrite /-> min_succ/.
compat.
apply /IH/.
}
qed ();



lemma "plus_dist_min_l"
/
  forall m n p . min m n + p = min (m + p) (n + p) : nat
/;

inference.
intro /m n p/.
rewrite /-> plus_commute at 0 1 2/.
apply /plus_dist_min_r/.
qed ();



(* Maximum *)

definerec /max m n/
/
  nat_case m
    n
    (fn m' .
       nat_case n
         m
         (fn n' . succ (max m' n')))
//
  nat -> nat -> nat
/;

introOf /m n/.
revert /n/.
sinduction /m/.
reintro /IH/.
destruct /m/ /| m/.

(* 0 *)
{
intro /n/.
unroll /max/.
reduce //.
hypof.
}

(* succ *)
{
intro /n/.
destruct /n/ /| n/.
  {
  unroll /max/.
  reduce //.
  typecheck.
  }
unroll /max/.
reduce //.
typecheck1.
apply /IH/.
apply /lt_succ/.
}
qed ();

val max = parseConstant /max/;



lemma "max_id_l"
/
  forall n . max 0 n = n : nat
/;

inference.
intro /n/.
unroll /max/ >> reduce //.
reflexivity.
qed ();



lemma "max_id_r"
/
  forall n . max n 0 = n : nat
/;

inference.
intro /n/.
unroll /max/.
destruct /n/ /| n/ >> reduce // >> reflexivity.
qed ();



lemma "max_succ"
/
  forall m n . max (succ m) (succ n) = succ (max m n) : nat
/;

inference.
intro /m n/.
unroll /max/ >> reduce //.
reflexivity.
qed ();



lemma "max_commute"
/
  forall m n . max m n = max n m : nat
/;

inference.
intro /m/.
induction /m/.
  {
  intro /n/.
  unroll /max at 0 1/.
  reduce //.
  destruct /n/ /| n/ >> reduce // >> auto.
  }
intro /m IH n/.
destruct /n/ /| n/.
  {
  unroll /max at 0 1/.
  reduce //.
  auto.
  }
unroll /max at 0 1/.
reduce //.
compat.
apply /IH/.
qed ();



lemma "max_assoc"
/
  forall m n p . max (max m n) p = max m (max n p) : nat
/;

inference.
intro /m/.
induction /m/.
  {
  intro /n p/.
  unroll /max at 3 0/.
  unroll /max at 3 0/.
  destruct /n/ /| n/.
    {
    reduce //.
    reflexivity.
    }
  destruct /p/ /| p/.
    {
    reduce //.
    unroll /max/.
    reduce //.
    reflexivity.
    }
  reduce //.
  reflexivity.
  }
intro /m IH n p/.
destruct /n/ /| n/.
  {
  unroll /max at 3 0 3 0/.
  destruct /p/ /| p/.
    {
    reduce //.
    unroll /max/ >> reduce //.
    reflexivity.
    }
  reduce //.
  reflexivity.
  }
unroll /max at 3 0 3 0/.
reduce //.
destruct /p/ /| p/ >> reduce // >> auto.
apply /max_succ/.
qed ();



lemma "max_leq_l"
/
  forall m n . m <= max m n
/;

inference.
intro /m/.
induction /m/.

(* zero *)
{
intro /n/.
rewrite /-> max_id_l/.
apply /leq_0_min/.
}

(* succ *)
{
intro /m IH n/.
destruct /n/ /| n/.
  {
  rewrite /-> max_id_r/.
  apply /leq_refl/.
  }
rewrite /-> max_succ/.
apply /leq_succ_succ/.
apply /IH/.
}
qed ();



lemma "max_leq_r"
/
  forall m n . n <= max m n
/;

inference.
intro /m n/.
revert /m/.
induction /n/.

(* zero *)
{
intro /m/.
rewrite /-> max_id_r/.
apply /leq_0_min/.
}

(* succ *)
{
intro /n IH m/.
destruct /m/ /| m/.
  {
  rewrite /-> max_id_l/.
  apply /leq_refl/.
  }
rewrite /-> max_succ/.
apply /leq_succ_succ/.
apply /IH/.
}
qed ();



lemma "max_lub"
/
  forall m n p .
    m <= p
    -> n <= p
    -> max m n <= p
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p _ Hnp/.
rewrite /-> max_id_l/.
hyp /Hnp/.
}

(* succ *)
{
intro /m IH n p Hmp Hnp/.
destruct /n/ /| n/.
  {
  rewrite /-> max_id_r/.
  hyp /Hmp/.
  }
destruct /p/ /| p/.
  {
  so /leq_succ_0_not _ Hmp/ /0/.
  }
rewrite /-> max_succ/.
apply /leq_succ_succ/.
apply /IH/.
  {
  apply /leq_succ_invert/.
  hyp /Hmp/.
  }

  {
  apply /leq_succ_invert/.
  hyp /Hnp/.
  }
}
qed ();



lemma "max_leq"
/
  forall m m' n n' .
    m <= m'
    -> n <= n'
    -> max m n <= max m' n'
/;

inference.
intro /m m' n n' Hm Hn/.
apply /max_lub/ >> autoWith /max_leq_l max_leq_r leq_trans/.
qed ();

val max_leq = parseConstant /max_leq/;



lemma "max_eq_l"
/
  forall m n .
    n <= m
    -> max m n = m : nat
/;

inference.
intro /m n Hnm/.
apply /leq_antisymm/.
  {
  apply /max_lub/.
    {
    apply /leq_refl/.
    }

    {
    hyp /Hnm/.
    }
  }

  {
  apply /max_leq_l/.
  }
qed ();



lemma "max_eq_r"
/
  forall m n .
    m <= n
    -> max m n = n : nat
/;

inference.
intro /m n Hmn/.
apply /leq_antisymm/.
  {
  apply /max_lub/.
    {
    hyp /Hmn/.
    }

    {
    apply /leq_refl/.
    }
  }

  {
  apply /max_leq_r/.
  }
qed ();



lemma "max_idem"
/
  forall n . max n n = n : nat
/;

inference.
intro /n/.
apply /max_eq_l/.
apply /leq_refl/.
qed ();



lemma "min_dist_max_r"
/
  forall m n p . min m (max n p) = max (min m n) (min m p) : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p/.
rewrite /-> min_ann_l at all/.
rewrite /-> max_id_l/.
reflexivity.
}

(* succ *)
{
intro /m IH n p/.
destruct /n/ /| n/.
  {
  rewrite /-> min_ann_r/.
  rewrite /-> max_id_l at all/.
  reflexivity.
  }
destruct /p/ /| p/.
  {
  rewrite /-> min_ann_r/.
  rewrite /-> max_id_r at all/.
  reflexivity.
  }
rewrite /-> max_succ/.
rewrite /-> min_succ at all/.
rewrite /-> max_succ/.
compat.
apply /IH/.
}
qed ();



lemma "min_dist_max_l"
/
  forall m n p . min (max m n) p = max (min m p) (min n p) : nat
/;

inference.
intro /m n p/.
rewrite /-> min_commute at 0 1 2/.
apply /min_dist_max_r/.
qed ();



lemma "min_max_same"
/
  forall m n . min m (max m n) = m : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n/.
apply /min_ann_l/.
}

(* succ *)
{
intro /m IH n/.
destruct /n/ /| n/.
  {
  rewrite /-> max_id_r/.
  apply /min_idem/.
  }
rewrite /-> max_succ , -> min_succ/.
compat.
apply /IH/.
}
qed ();



lemma "max_min_same"
/
  forall m n . max m (min m n) = m : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n/.
rewrite /-> min_ann_l/.
apply /max_idem/.
}

(* succ *)
{
intro /m IH n/.
destruct /n/ /| n/.
  {
  rewrite /-> min_ann_r/.
  rewrite /-> max_id_r/.
  reflexivity.
  }
rewrite /-> min_succ , -> max_succ/.
compat.
apply /IH/.
}
qed ();



lemma "max_dist_min_r"
/
  forall m n p . max m (min n p) = min (max m n) (max m p) : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p/.
rewrite /-> max_id_l at all/.
reflexivity.
}

(* succ *)
{
intro /m IH n p/.
destruct /n/ /| n/.
  {
  rewrite /-> min_ann_l/.
  rewrite /-> max_id_r at all/.
  destruct /p/ /| p/.
    {
    rewrite /-> max_id_r/.
    rewrite /-> min_idem/.
    reflexivity.
    }
  rewrite /-> max_succ/.
  rewrite /-> min_succ/.
  compat.
  symmetry.
  apply /min_max_same/.
  }
destruct /p/ /| p/.
  {
  rewrite /-> min_ann_r/.
  rewrite /-> max_id_r at all/.
  rewrite /-> min_commute/.
  symmetry.
  apply /min_max_same/.
  }
rewrite /-> min_succ/.
rewrite /-> max_succ at all/.
rewrite /-> min_succ/.
compat.
apply /IH/.
}
qed ();



lemma "max_dist_min_l"
/
  forall m n p . max (min m n) p = min (max m p) (max n p) : nat
/;

inference.
intro /m n p/.
rewrite /-> max_commute at 0 1 2/.
apply /max_dist_min_r/.
qed ();



lemma "plus_dist_max_r"
/
  forall m n p . m + max n p = max (m + n) (m + p) : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /n p/.
reflexivity.
}

(* succ *)
{
intro /m IH n p/.
rewrite /-> max_succ/.
compat.
apply /IH/.
}
qed ();



lemma "plus_dist_max_l"
/
  forall m n p . max m n + p = max (m + p) (n + p) : nat
/;

inference.
intro /m n p/.
rewrite /-> plus_commute at 0 1 2/.
apply /plus_dist_max_r/.
qed ();




(* Effective comparisons *)

(* Built-in:

definerec /eqb m n/
/
  nat_case m
    (nat_case n true (fn _ . false))
    (fn m' . nat_case n false (fn n' . eqb m' n'))
//
  nat -> nat -> bool
/;
*)

Namespace.aliasExport (parseIdent /eqb/) Prim.eqb;


Database.setUnroll Prim.eqb
  (Reduction.trans
     [DefineInternal.recUnroller Prim.eqb,
      Reduction.beta 2]);



(* Built-in:

definerec /leqb m n/
/
  nat_case m
    true
    (fn m' . nat_case n false (fn n' . leqb m' n'))
//
  nat -> nat -> bool
/;
*)

Namespace.aliasExport (parseIdent /leqb/) Prim.leqb;

Database.setUnroll Prim.leqb
  (Reduction.trans
     [DefineInternal.recUnroller Prim.leqb,
      Reduction.beta 2]);



lemma "eqb_type"
/
  eqb : nat -> nat -> bool
/;

introOf /m n/.
revert /n/.
sinduction /m/.
reintro /IH/.
intro /n/.
destruct /m/ /| m/.
  {
  unroll /eqb/.
  reduce //.
  typecheck.
  }

  {
  unroll /eqb/.
  reduce //.
  typecheck.
  apply /IH/.
  apply /lt_succ/.
  }
qed ();
Define.recordTyping "eqb_type";



lemma "istrue_eqb"
/
  forall m n .
    istrue (eqb m n) <-> m = n : nat
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /(| n)/.
  {
  split.
    {
    intro /_/.
    reflexivity.
    }

    {
    intro /_/.
    unroll /eqb/.
    reduce //.
    apply /istrue_true/.
    }
  }

  {
  split.
    {
    intro /H/.
    unroll /eqb in H/ >> reduce /H/.
    so /not_istrue_false __/ /0/.
    auto.
    }

    {
    intro /H/.
    injection /H/.
    }
  }
}

(* succ *)
{
intro /m IH (| n)/.
  {
  split.
    {
    intro /H/.
    unroll /eqb in H/ >> reduce /H/.
    so /not_istrue_false H/ /0/.
    }

    {
    intro /H/.
    injection /H/.
    }
  }

  {
  unroll /eqb/ >> reduce //.
  split.
    {
    intro /H/.
    compat.
    exact /IH _ #1 H/.
    }

    {
    intro /H/.
    injection /H/.
    reintro /H'/.
    exact /IH _ #2 H'/.
    }
  }
}
qed ();

val istrue_eqb = parseConstant /istrue_eqb/;



lemma "leqb_type"
/
  leqb : nat -> nat -> bool
/;

introOf /m n/.
revert /n/.
sinduction /m/.
reintro /IH/.
intro /n/.
destruct /m/ /| m/.
  {
  unroll /leqb/.
  reduce //.
  typecheck.
  }

  {
  unroll /leqb/.
  reduce //.
  typecheck.
  apply /IH/.
  apply /lt_succ/.
  }
qed ();
Define.recordTyping "leqb_type";



lemma "istrue_leqb"
/
  forall m n .
    istrue (leqb m n) <-> m <= n
/;

inference.
intro /m/.
induction /m/.

(* 0 *)
{
intro /(| n)/.
  {
  split.
    {
    intro /_/.
    apply /leq_refl/.
    }

    {
    intro /_/.
    unroll /leqb/ >> reduce //.
    apply /istrue_true/.
    }
  }

  {
  split.
    {
    intro /_/.
    apply /leq_0_min/.
    }

    {
    intro /_/.
    unroll /leqb/ >> reduce //.
    apply /istrue_true/.
    }
  }
}

(* succ *)
{
intro /m IH (| n)/.
  {
  split.
    {
    intro /H/.
    unroll /leqb in H/ >> reduce /H/.
    so /not_istrue_false H/ /0/.
    }

    {
    intro /H/.
    so /leq_succ_0_not _ H/ /0/.
    }
  }

  {
  unroll /leqb/ >> reduce //.
  split.
    {
    intro /H/.
    apply /leq_succ_succ/.
    exact /IH _ #1 H/.
    }

    {
    intro /H/.
    so /leq_succ_invert _ _ H/ /H'/.
    exact /IH _ #2 H'/.
    }
  }
}
qed ();

val istrue_leqb = parseConstant /istrue_leqb/;



define /ltb m n/
/
  leqb (succ m) n
//
  nat -> nat -> bool
/;

introOf /m n/.
unfold /ltb/.
typecheck.
qed ();

val ltb = parseConstant /ltb/;



lemma "istrue_ltb"
/
  forall m n .
    istrue (ltb m n) <-> m < n
/;

inference.
intro /m n/.
unfold /ltb , lt/.
apply /istrue_leqb/.
qed ();

val istrue_ltb = parseConstant /istrue_ltb/;



define /neqb m n/
/
  notb (eqb m n)
//
  nat -> nat -> bool
/;

introOf /m n/.
unfold /neqb/.
typecheck.
qed ();

val neqb = parseConstant /neqb/;



lemma "istrue_neqb"
/
  forall m n .
    istrue (neqb m n) <-> m != n : nat
/;

inference.
intro /m n/.
unfold /neqb , neq/.
rewrite /-> istrue_notb/.
rewrite /-> istrue_eqb/.
reflexivity.
qed ();

val istrue_neqb = parseConstant /istrue_neqb/;



writeRegistry /AfterIstrueNeqbEnv/
  /[constant constant constant constant constant constant]/
  (Collapse (ltb, neqb, istrue_eqb, istrue_leqb, istrue_ltb, istrue_neqb));
structure Nothing = AfterIstrueNeqb ();



lemma "notb_eqb"
/
  forall m n . notb (eqb m n) = neqb m n : bool
/;

inference.
intro /m n/.
unfold /neqb/.
reflexivity.
qed ();



lemma "notb_neqb"
/
  forall m n . notb (neqb m n) = eqb m n : bool
/;

inference.
intro /m n/.
unfold /neqb/.
apply /notb_invol/.
qed ();



lemma "notb_leqb"
/
  forall m n . notb (leqb m n) = ltb n m : bool
/;

inference.
intro /m n/.
apply /iff_eq_bool/.
rewrite /-> istrue_notb , -> istrue_leqb , -> istrue_ltb/.
apply /not_leq/.
qed ();



lemma "notb_ltb"
/
  forall m n . notb (ltb m n) = leqb n m : bool
/;

inference.
intro /m n/.
rewrite /<- notb_leqb/.
apply /notb_invol/.
qed ();



(* Decidability *)

lemma "eq_nat_decide"
/
  forall (m n : nat) . Decidable.decidable (m = n : nat)
/;

intro /m n/.
apply /Decidable.decidable_from_bool _ _ (eqb m n)/.
apply /istrue_eqb/.
qed ();



lemma "neq_nat_decide"
/
  forall (m n : nat) . Decidable.decidable (m != n : nat)
/;

intro /m n/.
unfold /neq/.
apply /Decidable.decidable_not/.
apply /Decidable.decidable_from_bool _ _ (eqb m n)/.
apply /istrue_eqb/.
qed ();



lemma "leq_decide"
/
  forall (m n : nat) . Decidable.decidable (m <= n)
/;

intro /m n/.
apply /Decidable.decidable_from_bool _ _ (leqb m n)/.
apply /istrue_leqb/.
qed ();

  

lemma "lt_decide"
/
  forall (m n : nat) . Decidable.decidable (m < n)
/;

intro /m n/.
apply /Decidable.decidable_from_bool _ _ (ltb m n)/.
apply /istrue_ltb/.
qed ();



lemma "eq_nat_stable"
/
  forall (m n : nat) . Stable.stable (m = n : nat)
/;

intro /m n/.
apply /Stable.decidable_impl_stable/.
apply /eq_nat_decide/.
qed ();
  


lemma "neq_nat_stable"
/
  forall (m n : nat) . Stable.stable (m != n : nat)
/;

intro /m n/.
apply /Stable.decidable_impl_stable/.
apply /neq_nat_decide/.
qed ();



lemma "leq_stable"
/
  forall (m n : nat) . Stable.stable (m <= n)
/;

intro /m n/.
apply /Stable.decidable_impl_stable/.
apply /leq_decide/.
qed ();
  


lemma "lt_stable"
/
  forall (m n : nat) . Stable.stable (m < n)
/;

intro /m n/.
apply /Stable.decidable_impl_stable/.
apply /lt_decide/.
qed ();
  


lemma "leq_iff_lt_or_eq"
/
  forall m n . m <= n <-> m < n % m = n : nat
/;

inference.
intro /m n/.
split.
  {
  intro /Hleq/.
  so /eq_nat_decide m n/ /Heq | Hneq/ >> auto.
  left.
  apply /lt_from_leq_neq/ >> auto.
  }

  {
  intro /(Hlt | Heq)/.
    {
    apply /lt_impl_leq/ >> auto.
    }

    {
    apply /leq_refl_eq/ >> auto.
    }
  }
qed ();



lemma "nat_trichotomy"
/
  forall (m n : nat) . m < n % m = n : nat % n < m
/;

intro /m n/.
setEq /b/ /eqb m n/ /bool/ /Heq/.
symmetryIn /Heq/.
destruct /b/ /|/.
  {
  rewrite /<- Bool.istrue_iff_eq_true in Heq/.
  rewrite /-> istrue_eqb in Heq/.
  right >> left.
  hyp /Heq/.
  }
rewrite /<- Bool.not_istrue_iff_eq_false in Heq/.
rewrite /-> istrue_eqb in Heq/.
setEq /b/ /ltb m n/ /bool/ /Hlt/.
symmetryIn /Hlt/.
destruct /b/ /|/.
  {
  rewrite /<- Bool.istrue_iff_eq_true in Hlt/.
  rewrite /-> istrue_ltb in Hlt/.
  left.
  hyp /Hlt/.
  }
rewrite /<- Bool.not_istrue_iff_eq_false in Hlt/.
rewrite /-> istrue_ltb in Hlt/.
right >> right.
rewrite /-> not_lt in Hlt/.
apply /lt_from_leq_neq/ >> auto.
intro /H/ >> witness /Heq __/.
symmetry.
auto.
qed ();



lemma "nat_dichotomy"
/
  forall (m n : nat) . m <= n % n < m
/;

intro /m n/.
so /nat_trichotomy m n/ /H | H | H/.
  {
  left.
  apply /lt_impl_leq/ >> auto.
  }

  {
  left.
  apply /leq_refl_eq/ >> auto.
  }

  {
  right.
  auto.
  }
qed ();



lemma "nat_dichotomy_weak"
/
  forall (m n : nat) . m <= n % n <= m
/;

intro /m n/.
so /nat_dichotomy m n/ /Hmn | Hnm/ >> autoWith /lt_impl_leq/.
qed ();



lemma "nat_dichotomy_neq"
/
  forall (m n : nat) .
    m != n : nat
    -> m < n % n < m
/;

intro /m n Hneq/.
so /nat_trichotomy m n/ /H | H | H/ >> auto.
so /Hneq __/ /0/.
hyp /H/.
qed ();



writeRegistry /AfterNatAllEnv/
  /[constant constant constant constant constant constant constant constant constant constant constant constant constant constant constant]/
  (Collapse (nat_iter, leq, lt, minus, min, max, leq_refl, leq_trans, leq_succ_succ, plus_leq, minus_leq, times_leq, min_leq, max_leq, leq_implication));


endModule ();
