
structure ParseLogic =
   struct

      structure T = ETerm

      val not = Susp.delay (fn () => parseConstant /Logic.not/)
      val iff = Susp.delay (fn () => parseConstant /Logic.iff/)
      val neq = Susp.delay (fn () => parseConstant /Logic.neq/)

      fun parseNot p = T.apply1 (Susp.force not) p
      fun parseIff p q = T.apply2 (Susp.force iff) p q
      fun parseNeq m n a = T.apply3 (Susp.force neq) a m n

   end


grammardef Logic

   open ParseLogic

   rule Term(5)  ::= Term(6) "<->" Term(6) => parseIff
   rule Term(30) ::= Term(31) "<>" Term(31) ":" Term(31) => parseNeq

end

grammaron Logic



functor AfterIff () :> sig end =
   struct

      structure B = BackchainInternal
      structure H = ConstantTable
      structure T = Term

      val not = parseConstant /Logic.not/
      val iff = parseConstant /Logic.iff/

      structure U = Show.Unparsing

      fun register k arity prec unp =
         ConstantTable.insert U.unparsingTable k (arity, prec, ref true, unp)


      val () =
         register iff 2 5
         (U.wrap
             (U.apply2 iff U.show U.show)
             (fn (p, q) => U.append [p 6, U.break 1, U.string "<-> ", q 6]))


      val () =
         ConstantTable.insert TypecheckInternal.semitrivialIntroTactics not
            (Term.Lam (NONE, Term.Triv), Backchain.applyPriority /Logic.not_inhabitant/);

      val () =
         H.insert EqualityTacticInternal.reflexivityTactics iff
         (B.witnessPriority /Logic.iff_refl _ _/)
      
      val () =
         H.insert EqualityTacticInternal.symmetryTactics iff
         (andthenOn 0 (B.witnessPriority /Logic.iff_symm _ _ _ __/))

      val () =
         H.insert EqualityTacticInternal.transitivityTactics iff
         (fn n => B.witnessPriority /Logic.iff_trans _ _ \n\ _ __ __/)

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (iff, 0, iff)
            (iff, true, andthenOn 0 (B.witnessPriority /Logic.iff_compat_1 _ _ _ _ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (iff, 1, iff)
            (iff, true, andthenOn 0 (B.witnessPriority /Logic.iff_compat_2 _ _ _ _ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (not, 0, Prim.arrow)
            (Prim.arrow, false, andthenOn 0 (B.witnessPriority /Logic.not_compat_arrow _ _ _ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (not, 0, iff)
            (iff, true, andthenOn 0 (B.witnessPriority /Logic.not_compat_iff _ _ _ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (Prim.prod, 0, iff)
            (iff, true, andthenOn 0 (Backchain.witnessPriority /prod_compat_iff _# 5 __ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (Prim.prod, 1, iff)
            (iff, true, andthenOn 1 (Backchain.witnessPriority /prod_compat_iff _# 5 __ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (Prim.sum, 0, iff)
            (iff, true, andthenOn 0 (Backchain.witnessPriority /sum_compat_iff _# 5 __ __/))

      val () =
         RewriteInternal.CICTable.insert 
            RewriteInternal.compatibilityTable
            (Prim.sum, 1, iff)
            (iff, true, andthenOn 1 (Backchain.witnessPriority /sum_compat_iff _# 5 __ __/))


            
         
      open Tactic


      fun weakenIffArrow tac =
         goalCaseT
         / \Prim.arrow\ ? ? =>
           \(fnc a b =>
                (* A -> B *)
                refine (Rule.prodElim1 (T.evar ()) (T.apply2 Prim.arrow b a))
                >>
                (* (A -> B) & (B -> A) *)
                refine (Rule.unreduce (T.apply2 iff a b) Reduction.unfold)
                >>
                tac)\
         /

      fun weakenIffArrowContra tac =
         goalCaseT
         / \Prim.arrow\ ? ? =>
           \(fnc b a =>
                (* B -> A *)
                refine (Rule.prodElim2 (T.apply2 Prim.arrow a b) (T.evar ()))
                >>
                (* (A -> B) & (B -> A) *)
                refine (Rule.unreduce (T.apply2 iff a b) Reduction.unfold)
                >>
                tac)\
         /


      val () = 
         List.app
            (fn (const, const', cov, f) =>
                H.insertMerge RewriteInternal.weakeningTable const 
                   [(const', cov, f)]
                   (fn l => (const', cov, f) :: l))
            [
            (iff, Prim.arrow, true, weakenIffArrow),
            (iff, Prim.arrow, false, weakenIffArrowContra)
            ]

   end


functor AfterNeq () :> sig end =
   struct

      structure U = Show.Unparsing

      val neq = parseConstant /Logic.neq/

      fun register k arity prec unp =
         ConstantTable.insert U.unparsingTable k (arity, prec, ref true, unp)

      val () =
         register neq 3 30
         (U.wrap
             (U.apply3 neq U.show U.show U.show)
             (fn (a, m, n) => U.append [m 31, 
                                        U.break 1, U.string "<> ", n 31, 
                                        U.break 1, U.string ": ", a 31]))

   end
