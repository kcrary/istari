
Ctrl.use "logic-load.iml";
Ctrl.use "bool-load.iml";
Ctrl.use "nat-load.iml";
Ctrl.use "nat-eff-aux.iml";


Namespace.beginModule "NatEff";


Namespace.openModule (parseLongident /Bool/);
Namespace.openModule (parseLongident /Nat/);



(* Built-in:

definerec /eqb m n/
/
  natcase m
    (natcase n true (fn _ . false))
    (fn m' . natcase n false (fn n' . eqb m' n'))
//
  nat -> nat -> bool
/;
*)

Namespace.alias (parseIdent /eqb/) Prim.eqb;

Database.setUnroll Prim.eqb
  (Reduction.trans
     [DefineInternal.recUnroller Prim.eqb,
      Reduction.beta 2]);



(* Built-in:

definerec /leqb m n/
/
  natcase m
    true
    (fn m' . natcase n false (fn n' . leqb m' n'))
//
  nat -> nat -> bool
/;
*)

Namespace.alias (parseIdent /leqb/) Prim.leqb;

Database.setUnroll Prim.leqb
  (Reduction.trans
     [DefineInternal.recUnroller Prim.leqb,
      Reduction.beta 2]);



structure Nothing = AfterLeqb ();



lemma "eqb_type"
/
  eqb : nat -> nat -> bool
/;

introOf /m n/.
revert /n/.
induct /m/.
reintro /IH/.
intro /n/.
destruct /m/ /| m/.
  {
  unroll /eqb/.
  reduce //.
  typecheck.
  }

  {
  unroll /eqb/.
  reduce //.
  typecheck.
  apply /IH/.
  apply /lt_succ/.
  }
qed ();
Define.recordTyping "eqb_type";



lemma "istrue_eqb"
/
  forall m n .
    istrue (eqb m n) <-> m = n : nat
/;

inference.
intro /m/.
iterate /m/.

(* 0 *)
{
intro /(| n)/.
  {
  split.
    {
    intro /_/.
    reflexivity.
    }

    {
    intro /_/.
    unroll /eqb/.
    reduce //.
    apply /istrue_true/.
    }
  }

  {
  split.
    {
    intro /H/.
    unroll /eqb in H/ >> reduce /H/.
    so /not_istrue_false __/ /0/.
    auto.
    }

    {
    intro /H/.
    injection /H/.
    }
  }
}

(* succ *)
{
intro /m IH (| n)/.
  {
  split.
    {
    intro /H/.
    unroll /eqb in H/ >> reduce /H/.
    so /not_istrue_false H/ /0/.
    }

    {
    intro /H/.
    injection /H/.
    }
  }

  {
  unroll /eqb/ >> reduce //.
  split.
    {
    intro /H/.
    compat.
    exact /IH _ #1 H/.
    }

    {
    intro /H/.
    injection /H/.
    reintro /H'/.
    exact /IH _ #2 H'/.
    }
  }
}
qed ();



lemma "leqb_type"
/
  leqb : nat -> nat -> bool
/;

introOf /m n/.
revert /n/.
induct /m/.
reintro /IH/.
intro /n/.
destruct /m/ /| m/.
  {
  unroll /leqb/.
  reduce //.
  typecheck.
  }

  {
  unroll /leqb/.
  reduce //.
  typecheck.
  apply /IH/.
  apply /lt_succ/.
  }
qed ();
Define.recordTyping "leqb_type";



lemma "istrue_leqb"
/
  forall m n .
    istrue (leqb m n) <-> m <= n
/;

inference.
intro /m/.
iterate /m/.

(* 0 *)
{
intro /(| n)/.
  {
  split.
    {
    intro /_/.
    reflexivity.
    }

    {
    intro /_/.
    unroll /leqb/ >> reduce //.
    apply /istrue_true/.
    }
  }

  {
  split.
    {
    intro /_/.
    apply /leq_0_min/.
    }

    {
    intro /_/.
    unroll /leqb/ >> reduce //.
    apply /istrue_true/.
    }
  }
}

(* succ *)
{
intro /m IH (| n)/.
  {
  split.
    {
    intro /H/.
    unroll /leqb in H/ >> reduce /H/.
    so /not_istrue_false H/ /0/.
    }

    {
    intro /H/.
    so /leq_succ_0_not _ H/ /0/.
    }
  }

  {
  unroll /leqb/ >> reduce //.
  split.
    {
    intro /H/.
    apply /leq_succ_succ/.
    exact /IH _ #1 H/.
    }

    {
    intro /H/.
    so /leq_succ_invert _ _ H/ /H'/.
    exact /IH _ #2 H'/.
    }
  }
}
qed ();



define /ltb m n/
/
  leqb (succ m) n
//
  nat -> nat -> bool
/;

introOf /m n/.
unfold /ltb/.
typecheck.
qed ();



lemma "istrue_ltb"
/
  forall m n .
    istrue (ltb m n) <-> m < n
/;

inference.
intro /m n/.
unfold /ltb , lt/.
apply /istrue_leqb/.
qed ();
