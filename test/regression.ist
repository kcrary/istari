
Message.squelch := 1;


Ctrl.use "../library/acc-load.iml";
Ctrl.use "../library/nat-load.iml";
Ctrl.use "../library/integer-load.iml";

fun shouldfail tac = ifthen tac (fail "unexpected success") idtac;



lemma "annotated_redex"
/
  forall n .
    (fn (x : nat) . succ x) n = succ n : nat
/;

inference.
intro /n/.
reduce //.
reflexivity.
qed ();



lemma "extensionality_union"
/
  forall i (a : U i) (b : a -> U i) (m : a) (n p : b m) .
    n = p : b m
    -> n = p : (union (x : a) . b x)
/;

inference.
intro /i a b m n p H/.
existsEq /m/.
hyp /H/.
qed ();



lemma "extensionality_iexists"
/
  forall i (a : kind i) (b : a -> U i) (m : a) (n p : b m) .
    n = p : b m
    -> n = p : (iexists (x : a) . b x)
/;

inference.
intro /i a b m n p H/.
existsEq /m/.
hyp /H/.
qed ();



lemma "extensionalityAuto"
/
  forall i (a : U i) (b c : a -> U i) (d e : forall x . c x -> U i) .
    (fn t .
       forall (m n : t) .
         (forall x y . m x y #1 = n x y #1 : c x)
         -> (forall x y z . m x y #2 #1 z = n x y #2 #1 z : e x (m x y #1))
         -> m = n : t)
    (forall (x : a) . b x -> exists (z : c x) . (d x z -> e x z) & (x : a))
/;

reduce /concl/.
inference.
intro /i a b c d e m n H1 H2/.
  {
  reintro /x y z/.
  symmetry.
  apply /H1/.
  }

  {
  reintro /x y z/.
  apply /H1/.
  }
extensionalityAuto >> auto.
qed ();



lemma "extensionalityAuto_manual"
/
  forall i (a : U i) (b c : a -> U i) (d e : forall x . c x -> U i) .
    (fn t .
       forall (m n : t) .
         (forall x y . m x y #1 = n x y #1 : c x)
         -> (forall x y z . m x y #2 #1 z = n x y #2 #1 z : e x (m x y #1))
         -> m = n : t)
    (forall (x : a) . b x -> exists (z : c x) . (manuals (d x z -> e x z)) & (x : a))
/;

reduce /concl/.
inference.
intro /i a b c d e m n H1 H2/.
  {
  reintro /x y z/.
  symmetry.
  apply /H1/.
  }

  {
  reintro /x y z/.
  apply /H1/.
  }
extensionalityAuto >> auto.
introEq /x/ >> auto.
qed ();



lemma "iforall_extensionality"
/
  forall i (k : kind i) (b : k -> U i) (m n : iforall (x : k) . b x) .
    (forall (x : k) . m = n : b x)
    -> m = n : (iforall (x : k) . b x)
/;

inference.
intro /i k b m n Heq/.
extensionality.
apply /Heq/.
qed ();



lemma "intersect_extensionality"
/
  forall i (a : U i) (b : a -> U i) (m n : intersect (x : a) . b x) .
    (forall (x : a) . m = n : b x)
    -> m = n : (intersect (x : a) . b x)
/;

inference.
intro /i a b m n Heq/.
introEq /x/.
apply /Heq/.
qed ();



lemma "univIntroEqtype"
/
  forall i (a b : U i) .
    a = b : type
    -> a = b : U i
/;

inference.
intro /i a b H/.
univIntroEqtype >> typecheck.
qed ();



lemma "positive_under_binder"
/
  forall i (a b : U i) .
    (mu t . forall (x : a) (y : t) . b) : type
/;

inference.
intro /i a b/.
shouldfail (typecheck >> done).
Prover.abandon ();



lemma "positive_future"
/
  forall i (a : U i) .
    (mu t . a % future t) : type
/;

inference.
intro /i a/.
typecheck.
qed ();



lemma "inject_future"
/
  forall i (a : U i) (m n : a) .
    next m = next n : (future a)
    -> future (m = n : a)
/;

inference.
intro /i a m n H/.
injection /H/.
assumption.
qed ();



lemma "eliminate_iexists"
/
  forall i (a : kind i) (b : a -> U i) (y : iexists (x : a) . b x) . 
    unit
    -> y = y : (iexists (x : a) . b x)
    -> { exists (x : a) . b x }
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
split.
exists /x/.
auto.
qed ();



lemma "eliminate_iexists_dependent"
/
  forall i (a : kind i) (b : a -> U i) (y : iexists (x : a) . b x) . 
    unit
    -> y = y : (iexists (x : a) . b x)
    -> y : (iexists (x : a) . b x)
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
typecheck.
qed ();



lemma "eliminate_union"
/
  forall i (a : U i) (b : a -> U i) (y : union (x : a) . b x) . 
    unit
    -> y = y : (union (x : a) . b x) 
    -> { exists (x : a) . b x }
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
split.
exists /x/.
auto.
qed ();



lemma "eliminate_union_dependent"
/
  forall i (a : U i) (b : a -> U i) (y : union (x : a) . b x) . 
    unit
    -> y = y : (union (x : a) . b x) 
    -> y : union (x : a) . b x
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
typecheck.
qed ();



lemma "inhabit_union"
/
  forall i (a : U i) (b : a -> U i) (x : a) (y : b x) .
    union (z : a) . b z
/;

inference.
intro /i a b x y/.
exists /x/.
hyp /y/.
qed ();



lemma "union_introduction_auto"
/
  forall i (a : U i) (b : a -> U i) (x : a) (y : b x) .
    y : (union (z : a) . b z)
/;

inference.
intro /i a b x y/.
typecheck.
qed ();



lemma "union_introduction_manual"
/
  forall i (a : U i) (b : a -> U i) (x : a) (y : b x) .
    y : (union (z : a) . b z)
/;

inference.
intro /i a b x y/.
existsOf /x/.
hypof.
qed ();



lemma "iexists_introdution_auto"
/
  forall i (k : kind i) (b : k -> U i) (x : k) (y : b x) .
    y : (iexists (z : k) . b z)
/;

inference.
intro /i k b x y/.
typecheck.
qed ();



lemma "iexists_introdution_manual"
/
  forall i (k : kind i) (b : k -> U i) (x : k) (y : b x) .
    y : (iexists (z : k) . b z)
/;

inference.
intro /i k b x y/.
existsOf /x/.
hypof.
qed ();



lemma "union_equality_transitive"
/
  forall i (a : U i) (b : a -> U i) (c : U i) (a1 a2 : a) (b1 : b a1) (b2 : c) (b3 : b a2) .
    c <: b a1
    -> c <: b a2
    -> b1 = b2 : b a1
    -> b2 = b3 : b a2
    -> b1 = b3 : (union (x : a) . b x)
/;

inference.
intro /i a b c a1 a2 b1 b2 b3 Hsub1 Hsub2 Heq12 Heq23/.
transitivity /b2/.
  {
  RuleTactic.unionIntroEq >> auto.
  typecheck.
  }

  {
  RuleTactic.unionIntroEq >> auto.
  typecheck.
  }
qed ();



lemma "backtrack_through_typecheck"
/
  forall i (a b c : U i) . (a -> c) -> (b -> c) -> b -> c
/;

inference.
intro /i a b c Hac Hbc Hb/.
shouldfail ((Typecheck.withTypecheck $ cut (first [witness /Hac __/, witness /Hbc __/])) >> auto >> done).
(Typecheck.withTypecheck $ first [witness /Hac __/, witness /Hbc __/]) >> auto >> done.
qed ();



lemma "backtrack_through_apply"
/
  forall i (a : U i) (a1 a2 : a) (P : a -> U i) (R : a -> a -> U i) .
    (forall x y . R x y -> P x & P y)
    -> R a1 a2
    -> P a2
/;

inference.
intro /i a a1 a2 P R H1 H2/.
apply /H1/ >> auto >> done.
qed ();



lemma "manual_subtype"
/
  forall i (a b c : U i) . a <: b -> (b -> c) <: (a -> c)
/;

inference.
intro /i a b c H/.
fold /manual a/.
typecheck.
hyp /H/.
qed ();



lemma "squash_subtype"
/
  forall i (a b : U i) . (unit & (a -> b)) -> squash a <: squash b
/;

intro /i a b H/.
typecheck.
apply /H/.
qed ();



lemma "intro_of_arrows"
/
  forall i (a : U i) (b c d : a -> U i) .
    (fn x y z w . 0) : (forall (x : a) . b x -> c x -t> d x -k> nat)
/;

inference.
intro /i a b c d/.
introOf /x y z w/.
reduce //.
typecheck.
qed ();



lemma "unhide_subtype"
/
  forall i (a b : U i) . { a <: b } -> a <: b
/;

inference.
intro /i a b H/.
destruct /H/ /[H]/.
unhide.
hyp /H/.
qed ();



lemma "exclude"
/
  forall i (a b : U i) (f : a -> b) (x : (exclude` a in _) a) . f x : b
/;

inference.
intro /i a b f x/.
typecheck.
qed ();



(* check reductions using natives *)

defineRaw /is_minus_one x/
/
  Integer.eqzb (x +z z`1) z`0
/;


defineRaw /minus_one/ /z`-1/;


reductions
/
  is_minus_one (minus_one) --> true ;
  unfolding is_minus_one minus_one
/;



lemma "destructSet"
/
  forall i (a : U i) (b : a -> U i) (x : {x : a | b x}) .
    exists (y : a) . { b y }
/;

inference.
intro /i a b x/.
infer /x/ /H1/.
destructSet /H1/ /H2/.
existsRaw /x/.
  {
  typecheck.
  }

  {
  hyp /H1/.
  }

  {
  split.
  hyp /H2/.
  }
qed ();



lemma "infer_through_set"
/
  forall i (a b : U i) (P : (a -> b) -> U i) (f : {f : a -> b | P f}) (x : a) .
    f x : b
/;

inference.
intro /i a b P f x/.
infer /f x/ /H/.
hyp /H/.
qed ();



lemma "contrapositive"
/
  forall i (a b c : U i) .
    (a -> c)
    -> (b -> a)
    -> (b -> c)
/;

inference.
intro /i a b c Hac Hba/.
contrapositive /Hac/.
auto.
qed ();



lemma "make_orphan"
/
  forall (x y : nat) (P : nat -> U 0) . P x -> P (if true then x else y)
/;

intro /x y P H/.
clear /y/.
reduce //.
hyp /H/.
qed ();



lemma "make_orphan_unify"
/
  forall i 
    (a : nat -> U i)
    (b : U i)
    (x : nat)
    (f : a _ -> b)
    (x' : nat)
    (y : a (succ (if true then x else x')))
    . b
/;

inference.
intro /i a b x f x' y/.
1:{
  exact /f y/.
  }
reduce //.
typecheck.
qed ();



lemma "make_free_variable"
/
  let x = l` 0 in unit
/;

unfold /let/.
split.
Prover.abandon ();



lemma "open_extract"
/
  unit
/;

exactRaw /let x = l` 0 in ()/.
unfold /let/.
typecheck.
qed ();



lemma "free_evar_extract"
/
  unit
/;

exactRaw /let x = _ in ()/.
unfold /let/.
typecheck.
qed ();



lemma "substitution_cycle"
/
  forall i (a : U i) (f : a -> a) (x : a) .
    x = f x : a
    -> unit
/;

inference.
intro /i a f x Heq/.
shouldfail (subst /x/).
split.
qed ();


lemma "substitution_with_move"
/
  forall i (a : U i) (P : a -> U i) (x y z : a) .
    x = z : a
    -> P z
    -> P x
/;

inference.
intro /i a P x y z Heq Hz/.
shouldfail (substStrict /x/).
subst /x/.
hyp /Hz/.
qed ();


lemma "move_deps"
/
  forall i (t a : U i) (b : a -> U i) (c : forall (x : a) . b x -> U i)
    (a1 a2 : a) (b1 b2 : b a1) (c1 c2 : c a1 b1) (t1 : t) .
    unit
/;

inference.
intro /i t a b c a1 a2 b1 b2 c1 c2 t1/.
shouldfail (moveBeforeDeps /t1/ /t/).
moveBeforeDeps /c2 c1/ /t/.
split.
qed ();


lemma "rename_before"
/
  0 <= 1
  -> 0 <= 2
  -> 0 <= 3
  -> 0 <= 4
  -> 0 <= 5
  -> 0 <= 6
  -> 0 <= 7
  -> unit
/;

intro /a b c d e f g/.
renameBefore /x _ ? y/ /f/.
split.
qed ();


lemma "extensionality_iset"
/
  forall i (a : U i) (b : a -> U i) (m n : a) .
    b m
    -> m = n : a
    -> m = n : (iset (x : a) . b x)
/;

intro /i a b m n H Heq/.
extensionality.
  {
  hyp /Heq/.
  }

  {
  hyp /H/.
  }
qed ();


lemma "destruct_iset"
/
  forall i (a : U i) (b : a -> U i) (x : iset (x : a) . b x) .
    x : (iset (y : a) . b y)
/;

inference.
intro /i a b x/.
destructRaw /x/ /[x H]/.
typecheck.
split.
hyp /H/.
qed ();


lemma "infer_spine"
/
  forall i (a b c : U i) (f : { y : a -> b & c | unit }) (x : a) .
    f x #1 : b
/;

inference.
intro /i a b c f x/.
assert /f : a -> b & c/ /Hf/.
  {
  typecheck.
  }
inferSpine /Hf/ /__ x #1/ /H/.
hyp /H/.
qed ();
  


lemma "so_pi1_after_marker"
/
  forall i (a b : U i) (c : b -> U i) (f : a -> exists (x : b) . c x) .
    a -> b
/;

inference.
intro /i a b c f x/.
so /f __ #1/ /H/.
  {
  auto.
  }
hyp /H/.
qed ();



define /arrow' A B/
/
  A -> B
//
  intersect i . U i -> U i -> U i
/;

unfold /arrow'/.
typecheck.
qed ();



define /prod' A B/
/
  A & B
//
  intersect i . U i -> U i -> U i
/;

unfold /prod'/.
typecheck.
qed ();



lemma "destruct_unfolds"
/
  forall i (a b : U i) . prod' a b -> a & b
/;

inference.
intro /i a b H/.
destruct /H/ /H1 H2/.
auto.
qed ();



lemma "so_unfolds"
/
  forall i (a b c d e : U i) (f : arrow' a (arrow' b (arrow' c (prod' d e)))) .
    a -> b -> c -> d
/;

inference.
intro /i a b c d e f x y z/.
so /f x __ z #1/ /H1/.
  {
  hyp /y/.
  }
so /f x __ z #2/ /H2/.
  {
  hyp /y/.
  }
hyp /H1/.
qed ();



lemma "infer_unfolds"
/
  forall i (a b : U i) (f : arrow' a b) (x : a) .
    f x : b
/;

inference.
intro /i a b f x/.
infer /f x/ /H/.
hyp /H/.
qed ();



lemma "squash_hidden"
/
  forall i (a : U i) (b : a -> U i) (c : U i) (x y : { z : a | b z }) .
    c -> { b x } & { b y }
/;

intro /i a b c x y Hc/.
destruct /x/ /x Hx/.
destruct /y/ /y Hy/.
squashHidden /Hx Hy/.
auto.
qed ();



lemma "unprotected_hypothesis"
/
  forall i (a b : U i) (f : a -g> b) .
    _
    -> f : b
/;

intro /i a b f H/.
1:{
  typecheck.
  hyp /H/.
  }
typecheck.
qed ();



lemma "contains_unresolved_evar"
/
  void -> _
/;

intro /H/.
destruct /H/ /0/.
(* qed should return an error *)
Prover.abandon ();



lemma "contains_free_variable"
/
  void -> l` 1
/;

intro /0/.
(* qed should return an error *)
Prover.abandon ();



lemma "contains_marker"
/
  void -> __
/;

intro /0/.
(* qed should return an error *)
Prover.abandon ();



lemma "id_at_forall_nat"
/
  (fn (x : nat) . x) : _
/;

typecheck.
qed ();



lemma "id_at_arrow_nat"
/
  (fn (x : nat) . x) : nat -> nat
/;

typecheck.
qed ();



lemma "id_at_tarrow_nat"
/
  (fn (x : nat) . x) : nat -t> nat
/;

typecheck.
qed ();



lemma "forall_is_arrow"
/
  foralltp a b .
    (forall (x : a) . b) = (a -> b) : type
/;

intro /a b/.
typecheck.
qed ();



lemma "forall_is_tarrow"
/
  foralltp a b .
    (forall (x : a) . b) = (a -t> b) : type
/;

intro /a b/.
typecheck.
qed ();
  


lemma "forall_is_arrow_univ"
/
  forall i (a b : U i) .
    (forall (x : a) . b) = (a -> b) : U i
/;

intro /i a b/.
typecheck.
qed ();
  


lemma "forall_is_tarrow_univ"
/
  forall i (a b : U i) .
    (forall (x : a) . b) = (a -t> b) : U i
/;

intro /i a b/.
typecheck.
qed ();



defineRaw /silly x/ /Integer.plusz z`1 z`1/;


reductions
/
  silly (zero) --> z` 2 ;
  unfolding silly
/;



lemma "integer_negation"
/
  Integer.negz z`1 : integer
/;

reduce //.
typecheck.
qed ();



lemma "integer_addition"
/
  Integer.plusz z`12 z`-12 : integer
/;

reduce //.
typecheck.
qed ();



lemma "integer_comparison"
/
  Integer.leqzb z`12 z`0 : bool
/;

reduce //.
typecheck.
qed ();



lemma "twelve_of"
/
  z`12 : integer
/;

typecheck.
qed ();



lemma "twelve_eq"
/
  z`12 = z`12 : integer
/;

reflexivity.
qed ();



lemma "destruct_hidden_zero"
/
  forall (a : U 0) . { void } -> a
/;

intro /a H/.
destruct /H/ /[H]/.
destruct /H/ /0/.
qed ();



lemma "exfalso"
/
  forall (a : U 0) . { void } -> a
/;

intro /a H/.
destruct /H/ /[H]/.
exfalso.
hyp /H/.
qed ();



lemma "unhide_void"
/
  forall (a : U 0) . { a } -> (a -> void) -> void
/;

intro /a H Hnot/.
destruct /H/ /[H]/.
unhide.
auto.
qed ();



lemma "unhide_void_hyp"
/
  forall (a : U 0) . { void } -> a
/;

intro /a H/.
destruct /H/ /[H]/.
unhide.
destruct /H/ /0/.
qed ();



lemma "trivialize"
/
  forall i (a b : U i) (m n : a) .
    a
    -> (a -> m = n : a)
    -> m = n : a
/;

inference.
intro /i a b m n Ha H/.
trivialize.
auto.
qed ();
Show.showClosed $ Option.valOf $ Constant.definition $ parseConstant /trivialize/;



lemma "trivialize_typecheck"
/
  forall i (a : U i) (m n : a) .
    m = n : a
    -> () : m = n : a
/;

inference.
intro /i a m n H/.
typecheck.
qed ();



lemma "eqtp_table"
/
  forall (i : level) (a b c : U i) (f : a -> c) (x : b) .
    a = b : type
    -> f x : c
/;

intro /i a b c f x Heq/.
typecheck.
qed ();



lemma "equniv_table"
/
  forall (i : level) (a b c : U i) (f : a -> c) (x : b) .
    a = b : U i
    -> f x : c
/;

intro /i a b c f x Heq/.
typecheck.
qed ();



lemma "degenerate_quotient"
/
  (quotient (x y : nat) . x = y : nat) : type
/;

typecheck.
  {
  reintro /x y H/.
  symmetry.
  hyp /H/.
  }

  {
  reintro /x y z Hxy Hyz/.
  etransitivity.
    {
    hyp /Hxy/.
    }

    {
    hyp /Hyz/.
    }
  }
qed ();



lemma "destruct_quotient_of"
  / (quotient (x y : nat) . x = y : nat) <: nat /;

so /degenerate_quotient/ /Histp/.
intro /z/.
destruct /z/ /[ x y H ]/.
hyp /H/.
qed ();



lemma "destruct_quotient_eq"
/
  forall (x : quotient (x y : nat) . x = y : nat) . x = x : nat
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destructRaw /z/ /[x y H]/.
  {
  typecheck.
  }
hyp /H/.
qed ();



lemma "destruct_quotient_eq_dep"
/
  forall (x : quotient (x y : nat) . x = y : nat) . () : x = x : nat
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destructRaw /z/ /[x y H]/.
  {
  typecheck.
  }

  {
  typecheck.
  }

  {
  typecheck.
  }
qed ();



lemma "destruct_quotient_istype"
/
  forall (x : quotient (x y : nat) . x = y : nat) . (x : nat) : type
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destruct /z/ /[x y H]/.
typecheck.
qed ();



lemma "destruct_quotient_eqtype"
/
  forall (x : quotient (x y : nat) . x = y : nat) . (x : nat) = (x : nat) : type
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destruct /z/ /[x y H]/.
typecheck.
qed ();



lemma "inject_quotient"
/
  forall (x u : quotient (x y : nat) . x = y : nat) . 
    x = u : (quotient (x y : nat) . x = y : nat)
    -> x = u : nat
/;

so /degenerate_quotient/ /Histp/.
intro /x u Heq/.
destruct /x/ /[x y Hxy]/.
destruct /u/ /[u v Huv]/.
injection /Heq/.
reintro /Heq'/.
transitivity /u/ >> auto.
qed ();



lemma "apply_forall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (f : iforall (x : a) . b x) (m : a) .
    b m
/;

inference.
intro /i a b f m/.
apply /f/.
qed ();



lemma "exploit_forall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (f : iforall (x : a) . b x) (m : a) .
    b m
/;

inference.
intro /i a b f m/.
eexploit /f/ /H/.
  {
  hyp /H/.
  }
typecheck.
qed ();



lemma "infer_iforall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (f : iforall (x : a) . b x) (m : a) .
    f : b m
/;

inference.
intro /i a b f m/.
infer /f ap m/ /H/.
unfold /ap in H/.
hyp /H/.
qed ();



lemma "compat_iforall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (c : forall (x : a) . b x -> U i) 
    (f : iforall (x : a) . forall (y : b x) . c x y) (m : a) (n1 n2 : b m) .
      n1 = n2 : b m
      -> f n1 = f n2 : c m n1
/;

inference.
intro /i a b c f m n1 n2 Heq/.
fold /f ap m/.
compat.
hyp /Heq/.
qed ();



lemma "substitution_simple"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b y
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substitutionRaw /x/ /y/.
  {
  hyp /Heq/.
  }
hypof.
qed ();


lemma "substitution_complex"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b x
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substitutionRaw /x/ /y/.
  {
  typecheck.
  }

  {
  hyp /Heq/.
  }

  {
  hypof.
  }
qed ();



lemma "subst_simple"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b y
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substRaw /x/.
hypof.
qed ();


lemma "subst_complex"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b x
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substRaw /x/.
  {
  typecheck.
  }

  {
  hypof.
  }
qed ();



lemma "copy"
/
  forall (i : level) (P : U i) . P -> P
/;

intro /i P H1/.
copy /H1/ /H2/.
hyp /H2/.
qed ();



lemma "kind_sub"
/
  forall (i : level) . let j = _ in (Kind i <: U j) & (j : level)
/;

intro /i j/.
subst /j/.
split.
  {
  typecheck.
  }
typecheck.
qed ();



lemma "inject_set"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : {z : a | b z}) .
    x = y : {z : a | b z}
    -> x = y : a & { b x } & { b y }
/;

intro /i a b x y Heq/.
injection /Heq/ >> clear /Heq/.
reintro /Heq Hx Hy/.
auto.
qed ();



lemma "absolute"
/
  forall (i : level) (a b : U i) (f : a -> b) (x y z : a) . _ -> f x : b
/;

intro /i a b f x y z/.
val (_, dir) = Prover.currentGoal ();
val ec = ETerm.absolute dir (Prover.currentConcl ());
moveBefore /x/ /f/.
moveBefore /b/ /a/.
clear /z/.
assert ec /H/.
1:{
  hyp /H/.
  }
change /concl/ /unit -> _/.
auto.
qed ();



lemma "setEq"
/
  forall (i : level) (a : U i) (P : a -> U i) (f : a -> a) (x : a) .
    P (f x)
    -> P (f x)
/;

intro /i a P f x H/.
setEq /y/ /f x/ /_/ /Heq/.
rewrite /<- Heq/.
moveBefore /y Heq/ /H/.
rewrite /<- Heq in H/.
hyp /H/.
qed ();



lemma "remember"
/
  forall (i : level) (a : U i) (f : a -> bool) (x : a) .
    (f x = false : bool -> void)
    -> if f x then unit else void
/;

intro /i a f x H/.
remember /f x/ /_/ /b/ /Heq/.
destruct /b/ /|/.
  {
  reduce //.
  split.
  }

  {
  auto.
  }
qed ();



lemma "apply_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
apply /H/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
qed ();



lemma "so_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
so /H _ _ __ __/ /H'/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
hyp /H'/.
qed ();



lemma "exploit_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
eexploit /H/ /H'/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
hyp /H'/.
qed ();



lemma "witness_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
witness /H _ _ __ __/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
qed ();



lemma "unroll_letrec"
/
  let f = fix (fn f x . nat_case x 0 (fn x' . succ (f x'))) in f : nat -> nat
/;

intro /f/.
assert /f : nat -> nat/ /H/.
  {
  introOf /n/.
  sinduction /n/.
  reintro /IH/.
  unroll /f/.
  destruct /n/ /| n/.
    {
    reduce //.
    typecheck.
    }
  reduce //.
  typecheck1.
  apply /IH/.
  apply /Nat.lt_succ/.
  }
unroll /f/.
roll /f/.
unroll /f in H/.
roll /f in H/.
hyp /H/.
qed ();



lemma "unroll_letrec_under"
/
  let f = fix (fn f x . nat_case x 0 (fn x' . succ (f x'))) in (fn y z . f z) : nat -> nat -> nat
/;

intro /f/.
unroll /f/.
roll /f z within y z/.
goalCaseT /? => \fnc c => assert /\c\/ /H/\/.
  {
  introOf /_ n/.
  reduce //.
  so /unroll_letrec/ /H/.
  reduceHard /H/.
  fold /f in H/.
  generalize /f/ /nat -> nat/ /f'/.
  typecheck.
  }
unroll /f in H/.
roll /f z within y z in H/.
hyp /H/.
qed ();



definerec /countdown x/
/
  nat_case x 0 (fn x' . succ (countdown x'))
//
  nat -> nat
/;

introOf /n/.
sinduction /n/.
reintro /IH/.
unroll /countdown/.
roll /countdown n/.
unroll /countdown/.
destruct /n/ /| n/.
  {
  reduce //.
  typecheck.
  }
reduce //.
typecheck1.
apply /IH/.
apply /Nat.lt_succ/.
qed ();



lemma "countdown_identity"
/
  forall n . countdown n = n : nat
/;

inference.
intro /n/.
induction /n/.
  {
  unroll /countdown/.
  reduce //.
  auto.
  }
intro /n IH/.
unroll /countdown/.
convertRoll /countdown (succ n)/.
unroll /countdown/.
reduce //.
compat.
auto.
qed ();
    



defineRaw /mypair x y/ /(x , y)/;


lemma "unroll_whnf"
/
  mypair 1 : nat -> nat & nat
/;

unfoldHead /mypair/.
fold /mypair 1/.
unfold /mypair/.
fold /mypair 1/.
introOf /x/.
unfold /mypair/.
typecheck.
qed ();


lemma "unroll_let_whnf"
/
  let f = (fn x y . (x , y)) in f 1 : nat -> nat & nat
/;

intro /f/.
unfoldHead /f/.
fold /f 1/.
unfold /f/.
fold /f 1/.
introOf /x/.
unfold /f/.
typecheck.
qed ();



lemma "unroll_rec_univ"
/
  forall i (a : U i -> U i) (b : U i -> U i) .
    b (future (a (rec t . future (a t))))
    -> b (rec t . future (a t))
/;

inference.
intro /i a b H/.
unrollTypeUniv /rec with i/.
auto.
qed ();


lemma "let_intro"
/
  forall i (a : U i) (m : a) . let x = m in x : a
/;

inference.
intro /i a m x/.
set /y/ /x/.
unfold /x in y/.
revert /x/.
intro /x/.
moveBefore /x/ /y/.
subst /x/.
hypof.
qed ();



lemma "let_fold_under"
/
  forall i (a : U i) (m n : a) (f : a -> a) (P : a -> U i).
    (forall x . P (f (f x)))
    -> P (f (f m))
/;

inference.
intro /i a m n f P H/.
set /g/ /fn x . f (f x)/.
moveBefore /g/ /H/.
fold /g x within x in H/.
unfold /g in H/.
reduce /H/.
fold /g x within x in H/.
fold /g m/.
unfold /g/.
reduce //.
fold /g m/.
apply /H/.
qed ();



lemma "let_fold"
/
  forall i (a : U i) (m n : a) . m : a
/;

inference.
intro /i a m n/.
set /x/ /m/.
moveBefore /x/ /n/.
assert /x : a/ /H/.
  {
  subst /x/.
  hypof.
  }
fold /x/.
unfold /x/.
unfold /x in H/.
fold /x in H/.
subst /x/.
hyp /H/.
qed ();



lemma "let_bind"
/
  forall m n .
    (let x = m in x + n) = m + n : nat
/;

inference.
intro /m n/.
reflexivity.
qed ();



lemma "injection_zero_succ"
/
  forall n . 
    0 = 0 : nat
    -> 0 = succ n : nat 
    -> void
/;

inference.
intro /n Heq1 Heq2/.
injection /Heq1/.
injection /Heq2/.
qed ();



lemma "injection_succ_zero"
/
  forall n . succ n = 0 : nat -> void
/;

inference.
intro /n Heq/.
injection /Heq/.
qed ();



lemma "injection_succ"
/
  forall m n . succ m = succ n : nat -> m = n : nat
/;

inference.
intro /m n Heq/.
injection /Heq/.
reintro /Heq'/.
hyp /Heq'/.
qed ();



lemma "injection_exists"
/
  forall i (a : U i) (b : a -> U i) (x y : a) (v : b x) (w : b y) .
    (x , v) = (y , w) : (exists (x : a) . b x)
    -> (x = y : a & v = w : b x)
/;

inference.
intro /i a b x y v w Heq/.
injection /Heq/.
reintro /Heq1 Heq2/.
exact /(Heq1 , Heq2)/.
qed ();



lemma "injection_inl"
/
  forall i (a b : U i) (x y : a) .
    inl x = inl y : (a % b)
    -> x = y : a
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
reintro /Heq'/.
hyp /Heq'/.
qed ();



lemma "injection_inr"
/
  forall i (a b : U i) (x y : b) .
    inr x = inr y : (a % b)
    -> x = y : b
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
reintro /Heq'/.
hyp /Heq'/.
qed ();



lemma "injection_inl_inr"
/
  forall i (a b : U i) (x : a) (y : b) .
    inl x = inr y : (a % b)
    -> void
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
qed ();



lemma "injection_inr_inl"
/
  forall i (a b : U i) (x : b) (y : a) .
    inr x = inl y : (a % b)
    -> void
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
qed ();



lemma "lam_compat"
/
  forall i (a : U i) (f : nat -> a) .
    (fn x . f (succ x)) = (fn x . f (x + 1)) : (nat -> a)
/;

inference.
intro /i a f/.
compat.
compat.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "lam_compat_dep"
/
  forall i (a : nat -> U i) (f : forall (x : nat) . a x) .
    (fn x . f (succ x)) = (fn x . f (x + 1)) : (forall (x : nat) . a (succ x))
/;

inference.
intro /i a f/.
compat.
compat.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "pair_compat_dep"
/
  forall i (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> (x , z) = (y , z) : (exists (x : a) . b x)
/;

inference.
intro /i a b x y z Heq/.
compat.
hyp /Heq/.
qed ();



lemma "next_compat"
/
  forall i (a : U i) (x y : a) .
    future (x = y : a)
    -> next x = next y : (future a)
/;

inference.
intro /i a x y Heq/.
destruct /Heq/ /[Heq]/.
compat.
hyp /Heq/.
qed ();



lemma "inl_compat"
/
  forall i (a b : U i) (x y : a) .
    x = y : a
    -> inl x = inl y : (a % b)
/;

inference.
intro /i a b x y Heq/.
compat.
hyp /Heq/.
qed ();




lemma "guards"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
introOf /H/.
typecheck.
apply /Hba/.
hyp /H/.
qed ();



lemma "typecheck_guard"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
typecheck.
reintro /Hb/.
apply /Hba/.
hyp /Hb/.
qed ();



lemma "infer_guard"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
typecheck1 >>> [typecheck, idtac].
reintro /Hb/.
infer /x/ /Hx/.
  {
  apply /Hba/.
  hyp /Hb/.
  }
hyp /Hx/.
qed ();



lemma "infer_guard_ap"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
typecheck1 >>> [typecheck, idtac].
reintro /Hb/.
infer /x ap (Hba Hb)/ /Hx/.
unfold /ap in Hx/.
hyp /Hx/.
qed ();



lemma "compat_guard"
/
  forall i (a b c : U i) (f : a -> b -g> c) (x x' : a) .
    b
    -> x = x' : a
    -> f x = f x' : c
/;

intro /i a b c f x x' Hb Heq/.
compat.
  {
  hyp /Heq/.
  }
  
  {
  hyp /Hb/.
  }
qed ();



lemma "compat_guard_ap"
/
  forall i (a b c : U i) (f : a -> b -g> c) (x x' : a) .
    b
    -> x = x' : a
    -> f x = f x' : c
/;

intro /i a b c f x x' Hb Heq/.
convert /f x ap Hb/.
compat.
hyp /Heq/.
qed ();



lemma "level_assumption"
/
  forall i j (a : U i) .
    i <l= j
    -> a : U j
/;

inference.
intro /i j a H/.
typecheck.
qed ();



val four = (4, ETerm.closed /4/);

lemma "embedded"
/
  \snd four\ : \Term.Const Prim.nat\
/;

typecheck.
qed ();



lemma "strict_cycle"
/
  (fn e . U e : U e) _
/;

reduce //.
inference.
(*
Should see:
Level error: constraints have no solution: strict cycle
*)
Prover.abandon ();


lemma "inexpressible_constraint1"
/
  (fn e . (forall i (a : U i) . a) : U e) _
/;

reduce //.
inference.
(*
Should see:
Level error: constraints have no solution: scope violation
*)
Prover.abandon ();


lemma "inexpressible_constraint2"
/
  (fn e . forall i (a : U i) . a : U e) _
/;

reduce //.
inference.
(* Should see:
Level error: constraints have no solution: scope violation
*)
Prover.abandon ();


lemma "exotic_cycle"
/
  forall (f : level -> level) .
    (fn e . forall (a : univ (f e)) . a : U e) _
/;

reduce //.
inference.
(* Should see:
Warning: not solving exotic constraints: unrecognized level operator
*)
Prover.abandon ();


lemma "solve_universe"
/
  forall i j .
    (fn e .
       forall (a : U i) (b : U j) (c : U e) .
         a & b & b & c & unit & U i & U 1 : U e)
    _
/;

reduce //.
inference.
(* solution should be [2 (1 + i) j] *)
intro /i j a b c/.
typecheck.
qed ();



lemma "solve_universe_simple"
/
  (fn e . (unit : U e) & (U e : U (1 + e))) _
/;

reduce //.
inference.
split >> typecheck.
qed ();



lemma "univ_include_path"
/
  forall i j (f : nat -> U i) . lleq i j -> f 2 : U j
/;

inference.
intro /i j f H/.
typecheck.
qed ();



lemma "subtype_univ"
/
  forall i j . lleq i j -> U i <: U j
/;

inference.
intro /i j H/.
typecheck.
qed ();


lemma "typecheck_univ"
/
  forall i j . lleq (lsucc i) j -> U i : U j
/;

intro /i j H/.
typecheck.
hyp /H/.
qed ();


lemma "typecheck_nat"
/
  4 : nat
/;

typecheck.
qed ();


lemma "destruct_nat_hyp"
/
  forall i (P : nat -> U i) (n : nat) . P n -> P n
/;

intro /i P n H/.
destruct /n/ /| n/.
  {
  hyp /H/.
  }

  {
  hyp /H/.
  }
qed ();



lemma "use_nat_case"
/
  forall (n : nat) .
    nat_case n void (fn _ . unit) : type
/;

intro /n/.
destruct /n/ /| | n/.
  {
  reduce //.
  typecheck1.
  }

  {
  reduce //.
  typecheck1.
  }

  {
  reduce //.
  typecheck1.
  }
qed ();



lemma "nat_induction"
/
  forall (n : nat) .
    fix (fn f x . nat_case x void (fn y . unit & f y)) n : type
/;

intro /n/.
sinduction /n/.
reintro /IH/.
destruct /n/ /| n/.
  {
  unroll /fix/.
  reduce //.
  typecheck1.
  }

  {
  unroll /fix/.
  reduce //.
  fold /manual (fix _ _)/.
  typecheck.
  apply /IH/.
  apply /Nat.lt_succ/.
  }
qed ();



defineRaw /identity/ /fn x . x/;

lemma "identity_type"
/
  identity : foralltp a . a -> a
/;

unfold /identity/.
typecheck.
qed ();



lemma "identity_type2"
/
  identity : foralltp a . a -> a
/;

introOf /a x/.
unfold /identity/.
reduce //.
typecheck.
qed ();



lemma "identity_type3"
/
  foralltp a . a -> a
/;

intro /a x/.
hyp /x/.
qed ();



lemma "induct_mu"
/
  forall (x : nat) . x : nat
/;

intro /x/.
unfold /nat in x , nat/.
sinduction /x/.
reintro /u x Hu IH/.
unrollType /mu/.
destruct /x/ /| x/.
  {
  typecheck.
  }

  {
  clear /Hu/.
  typecheck1.
    {
    typecheck.
    }
  apply /IH/.
  }
qed ();


lemma "unroll_mu" /
  forall (x : nat) . x : nat
/;

intro /x/.
unrollType /nat in x/.
unrollType /nat/.
assert /nat/ /H/.
  {
  unrollType /nat/.
  hyp /x/.
  }
clear /H/.
hypof.
qed ();



defineRaw /badnat/ /rec t . unit % future t/;

lemma "badnat_type" /badnat : U 0/;

unfold /badnat/.
typecheck.
qed ();
recordTyping "badnat_type";



lemma "unroll_rec" /
  forall (x : badnat) . x : badnat
/;

intro /x/.
unrollType /badnat in x/.
unrollType /badnat/.
assert /badnat/ /H/.
  {
  unrollType /badnat/.
  hyp /x/.
  }
clear /H/.
hypof.
qed ();



lemma "intersection" /
  (fn t u . t -> t) : intersect i j . U i -> U j -> U i
/;

typecheck.
qed ();



lemma "nat_eq_refl" /
  forall (n : nat) . n = n : nat
/;

unfold /nat at 0/.
introRaw /n/.
  {
  convert /(mu t . unit % t) : type/.
  withTypecheck RuleTactic.muForm.
  }
let do dir = Tactic.withidir
in
  Tactic.refine (Rule.muInd
                   (ETerm.withidir dir /additional` t . unit % t/)
                   (ETerm.withidir dir /additional` x . x = x : nat/)
                   (ETerm.withidir dir /n/))
end.
Prover.pull 2;
  {
  Tactic.chdir (Directory.literal (parseIdents /n t x H IH/)).
  clear /n/.
  fold /nat in H/.

Prover.abandon ();



lemma "contract_goals" /
  forall i (a : U i) . a -> a & unit & a
/;

intro /i a H/.
split >>> [idtac, split].
pull 2;
Prover.reorder (Reorder.contract 1);
  {
  hyp /H/.
  }

  {
  split.
  }
qed ();



defineRaw /myunit/ /unit/;
Constant.setOpacity (parseConstant /myunit/) Constant.SOFT;


lemma "soft_constant" /
  forall i (a : U i) (f : unit -> unit) (x : myunit) . myunit
/;

inference.
intro /i a f x/.
apply /f/.
hyp /x/.
qed ();



defineRaw /myarrow a b/ /a -> b/;
Constant.setOpacity (parseConstant /myarrow/) Constant.SOFT;

lemma "soft_constant_2" /
  forall i (a : U i) . myarrow a a
/;

inference.
intro /i a x/.
hyp /x/.
qed ();



lemma "inference" /
  forall i . (nat : U i)
/;

inference.
intro /i/.
typecheck.
qed ();



lemma "extensionalityOf" /
  forall i (a b : U i) (p : b -> U i) (f : a -> b) .
    (forall (x : a) . p (f x))
    -> f : a -> { x : b | p x }
/;

intro /? ? ? ? ? ?/.
reintro /H/.
introOf /x/.
typecheck.
split.
apply /H/.
qed ();



lemma "prove_subtype" /
  forall i (a a' : U i) (b : a -> U i) (b' c : U i) 
    (x : c -> forall (z : a) . b z) (y : c) (f : (a' -> b') -> c) .
    a' <: a
    -> (forall (z : a) . b z <: b')
    -> f (x y) : c
/;

intro /i a a' b b' c x y f Ha Hb/.
assert /forall (z : a') . b z <: b'/ /H/.
  {
  intro /z/.
  apply /Hb/.
  }
typecheck.
qed ();
  


lemma "infer_spine2" /
  forall i (a b : U i) (c : b -> U i) (x : a) (f : forall (y : b) . c y) .
    a = b : type
    -> f x : c x
/;

intro /i a b c x f Heq/.
assert /f : forall (y : a) . c y/ /Hof/.
  {
  eeqtp >>> [idtac , hypof].
  typecheck1.
    {
    symmetry.
    hyp /Heq/.
    }
  reflexivity.
  }
inferSpine /Hof/ /__ x/ /Hof'/.
hyp /Hof'/.
qed ();



Prover.openGoal
  (Judgement.make
     (Seq.cons (Judgement.Tm (ETerm.closed / 0 : void /)) Seq.empty)
     (ETerm.closed / 0 : void /),
   Directory.literalStr ["H"]);

hyp /H/.
qed ();



lemma "assert_pattern"
  / forall i (a : U i) (b : a -> U i) (x : a) (y : b x) . unit /;

intro /i a b x y/.
assert /exists (x' : a) . b x'/ /x' y'/.
  {
  exists /x/.
  hyp /y/.
  }
split.
qed ();



lemma "reintro_weaken"
  / forall (i : level) . 
      (forall (a : U i) (b : a -> U i) (c : forall (x : a) . b x -> U i) . void -> zero)
      : type /;

intro /i/.
fold /manual 0/.
typecheck.
reintro /x _ _ v/.
destruct /v/ /0/.
qed ();



lemma "eeqtp_symm"
  / forall i (a b : U i) . a <:> b -> a <:> b /;

intro /i a b H/.
symmetry.
symmetryIn /H/.
hyp /H/.
qed ();



lemma "set_extensionality"
  / forall i (a : U i) (b : a -> U i) (m n : { x : a | b x }) .
      m = n : a
      -> m = n : { x : a | b x } /;

intro /i a b m n Heq/.
infer /m/ /Hofm/.
destructSet /Hofm/ /H/.
clear /Hofm/.
extensionality >> auto.
qed ();



lemma "fixed"
  / pause (fix (fn t . void -> t)) /;

unroll /fix/ >> reduce /concl/.
unroll /fix/ >> reduce /concl/.
unroll /fix/ >> reduce /concl/.
unroll /pause/.
intro /_ _ 0/.
qed ();



defineRaw /myfix/
  / fn f . pause (fn x . f (pause x x)) (fn x . f (pause x x)) /;
val myfix = Namespace.resolve [`"myfix"];

structure R = Reduction;

val t1 = parseLTerm /myfix 0/;
val t2 = parseLTerm /0 (myfix 0)/;

val r1 =
  R.trans
    [
    R.unfold,
    R.beta 1,
    R.user1 PrimReduction.unroll_pause,
    R.beta 1
    ];

val r2 =
  R.within [1]
    (R.trans
       [
       R.unfold,
       R.beta 1
       ]);

Show.showLiteral (Normalize.simplifyAll (R.reduce r1 t1));
Show.showLiteral (Normalize.simplifyAll (R.reduce r2 t2));

val r = R.new1 myfix 1 t2 r1 r2;



lemma "paused"
  / pause (fn x . void -> pause x x) (fn x . void -> pause x x) /;

reduceUsing /\Reduction.user1 PrimReduction.unroll_pause\/.
whreduce /concl/.
unreduceUsing /\Reduction.user1 PrimReduction.unroll_pause\ with pause (fn x . void -> pause x x) (fn x . void -> pause x x)/.
reduceUsing /\Reduction.user1 PrimReduction.unroll_pause\/.
convertUnreduceUsing /\Reduction.user1 PrimReduction.unroll_pause\ with pause (fn x . void -> pause x x) (fn x . void -> pause x x)/.
unroll /pause/.
whreduce /concl/.
roll /pause (fn x . void -> pause x x) (fn x . void -> pause x x)/.
unroll /pause/.
showPosition /at 0/;
convertRoll /pause (fn x . void -> pause x x) (fn x . void -> pause x x) at 0/.
unroll /pause/.
reduce /concl/.
unroll /pause/.
reduce /concl/.
unroll /pause/.
reduce /concl/.
intro /0/.
qed ();



defineRaw /natind/
/
  fix (fn f n hz hs .
         nat_case n hz (fn n' . hs n' (f n' hz hs)))
/;


val t1 =
  parseLTerm
    / natind zero 1 0 /;

val r1 =
  R.trans
    [
    R.unfold,
    R.user1 PrimReduction.unroll_fix,
    R.beta 4,
    R.user2 PrimReduction.nat_case_zero
    ];

val natind_zero = R.new2 (parseConstant /natind/) 0 2 (parseConstant /zero/) 0 (Term.Var 1) r1 R.refl;

val t2a =
  parseLTerm
    / natind (succ 2) 1 0 /;

val r2a =
  R.trans
    [
    R.unfold,
    R.user1 PrimReduction.unroll_fix,
    R.beta 4,
    R.user2 PrimReduction.nat_case_succ,
    R.beta 1
    ];

val t2b =
    parseLTerm
      / 0 2 (natind 2 1 0) /;

val r2b =
  R.within [2] R.unfold;

val natind_succ = R.new2 (parseConstant /natind/) 0 2 (parseConstant /succ/) 1 t2b r2a r2b;

Define.register natind_zero;
Define.register natind_succ;



lemma "reduction"
  / unit /;

assert /natind 4 unit (fn _ a . nat & a) : type / /H/.
  {
  reduce /concl/.
  typecheck.
  }
reduce /H/.
split.
qed ();



defineRaw /mynatind/ / natind /;
val mynatind = Namespace.resolve [`"mynatind"];

val t1 = parseLTerm /mynatind (succ 2) 1 0/;
val t2 = parseLTerm /0 2 (mynatind 2 1 0)/;

val r1 =
  R.trans 
    [
    R.unfold,
    R.user2 natind_succ
    ];

val r2 = R.within [2] R.unfold;

Show.showLiteral (Normalize.simplifyAll (R.reduce r1 t1));
Show.showLiteral (Normalize.simplifyAll (R.reduce r2 t2));

val r = R.new2 mynatind 0 2 Prim.succ 1 t2 r1 r2;

Show.showLiteral (Normalize.simplifyAll (R.reduce (R.user2 r) t1));

val t1' = parseLTerm /mynatind zero 1 0/;
val t2' = parseLTerm /1/;

val r1' =
  R.trans
    [
    R.unfold,
    R.user2 natind_zero
    ];

Show.showLiteral (Normalize.simplifyAll (R.reduce r1' t1'));

val r' = R.new2 mynatind 0 2 Prim.zero 0 (Term.Var 1) r1' R.refl;

Show.showLiteral (Normalize.simplifyAll (R.reduce (R.user2 r') t1'));



lemma "myreduction_manual"
  / unit /;

assert /mynatind 4 unit (fn _ a . nat & a) : type / /H/.
  {
  reduce /concl/.
  showPosition /at 1/;
  reduceUsing /\R.trans [R.user2 r, R.beta 2]\ at pos 1/.
  showPosition /at 3/;
  reduceUsing /\R.trans [R.user2 r, R.beta 2]\ at pos 3/.
  showPosition /at 5/;
  reduceUsing /\R.trans [R.user2 r, R.beta 2]\ at pos 5/.
  showPosition /at 7/;
  reduceUsing /\R.trans [R.user2 r, R.beta 2]\ at pos 7/.
  showPosition /at 9/;
  reduceUsing /\Reduction.user2 r'\ at pos 9/.
  typecheck.
  }
split.
qed ();


Define.register r;
Define.register r';


lemma "myreduction"
  / unit /;

assert /mynatind 4 unit (fn _ a . nat & a) : type / /H/.
  {
  reduce /concl/.
  typecheck.
  }
reduce /H/.
split.
qed ();


defineRaw /mypause/ / fn x . x /;
val mypause = Namespace.resolve [`"mypause"];

val t1 = parseLTerm /mypause 0/;

val r1 =
  R.trans [R.unfold, R.beta 1];

Show.showLiteral (Normalize.simplifyAll (R.reduce r1 t1));

val r = R.new1 mypause 1 (Term.Var 0) r1 R.refl;

Show.showLiteral (Normalize.simplifyAll (R.reduce (R.user1 r) (ETerm.closed /mypause (nat -> nat)/)));



lemma "rewrite_subtype_of"
  / forall i (a b : U i) (x : a) .
      a <: b
      -> x : b /;

intro /i a b x H/.
assert /x : a/ /Hof/.
  {
  hypof.
  }
rewriteRaw /-> H in Hof/.
rewriteRaw /<- H/.
hypof.
qed ();


lemma "rewrite_subtype_of_forall"
  / forall i (a : U i) (b c : a -> U i) (x : a) (y : b x) .
      (forall x . b x <: c x)
      -> y : c x /;

intro /i a b c x y H/.
assert /y : b x/ /Hof/.
  {
  hypof.
  }
rewriteRaw /-> H in Hof/.
  {
  typecheck.
  }
rewriteRaw /<- H/.
Prover.pull 1;
  {
  hypof.
  }
hypof.
qed ();



lemma "rewrite_subtype_of_connectives"
  / forall i (a b c d : U i) (x : nat -> a) (y : d) .
      a <: b
      -> forall (n : nat) . c -> d & (x n : b) & d /;

intro /i a b c d x y H/.
assert /forall (n : nat) . c -> d & (x n : a) & d/ /Hof/.
  {
  intro /n Hc/.
  split.
    {
    hyp /y/.
    }
  split.
    {
    typecheck.
    }
  hyp /y/.
  }
rewriteRaw /-> H in Hof/.
rewriteRaw /<- H/.
intro /n Hc/.
split.
  {
  hyp /y/.
  }
split.
  {
  typecheck.
  }
hyp /y/.
qed ();



lemma "rewrite_subtype_of_capture"
  / forall i (a b : nat -> U i) (c d : U i) (x : forall (n : nat) . a n) (y : d) .
      (forall n . a n <: b n)
      -> forall (n : nat) . c -> d & (x n : b n) & d /;

intro /i a b c d x y H/.
assert /forall (n : nat) . c -> d & (x n : a n) & d/ /Hof/.
  {
  intro /n Hc/.
  split.
    {
    hyp /y/.
    }
  split.
    {
    typecheck.
    }
  hyp /y/.
  }
rewrite /-> H n within n in Hof/.
rewrite /<- H n within n/.
intro /n Hc/.
split.
  {
  hyp /y/.
  }
split.
  {
  typecheck.
  }
hyp /y/.
qed ();



lemma "rewrite_eeqtp_concl"
  / forall i (a b : U i) .
      a <:> b
      -> a
      -> b /;

intro /i a b Heq Ha/.
rewrite /<- Heq/.
hyp /Ha/.
qed ();



lemma "rewrite_eeqtp_hyp"
  / forall i (a b c : U i) (d : b -> U i) (x : a) .
      a <:> (b & c)
      -> (forall (y : b) . d y)
      -> d (x #1) /;

intro /i a b c d x Heq H/.
moveBefore /Heq/ /x/.
rewrite /-> Heq in x/.
destruct /x/ /y z/.
reduce /concl/.
apply /H/.
qed ();



lemma "rewrite_subtype_simple1"
  / forall i (a a' b b' : U i) .
      a <: a'
      -> b <: b'
      -> a & b
      -> a' & b' /;

intro /i a a' b b' Ha Hb H/.
destruct /H/ /H1 H2/.
split.
  {
  rewrite /<- Ha/.
  hyp /H1/.
  }

  {
  rewrite /-> Hb in H2/.
  hyp /H2/.
  }
qed ();



lemma "rewrite_subtype_simple2"
  / forall i (a a' b b' : U i) .
      a <: a'
      -> b <: b'
      -> a & b
      -> a' & b' /;

intro /i a a' b b' Ha Hb H/.
rewrite /-> Ha in H/.
rewrite /<- Hb/.
hyp /H/.
qed ();



lemma "multi_rewrite"
  / forall (m m' : nat) .
      m = m' : nat
      -> unit
      -> (m , m) = (m' , m') : (nat & nat) /;

unfold /arrow in concl at 1 0/.
intro /m m'/.
fold /_ -> _/.
fold /_ -> _/.
intro /Hm _/.
testRewrite /-> Hm in concl at 1 0/;
rewrite /-> Hm in concl at 1 0/.
reflexivity.
qed ();



lemma "generalize"
  / forall (f : nat -> nat) (m n : nat) . (forall n . f m = n : nat) -> f m = f n : nat /;

intro /f m n/.
generalize /f m/ /nat/ /x/.
generalizeAt /f n/ /nat/ [0] /y/.
intro /H/.
apply /H/.
qed ();



lemma "subst"
  / forall (n : nat) . n = 0 : nat -> n = 0 : nat /;

intro /n H/.
symmetryIn /H/.
subst /n/.
reflexivity.
qed ();



lemma "substitution"
  / forall (n : nat) . n = 0 : nat -> n = 0 : nat /;

intro /n H/.
substitution /n/ /0/.
  {
  hyp /H/.
  }
reflexivity.
qed ();



lemma "revert"
  / forall i (a : U i) (x y : a) . x = y : a -> x = y : a /;

intro /i a x y Heq/.
revert /y x Heq/.
intro /y x Heq/.
hyp /Heq/.
qed ();



lemma "extensionality"
/
  forall i (a : U i) (b c : a -> U i) (d : forall x . c x -> U i) .
    (fn t .
       forall (m n : t) .
         (forall x y . m x y #1 = n x y #1 : c x)
         -> (forall x y . m x y #2 #1 = n x y #2 #1 : d x (m x y #1))
         -> m = n : t)
    (forall (x : a) . b x -> exists (z : c x) . d x z & (x : a))
/;

reduce /concl/.
intro /i a b c d m n H1 H2/.
  {
  reintro /x y/.
  symmetry.
  apply /H1/.
  }
extensionalityAuto.
  {
  reintro /x y/.
  apply /H1/.
  }

  {
  reintro /x y Heq/.
  apply /H2/.
  }
qed ();



lemma "extensionality_arrows"
  / forall i (a : U i) (b c d e : a -> U i) .
      (fn t .
         forall (m n : t) .
           (forall x y z w . m x y z w = n x y z w : e x)
           -> m = n : t)
      (forall (x : a) . b x -> c x -t> d x -k> e x) /;

reduce /concl/.
intro /i a b c d e m n H/.
introEq /x y z w/.
apply /H/.
qed ();



lemma "extensionality_arrows_auto"
  / forall i (a : U i) (b c d e : a -> U i) .
      (fn t .
         forall (m n : t) .
           (forall x y z w . m x y z w = n x y z w : e x)
           -> m = n : t)
      (forall (x : a) . b x -> c x -t> d x -k> e x) /;

reduce /concl/.
intro /i a b c d e m n H/.
extensionalityAuto.
apply /H/.
qed ();



lemma "extensionality_future"
  / forall i (a b : U i) (m n : a -> future b) .
      (forall x .
         let next z = m x
         in
         let next z' = n x
         in
           future (z = z' : b))
      -> m = n : (a -> future b) /;

intro /i a b m n H1/.
introEq /x/.
so /H1 x/ /H2/.
clear /H1/.
revert /H2/.
generalize /m x/ /_/ /m'/.
generalize /n x/ /_/ /n'/.
intro /H2/.
clear /m n x/.
destruct /m'/ /[m'']/.
destruct /n'/ /[n'']/.
whreduce /H2/.
destruct /H2/ /[H3]/.
extensionality.
hyp /H3/.
qed ();



lemma "extensionality_future2"
  / forall i (a : U i) (b c : a -> U i)
      (m n : forall (x : a) . b x -> future (c x)) .
        (forall (x : a) (y : b x) .
           let next z = m x y 
           in
           let next z' = n x y
           in
             future (z = z' : (c x)))
        -> m = n : (forall (x : a) . b x -> future (c x)) /;
      
intro /i a b c m n H1/.
introEq /x y/.
so /H1 x y/ /H2/.
clear /H1/.
revert /H2/.
generalize /m x y/ /_/ /m'/.
generalize /n x y/ /_/ /n'/.
intro /H2/.
clear /m n y/.
destruct /m'/ /[m'']/.
destruct /n'/ /[n'']/.
whreduce /H2/.
destruct /H2/ /[H3]/.
extensionality.
hyp /H3/.
qed ();



lemma "extensionality_future_then_more"
/
  forall i (a b c : U i) (m n : a -> future (b -> c)) .
    (forall x .
       let next z = m x
       in
       let next z' = n x
       in
         future (forall y . z y = z' y : c))
    -> m = n : (a -> future (b -> c))
/;

inference.
intro /i a b c m n Heq/.
introEq /x/.
so /Heq x/ /H1/.
revert /H1/.
generalize /m x/ /_/ /m'/.
generalize /n x/ /_/ /n'/.
intro /H1/.
destruct /m'/ /[m'']/.
destruct /n'/ /[n'']/.
reduce /H1/.
destruct /H1/ /[H2]/.
extensionality.
reduce //.
introEq /y/.
apply /H2/.
qed ();



(* Setting up for rewriting tests:

   leq is compatible with add and succ
   leq is reflexive and transitive
   leq through leq becomes implication (contravariant in first position)
   eqnat is symmetric
   eqnat weakens to leq
   eqnat through natop becomes equality (why? who knows)

   Note:
   eqnat would actually imply equality, but we'll ignore that for the purpose of these tests.
   no idea what natop is actually supposed to mean; again, just for the tests
*)

val eqnat = Namespace.declare (`"eqnat") NONE;
val add = Namespace.declare (`"add") NONE;
val natop = Namespace.declare (`"natop") NONE;


Unsafe.allow ();
structure H = ConstantTable;


lemma "eqnat_istp"
  / forall (m n : nat) . eqnat m n : type /;

trustme.
Prover.qed ();
H.insert TypecheckInternal.istpTactics eqnat (witnessRaw /eqnat_istp _ _/);


lemma "add_type"
  / add : nat -> nat -> nat /;

trustme.
Prover.qed ();
recordTyping "add_type";


lemma "natop_type"
  / natop : nat -> nat /;

trustme.
Prover.qed ();
recordTyping "natop_type";


lemma "succ_compat_leq"
  / forall (m n : nat) . m <= n -> succ m <= succ n /;

trustme.
Prover.qed ();


lemma "add_compat_leq"
  / forall (m m' n n' : nat) . m <= m' -> n <= n' -> add m n <= add m' n' /;

trustme.
Prover.qed ();


lemma "natop_compat_eqnat"
  / forall (m n : nat) . eqnat m n -> natop m = natop n : nat /;

trustme.
Prover.qed ();


lemma "eqnat_symm"
  / forall (m n : nat) . eqnat m n -> eqnat n m /;

trustme.
Prover.qed ();


lemma "eqnat_impl_leq"
  / forall (m n : nat) . eqnat m n -> m <= n /;

trustme.
qed ();


val leq = parseConstant /Nat.leq/;

structure B = BackchainInternal;

H.insert EqualityTacticInternal.reflexivityTactics (parseConstant /Nat.leq/)
(B.witnessPriority /Nat.leq_refl _/);

H.insert EqualityTacticInternal.symmetryTactics eqnat
(andthenOn 0 (B.witnessPriority /eqnat_symm _ _ __/));

H.insert EqualityTacticInternal.transitivityTactics (parseConstant /Nat.leq/)
(fn n => B.witnessPriority /Nat.leq_trans _ l` \n\ _ __ __/);

H.insert RewriteInternal.weakeningTable eqnat 
[(leq, true, andthenOn 0 (B.witnessPriority /eqnat_impl_leq _ _ __/))];



lemma "symmetries"
  / forall (m n : nat) . m = n : nat -> m = n : nat /;

intro /m n H/.
symmetryIn /H/.
symmetry.
hyp /H/.
qed ();



lemma "symmetries_eqnat"
  / forall (m n : nat) . eqnat m n -> eqnat m n /;

intro /m n H/.
symmetryInRaw /H/.
  {
  typecheck.
  }

  {
  typecheck.
  }
symmetry.
hyp /H/.
qed ();



Namespace.alias (parseIdent /leq/) (parseConstant /Nat.leq/);



lemma "leq_implication"
  / forall (m m' n n' : nat) .
      leq m' m
      -> leq n n'
      -> leq m n
      -> leq m' n' /;

intro /m m' n n' Hm Hn H/.
transitivity /m/.
  {
  hyp /Hm/.
  }
transitivity /n/.
  {
  hyp /H/.
  }
hyp /Hn/.
qed ();



List.app 
  (fn (hconst, i, const1, const2, cov, tacfn) => 
     RewriteInternal.CICTable.insert RewriteInternal.compatibilityTable (hconst, i, const1) (const2, cov, tacfn))
  [
  (Prim.succ, 0, leq, leq, true,
   andthenOn 0 (B.witnessPriority /succ_compat_leq _ _ __/)),

  (natop, 0, eqnat, Prim.eq, true,
   andthenOn 0 (B.witnessPriority /natop_compat_eqnat _ _ __/)),

  (add, 0, leq, leq, true,
   andthenOn 0 (B.witnessPriority /add_compat_leq _ _ _ _ __ __/)),

  (add, 1, leq, leq, true,
   andthenOn 1 (B.witnessPriority /add_compat_leq _ _ _ _ __ __/)),

  (leq, 0, leq, Prim.arrow, false,
   andthenOn 0 (B.witnessPriority /leq_implication _ _ _ _ __ __/)),

  (leq, 1, leq, Prim.arrow, true,
   andthenOn 1 (B.witnessPriority /leq_implication _ _ _ _ __ __/)),
  ];



lemma "rewrite_leq"
  / forall i (a b c : U i) (m n n' p : nat) .
      (a -> void % b & leq m (add n p) & c % void)
      -> leq n n'
      -> a
      -> leq m (add n' p) /;
 
intro /i a b c m n n' p H Hleq Ha/.
moveBefore /Hleq/ /H/.
rewrite /-> Hleq in H/.
so /H Ha/ /0 | H1 | 0/.
apply /H1/.
qed ();



lemma "rewrite_leq_exists"
  / forall i (a : U i) (b : a -> U i) (m n n' p : nat) .
      (exists (x : a) . b x -> leq m (add n p))
      -> leq n n'
      -> exists (x : a) . b x -> leq m (add n' p) /;
 
intro /i a b m n n' p H Hleq/.
moveBefore /Hleq/ /H/.
rewrite /-> Hleq in H/.
hyp /H/.
qed ();



lemma "rewrite_leq_forall"
  / forall i (a : U i) (b : a -> U i) (m n n' p : nat) .
      (forall (x : a) . b x -> leq m (add n p))
      -> leq n n'
      -> forall (x : a) . b x -> leq m (add n' p) /;
 
intro /i a b m n n' p H Hleq x Ha/.
moveBefore /Hleq/ /H/.
testRewrite /-> Hleq in H , <- Hleq/;
rewrite /-> Hleq in H/.
apply /H/ >>> [hyp /Ha/, idtac].
(* Should see:
i : level
a : U i
b : a -> U i
m : nat
n : nat
n' : nat
p : nat
Hleq : n <= n'
H : forall (x : a) . b x -> m <= add n' p
x : a
Ha : b x
|-
x : a
*)
hypof.
qed ();



lemma "rewrite_leq_dom"
  / forall i (a : U i) (m n p p' : nat) .
      (leq m (add n p) -> a)
      -> leq p' p
      -> leq m (add n p')
      -> a /;
 
intro /i a m n p p' H Hleq Hmnp/.
moveBefore /Hleq/ /H/.
rewrite /<- Hleq in H/.
apply /H/.
hyp /Hmnp/.
qed ();



lemma "rewrite_leq_set"
  / forall (a : U 0) (b : a -> U 0) (m : a -> nat) (n n' p : nat)
      (s : { x : a | leq (m x) (add n p) }) .
      eqnat n n'
      -> b s
      -> { leq (m s) (add n' p) } /; 

intro /a b m n n' p s Heq/.
assert /s : a/ /Hs/.
  {
  destruct /s/ /[s _]/.
  hypof.
  }
intro /H/.
moveBefore /Heq/ /s/.
testRewrite /-> Heq in s/;
rewrite /-> Heq in s/.
destruct /s/ /[s Hs']/.
split.
hyp /Hs'/.
qed ();



lemma "rewrite_eqnat"
  / forall i (a : U i) (m n n' p : nat) .
      (a -> leq m (add n p))
      -> eqnat n n'
      -> a
      -> leq m (add n' p) /;
 
intro /i a m n n' p H Heq Ha/.
moveBefore /Heq/ /H/.
rewrite /-> Heq in H/.
rewrite /<- Heq in H/.
rewrite /<- Heq/.
rewrite /-> Heq/.
rewrite /<- Heq/.
apply /H/.
hyp /Ha/.
qed ();



lemma "rewrite_to_equality"
  / forall i (a : U i) (b : nat -> U i) (m n : nat) .
      b (natop m)
      -> eqnat m n
      -> b (natop n) /;

intro /i a b m n H Heq/.
moveBefore /Heq/ /H/.
rewrite /<- Heq/.
rewrite /-> Heq/.
rewrite /-> Heq in H/.
rewrite /<- Heq in H/.
rewrite /-> Heq in H/.
hyp /H/.
qed ();



lemma "rewrite1"
  / forall i (a b : U i) (c : (a -> a -> b) -> U i) (f g : a -> b) .
       (f = g : (a -> b))
       -> c (fn y x . f x)
       -> c (fn y x . g x) /;

intro /i a b c f g Heq H/.
rewrite /<- Heq/.
witness /H/.
Prover.qed ();



lemma "rewrite2"
  / forall i (a b d : U i) (c : (a -> a -> b) -> U i) (f g : a -> b) .
       (d -> f = g : (a -> b))
       -> d
       -> c (fn y x . f x)
       -> c (fn y x . g x) /;

intro /i a b d c f g Heq Hd H/.
rewrite /-> Heq in H/.
  {
  hyp /Hd/.
  }
hyp /H/.
Prover.qed ();



lemma "rewrite3"
  / forall i (a b : U i) (c : b -> U i) (f g : a -> b) (x : a) .
       (forall (x : a) . f x = g x : b)
       -> c (f x)
       -> c (g x) /;

intro /i a b c f g x Heq H/.
rewrite /<- Heq/.
hyp /H/.
Prover.qed ();



lemma "rewrite4"
  / forall i (a b : U i) (c : b -> U i) (f g : a -> b) (x : a) .
       (forall (x : a) . f x = g x : b)
       -> c (f x)
       -> c (g x) /;

intro /i a b c f g x Heq H/.
rewrite /-> Heq in H/.
hyp /H/.
Prover.qed ();



lemma "rewrite5"
  / forall i (a b : U i) (c : (a -> a -> b) -> U i) (f g : a -> b) .
       (forall (x : a) . f x = g x : b)
       -> c (fn y x . f x)
       -> c (fn y x . g x) /;

intro /i a b c f g Heq H/.
rewrite /-> Heq within _ in H/.
witness /H/.
Prover.qed ();



lemma "replace"
  / forall i (a : U i) (b : a -> U i) (x y : a) . (y = x : a) -> b x -> b y /;

intro /i a b x y Heq H/.
testRewrite /\Rewrite.replaceRew [] /y/ /x/ /a/\ in concl/;
testRewrite /y = x : a/;
rewrite /y = x : a/.
  {
  hyp /Heq/.
  }
hyp /H/.
Prover.qed ();



lemma "replace_hyp"
  / forall i (a : U i) (b : a -> U i) (x y : a) . (y = x : a) -> b x -> b y /;

intro /i a b x y Heq H/.
testRewrite /\Rewrite.replaceRew [] /x/ /y/ /a/\ in H/;
rewrite /x = y : a in H at 0/.
  {
  symmetry.
  hyp /Heq/.
  }
hyp /H/.
Prover.qed ();



lemma "replace_binder"
  / forall i (a b : U i) (c : (a -> a -> b) -> U i) (f g : a -> b) .
       (f = g : (a -> b))
       -> c (fn y x . f x)
       -> c (fn y x . g x) /;

intro /i a b c f g Heq H/.
testRewrite /\Rewrite.replaceRew (parseOIdents /x/) /g x/ /f x/ /b/\ in concl/;
rewrite /g x = f x : b within x/.
  {
  symmetry.
  rewrite /-> Heq/.
  reflexivity.
  }
hyp /H/.
Prover.qed ();



lemma "replace_binder_hyp"
  / forall i (a b : U i) (c : (a -> a -> b) -> U i) (f g : a -> b) .
       (f = g : (a -> b))
       -> c (fn y x . f x)
       -> c (fn y x . g x) /;

intro /i a b c f g Heq H/.
testRewrite /\Rewrite.replaceRew (parseOIdents /x/) /f x/ /g x/ /b/\ in H/;
rewrite /f x' = g x' : b within x' in H/.
  {
  reintro /x'/.
  rewrite /-> Heq/.
  reflexivity.
  }
hyp /H/.
Prover.qed ();



lemma "replace_with_evar"
  / forall i (a b : U i) (c : (a -> a -> b) -> U i) (f g : a -> b) .
       (forall (x : a) . f x = g x : b)
       -> c (fn y x . f x)
       -> c (fn y x . g x) /;

intro /i a b c f g Heq H/.
let val e = Term.evar () in rewrite /g \e\ = f \e\ : b within _/ end.
  {
  symmetry.
  apply /Heq/.
  }
hyp /H/.
Prover.qed ();



lemma "unfold"
  / forall i (a : U i) . (a -> a) -> a -> a /;

unfold /arrow in concl at 2/.
showPosition /concl at 11/;
reduce /concl/.
showPosition /concl at 11/;
convert /((fn v0 v1 . forall (v2 : v0) . v1) a a) within a in concl at pos 11/.
fold /arrow/.
unfold /arrow in concl at 2/.
showPosition /concl at 11/;
whreduce /concl at 11/.
testRewrite /\Rewrite.foldRew (parseOIdents /a/) /a -> a/\ in concl at 0/;
idtac.
fold /a -> a within a in concl at 0/.
intro /i a x y/.
unfold /arrow in x/.
whreduce /x at 0/.
showPosition /x at 0/;
convert /((fn v0 v1 . forall (v2 : v0) . v1) a a) in x at 0/.
reduce /x/.
showPosition /x at 1/;
fold /a -> a in x/.
apply /x/.
hyp /y/.
Prover.qed ();



lemma "compatibility"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) (f : forall (x : a) . b x -> c -> d & e) (x x' : a) (y y' : b x) (z : c) .
      x = x' : a
      -> y = y' : b x
      -> f x' y z #1 = f x y' z #1 : d /;

intro /i a b c d e f x x' y y' z Heqx Heqy/.
compat.
  {
  symmetry.
  hyp /Heqx/.
  }

  {
  subsume /b x/.
    {
    intro /h/.
    eeqtp.
    Prover.pull 1;
      {
      hypof.
      }
    compat.
    hyp /Heqx/.
    }
  hyp /Heqy/.
  }
Prover.qed ();



lemma "reorder"
 / forall i (a : U i) (x1 x1' x2 x2' x3 x3' x4 x4' x5 x5' : a) (f : a -> a -> a -> a -> a -> a).
     x1 = x1' : a
     -> x2 = x2' : a
     -> x3 = x3' : a
     -> x4 = x4' : a
     -> x5 = x5' : a
     -> f x1 x2 x3 x4 x5 = f x1' x2' x3' x4' x5' : a /;

intro /i a x1 x1' x2 x2' x3 x3' x4 x4' x5 x5' f h1 h2 h3 h4 h5/.
Reorder.reorder compat (Reorder.rotateBackward 2)
>>> [hyp /h4/, hyp /h5/, hyp /h1/, hyp /h2/, hyp /h3/].
Prover.qed ();



lemma "refl"
  / 1 = 1 : nat /;

reflexivity.
Prover.qed ();



lemma "refl_type"
  / nat = nat : type /;

reflexivity.
Prover.qed ();



lemma "refl_subtype"
  / nat <: nat /;

reflexivity.
Prover.qed ();



lemma "symm"
  / 1 = 2 : nat /;

symmetry.
symmetry.
Prover.abandon ();



lemma "symm_type"
  / nat = bool : type /;

symmetry.
symmetry.
Prover.abandon ();



lemma "backchain"
  / forall i (a b : U i) (c d : a -> U i) (f : a -> a) (y : a) .
      (exists (z : a) . unit & (forall (x x' : a) . b -t> d z -k> d x' -> unit & (c (f x) -> d x)))
      -> d (f y) /;

intro /i a b c d f y g/.
apply /g #2/.
(* Should see:
[goal 4]
[ambiguous typing obligation]
E6842 : a

[goal 3]
c (f (f y))

[goal 2]
d E6842

[goal 1]
d (g #1)

[goal 0]
i : level
a : U i
b : U i
c : a -> U i
d : a -> U i
f : a -> a
y : a
g : exists (z : a) .
      unit
      & (forall (x : a) (x' : a) .
           b -t> d z -k> d x' -> unit & (c (f x) -> d x))
|-
b
*)
Prover.abandon ();



lemma "exploit"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : exists (y : a) . b y -> c -> (d -> e) & a) .
      b (f #1) -> c -> d -> e /;

intro /i a b c d e f x y z/.
exploit /f #2/ /H/.
  {
  hyp /x/.
  }

  {
  hyp /y/.
  }

  {
  apply /H/.
  hyp /z/.
  }
Prover.qed ();



lemma "eexploit"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : forall (y : a) . b y -> c -> (d -> e) & a)
      (w : a) .
      b w -> c -> d -> e /;

intro /i a b c d e f w x y z/.
eexploit /f/ /H/.
(* Should see:
[goal 3]
[ambiguous typing obligation]
E6984 : a

[goal 2]
e

[goal 1]
c

[goal 0]
i : level
a : U i
b : a -> U i
c : U i
d : U i
e : U i
f : forall (y : a) . b y -> c -> (d -> e) & a
w : a
x : b w
y : c
z : d
|-
b E6984
*)
  {
  hyp /x/.
  }

  {
  hyp /y/.
  }

  {
  apply /H/.
  hyp /z/.
  }

  {
  typecheck.
  }
Prover.qed ();



lemma "witness"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : exists (y : a) . b y -> c -> (d -> e) & a) .
      b (f #1) -> c -> d -> e /;

intro /i a b c d e f x y z/.
witness /f #2 __ y #1 z/.
hyp /x/.
Prover.qed ();



lemma "so"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : exists (y : a) . b y -> c -> (d -> e) & a) .
      b (f #1) -> c -> d -> e /;

intro /i a b c d e f x y z/.
so /f #2 x __ #1 _/ /H/.
(* Should see:
[goal 2]
[ambiguous typing obligation]
E7123 : d

[goal 1]
e

[goal 0]
i : level
a : U i
b : a -> U i
c : U i
d : U i
e : U i
f : exists (y : a) . b y -> c -> (d -> e) & a
x : b (f #1)
y : c
z : d
|-
c
*)
  {
  hyp /y/.
  }

  {
  hyp /H/.
  }

  {
  Tactic.refine (Rule.hypothesisOf 0).
  }
Prover.qed ();



lemma "so_pattern"
  / forall i (a b c d : U i)
      (f : a -> b -> c % d) (g : c -> d).
      a -> b -> d /;

intro /i a b c d f g x y/.
so /f x __/ /(H1 | H2)/.
  {
  witness /y/.
  }

  {
  apply /g/.
  witness /H1/.
  }

  {
  witness /H2/.
  }
Prover.qed ();



lemma "nonidentical_eqtype"
  / (forall x y . unit -> squash (x = y : nat)) = (forall x y . unit -t> squash (y = x : nat)) : type /;

typecheck1.
1:{
  reintro /x/.
  typecheck1.
  1:{
    reintro /y/.
    withTypecheck $ repeat typecheck1.
      {
      reintro /H/.
      symmetry.
      hyp /H/.
      }

      {
      reintro /H/. 
      symmetry.
      hyp /H/.
      }
    }
    
    {
    reflexivity.
    }
  }

  {
  reflexivity.
  }
qed ();



lemma "intro_destruct"
  / forall 
      (x : exists (a : future (unit % nat)) . 
             (let next a' = a in future (exists z . a' = inr z : (unit % nat))) -> void)
      (y : { y : (unit % nat) | y = inl () : (unit % nat) }) .
      future (x #1 #prev = y : (unit % nat)) /;

intro /([ a ] f) (z H)/.
split.
unhide.
destruct /a/ /| a/.
  {
  symmetry.
  hyp /H/.
  }

  {
  so /f (next (a , ()))/ /Hfalse/.
  destruct /Hfalse/ /0/.
  }
qed ();



lemma "typecheck1"
  / forall (f : nat -> nat) (x : nat) . (forall (y : nat). f y : bool) -> f x : bool /;

intro /f x/.
introRaw /H/.
1:{
  typecheck.
  }
reintro /y/.
typecheck1 >>> [typecheck, idtac].
typecheck1.
infer /f y/ /_/.
Prover.abandon ();



lemma "typecheck2"
  / forall i (a : U i) (b : a -> U i) (f : forall (y : a) . a & b y) (x : a) . next (inl (f x #2 , x)) : future (b x & a % void) /;

intro /i a b f x/.
typecheck.
Prover.qed ();



lemma "typecheck3"
  / forall i (a : U i) (x y : a) (f : a -> unit % a) . sum_case (f x) (fn z . y) (fn z . z) : a/;

intro /i a x y f/.
typecheck.
Prover.qed ();



lemma "typecheck4"
  / forall i (a b : U i) (f : a -> b) (g : nat -> future a) . letnext (g 2) (fn y . next (f y)) : future b /;

intro /i a b f x/.
typecheck.
Prover.qed ();



lemma "typecheck5"
  / forall i (a : U i) (f : nat -> void) . abort (f 1) : a /;

intro /i a f/.
typecheck.
Prover.qed ();



lemma "and_or"
  / (unit % void) & unit /;

split.
  {
  left.
  split.
  }

  {
  split.
  }
qed ();



lemma "absurdum"
  / (exists (x : nat) . void % (unit & void) ) -> 0 = 1 : nat /;

intro /x/.
destruct /x/ /_ (0 | y 0) /.
qed ();



lemma "destruction"
  / forall i (f : (unit % nat) -> univ i) (x : (unit % nat) & f (inl ()) & (forall (x : nat) . f (inr x))) . 
      f (x #1) /;

intro /i f x/.
destruct /x/ /(| n) ht ?/.
  {
  hyp /ht/.
  }

  {
  reintro /hf/.
  exact /hf n/.
  }
qed ();



lemma "test_formation"
  / forall i (a b : U(i)) . arrow a b = tarrow a b : type /;

intro /i a b/.
typecheck1.
  {
  hypof.
  }

  {
  hypof.
  }
qed ();



lemma "rectype_formation"
  / forall i . (rec a . future (a -> a)) : U(i) /;

Typecheck.withTypecheck $ introRaw /i/.
qed ();



lemma "rectype_formation_type"
  / (rec a . future (a -> a)) : type /;

RuleTactic.recForm.
reintro /a/.
typecheck1.
typecheck1.
  {
  hypof.
  }

  {
  clear /v0/.
  hypof.
  }
qed ();


lemma "set_formation"
  / forall (i : level) . { x : nat | x = 0 : nat } = { x : nat | 0 = x : nat } : U(i) /;

intro /i/.
typecheck.
  {
  reintro /x Heq/.
  symmetry.
  hyp /Heq/.
  }

  {
  reintro /x Heq/.
  symmetry.
  hyp /Heq/.
  }
qed ();



lemma "void_implies_void"
  /void -> void -> void/;

intro /x y/.
moveAfter /x/ /y/.
rename /x/ /z/.
clear /y/.
hyp /z/.
qed ();



lemma "all_whatever"
  / iforall (x : unit) . unit /;

intro /x/.
split.
qed ();



lemma "test_lrule"
  /forall (x : (exists (v : void) . void)) . (x : void) -> x : void/;

intro /x/.
introRaw /w/.
  {
  destruct /x/ /x y/.
  destruct /y/ /0/.
  }

  {
  typecheck.
  }
qed ();



lemma "foo"
  /void -> void -> void/;

apply /void_implies_void/.
qed ();



lemma "void_implies_void_form"
  / (forall (_ : void) . void -> void) : type /;

typecheck1.
  { typecheck. }
reintro /x/.
typecheck1.
  {
  typecheck1.
  }
reintro /y/.
typecheck1.
qed ();



lemma "bar"
  / forall (i : level) (a : U(i)) . a -> a /;

intro /i a x/.
hyp /x/.
qed ();
