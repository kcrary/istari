
Message.squelch := 1;


Ctrl.use "../core/acc-load.iml";
Ctrl.use "../core/nat-load.iml";
Ctrl.use "../core/integer-load.iml";

recordIrrelevance Prim.ap [1];
recordIrrelevance Prim.paramapp [1];

fun shouldfail tac goal fk sk = tac goal (fn _ => idtac goal fk sk) (fn _ => fk "unexpected success");

structure P = ReductionProver;



lemma "substitute_later"
/
  forall i (a : U i) (P Q : forallfut (_ : a) . U i) . forallfut (x y : a) .
    future (x = y : a)
    -> (P y -> Q y)
    -> P x
    -> Q x
/;

inference.
intro /i a P Q x y Heq Himpl HP/.
destruct /Heq/ /[Heq]/.
subst /x/.
auto.
qed ();



lemma "substitute_present_using_later"
/
  forall i (a : U i) (P Q : a -> U i) (x y : a) .
    future (x = y : a)
    -> P x
    -> P y
/;

inference.
intro /i a P Q x y Heq HP/.
destruct /Heq/ /[Heq]/.
shouldfail $ subst /x/.
Prover.abandon ();



lemma "unionElim_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) (d : U i) . intersect (x : a) .
  forall (f : parametric (_ : a) . union (y : b) . c y) (g : parametric (y : b) . forall (z : c y) . d) .
    d
/;

inference.
intro /i a b c d x f g/.
RuleTactic.unionElim (parseCurr /b/) (parseCurr /additional` y . c y/) (parseCurr /f Ap x/).
  {
  reintro /y z/.
  exact /g Ap y z/.
  }

  {
  infer /f Ap x/ /H/.
  hyp /H/.
  }
qed ();



lemma "unionElimDep_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) (d : (union (y : b) . c y) -> U i) . intersect (x : a) .
  forall (f : parametric (_ : a) . union (y : b) . c y) (g : parametric (y : b) . forall (z : c y) . d z) .
    d (f Ap x)
/;

inference.
intro /i a b c d x f g/.
RuleTactic.unionElimDep (parseCurr /b/) (parseCurr /additional` y . c y/) (parseCurr /additional` z . d z/) (parseCurr /f Ap x/).
  {
  reintro /y z/.
  exact /g Ap y z/.
  }

  {
  infer /f Ap x/ /H/.
  hyp /H/.
  }
qed ();



lemma "iexistsElim_irrelevant_hidden"
/
  forall i (a : U i) (b : Kind i) (c : b -> U i) (d : U i) . intersect (x : a) .
  forall (f : parametric (_ : a) . iexists (y : b) . c y) (g : parametric (y : b) . forall (z : c y) . d) .
    d
/;

inference.
intro /i a b c d x f g/.
RuleTactic.iexistsElim (parseCurr /additional` y . c y/) (parseCurr /i/) (parseCurr /b/) (parseCurr /f Ap x/).
  { auto. }
  { auto. }

  {
  reintro /y z/.
  exact /g Ap y z/.
  }

  {
  infer /f Ap x/ /H/.
  hyp /H/.
  }
qed ();



lemma "iexistsElimDep_irrelevant_hidden"
/
  forall i (a : U i) (b : Kind i) (c : b -> U i) (d : (iexists (y : b) . c y) -> U i) . intersect (x : a) .
  forall (f : parametric (_ : a) . iexists (y : b) . c y) (g : parametric (y : b) . forall (z : c y) . d z) .
    d (f Ap x)
/;

inference.
intro /i a b c d x f g/.
RuleTactic.iexistsElimDep (parseCurr /additional` y . c y/) (parseCurr /additional` z . d z/) (parseCurr /i/) (parseCurr /b/) (parseCurr /f Ap x/).
  { auto. }
  { auto. }

  {
  reintro /y z/.
  exact /g Ap y z/.
  }

  {
  infer /f Ap x/ /H/.
  hyp /H/.
  }
qed ();



lemma "boolElim_irrelevant_hidden"
/
  forall i (a : U i) (c : bool -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . bool) (g : forall (y : bool) . c y) .
    c (f Ap x)
/;

inference.
intro /i a c x f g/.
RuleTactic.boolElim (parseCurr /additional` y . c y/) (parseCurr /f Ap x/).
  { auto. }
  { auto. }
  { auto. }
qed ();



lemma "muInd_irrelevant_hidden"
/
  forall i (a b : U i) (c : (mu t . b) -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : mu t . b) . c y) .
    c (f Ap x)
/;
 
inference.
intro /i a b c x f g/.
RuleTactic.muInd (parseCurr /additional` _ . b/) (parseCurr /additional` y . c y/) (parseCurr /f Ap x/).
  { auto. }
  { auto. }

  {
  reintro /t y _ _/.
  assert /y : mu t . b/ /Hof/.
    {
    unrollType /mu/.
    hypof.
    }
  apply /g/.
  }

  {
  unrollType /mu/.
  typecheck.
  }
qed ();



lemma "muIndUniv_irrelevant_hidden"
/
  forall i (a b : U i) (c : (mu t . b) -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : mu t . b) . c y) .
    c (f Ap x)
/;
 
inference.
intro /i a b c x f g/.
RuleTactic.muIndUniv (parseCurr /additional` _ . b/) (parseCurr /additional` y . c y/) (parseCurr /i/) (parseCurr /f Ap x/).
  { auto. }
  { auto. }
  { auto. }

  {
  reintro /t y _ _/.
  assert /y : mu t . b/ /Hof/.
    {
    unrollType /mu/.
    hypof.
    }
  split >> auto.
  }

  {
  unrollType /mu/.
  typecheck.
  }
qed ();



lemma "accInd_irrelevant_hidden"
/
  forall i (a : U i) (c : nat -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . nat) (g : forall (y : nat) . c y) .
    c (f Ap x)
/;

inference.
intro /i a c x f g/.
so /Nat.lt_well_founded (f Ap x)/ /H/.
RuleTactic.accInd (parseCurr /nat/) (parseCurr /additional` y . c y/) (parseCurr /i/) (parseCurr /f Ap x/) (parseCurr /H/) (parseCurr /Nat.lt/).
  { auto. }
  { auto. }
  { auto. }
  { auto. }
  { auto. }
qed ();



lemma "setIntro_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : b) . c y) .
    { y : b | c y }
/;

inference.
intro /i a b c x f g/.
exists /f Ap x/.
apply /g/.
qed ();



lemma "isetIntro_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : b) . c y) .
    iset (y : b) . c y
/;

inference.
intro /i a b c x f g/.
exists /f Ap x/.
apply /g/.
qed ();



lemma "futureElim_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : b) . c y) .
    let next y = next (f Ap x) in future (c y)
/;

inference.
intro /i a b c x f g/.
unfold /letnext/.
RuleTactic.futureElim (parseCurr /b/) (parseCurr /additional` y . future (c y)/) (parseCurr /next (f Ap x)/).
  { auto. }
  { auto. }
  { auto. }
qed ();



lemma "sumElim_irrelevant_hidden"
/
  forall i (a b c : U i) (d : b % c -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b % c) (g : forall (y : b) . d (inl y)) (h : forall (y : c) . d (inr y)) .
    d (f Ap x)
/;

inference.
intro /i a b c d x f g h/.
RuleTactic.sumElim (parseCurr /b/) (parseCurr /c/) (parseCurr /additional` y . d y/) (parseCurr /f Ap x/).
  { auto. }
  { auto. }
  { auto. }
qed ();



lemma "generalize_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : b) . c y) .
    c (f Ap x)
/;

inference.
intro /i a b c x f g/.
generalize /f Ap x/ /_/ /y/.
apply /g/.
qed ();



lemma "forallLeft_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : b) . c y) .
    c (f Ap x)
/;

inference.
intro /i a b c x f g/.
RuleTactic.forallLeft (Term.Sub (parseCurr /f Ap x/, Term.Dot (Term.Const Prim.orphan, Term.id))).
  {
  typecheck.
  }

  {
  hyp /g/.
  }
qed ();



lemma "forallElim_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : forall (y : b) . c y) .
    c (f Ap x)
/;

inference.
intro /i a b c x f g/.
RuleTactic.forallElim (parseCurr /b/) (parseCurr /additional` y . c y/) (parseCurr /f Ap x/).
  {
  hyp /g/.
  }

  {
  typecheck.
  }
qed ();



lemma "parametricElim_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : parametric (y : b) . c y) .
    c (f Ap x)
/;

inference.
intro /i a b c x f g/.
RuleTactic.parametricElim (parseCurr /b/) (parseCurr /additional` y . c y/) (parseCurr /f Ap x/).
  {
  hyp /g/.
  }

  {
  typecheck.
  }
qed ();



lemma "existsIntro_irrelevant_hidden"
/
  forall i (a b : U i) (c : b -> U i) . intersect (x : a) . 
  forall (f : parametric (_ : a) . b) (g : parametric (y : b) . c y) .
    exists (y : b) . c y
/;

inference.
intro /i a b c x f g/.
exists /f Ap x/.
apply /g/.
qed ();



lemma "let_using_irrelevant_hidden"
/
  forall i (a : U i) (b : a -> U i) .
  intersect (x : a) .
    (parametric (y : a) . b y)
    -> b x
/;

inference.
intro /i a b x Himpl/.
set /z/ /Himpl Ap x/.
exact /z/.
unfold /z/.
typecheck.
qed ();



lemma "forallLeft_hidden"
/
  forall i . intersect (a : U i) . forall (x : a) .
    (forall (b : U i) . b -> b)
    -> a
/;

inference.
intro /i a x Hid/.
shouldfail $ RefineTactic.refine (Rule.forallLeft (Term.Var 1)).
Prover.abandon ();



lemma "apply_using_irrelevant_hidden"
/
  forall i (a : U i) (b : a -> U i) .
  intersect (x : a) .
    (parametric (y : a) . b y)
    -> b x
/;

inference.
intro /i a b x Himpl/.
apply /Himpl/.
qed ();



lemma "let_using_hidden"
/
  forall i (a : U i) . { a } -> a
/;

inference.
intro /i a [x]/.
shouldfail $ set /y/ /x/.
Prover.abandon ();



lemma "let_extract"
/
  forall i (a b : U i) . (a -> b) -> a -> b
/;

inference.
intro /i a b f x/.
set /y/ /f x/.
exact /y/.
unfold /y/.
typecheck.
qed ();



lemma "apply_hidden_variable_message"
/
  forall i (a : U i) (b : a -> U i) . intersect (x : a) .
    (forall (y : a) . b y)
    -> b x
/;

inference.
intro /i a b x Hall/.
shouldfail $ apply /Hall/.
Prover.abandon ();



lemma "parametricfut_compat_ap"
/
  forall i (a : U i) (b c : forallfut (_ : a) . U i) (xf : future a) 
    (f : parametricfut (x : a) . b x -> c x) .
      let next x = xf
      in
        forall (m n : b x) .
          m = n : b x
          -> f Ap x m = f Ap x n : c x
/;

inference.
intro /i a b c [x] f m n Heq/.
compat.
hyp /Heq/.
qed ();



lemma "parametricfut_elim"
/
  forall i (a : U i) (b : forallfut (_ : a) . U i) (xf : future a) (f : parametricfut (x : a) . b x) .
    let next x = xf
    in
      f Ap x : b x
/;

inference.
intro /i a b [x] f/.
reduce //.
typecheck.
qed ();



lemma "parametricfut_intro"
/
  forall i (a : U i) (b : a -> U i) .
    (forall (x : future a) . let next x' = x in future (b x'))
    -> parametricfut (x : a) . { future (b x) }
/;

inference.
intro /i a b Hall/.
intro /x/.
split.
apply /Hall (next x)/.
qed ();



lemma "parametricfut_intro'"
/
  forall i (a : U i) (b : a -> U i) .
    (forall (x : future a) . let next x' = x in future (b x'))
    -> parametricfut (x : a) . future unit
/;

inference.
intro /i a b Hall/.
intro /x/.
split.
split.
qed ();



lemma "parametricfut_intro_of"
/
  forall i (a : U i) (b : a -> U i)
    (f : parametric (x : future a) . let next x' = x in future (b x')) .
      f : parametricfut (x : a) . future (b x)
/;

inference.
intro /i a b f/.
introOf /x/.
unfold /paramapp/.
fold /f Ap (next x)/.
typecheck.
qed ();
    


lemma "parametricfut_intro_eq"
/
  forall i (a : U i) (b : a -> U i)
    (f g : parametric (x : future a) . let next x' = x in future (b x')) .
      (forall (x : future a) . let next x' = x in f Ap x' = g Ap x' : future (b x'))
      -> f = g : (parametricfut (x : a) . future (b x))
/;

inference.
intro /i a b f g/.
so /parametricfut_intro_of _ _ _ f/ /Hoff/.
so /parametricfut_intro_of _ _ _ g/ /Hofg/.
introRaw /Heq/.
  {
  introForm /[x]/.
  reduce //.
  infer /f Ap (next x)/ /Hoffx/.
  infer /g Ap (next x)/ /Hofgx/.
  reduce /Hoffx Hofgx/.
  unfold /paramapp in Hoffx in Hofgx/.
  fold /f Ap x in Hoffx/.
  fold /g Ap x in Hofgx/.
  typecheck.
  }
introEq /x/.
apply /Heq (next x)/.
qed ();
    


lemma "parametricfut_ext"
/
  forall i (a : U i) (b : a -> U i)
    (f g : parametric (x : future a) . let next x' = x in future (b x')) .
      (forall (x : future a) . let next x' = x in f Ap x' = g Ap x' : future (b x'))
      -> f = g : (parametricfut (x : a) . future (b x))
/;

inference.
intro /i a b f g/.
so /parametricfut_intro_of _ _ _ f/ /Hoff/.
so /parametricfut_intro_of _ _ _ g/ /Hofg/.
introRaw /Heq/.
  {
  introForm /[x]/.
  reduce //.
  infer /f Ap (next x)/ /Hoffx/.
  infer /g Ap (next x)/ /Hofgx/.
  reduce /Hoffx Hofgx/.
  unfold /paramapp in Hoffx in Hofgx/.
  fold /f Ap x in Hoffx/.
  fold /g Ap x in Hofgx/.
  typecheck.
  }
extensionality.
reintro /x/.
apply /Heq (next x)/.
qed ();
    


lemma "destruct_hidden_future"
/
  forall i . forallfut (a : U i) . forall (b : forallfut (_ : a) . U i) .
    (intersectfut (x : a) . future (b x))
    -> intersect (x : future a) . let next x' = x in future (b x')
/;

inference.
intro /i a b Hall x/.
destruct /x/ /[x]/.
reduce //.
apply /Hall ap x/.
qed ();



lemma "squash_hidden_later"
/
  forall i (a : U i) (b : a -> U i) (c : U i) (x y : a) .
    intersectfut (_ : b x) (_ : b y) .
    c -> future ({ b x } & { b y })
/;

intro /i a b c x y Hx Hy Hc/.
squashHidden /Hx Hy/.
auto.
qed ();



lemma "squash_hidden_dep"
/
  forall i (a : U i) (b : a -> U i) .
    intersect (x : a) . b x
/;

inference.
intro /i a b x/.
shouldfail $ squashHidden /x/.
Prover.abandon ();



lemma "intersectfut_intro"
/
  forall i (a : U i) (b : a -> U i) .
    (forall (x : future a) . let next x' = x in future (b x'))
    -> intersectfut (x : a) . { future (b x) }
/;

inference.
intro /i a b Hall/.
intro /x/.
split.
apply /Hall (next x)/.
qed ();



lemma "intersectfut_intro'"
/
  forall i (a : U i) (b : a -> U i) .
    (forall (x : future a) . let next x' = x in future (b x'))
    -> intersectfut (x : a) . future unit
/;

inference.
intro /i a b Hall/.
intro /x/.
split.
split.
qed ();



lemma "revert_hidden"
/
  forall i (a : U i) (b : a -> U i) . 
    (intersect (x : a) . b x)
    -> parametric (x : a) . b x
/;

inference.
intro /i a b Hall x/.
revert /i a b Hall x/.
intro /i a b Hall x/.
revert /i a b Hall x/.
auto.
qed ();



lemma "revert_later"
/
  forall i . forallfut (a : U i) . forall (b : forallfut (_ : a) . U i) .
    (forallfut (x : a) . future (b x))
    -> forall (x : future a) . let next x' = x in future (b x')
/;

inference.
intro /i a b Hall [x]/.
reduce //.
revert /i a b Hall x/.
auto.
qed ();



lemma "revert_later_hidden"
/
  forall i . forallfut (a : U i) . forall (b : forallfut (_ : a) . U i) .
    (intersect (x : future a) . let next x' = x in future (b x'))
    -> intersectfut (x : a) . future (b x)
/;

inference.
intro /i a b Hall x/.
revert /i a b Hall x/.
intro /i a b Hall x/.
apply /Hall ap (next x)/.
qed ();



lemma "intersectfut_compat"
/
  forall i (a : U i) (b c : forallfut (_ : a) . U i) (xf : future a) 
    (f : intersectfut (x : a) . b x -> c x) .
      let next x = xf
      in
        forall (m n : b x) .
          m = n : b x
          -> f m = f n : c x
/;

inference.
intro /i a b c [x] f m n Heq/.
compat.
hyp /Heq/.
qed ();



lemma "intersectfut_compat_ap"
/
  forall i (a : U i) (b c : forallfut (_ : a) . U i) (xf : future a) 
    (f : intersectfut (x : a) . b x -> c x) .
      let next x = xf
      in
        forall (m n : b x) .
          m = n : b x
          -> f ap x m = f n : c x
/;

inference.
intro /i a b c [x] f m n Heq/.
compat.
hyp /Heq/.
qed ();



lemma "intersectfut_elim"
/
  forall i (a : U i) (b : forallfut (_ : a) . U i) (xf : future a) (f : intersectfut (x : a) . b x) .
    let next x = xf
    in
      f : b x
/;

inference.
intro /i a b [x] f/.
reduce //.
typecheck.
qed ();



lemma "intersectfut_elim_ap"
/
  forall i (a : U i) (b : forallfut (x : a) . U i) (xf : future a) (f : intersectfut (x : a) . b x) .
    let next x = xf
    in
      f ap x : b x
/;

inference.
intro /i a b [x] f/.
reduce //.
typecheck.
qed ();



lemma "intersectfut_intro_of"
/
  forall i (a : U i) (b : a -> U i)
    (f : intersect (x : future a) . let next x' = x in future (b x')) .
      f : intersectfut (x : a) . future (b x)
/;

inference.
intro /i a b f/.
introOf /x/.
fold /f ap (next x)/.
typecheck.
qed ();
    


lemma "intersectfut_intro_eq"
/
  forall i (a : U i) (b : a -> U i)
    (f g : intersect (x : future a) . let next x' = x in future (b x')) .
      (forall (x : future a) . let next x' = x in f = g : future (b x'))
      -> f = g : (intersectfut (x : a) . future (b x))
/;

inference.
intro /i a b f g/.
so /intersectfut_intro_of _ _ _ f/ /Hoff/.
so /intersectfut_intro_of _ _ _ g/ /Hofg/.
introRaw /Heq/.
  {
  introForm /[x]/.
  reduce //.
  infer /f ap (next x)/ /Hoffx/.
  infer /g ap (next x)/ /Hofgx/.
  reduce /Hoffx Hofgx/.
  unfold /ap in Hoffx in Hofgx/.
  typecheck.
  }
introEq /x/.
apply /Heq (next x)/.
qed ();
    


lemma "intersectfut_ext"
/
  forall i (a : U i) (b : a -> U i)
    (f g : intersect (x : future a) . let next x' = x in future (b x')) .
      (forall (x : future a) . let next x' = x in f = g : future (b x'))
      -> f = g : (intersectfut (x : a) . future (b x))
/;

inference.
intro /i a b f g/.
so /intersectfut_intro_of _ _ _ f/ /Hoff/.
so /intersectfut_intro_of _ _ _ g/ /Hofg/.
introRaw /Heq/.
  {
  introForm /[x]/.
  reduce //.
  infer /f ap (next x)/ /Hoffx/.
  infer /g ap (next x)/ /Hofgx/.
  reduce /Hoffx Hofgx/.
  unfold /ap in Hoffx in Hofgx/.
  typecheck.
  }
extensionality.
reintro /x/.
apply /Heq (next x)/.
qed ();
    


lemma "forallfut_so"
/
  forall i (a : U i) (b : forallfut (_ : a) . U i) (P : U i) (Q : forallfut (x : a) . b x -> U i) .
    P
    -> (forallfut (x : a) . P -> forall (y : b x) . Q x y)
    -> forallfut (x : a) . forall (y : b x) . Q x y
/;

inference.
intro /i a b P Q HP HQ/.
intro /x y/.
so /HQ x __ y/ /H/.
  {
  hyp /HP/.
  }
hyp /H/.
qed ();



lemma "forallfut_exploit"
/
  forall i (a : U i) (b : forallfut (_ : a) . U i) (P : U i) (Q : forallfut (x : a) . b x -> U i) .
    P
    -> (forallfut (x : a) . forall (y : b x) . P -> Q x y)
    -> forallfut (x : a) . forall (y : b x) . Q x y
/;

inference.
intro /i a b P Q HP HQ/.
intro /x y/.
exploit /HQ x y/ /H/.
  {
  hyp /HP/.
  }
hyp /H/.
qed ();



lemma "forallfut_introEq"
/
  forall i (a : U i) (b : a -> U i) (f g : forallfut (x : a) . future (b x)) .
    (forall (xf : future a) . let next x = xf in f x = g x : future (b x))
    -> f = g : (forallfut (x : a) . future (b x))
/;

inference.
intro /i a b f g Heq/.
introEq /x/.
apply /Heq (next x)/.
qed ();



lemma "forallfut_extensionalityAuto"
/
  forall i (a : U i) (b : a -> U i) (f g : forallfut (x : a) . future (b x)) .
    (forall (xf : future a) . let next x = xf in f x = g x : future (b x))
    -> f = g : (forallfut (x : a) . future (b x))
/;

inference.
intro /i a b f g Heq/.
extensionalityAuto.
reintro /x/.
apply /Heq (next x)/.
qed ();



lemma "forallfut_ext"
/
  forall i (a : U i) (b : a -> U i) (f g : forallfut (x : a) . future (b x)) .
    (forallfut (x : a) . f x = g x : future (b x))
    -> f = g : (forallfut (x : a) . future (b x))
/;

inference.
intro /i a b f g Heq/.
extensionality.
reintro /x/.
apply /Heq/.
qed ();



lemma "forallfut_sub"
/
  forall i (a a' : U i) (b : forallfut (_ : a). U i) (b' : forallfut (_ : a'). U i) .
    a' <: a
    -> (forallfut (x : a') . b x <: b' x)
    -> (forallfut (x : a) . b x) <: (forallfut (x : a') . b' x)
/;

inference.
intro /i a a' b b' Ha Hb/.
typecheck.
qed ();



lemma "forallfut_intro_of'"
/
  forall i (a : U i) (b : a -> U i)
    (f : forall (x : future a) . let next x' = x in future (b x')) .
      (fn x . f (next x)) : forallfut (x : a) . future (b x)
/;

inference.
intro /i a b f/.
introOf /x/.
reduce //.
typecheck.
qed ();



lemma "forallfut_in_table"
/
  forall i (a b c : U i) (P : U i) 
    (f : a -> b)
    (g : forall (x : future b) . P -g> c) (m : future a) .
      P
      -> let next m' = m
         in
           g (next (f m')) : c
/;

inference.
intro /i a b c P f g m HP/.
assert /forallfut (x : a) . g (next (f x)) : c/ /Hof/.
  {
  intro /x/.
  typecheck.
  }
clear /HP/.
destruct /m/ /[m]/.
reduce //.
typecheck.
qed ();



lemma "forallfut_elim_eq"
/
  forall i (a : U i) (b : a -> U i) (f : forallfut (x : a) . future (b x)) (m n : future a) .
    let next m' = m in
    let next n' = n
    in
      future (m' = n' : a)
      -> f m' = f n' : future (b m')
/;

inference.
intro /i a b f [m] [n] [Heq]/.
compat.
hyp /Heq/.
qed ();



lemma "forallfut_elim_of"
/
  forall i (a : U i) (b : a -> U i) (f : forallfut (x : a) . future (b x)) (m : future a) .
    let next m' = m
    in
      f m' : future (b m')
/;

inference.
intro /i a b f [m]/.
reduce //.
typecheck.
qed ();



lemma "forallfut_intro_eq"
/
  forall i (a : U i) (b : a -> U i)
    (f : forall (x : future a) . let next x' = x in future (b x')) .
      (fn x . f (next x)) 
      = (fn x . f (next x)) 
      : (forallfut (x : a) . future (b x))
/;

inference.
intro /i a b f/.
compat.
qed ();
    


lemma "forallfut_intro_of"
/
  forall i (a : U i) (b : a -> U i)
    (f : forall (x : future a) . let next x' = x in future (b x')) .
      (fn x . f (next x)) : forallfut (x : a) . future (b x)
/;

inference.
intro /i a b f/.
typecheck.
qed ();
    


lemma "forallfut_intro"
/
  forall i (a : U i) (b : a -> U i) .
    (forall (x : future a) . let next x' = x in future (b x'))
    -> forallfut (x : a) . future (b x)
/;

inference.
intro /i a b H x/.
apply /H (next x)/.
qed ();



lemma "assert_later"
/
  forall i (a b : U i) (f : future (a -> b)) (x : future a) .
    let next f' = f in
    let next x' = x
    in
      future (f' x' : b)
/;

inference.
intro /i a b [f] [x]/.
reduce //.
assertLater /f x : b/ /Hof/.
  {
  typecheck.
  }
split.
hyp /Hof/.
qed ();
    


lemma "set_extensionality_auto"
  / forall i (a : U i) (b : a -> U i) (m n : { x : a | b x }) .
      m = n : a
      -> m = n : { x : a | b x } /;

intro /i a b m n Heq/.
infer /m/ /Hofm/.
destructSet /Hofm/ /H/.
clear /Hofm/.
extensionalityAuto.
auto.
qed ();



lemma "iset_extensionality_auto"
  / forall i (a : U i) (b : a -> U i) (m n : { x : a | b x }) .
      m = n : a
      -> m = n : (iset (x : a) . b x)/;

intro /i a b m n Heq/.
infer /m/ /Hofm/.
destructSet /Hofm/ /H/.
clear /Hofm/.
extensionalityAuto.
  {
  split.
  forceExact /H/.
  auto.
  }
  
  {
  auto.
  }
qed ();



lemma "typechecker_destructs_futures"
/
  forall i (a : U i) (b : a -> U i) (f : forall (z : a) . b z -> nat) .
    (fn x y . let next x' = x in let next y' = y in next (f x' y'))
    :
    forall (x : future a) .
      (let next x' = x in future (b x'))
      -> future nat
/;

inference.
intro /i a b f/.
typecheck.
qed ();



lemma "typechecker_reduces_letnext"
/
  forall i (a : U i) (b : a -> U i) (x : future a) 
    (y : let next x' = x in future (b x'))
    (f : forall (z : a) . b z -> nat) .
      (let next x' = x in let next y' = y in next (f x' y')) : future nat
/;

inference.
intro /i a b x y f/.
destruct /x/ /[x]/.
reduce /y/.
destruct /y/ /[y]/.
typecheck.
qed ();




define /myforall_elim f/
/
  f
//
  intersect i (a : U i) (P : a -> U i) . (forall (x : a) . P x) -> forall (x : a) . P x
/;

unfold /myforall_elim/.
typecheck.
qed ();



lemma "deferred_inference"
/
  forall i (a : U i) (P Q : a -> U i) (f : forall (x : a) . P x -> Q x) (x : a) (h : P x) .
    myforall_elim f x h : Q x
/;

inference.
intro /i a P Q f x h/.
typecheck.
qed ();



lemma "squashed_typechecking_goal"
/
  forall i (a : U i) (P : a -> U i) (x : a) .
    P x
    -> x : { y : a | P y }
/;

inference.
intro /i a P x H/.
typecheck.
qed ();



lemma "introForm"
/
  (intersect (i : level) . forall (a : U i) . exists (b : U i) . iforall (c : U i) . iexists (d : U i) . foralltp e . e)
  :
  type
/;

introForm /i a b c d e/.
hypof.
qed ();



lemma "introFormUniv"
/
  forall (i : level) .
    (intersect (z : U i) . forall (a : U i) . exists (b : U i) . iforall (c : U (1 + i)) . iexists (d : U (1 + i)) . d)
    : U (1 + i)
/;

intro /i/.
introForm /z a b c d/.
hypof.
qed ();



define /plus2 x y/
/
  x + y
//
  nat -> nat -> nat
/;

unfold /plus2/.
typecheck.
qed ();



reductions
/
  plus2 (zero) (zero) --> 0 ;

  plus2 (zero) (succ n) --> succ n ;

  plus2 (succ m) (succ n) --> succ (plus2 m (succ n)) ;

  unfolding plus2
/;



lemma "binary_reduction"
/
  forall (x y : nat) .
    x = 0 : nat
    -> y = 3 : nat
    -> plus2 x y = y : nat
/;

intro /x y Hx Hy/.
reduce //.
subst /x/.
reduce //.
shouldfail reflexivity.
subst /y/.
reduce //.
reflexivity.
qed ();



define /ignore1 z x/
/
  x
//
  integer -> nat -> nat
/;

unfold /ignore1/.
typecheck.
qed ();



val red = makeReduction
/
  ignore1 z (succ n) --> succ n ;

  unfolding ignore1
/;

Define.registerNative 0 1 red;



lemma "native_reduction"
/
  forall (z : integer) (x : nat) .
    z = z`0 : integer
    -> x = 3 : nat
    -> ignore1 z x = x : nat
/;

intro /z x Hz Hx/.
reduce //.
subst /x/.
reduce //.
shouldfail reflexivity.
subst /z/.
reduce //.
reflexivity.
qed ();



lemma "isquash_intro_elim"
/
  forall i (a : U i) . a -> isquash a
/;

inference.
intro /i a H/.
assert /isquash a/ /Hsq/.
  {
  split.
  hyp /H/.
  }
clear /H/.
destructRaw /Hsq/ /[H]/.
unhide.
split.
hyp /H/.
qed ();



lemma "introOf_iforall"
/
  (fn x . x) : iforall (a : U 0) . a -> a
/;

introOf /a x/.
typecheck.
qed ();



lemma "let_type"
/
  (let x = 1 in x) : nat
/;

typecheck.
qed ();



lemma "leth_type"
/
  (leth x = 1 in x) : nat
/;

typecheck.
qed ();



lemma "lete_type"
/
  (lete x = 1 in x) : nat
/;

typecheck.
qed ();



lemma "let_reduce"
/
  let n = (fn x . x) 0
  in
    { n : nat }
/;

whreduceHard //.
reduce //.
split.
typecheck.
qed ();



lemma "leth_reduce"
/
  leth n = (fn x . x) 0
  in
    { n : nat }
/;

whreduceHard //.
unfold /leth/.
reduce //.
split.
typecheck.
qed ();



lemma "lete_reduce"
/
  lete n = (fn x . x) 0
  in
    { n : nat }
/;

whreduceHard //.
split.
typecheck.
qed ();



lemma "insert"
/
  forall (a : U 0) . a -> (a & unit)
/;

intro /a x/.
RuleTactic.insert 1.
renameBefore /h/ /x/.
split.
  {
  hyp /x/.
  }

  {
  hyp /h/.
  }
qed ();



lemma "forallArrowLeft"
/
  forall i (a : U i) (b c : a -> U i) (x : a) .
    (forall (x : a) . b x -> c x)
    -> b x
    -> c x
/;

inference.
intro /i a b c x H Hb/.
moveBefore /H/ /concl/.
RuleTactic.forallLeft (Term.Var 1).
  {
  hypof.
  }
RuleTactic.arrowLeft.
  {
  hyp /Hb/.
  }
hyp /H/.
qed ();



lemma "seq_nat_value"
/
  seq x = 1 + 1 in x = 2 : nat
/;

reduce //.
auto.
qed ();



lemma "seq_integer_value"
/
  seq x = z`1 +z z`1 in x = z`2 : integer
/;

reduce //.
auto.
qed ();



lemma "seq_nonvalue"
/
  seq x = 0 0 in unit
/;

reduce //.
shouldfail (unfold /seq/).
Prover.abandon ();



lemma "let_nonvalue"
/
  let x = 0 0 in unit
/;

reduce //.
unfold /let/.
split.
qed ();



lemma "seqt_nat_value"
/
  seqt x = 1 + 1 in x = 2 : nat
/;

reduce //.
auto.
qed ();



lemma "seqt_integer_value"
/
  seqt x = z`1 +z z`1 in x = z`2 : integer
/;

reduce //.
auto.
qed ();



lemma "seqt_nonvalue"
/
  seqt x = 0 0 in unit
/;

reduce //.
shouldfail (unfold /seq/).
Prover.abandon ();



lemma "arrow_extensionality"
/
  forall i (a b : U i) (f g : a -> b) .
    (forall x . f x = g x : b)
    -> f = g : (a -> pause b)
/;

inference.
intro /i a b f g Heq/.
(* introEq and extensionalityAuto won't work because of the pause *)
extensionality.
unfold /pause/.
apply /Heq/.
qed ();



lemma "pi_extensionality"
/
  forall i (a : U i) (b : a -> U i) (f g : forall (x : a) . b x) .
    (forall x . f x = g x : b x)
    -> f = g : (forall (x : a) . pause (b x))
/;

inference.
intro /i a b f g Heq/.
(* introEq and extensionalityAuto won't work because of the pause *)
extensionality.
unfold /pause/.
apply /Heq/.
qed ();



lemma "set_intro"
/
  forall i (a : U i) (b : a -> U i) (x : a) .
    b x
    -> x : { x' : a | b x' }
/;

inference.
intro /i a b x H/.
typecheck.
qed ();



lemma "coguard_intro"
/
  forall i (a b : U i) . a -> b -> a &g b
/;

inference.
intro /i a b Ha Hb/.
split >> auto.
qed ();



lemma "coguard_intro_of"
/
  forall i (a b : U i) (x : b) . a -> x : a &g b
/;

inference.
intro /i a b x H/.
typecheck.
qed ();



lemma "coguard_formation"
/
  forall i (a b : U i) (c : b -> U i) (x : a) .
    (a <: b) &g c x : type
/;

inference.
intro /i a b c x/.
typecheck.
qed ();



lemma "coguard_sub_elim"
/
  forall i (a b : U i) (x : a &g b) .
    x : b
/;

inference.
intro /i a b x/.
typecheck.
qed ();



lemma "coguard_destruct"
/
  forall i (a b : U i) (x : a &g b) .
    x : { y : b | a }
/;

inference.
intro /i a b x/.
destruct /x/ /[H x]/.
typecheck.
qed ();



lemma "of_equands"
/
  forall i (a : U i) (m n : a) .
    m = n : a
    -> (m : a) & (n : a)
/;

inference.
intro /i a m n Heq/.
ofEquands /Heq/ /Hof Hof'/.
clear /Hof Hof'/.
split.
  {
  ofEquands /Heq/ /? _/.
  assumption.
  }

  {
  ofEquands /Heq/ /_ ?/.
  assumption.
  }
qed ();



lemma "mimic_sum"
/
  forall i (a b : U i) (P : (a % b) -> U i) x1 x2 y1 y2 .
    x1 = inl y1 : (a % b)
    -> x2 = inr y2 : (a % b)
    -> P (inl y1)
    -> P (inr y2)
    -> P x1 & P x2
/;

inference.
intro /i a b P x1 x2 y1 y2 Heq1 Heq2 H1 H2/.
split.
  {
  mimic /Heq1/ /y1'/.
  forceExact /H1/.
  compat.
  compat.
  auto.
  }

  {
  mimic /Heq2/ /y2'/.
  forceExact /H2/.
  compat.
  compat.
  auto.
  }
qed ();



lemma "mimic_nat"
/
  forall (P : nat -> U 0) x1 x2 y2 .
    x1 = zero : nat
    -> x2 = succ y2 : nat
    -> P zero
    -> P (succ y2)
    -> P x1 & P x2
/;

inference.
intro /P x1 x2 y2 Heq1 Heq2 H1 H2/.
split.
  {
  mimic /Heq1/ //.
  hyp /H1/.
  }

  {
  mimic /Heq2/ /y2'/.
  forceExact /H2/.
  compat.
  compat.
  auto.
  }
qed ();



lemma "cautious_substitution"
/
  forall (P : nat -> U 0) (Q : U 0) (x y : nat) .
    x = y : nat
    -> P x
    -> (P y -> Q)
    -> (P y & Q)
/;

intro /P Q x y Heq Hx Himp/.
split.
  {
  shouldfail (substCautious /y/).
  subst /y/.
  hyp /Hx/.
  }

  {
  substCautious /y/.
  apply /Himp/.
  hyp /Hx/.
  }
qed ();



definemutrecRaw /x/
/
  snork1 y =
    if Nat.eqb y 0 then
      x
    else
      snork2 y

  and
  snork2 y = snork1 (y - 1) * 2
/;



lemma "snorkism"
/
  snork2 4 2 = 16 : nat
/;

unroll /snork2/.
reduce //.
unroll /snork1/.
unroll /Nat.eqb/.
reduce //.
unroll /snork2/.
reduce //.
unroll /snork1/.
unroll /Nat.eqb/.
reduce //.
reflexivity.
qed ();



lemma "snork1_type"
/
  snork1 : nat -> nat -> nat
/;

introOf /x y/.
sinduction /y/.
reintro /IH/.
unroll /snork1/.
destruct /y/ /| y/.
  {
  unroll /Nat.eqb/.
  reduce //.
  hypof.
  }
unroll /Nat.eqb/.
reduce //.
unroll /snork2/.
reduce //.
typecheck.
apply /IH/.
apply /Nat.lt_succ/.
qed ();



lemma "integer_to_nat_reduce"
/
  Integer.integer_to_nat z`10 = 10 : nat
/;

reduce //.
reflexivity.
qed ();



lemma "integer_literals"
/
  z`\1000000000001I\ -z z`\1000000000000I\ = z`1 : integer
/;

reduce //.
reflexivity.
qed ();



lemma "forallElimOf"
/
  forall i (a : U i) (b : a -> U i) (m : forall (x : a) . b x) (p : a) .
    m p : b p
/;

inference.
intro /i a b m p/.
RuleTactic.forallElimOf (parseCurr /a/) (parseCurr /additional` x . b x/) (parseCurr /m/) (parseCurr /p/).
  {
  hypof.
  }

  {
  hypof.
  }
qed ();



lemma "forallSub"
/
  forall i (a a' : U i) (b : a -> U i) (b' : a' -> U i) .
    a' <: a
    -> (forall (x : a') . b x <: b' x)
    -> (forall (x : a) . b x) <: (forall (x' : a') . b' x')
/;

inference.
intro /i a a' b b' Ha Hb/.
RuleTactic.forallSub.
(* the point here is the variable names *)
  {
  hyp /Ha/.
  }

  {
  infer /x'/ /Hof/.
  auto.
  }

  {
  infer /x/ /Hof/.
  auto.
  }
qed ();



lemma "prodLeft"
/
  forall i (a b c : U i) (x : a & b) (y : a -> b -> c) . c
/;

inference.
intro /i a b c x v0/.
RuleTactic.prodLeft 1.
(* the point is v0 is undisturbed *)
renameBefore /x y/ /v0/.
exact /v0 x y/.
qed ();



lemma "extensionality_guard"
/
  forall i (a b : U i) (x y : a -g> b) .
    (a -> x = y : b)
    -> x = y : (a -g> b)
/;

inference.
intro /i a b x y Heq/.
introEq /H/.
apply /Heq/ >> auto.
qed ();



lemma "typecheck_let"
/
  let f = succ in f 1 : nat
/;

intro /f/.
typecheckLet /f/ /_/ /Hof/.
typecheck.
qed ();



lemma "annotated_redex"
/
  forall n .
    (fn (x : nat) . succ x) n = succ n : nat
/;

inference.
intro /n/.
reduce //.
reflexivity.
qed ();



lemma "extensionality_union"
/
  forall i (a : U i) (b : a -> U i) (m : a) (n p : b m) .
    n = p : b m
    -> n = p : (union (x : a) . b x)
/;

inference.
intro /i a b m n p H/.
existsEq /m/.
hyp /H/.
qed ();



lemma "extensionality_iexists"
/
  forall i (a : Kind i) (b : a -> U i) (m : a) (n p : b m) .
    n = p : b m
    -> n = p : (iexists (x : a) . b x)
/;

inference.
intro /i a b m n p H/.
existsEq /m/.
hyp /H/.
qed ();



lemma "extensionalityAuto"
/
  forall i (a : U i) (b c : a -> U i) (d e : forall x . c x -> U i) .
    (fn t .
       forall (m n : t) .
         (forall x y . m x y #1 = n x y #1 : c x)
         -> (forall x y z . m x y #2 #1 z = n x y #2 #1 z : e x (m x y #1))
         -> m = n : t)
    (forall (x : a) . b x -> exists (z : c x) . (d x z -> e x z) & (x : a))
/;

reduce /concl/.
inference.
intro /i a b c d e m n H1 H2/.
  {
  reintro /x y z/.
  symmetry.
  apply /H1/.
  }

  {
  reintro /x y z/.
  apply /H1/.
  }
extensionalityAuto >> auto.
qed ();



lemma "extensionalityAuto_manual"
/
  forall i (a : U i) (b c : a -> U i) (d e : forall x . c x -> U i) .
    (fn t .
       forall (m n : t) .
         (forall x y . m x y #1 = n x y #1 : c x)
         -> (forall x y z . m x y #2 #1 z = n x y #2 #1 z : e x (m x y #1))
         -> m = n : t)
    (forall (x : a) . b x -> exists (z : c x) . (manuals (d x z -> e x z)) & (x : a))
/;

reduce /concl/.
inference.
intro /i a b c d e m n H1 H2/.
  {
  reintro /x y z/.
  symmetry.
  apply /H1/.
  }

  {
  reintro /x y z/.
  apply /H1/.
  }
extensionalityAuto >> auto.
introEq /x/ >> auto.
qed ();



lemma "iforall_extensionality"
/
  forall i (k : Kind i) (b : k -> U i) (m n : iforall (x : k) . b x) .
    (forall (x : k) . m = n : b x)
    -> m = n : (iforall (x : k) . b x)
/;

inference.
intro /i k b m n Heq/.
extensionality.
apply /Heq/.
qed ();



lemma "intersect_extensionality"
/
  forall i (a : U i) (b : a -> U i) (m n : intersect (x : a) . b x) .
    (forall (x : a) . m = n : b x)
    -> m = n : (intersect (x : a) . b x)
/;

inference.
intro /i a b m n Heq/.
introEq /x/.
apply /Heq/.
qed ();



lemma "univIntroEqtype"
/
  forall i (a b : U i) .
    a = b : type
    -> a = b : U i
/;

inference.
intro /i a b H/.
univIntroEqtype >> typecheck.
qed ();



lemma "positive_under_binder"
/
  forall i (a b : U i) .
    (mu t . forall (x : a) (y : t) . b) : type
/;

inference.
intro /i a b/.
shouldfail (typecheck >> done).
Prover.abandon ();



lemma "positive_future"
/
  forall i (a : U i) .
    (mu t . a % future t) : type
/;

inference.
intro /i a/.
typecheck.
qed ();



lemma "inject_future"
/
  forall i (a : U i) (m n : a) .
    next m = next n : (future a)
    -> future (m = n : a)
/;

inference.
intro /i a m n H/.
injection /H/.
assumption.
qed ();



lemma "eliminate_iexists"
/
  forall i (a : Kind i) (b : a -> U i) (y : iexists (x : a) . b x) . 
    unit
    -> y = y : (iexists (x : a) . b x)
    -> { exists (x : a) . b x }
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
split.
exists /x/.
auto.
qed ();



lemma "eliminate_iexists_dependent"
/
  forall i (a : Kind i) (b : a -> U i) (y : iexists (x : a) . b x) . 
    unit
    -> y = y : (iexists (x : a) . b x)
    -> y : (iexists (x : a) . b x)
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
typecheck.
qed ();



lemma "eliminate_union"
/
  forall i (a : U i) (b : a -> U i) (y : union (x : a) . b x) . 
    unit
    -> y = y : (union (x : a) . b x) 
    -> { exists (x : a) . b x }
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
split.
exists /x/.
auto.
qed ();



lemma "eliminate_union_dependent"
/
  forall i (a : U i) (b : a -> U i) (y : union (x : a) . b x) . 
    unit
    -> y = y : (union (x : a) . b x) 
    -> y : union (x : a) . b x
/;

inference.
intro /i a b y H1 H2/.
shouldfail (destruct /y/ /x y/).
clear /H2/.
destruct /y/ /x y/.
typecheck.
qed ();



lemma "inhabit_union"
/
  forall i (a : U i) (b : a -> U i) (x : a) (y : b x) .
    union (z : a) . b z
/;

inference.
intro /i a b x y/.
exists /x/.
hyp /y/.
qed ();



lemma "union_introduction_auto"
/
  forall i (a : U i) (b : a -> U i) (x : a) (y : b x) .
    y : (union (z : a) . b z)
/;

inference.
intro /i a b x y/.
typecheck.
qed ();



lemma "union_introduction_manual"
/
  forall i (a : U i) (b : a -> U i) (x : a) (y : b x) .
    y : (union (z : a) . b z)
/;

inference.
intro /i a b x y/.
existsOf /x/.
hypof.
qed ();



lemma "iexists_introdution_auto"
/
  forall i (k : Kind i) (b : k -> U i) (x : k) (y : b x) .
    y : (iexists (z : k) . b z)
/;

inference.
intro /i k b x y/.
typecheck.
qed ();



lemma "iexists_introdution_manual"
/
  forall i (k : Kind i) (b : k -> U i) (x : k) (y : b x) .
    y : (iexists (z : k) . b z)
/;

inference.
intro /i k b x y/.
existsOf /x/.
hypof.
qed ();



lemma "union_equality_transitive"
/
  forall i (a : U i) (b : a -> U i) (c : U i) (a1 a2 : a) (b1 : b a1) (b2 : c) (b3 : b a2) .
    c <: b a1
    -> c <: b a2
    -> b1 = b2 : b a1
    -> b2 = b3 : b a2
    -> b1 = b3 : (union (x : a) . b x)
/;

inference.
intro /i a b c a1 a2 b1 b2 b3 Hsub1 Hsub2 Heq12 Heq23/.
transitivity /b2/.
  {
  RuleTactic.unionIntroEq (Term.evar ()) >> auto.
  typecheck.
  }

  {
  RuleTactic.unionIntroEq (Term.evar ()) >> auto.
  typecheck.
  }
qed ();



lemma "backtrack_through_typecheck"
/
  forall i (a b c : U i) . (a -> c) -> (b -> c) -> b -> c
/;

inference.
intro /i a b c Hac Hbc Hb/.
shouldfail ((Typecheck.withTypecheck $ cut (first [witness /Hac __/, witness /Hbc __/])) >> auto >> done).
(Typecheck.withTypecheck $ first [witness /Hac __/, witness /Hbc __/]) >> auto >> done.
qed ();



lemma "backtrack_through_apply"
/
  forall i (a : U i) (a1 a2 : a) (P : a -> U i) (R : a -> a -> U i) .
    (forall x y . R x y -> P x & P y)
    -> R a1 a2
    -> P a2
/;

inference.
intro /i a a1 a2 P R H1 H2/.
apply /H1/ >> auto >> done.
qed ();



lemma "manual_subtype"
/
  forall i (a b c : U i) . a <: b -> (b -> c) <: (a -> c)
/;

inference.
intro /i a b c H/.
fold /manual a/.
typecheck.
hyp /H/.
qed ();



lemma "squash_subtype"
/
  forall i (a b : U i) . (unit & (a -> b)) -> squash a <: squash b
/;

intro /i a b H/.
typecheck.
apply /H/.
qed ();



lemma "intro_of_arrows"
/
  forall i (a : U i) (b c d : a -> U i) .
    (fn x y z w . 0) : (forall (x : a) . b x -> c x -t> d x -k> nat)
/;

inference.
intro /i a b c d/.
introOf /x y z w/.
reduce //.
typecheck.
qed ();



lemma "unhide_subtype"
/
  forall i (a b : U i) . { a <: b } -> a <: b
/;

inference.
intro /i a b H/.
destruct /H/ /[H]/.
unhide.
hyp /H/.
qed ();



lemma "exclude"
/
  forall i (a b : U i) (f : a -> b) (x : (exclude` a in _) a) . f x : b
/;

inference.
intro /i a b f x/.
typecheck.
qed ();



(* check reductions using natives *)

defineRaw /is_minus_one x/
/
  Integer.eqzb (x +z z`1) z`0
/;


defineRaw /minus_one/ /z`-1/;


reductions
/
  is_minus_one (minus_one) --> true ;
  unfolding is_minus_one minus_one
/;



lemma "destructSet"
/
  forall i (a : U i) (b : a -> U i) (x : {x : a | b x}) .
    exists (y : a) . { b y }
/;

inference.
intro /i a b x/.
infer /x/ /H1/.
destructSet /H1/ /H2/.
existsRaw /x/.
  {
  typecheck.
  }

  {
  hyp /H1/.
  }

  {
  split.
  hyp /H2/.
  }
qed ();



lemma "infer_through_set"
/
  forall i (a b : U i) (P : (a -> b) -> U i) (f : {f : a -> b | P f}) (x : a) .
    f x : b
/;

inference.
intro /i a b P f x/.
infer /f x/ /H/.
hyp /H/.
qed ();



lemma "contrapositive"
/
  forall i (a b c : U i) .
    (a -> c)
    -> (b -> a)
    -> (b -> c)
/;

inference.
intro /i a b c Hac Hba/.
contrapositive /Hac/.
auto.
qed ();



lemma "make_orphan"
/
  forall (x y : nat) (P : nat -> U 0) . P x -> P (if true then x else y)
/;

intro /x y P H/.
clear /y/.
reduce //.
hyp /H/.
qed ();



lemma "make_orphan_unify"
/
  forall i 
    (a : nat -> U i)
    (b : U i)
    (x : nat)
    (f : a _ -> b)
    (x' : nat)
    (y : a (succ (if true then x else x')))
    . b
/;

inference.
intro /i a b x f x' y/.
1:{
  exact /f y/.
  }
reduce //.
typecheck.
qed ();



lemma "make_free_variable"
/
  let x = l` 0 in unit
/;

unfold /let/.
split.
Prover.abandon ();



lemma "open_extract"
/
  unit
/;

exactRaw /let x = l` 0 in ()/.
unfold /let/.
typecheck.
qed ();



lemma "free_evar_extract"
/
  unit
/;

exactRaw /let x = _ in ()/.
unfold /let/.
typecheck.
qed ();



lemma "substitution_cycle"
/
  forall i (a : U i) (f : a -> a) (x : a) .
    x = f x : a
    -> unit
/;

inference.
intro /i a f x Heq/.
shouldfail (subst /x/).
split.
qed ();


lemma "substitution_with_move"
/
  forall i (a : U i) (P : a -> U i) (x y z : a) .
    x = z : a
    -> P z
    -> P x
/;

inference.
intro /i a P x y z Heq Hz/.
shouldfail (substStrict /x/).
subst /x/.
hyp /Hz/.
qed ();


lemma "move_deps"
/
  forall i (t a : U i) (b : a -> U i) (c : forall (x : a) . b x -> U i)
    (a1 a2 : a) (b1 b2 : b a1) (c1 c2 : c a1 b1) (t1 : t) .
    unit
/;

inference.
intro /i t a b c a1 a2 b1 b2 c1 c2 t1/.
shouldfail (moveBeforeDeps /t1/ /t/).
moveBeforeDeps /c2 c1/ /t/.
split.
qed ();


lemma "rename_before"
/
  0 <= 1
  -> 0 <= 2
  -> 0 <= 3
  -> 0 <= 4
  -> 0 <= 5
  -> 0 <= 6
  -> 0 <= 7
  -> unit
/;

intro /a b c d e f g/.
renameBefore /x _ ? y/ /f/.
split.
qed ();


lemma "extensionality_iset"
/
  forall i (a : U i) (b : a -> U i) (m n : a) .
    b m
    -> m = n : a
    -> m = n : (iset (x : a) . b x)
/;

intro /i a b m n H Heq/.
extensionality.
  {
  hyp /Heq/.
  }

  {
  split.
  hyp /H/.
  }
qed ();


lemma "destruct_iset"
/
  forall i (a : U i) (b : a -> U i) (x : iset (x : a) . b x) .
    x : (iset (y : a) . b y)
/;

inference.
intro /i a b x/.
destructRaw /x/ /[x H]/.
typecheck.
qed ();


lemma "infer_spine"
/
  forall i (a b c : U i) (f : { y : a -> b & c | unit }) (x : a) .
    f x #1 : b
/;

inference.
intro /i a b c f x/.
assert /f : a -> b & c/ /Hf/.
  {
  typecheck.
  }
inferSpine /Hf/ /__ x #1/ /H/.
hyp /H/.
qed ();
  


lemma "so_pi1_after_marker"
/
  forall i (a b : U i) (c : b -> U i) (f : a -> exists (x : b) . c x) .
    a -> b
/;

inference.
intro /i a b c f x/.
so /f __ #1/ /H/.
  {
  auto.
  }
hyp /H/.
qed ();



define /arrow' A B/
/
  A -> B
//
  intersect i . U i -> U i -> U i
/;

unfold /arrow'/.
typecheck.
qed ();



define /prod' A B/
/
  A & B
//
  intersect i . U i -> U i -> U i
/;

unfold /prod'/.
typecheck.
qed ();



lemma "destruct_unfolds"
/
  forall i (a b : U i) . prod' a b -> a & b
/;

inference.
intro /i a b H/.
destruct /H/ /H1 H2/.
auto.
qed ();



lemma "so_unfolds"
/
  forall i (a b c d e : U i) (f : arrow' a (arrow' b (arrow' c (prod' d e)))) .
    a -> b -> c -> d
/;

inference.
intro /i a b c d e f x y z/.
so /f x __ z #1/ /H1/.
  {
  hyp /y/.
  }
so /f x __ z #2/ /H2/.
  {
  hyp /y/.
  }
hyp /H1/.
qed ();



lemma "infer_unfolds"
/
  forall i (a b : U i) (f : arrow' a b) (x : a) .
    f x : b
/;

inference.
intro /i a b f x/.
infer /f x/ /H/.
hyp /H/.
qed ();



lemma "squash_hidden"
/
  forall i (a : U i) (b : a -> U i) (c : U i) (x y : { z : a | b z }) .
    c -> { b x } & { b y }
/;

intro /i a b c x y Hc/.
destruct /x/ /x Hx/.
destruct /y/ /y Hy/.
squashHidden /Hx Hy/.
auto.
qed ();



lemma "unprotected_hypothesis"
/
  forall i (a b : U i) (f : a -g> b) .
    _
    -> f : b
/;

intro /i a b f H/.
1:{
  typecheck.
  hyp /H/.
  }
typecheck.
qed ();



lemma "contains_unresolved_evar"
/
  void -> _
/;

intro /H/.
destruct /H/ /0/.
(* qed should return an error *)
Prover.abandon ();



lemma "contains_free_variable"
/
  void -> l` 1
/;

intro /0/.
(* qed should return an error *)
Prover.abandon ();



lemma "contains_marker"
/
  void -> __
/;

intro /0/.
(* qed should return an error *)
Prover.abandon ();



lemma "id_at_forall_nat"
/
  (fn (x : nat) . x) : _
/;

typecheck.
qed ();



lemma "id_at_arrow_nat"
/
  (fn (x : nat) . x) : nat -> nat
/;

typecheck.
qed ();



lemma "id_at_tarrow_nat"
/
  (fn (x : nat) . x) : nat -t> nat
/;

typecheck.
qed ();



lemma "forall_is_arrow"
/
  foralltp a b .
    (forall (x : a) . b) = (a -> b) : type
/;

intro /a b/.
typecheck.
qed ();



lemma "forall_is_tarrow"
/
  foralltp a b .
    (forall (x : a) . b) = (a -t> b) : type
/;

intro /a b/.
typecheck.
qed ();
  


lemma "forall_is_arrow_univ"
/
  forall i (a b : U i) .
    (forall (x : a) . b) = (a -> b) : U i
/;

intro /i a b/.
typecheck.
qed ();
  


lemma "forall_is_tarrow_univ"
/
  forall i (a b : U i) .
    (forall (x : a) . b) = (a -t> b) : U i
/;

intro /i a b/.
typecheck.
qed ();



defineRaw /silly x/ /Integer.plusz z`1 z`1/;


reductions
/
  silly (zero) --> z` 2 ;
  unfolding silly
/;



lemma "integer_negation"
/
  Integer.negz z`1 : integer
/;

reduce //.
typecheck.
qed ();



lemma "integer_addition"
/
  Integer.plusz z`12 z`-12 : integer
/;

reduce //.
typecheck.
qed ();



lemma "integer_comparison"
/
  Integer.leqzb z`12 z`0 : bool
/;

reduce //.
typecheck.
qed ();



lemma "twelve_of"
/
  z`12 : integer
/;

typecheck.
qed ();



lemma "twelve_eq"
/
  z`12 = z`12 : integer
/;

reflexivity.
qed ();



lemma "destruct_hidden_zero"
/
  forall (a : U 0) . { void } -> a
/;

intro /a H/.
destruct /H/ /[H]/.
destruct /H/ /0/.
qed ();



lemma "exfalso"
/
  forall (a : U 0) . { void } -> a
/;

intro /a H/.
destruct /H/ /[H]/.
exfalso.
hyp /H/.
qed ();



lemma "unhide_void"
/
  forall (a : U 0) . { a } -> (a -> void) -> void
/;

intro /a H Hnot/.
destruct /H/ /[H]/.
unhide.
auto.
qed ();



lemma "unhide_void_hyp"
/
  forall (a : U 0) . { void } -> a
/;

intro /a H/.
destruct /H/ /[H]/.
unhide.
destruct /H/ /0/.
qed ();



lemma "trivialize"
/
  forall i (a b : U i) (m n : a) .
    a
    -> (a -> m = n : a)
    -> m = n : a
/;

inference.
intro /i a b m n Ha H/.
trivialize.
auto.
qed ();
Show.showClosed $ Option.valOf $ Constant.definition $ parseConstant /trivialize/;



lemma "trivialize_typecheck"
/
  forall i (a : U i) (m n : a) .
    m = n : a
    -> () : m = n : a
/;

inference.
intro /i a m n H/.
typecheck.
qed ();



lemma "eqtp_table"
/
  forall (i : level) (a b c : U i) (f : a -> c) (x : b) .
    a = b : type
    -> f x : c
/;

intro /i a b c f x Heq/.
typecheck.
qed ();



lemma "equniv_table"
/
  forall (i : level) (a b c : U i) (f : a -> c) (x : b) .
    a = b : U i
    -> f x : c
/;

intro /i a b c f x Heq/.
typecheck.
qed ();



lemma "degenerate_quotient"
/
  (quotient (x y : nat) . x = y : nat) : type
/;

typecheck.
  {
  reintro /x y H/.
  symmetry.
  hyp /H/.
  }

  {
  reintro /x y z Hxy Hyz/.
  etransitivity.
    {
    hyp /Hxy/.
    }

    {
    hyp /Hyz/.
    }
  }
qed ();



lemma "destruct_quotient_of"
  / (quotient (x y : nat) . x = y : nat) <: nat /;

so /degenerate_quotient/ /Histp/.
intro /z/.
destruct /z/ /[ x y H ]/.
hyp /H/.
qed ();



lemma "destruct_quotient_eq"
/
  forall (x : quotient (x y : nat) . x = y : nat) . x = x : nat
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destructRaw /z/ /[x y H]/.
  {
  typecheck.
  }
hyp /H/.
qed ();



lemma "destruct_quotient_eq_dep"
/
  forall (x : quotient (x y : nat) . x = y : nat) . () : x = x : nat
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destructRaw /z/ /[x y H]/.
  {
  typecheck.
  }

  {
  typecheck.
  }

  {
  typecheck.
  }
qed ();



lemma "destruct_quotient_istype"
/
  forall (x : quotient (x y : nat) . x = y : nat) . (x : nat) : type
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destruct /z/ /[x y H]/.
typecheck.
qed ();



lemma "destruct_quotient_eqtype"
/
  forall (x : quotient (x y : nat) . x = y : nat) . (x : nat) = (x : nat) : type
/;

so /degenerate_quotient/ /Histp/.
intro /z/.
destruct /z/ /[x y H]/.
typecheck.
qed ();



lemma "inject_quotient"
/
  forall (x u : quotient (x y : nat) . x = y : nat) . 
    x = u : (quotient (x y : nat) . x = y : nat)
    -> x = u : nat
/;

so /degenerate_quotient/ /Histp/.
intro /x u Heq/.
destruct /x/ /[x y Hxy]/.
destruct /u/ /[u v Huv]/.
injection /Heq/.
reintro /Heq'/.
transitivity /u/ >> auto.
qed ();



lemma "apply_forall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (f : iforall (x : a) . b x) (m : a) .
    b m
/;

inference.
intro /i a b f m/.
apply /f/.
qed ();



lemma "exploit_forall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (f : iforall (x : a) . b x) (m : a) .
    b m
/;

inference.
intro /i a b f m/.
eexploit /f/ /H/.
  {
  hyp /H/.
  }
typecheck.
qed ();



lemma "infer_iforall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (f : iforall (x : a) . b x) (m : a) .
    f : b m
/;

inference.
intro /i a b f m/.
infer /f ap m/ /H/.
unfold /ap in H/.
hyp /H/.
qed ();



lemma "compat_iforall"
/
  forall (i : level) (a : Kind i) (b : a -> U i) (c : forall (x : a) . b x -> U i) 
    (f : iforall (x : a) . forall (y : b x) . c x y) (m : a) (n1 n2 : b m) .
      n1 = n2 : b m
      -> f n1 = f n2 : c m n1
/;

inference.
intro /i a b c f m n1 n2 Heq/.
fold /f ap m/.
compat.
hyp /Heq/.
qed ();



lemma "substitution_simple"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b y
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substitutionRaw /x/ /y/.
  {
  hyp /Heq/.
  }
hypof.
qed ();


lemma "substitution_complex"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b x
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substitutionRaw /x/ /y/.
  {
  typecheck.
  }

  {
  hyp /Heq/.
  }

  {
  hypof.
  }
qed ();



lemma "subst_simple"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b y
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substRaw /x/.
hypof.
qed ();


lemma "subst_complex"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> z : b x
/;

intro /i a b x y z Heq/.
moveBefore /y/ /x/.
substRaw /x/.
  {
  typecheck.
  }

  {
  hypof.
  }
qed ();



lemma "copy"
/
  forall (i : level) (P : U i) . P -> P
/;

intro /i P H1/.
copy /H1/ /H2/.
hyp /H2/.
qed ();



lemma "kind_sub"
/
  forall (i : level) . let j = _ in (Kind i <: U j) & (j : level)
/;

intro /i j/.
subst /j/.
split.
  {
  typecheck.
  }
typecheck.
qed ();



lemma "inject_set"
/
  forall (i : level) (a : U i) (b : a -> U i) (x y : {z : a | b z}) .
    x = y : {z : a | b z}
    -> x = y : a & { b x } & { b y }
/;

intro /i a b x y Heq/.
injection /Heq/ >> clear /Heq/.
reintro /Heq Hx Hy/.
auto.
qed ();



lemma "absolute"
/
  forall (i : level) (a b : U i) (f : a -> b) (x y z : a) . _ -> f x : b
/;

intro /i a b f x y z/.
val (_, dir) = Prover.currentGoal ();
val ec = ETerm.absolute dir (Prover.currentConcl ());
moveBefore /x/ /f/.
moveBefore /b/ /a/.
clear /z/.
assert ec /H/.
1:{
  hyp /H/.
  }
change /concl/ /unit -> _/.
auto.
qed ();



lemma "setEq"
/
  forall (i : level) (a : U i) (P : a -> U i) (f : a -> a) (x : a) .
    P (f x)
    -> P (f x)
/;

intro /i a P f x H/.
setEq /y/ /f x/ /_/ /Heq/.
rewrite /<- Heq/.
moveBefore /y Heq/ /H/.
rewrite /<- Heq in H/.
hyp /H/.
qed ();



lemma "remember"
/
  forall (i : level) (a : U i) (f : a -> bool) (x : a) .
    (f x = false : bool -> void)
    -> if f x then unit else void
/;

intro /i a f x H/.
remember /f x/ /_/ /b/ /Heq/.
destruct /b/ /|/.
  {
  reduce //.
  split.
  }

  {
  auto.
  }
qed ();



lemma "apply_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
apply /H/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
qed ();



lemma "so_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
so /H _ _ __ __/ /H'/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
hyp /H'/.
qed ();



lemma "exploit_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
eexploit /H/ /H'/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
hyp /H'/.
qed ();



lemma "witness_subgoals"
/
  forall (a : U 0) (b : a -> U 0) (c : U 0) (a1 a2 : a) .
    (forall (x y : a) . b x -> b y -> c)
    -> b a1
    -> b a2
    -> c
/;

intro /a b c a1 a2 H H1 H2/.
witness /H _ _ __ __/.
  {
  hyp /H1/.
  }

  {
  hyp /H2/.
  }
typechecker ();
qed ();



lemma "unroll_letrec"
/
  let f = fix (fn f x . nat_case x 0 (fn x' . succ (f x'))) in f : nat -> nat
/;

intro /f/.
assert /f : nat -> nat/ /H/.
  {
  introOf /n/.
  sinduction /n/.
  reintro /IH/.
  unroll /f/.
  destruct /n/ /| n/.
    {
    reduce //.
    typecheck.
    }
  reduce //.
  typecheck1.
  apply /IH/.
  apply /Nat.lt_succ/.
  }
unroll /f/.
roll /f/.
unroll /f in H/.
roll /f in H/.
hyp /H/.
qed ();



lemma "unroll_letrec_under"
/
  let f = fix (fn f x . nat_case x 0 (fn x' . succ (f x'))) in (fn y z . f z) : nat -> nat -> nat
/;

intro /f/.
unroll /f/.
roll /f z within y z/.
goalCaseT /? => \fnc c => assert /\c\/ /H/\/.
  {
  introOf /_ n/.
  reduce //.
  so /unroll_letrec/ /H/.
  reduceHard /H/.
  fold /f in H/.
  generalize /f/ /nat -> nat/ /f'/.
  typecheck.
  }
unroll /f in H/.
roll /f z within y z in H/.
hyp /H/.
qed ();



definerec /countdown x/
/
  nat_case x 0 (fn x' . succ (countdown x'))
//
  nat -> nat
/;

introOf /n/.
sinduction /n/.
reintro /IH/.
unroll /countdown/.
roll /countdown n/.
unroll /countdown/.
destruct /n/ /| n/.
  {
  reduce //.
  typecheck.
  }
reduce //.
typecheck1.
apply /IH/.
apply /Nat.lt_succ/.
qed ();



lemma "countdown_identity"
/
  forall n . countdown n = n : nat
/;

inference.
intro /n/.
induction /n/.
  {
  unroll /countdown/.
  reduce //.
  auto.
  }
intro /n IH/.
unroll /countdown/.
convertRoll /countdown (succ n)/.
unroll /countdown/.
reduce //.
compat.
auto.
qed ();
    



defineRaw /mypair x y/ /(x , y)/;


lemma "unroll_whnf"
/
  mypair 1 : nat -> nat & nat
/;

unfoldHead /mypair/.
fold /mypair 1/.
unfold /mypair/.
fold /mypair 1/.
introOf /x/.
unfold /mypair/.
typecheck.
qed ();


lemma "unroll_let_whnf"
/
  let f = (fn x y . (x, y)) in f 1 : nat -> nat & nat
/;

intro /f/.
unfoldHead /f/.
fold /f 1/.
unfold /f/.
fold /f 1/.
introOf /x/.
unfold /f/.
typecheck.
qed ();



lemma "unroll_rec_univ"
/
  forall i (a : U i -> U i) (b : U i -> U i) .
    b (future (a (rec t . future (a t))))
    -> b (rec t . future (a t))
/;

inference.
intro /i a b H/.
unrollTypeUniv /rec with i/.
auto.
qed ();


lemma "let_intro"
/
  forall i (a : U i) (m : a) . let x = m in x : a
/;

inference.
intro /i a m x/.
set /y/ /x/.
unfold /x in y/.
revert /x/.
intro /x/.
moveBefore /x/ /y/.
subst /x/.
hypof.
qed ();



lemma "let_fold_under"
/
  forall i (a : U i) (m n : a) (f : a -> a) (P : a -> U i).
    (forall x . P (f (f x)))
    -> P (f (f m))
/;

inference.
intro /i a m n f P H/.
set /g/ /fn x . f (f x)/.
moveBefore /g/ /H/.
fold /g x within x in H/.
unfold /g in H/.
reduce /H/.
fold /g x within x in H/.
fold /g m/.
unfold /g/.
reduce //.
fold /g m/.
apply /H/.
qed ();



lemma "let_fold"
/
  forall i (a : U i) (m n : a) . m : a
/;

inference.
intro /i a m n/.
set /x/ /m/.
moveBefore /x/ /n/.
assert /x : a/ /H/.
  {
  subst /x/.
  hypof.
  }
fold /x/.
unfold /x/.
unfold /x in H/.
fold /x in H/.
subst /x/.
hyp /H/.
qed ();



lemma "let_bind"
/
  forall m n .
    (let x = m in x + n) = m + n : nat
/;

inference.
intro /m n/.
reflexivity.
qed ();



lemma "injection_zero_succ"
/
  forall n . 
    0 = 0 : nat
    -> 0 = succ n : nat 
    -> void
/;

inference.
intro /n Heq1 Heq2/.
injection /Heq1/.
injection /Heq2/.
qed ();



lemma "injection_succ_zero"
/
  forall n . succ n = 0 : nat -> void
/;

inference.
intro /n Heq/.
injection /Heq/.
qed ();



lemma "injection_succ"
/
  forall m n . succ m = succ n : nat -> m = n : nat
/;

inference.
intro /m n Heq/.
injection /Heq/.
reintro /Heq'/.
hyp /Heq'/.
qed ();



lemma "injection_exists"
/
  forall i (a : U i) (b : a -> U i) (x y : a) (v : b x) (w : b y) .
    (x , v) = (y , w) : (exists (x : a) . b x)
    -> (x = y : a & v = w : b x)
/;

inference.
intro /i a b x y v w Heq/.
injection /Heq/.
reintro /Heq1 Heq2/.
exact /(Heq1 , Heq2)/.
qed ();



lemma "injection_inl"
/
  forall i (a b : U i) (x y : a) .
    inl x = inl y : (a % b)
    -> x = y : a
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
reintro /Heq'/.
hyp /Heq'/.
qed ();



lemma "injection_inr"
/
  forall i (a b : U i) (x y : b) .
    inr x = inr y : (a % b)
    -> x = y : b
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
reintro /Heq'/.
hyp /Heq'/.
qed ();



lemma "injection_inl_inr"
/
  forall i (a b : U i) (x : a) (y : b) .
    inl x = inr y : (a % b)
    -> void
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
qed ();



lemma "injection_inr_inl"
/
  forall i (a b : U i) (x : b) (y : a) .
    inr x = inl y : (a % b)
    -> void
/;

inference.
intro /i a b x y Heq/.
injection /Heq/.
qed ();



lemma "lam_compat"
/
  forall i (a : U i) (f : nat -> a) .
    (fn x . f (succ x)) = (fn x . f (x + 1)) : (nat -> a)
/;

inference.
intro /i a f/.
compat.
compat.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "lam_compat_dep"
/
  forall i (a : nat -> U i) (f : forall (x : nat) . a x) .
    (fn x . f (succ x)) = (fn x . f (x + 1)) : (forall (x : nat) . a (succ x))
/;

inference.
intro /i a f/.
compat.
compat.
rewrite /-> Nat.plus_commute/.
reflexivity.
qed ();



lemma "pair_compat_dep"
/
  forall i (a : U i) (b : a -> U i) (x y : a) (z : b x) .
    x = y : a
    -> (x , z) = (y , z) : (exists (x : a) . b x)
/;

inference.
intro /i a b x y z Heq/.
compat.
hyp /Heq/.
qed ();



lemma "next_compat"
/
  forall i (a : U i) (x y : a) .
    future (x = y : a)
    -> next x = next y : (future a)
/;

inference.
intro /i a x y Heq/.
destruct /Heq/ /[Heq]/.
compat.
hyp /Heq/.
qed ();



lemma "inl_compat"
/
  forall i (a b : U i) (x y : a) .
    x = y : a
    -> inl x = inl y : (a % b)
/;

inference.
intro /i a b x y Heq/.
compat.
hyp /Heq/.
qed ();




lemma "guards"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
introOf /H/.
typecheck.
apply /Hba/.
hyp /H/.
qed ();



lemma "typecheck_guard"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
typecheck.
reintro /Hb/.
apply /Hba/.
hyp /Hb/.
qed ();



lemma "infer_guard"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
typecheck1 >>> [typecheck, idtac].
reintro /Hb/.
infer /x/ /Hx/.
  {
  apply /Hba/.
  hyp /Hb/.
  }
hyp /Hx/.
qed ();



lemma "infer_guard_ap"
/
  forall i (a b c : U i) (x : a -g> c) .
    (b -> a)
    -> x : b -g> c
/;

inference.
intro /i a b c x Hba/.
typecheck1 >>> [typecheck, idtac].
reintro /Hb/.
infer /x ap (Hba Hb)/ /Hx/.
unfold /ap in Hx/.
hyp /Hx/.
qed ();



lemma "compat_guard"
/
  forall i (a b c : U i) (f : a -> b -g> c) (x x' : a) .
    b
    -> x = x' : a
    -> f x = f x' : c
/;

intro /i a b c f x x' Hb Heq/.
compat.
  {
  hyp /Heq/.
  }
  
  {
  hyp /Hb/.
  }
qed ();



lemma "compat_guard_ap"
/
  forall i (a b c : U i) (f : a -> b -g> c) (x x' : a) .
    b
    -> x = x' : a
    -> f x = f x' : c
/;

intro /i a b c f x x' Hb Heq/.
convert /f x ap Hb/.
compat.
hyp /Heq/.
qed ();



lemma "level_assumption"
/
  forall i j (a : U i) .
    i <l= j
    -> a : U j
/;

inference.
intro /i j a H/.
typecheck.
qed ();



val four = (4, ETerm.closed /4/);

lemma "embedded"
/
  \snd four\ : \Term.Const Prim.nat\
/;

typecheck.
qed ();



lemma "strict_cycle"
/
  (fn e . U e : U e) _
/;

reduce //.
inference.
(*
Should see:
Level error: constraints have no solution: strict cycle
*)
Prover.abandon ();


lemma "inexpressible_constraint1"
/
  (fn e . (forall i (a : U i) . a) : U e) _
/;

reduce //.
inference.
(*
Should see:
Level error: constraints have no solution: scope violation
*)
Prover.abandon ();


lemma "inexpressible_constraint2"
/
  (fn e . forall i (a : U i) . a : U e) _
/;

reduce //.
inference.
(* Should see:
Level error: constraints have no solution: scope violation
*)
Prover.abandon ();


lemma "exotic_cycle"
/
  forall (f : level -> level) .
    (fn e . forall (a : univ (f e)) . a : U e) _
/;

reduce //.
inference.
(* Should see:
Warning: not solving exotic constraints: unrecognized level operator
*)
Prover.abandon ();


lemma "solve_universe"
/
  forall i j .
    (fn e .
       forall (a : U i) (b : U j) (c : U e) .
         a & b & b & c & unit & U i & U 1 : U e)
    _
/;

reduce //.
inference.
(* solution should be [2 (1 + i) j] *)
intro /i j a b c/.
typecheck.
qed ();



lemma "solve_universe_simple"
/
  (fn e . (unit : U e) & (U e : U (1 + e))) _
/;

reduce //.
inference.
split >> typecheck.
qed ();



lemma "univ_include_path"
/
  forall i j (f : nat -> U i) . lleq i j -> f 2 : U j
/;

inference.
intro /i j f H/.
typecheck.
qed ();



lemma "subtype_univ"
/
  forall i j . lleq i j -> U i <: U j
/;

inference.
intro /i j H/.
typecheck.
qed ();


lemma "typecheck_univ"
/
  forall i j . lleq (lsucc i) j -> U i : U j
/;

intro /i j H/.
typecheck.
hyp /H/.
qed ();


lemma "typecheck_nat"
/
  4 : nat
/;

typecheck.
qed ();


lemma "destruct_nat_hyp"
/
  forall i (P : nat -> U i) (n : nat) . P n -> P n
/;

intro /i P n H/.
destruct /n/ /| n/.
  {
  hyp /H/.
  }

  {
  hyp /H/.
  }
qed ();



lemma "use_nat_case"
/
  forall (n : nat) .
    nat_case n void (fn _ . unit) : type
/;

intro /n/.
destruct /n/ /| | n/.
  {
  reduce //.
  typecheck1.
  }

  {
  reduce //.
  typecheck1.
  }

  {
  reduce //.
  typecheck1.
  }
qed ();



lemma "nat_induction"
/
  forall (n : nat) .
    fix (fn f x . nat_case x void (fn y . unit & f y)) n : type
/;

intro /n/.
sinduction /n/.
reintro /IH/.
destruct /n/ /| n/.
  {
  unroll /fix/.
  reduce //.
  typecheck1.
  }

  {
  unroll /fix/.
  reduce //.
  fold /manual (fix _ _)/.
  typecheck.
  apply /IH/.
  apply /Nat.lt_succ/.
  }
qed ();



defineRaw /identity/ /fn x . x/;

lemma "identity_type"
/
  identity : foralltp a . a -> a
/;

unfold /identity/.
typecheck.
qed ();



lemma "identity_type2"
/
  identity : foralltp a . a -> a
/;

introOf /a x/.
unfold /identity/.
reduce //.
typecheck.
qed ();



lemma "identity_type3"
/
  foralltp a . a -> a
/;

intro /a x/.
hyp /x/.
qed ();



lemma "induct_mu"
/
  forall (x : nat) . x : nat
/;

setOpacity Prim.nat Constant.HARD;

intro /x/.
unfold /nat in x , nat/.
sinduction /x/.
reintro /u x Hu IH/.
unrollType /mu/.
destruct /x/ /| x/.
  {
  typecheck.
  }

  {
  clear /Hu/.
  typecheck1.
    {
    typecheck.
    }
  apply /IH/.
  }

setOpacity Prim.nat Constant.OPAQUE;
qed ();



lemma "unroll_mu" 
/
  forall (x : nat) . x : nat
/;

setOpacity Prim.nat Constant.HARD;

intro /x/.
unrollType /nat in x/.
unrollType /nat/.
assert /nat/ /H/.
  {
  unrollType /nat/.
  hyp /x/.
  }
clear /H/.
hypof.

setOpacity Prim.nat Constant.OPAQUE;
qed ();



defineRaw /badnat/ /rec t . unit % future t/;

lemma "badnat_type" /badnat : U 0/;

unfold /badnat/.
typecheck.
qed ();
recordTyping "badnat_type";



lemma "unroll_rec" 
/
  forall (x : badnat) . x : badnat
/;

intro /x/.
unrollType /badnat in x/.
unrollType /badnat/.
assert /badnat/ /H/.
  {
  unrollType /badnat/.
  hyp /x/.
  }
clear /H/.
hypof.
qed ();



lemma "intersection" 
/
  (fn t u . t -> t) : intersect i j . U i -> U j -> U i
/;

typecheck.
qed ();



lemma "nat_eq_refl" 
/
  forall (n : nat) . n = n : nat
/;

setOpacity Prim.nat Constant.HARD;

unfold /nat at 0/.
introRaw /n/.
  {
  convert /(mu t . unit % t) : type/.
  withTypecheck RuleTactic.muForm.
  }
let do dir = Tactic.withidir
in
  RefineTactic.refine (Rule.muInd
                   (ETerm.withidir dir /additional` t . unit % t/)
                   (ETerm.withidir dir /additional` x . x = x : nat/)
                   (ETerm.withidir dir /n/))
end.
Prover.pull 2;
  {
  Tactic.chdir (Directory.literal (parseIdents /n t x H IH/)).
  clear /n/.
  fold /nat in H/.

setOpacity Prim.nat Constant.OPAQUE;
Prover.abandon ();



lemma "contract_goals" /
  forall i (a : U i) . a -> a & unit & a
/;

intro /i a H/.
split >>> [idtac, split].
pull 2;
Prover.reorder (Reorder.contract 1);
  {
  hyp /H/.
  }

  {
  split.
  }
qed ();



defineRaw /myunit/ /unit/;
Constant.setOpacity (parseConstant /myunit/) Constant.SOFT;


lemma "soft_constant" /
  forall i (a : U i) (f : unit -> unit) (x : myunit) . myunit
/;

inference.
intro /i a f x/.
apply /f/.
hyp /x/.
qed ();



defineRaw /myarrow a b/ /a -> b/;
Constant.setOpacity (parseConstant /myarrow/) Constant.SOFT;

lemma "soft_constant_2" /
  forall i (a : U i) . myarrow a a
/;

inference.
intro /i a x/.
hyp /x/.
qed ();



lemma "inference" /
  forall i . (nat : U i)
/;

inference.
intro /i/.
typecheck.
qed ();



lemma "extensionalityOf" /
  forall i (a b : U i) (p : b -> U i) (f : a -> b) .
    (forall (x : a) . p (f x))
    -> f : a -> { x : b | p x }
/;

intro /? ? ? ? ? ?/.
reintro /H/.
introOf /x/.
typecheck.
split.
apply /H/.
qed ();



lemma "prove_subtype" /
  forall i (a a' : U i) (b : a -> U i) (b' c : U i) 
    (x : c -> forall (z : a) . b z) (y : c) (f : (a' -> b') -> c) .
    a' <: a
    -> (forall (z : a) . b z <: b')
    -> f (x y) : c
/;

intro /i a a' b b' c x y f Ha Hb/.
assert /forall (z : a') . b z <: b'/ /H/.
  {
  intro /z/.
  apply /Hb/.
  }
typecheck.
qed ();
  


lemma "infer_spine2" /
  forall i (a b : U i) (c : b -> U i) (x : a) (f : forall (y : b) . c y) .
    a = b : type
    -> f x : c x
/;

intro /i a b c x f Heq/.
assert /f : forall (y : a) . c y/ /Hof/.
  {
  eeqtp >>> [idtac , hypof].
  typecheck1.
    {
    symmetry.
    hyp /Heq/.
    }
  reflexivity.
  }
inferSpine /Hof/ /__ x/ /Hof'/.
hyp /Hof'/.
qed ();



Prover.openGoal
  (Judgement.make
     (Seq.cons (Judgement.Tm (ETerm.closed / 0 : void /)) Seq.empty)
     (ETerm.closed / 0 : void /),
   Directory.literalStr ["H"]);

hyp /H/.
qed ();



lemma "assert_pattern"
  / forall i (a : U i) (b : a -> U i) (x : a) (y : b x) . unit /;

intro /i a b x y/.
assert /exists (x' : a) . b x'/ /x' y'/.
  {
  exists /x/.
  hyp /y/.
  }
split.
qed ();



lemma "reintro_weaken"
  / forall (i : level) . 
      (forall (a : U i) (b : a -> U i) (c : forall (x : a) . b x -> U i) . void -> zero)
      : type /;

intro /i/.
fold /manual 0/.
typecheck.
reintro /x _ _ v/.
destruct /v/ /0/.
qed ();



lemma "eeqtp_symm"
  / forall i (a b : U i) . a <:> b -> a <:> b /;

intro /i a b H/.
symmetry.
symmetryIn /H/.
hyp /H/.
qed ();



lemma "set_extensionality"
  / forall i (a : U i) (b : a -> U i) (m n : { x : a | b x }) .
      m = n : a
      -> m = n : { x : a | b x } /;

intro /i a b m n Heq/.
infer /m/ /Hofm/.
destructSet /Hofm/ /H/.
clear /Hofm/.
extensionality >> auto.
qed ();



lemma "fixed"
  / pause (fix (fn t . void -> t)) /;

unroll /fix/ >> reduce /concl/.
unroll /fix/ >> reduce /concl/.
unroll /fix/ >> reduce /concl/.
unroll /pause/.
intro /_ _ 0/.
qed ();



defineRaw /myfix/
  / fn f . pause (fn x . f (pause x x)) (fn x . f (pause x x)) /;
val myfix = Namespace.resolve [`"myfix"];

structure R = Reduction;

val t1 = parseLTerm /myfix 0/;
val t2 = parseLTerm /0 (myfix 0)/;

val r1 =
  R.trans
    [
    R.unfold,
    R.beta 1,
    R.user PrimReduction.unroll_pause,
    R.beta 1
    ];

val r2 =
  R.within [1]
    (R.trans
       [
       R.unfold,
       R.beta 1
       ]);

Show.showLiteral (Normalize.simplifyAll (R.reduce r1 t1));
Show.showLiteral (Normalize.simplifyAll (R.reduce r2 t2));

val r = R.new myfix [] 1 t2 r1 r2;



lemma "paused"
  / pause (fn x . void -> pause x x) (fn x . void -> pause x x) /;

reduceUsing /\Reduction.user PrimReduction.unroll_pause\/.
whreduce /concl/.
unreduceUsing /\Reduction.user PrimReduction.unroll_pause\ with pause (fn x . void -> pause x x) (fn x . void -> pause x x)/.
reduceUsing /\Reduction.user PrimReduction.unroll_pause\/.
convertUnreduceUsing /\Reduction.user PrimReduction.unroll_pause\ with pause (fn x . void -> pause x x) (fn x . void -> pause x x)/.
unroll /pause/.
whreduce /concl/.
roll /pause (fn x . void -> pause x x) (fn x . void -> pause x x)/.
unroll /pause/.
showPosition /at 0/;
convertRoll /pause (fn x . void -> pause x x) (fn x . void -> pause x x) at 0/.
unroll /pause/.
reduce /concl/.
unroll /pause/.
reduce /concl/.
unroll /pause/.
reduce /concl/.
intro /0/.
qed ();



defineRaw /natind/
/
  fix (fn f n hz hs .
         nat_case n hz (fn n' . hs n' (f n' hz hs)))
/;


val t1 =
  parseLTerm
    / natind zero 1 0 /;

val r1 =
  R.trans
    [
    R.unfold,
    R.user PrimReduction.unroll_fix,
    R.beta 4,
    R.user PrimReduction.nat_case_zero
    ];

val natind_zero = R.new (parseConstant /natind/) [(0, parseConstant /zero/, 0)] 2 (Term.Var 1) r1 R.refl;

val t2a =
  parseLTerm
    / natind (succ 2) 1 0 /;

val r2a =
  R.trans
    [
    R.unfold,
    R.user PrimReduction.unroll_fix,
    R.beta 4,
    R.user PrimReduction.nat_case_succ,
    R.beta 1
    ];

val t2b =
    parseLTerm
      / 0 2 (natind 2 1 0) /;

val r2b =
  R.within [2] R.unfold;

val natind_succ = R.new (parseConstant /natind/) [(0, parseConstant /succ/, 1)] 2 t2b r2a r2b;

Define.register natind_zero;
Define.register natind_succ;



lemma "reduction"
  / unit /;

assert /natind 4 unit (fn _ a . nat & a) : type / /H/.
  {
  reduce /concl/.
  typecheck.
  }
reduce /H/.
split.
qed ();



defineRaw /mynatind/ / natind /;
val mynatind = Namespace.resolve [`"mynatind"];

val t1 = parseLTerm /mynatind (succ 2) 1 0/;
val t2 = parseLTerm /0 2 (mynatind 2 1 0)/;

val r1 =
  R.trans 
    [
    R.unfold,
    R.user natind_succ
    ];

val r2 = R.within [2] R.unfold;

Show.showLiteral (Normalize.simplifyAll (R.reduce r1 t1));
Show.showLiteral (Normalize.simplifyAll (R.reduce r2 t2));

val r = R.new mynatind [(0, Prim.succ, 1)] 2 t2 r1 r2;

Show.showLiteral (Normalize.simplifyAll (R.reduce (R.user r) t1));

val t1' = parseLTerm /mynatind zero 1 0/;
val t2' = parseLTerm /1/;

val r1' =
  R.trans
    [
    R.unfold,
    R.user natind_zero
    ];

Show.showLiteral (Normalize.simplifyAll (R.reduce r1' t1'));

val r' = R.new mynatind [(0, Prim.zero, 0)] 2 (Term.Var 1) r1' R.refl;

Show.showLiteral (Normalize.simplifyAll (R.reduce (R.user r') t1'));



lemma "myreduction_manual"
  / unit /;

assert /mynatind 4 unit (fn _ a . nat & a) : type / /H/.
  {
  reduce /concl/.
  showPosition /at 1/;
  reduceUsing /\R.trans [R.user r, R.beta 2]\ at pos 1/.
  showPosition /at 3/;
  reduceUsing /\R.trans [R.user r, R.beta 2]\ at pos 3/.
  showPosition /at 5/;
  reduceUsing /\R.trans [R.user r, R.beta 2]\ at pos 5/.
  showPosition /at 7/;
  reduceUsing /\R.trans [R.user r, R.beta 2]\ at pos 7/.
  showPosition /at 9/;
  reduceUsing /\Reduction.user r'\ at pos 9/.
  typecheck.
  }
split.
qed ();


Define.register r;
Define.register r';


lemma "myreduction"
  / unit /;

assert /mynatind 4 unit (fn _ a . nat & a) : type / /H/.
  {
  reduce /concl/.
  typecheck.
  }
reduce /H/.
split.
qed ();


defineRaw /mypause/ / fn x . x /;
val mypause = Namespace.resolve [`"mypause"];

val t1 = parseLTerm /mypause 0/;

val r1 =
  R.trans [R.unfold, R.beta 1];

Show.showLiteral (Normalize.simplifyAll (R.reduce r1 t1));

val r = R.new mypause [] 1 (Term.Var 0) r1 R.refl;

Show.showLiteral (Normalize.simplifyAll (R.reduce (R.user r) (ETerm.closed /mypause (nat -> nat)/)));



lemma "rewrite_subtype_of"
  / forall i (a b : U i) (x : a) .
      a <: b
      -> x : b /;

intro /i a b x H/.
assert /x : a/ /Hof/.
  {
  hypof.
  }
rewriteRaw /-> H in Hof/.
rewriteRaw /<- H/.
hypof.
qed ();


lemma "rewrite_subtype_of_forall"
  / forall i (a : U i) (b c : a -> U i) (x : a) (y : b x) .
      (forall x . b x <: c x)
      -> y : c x /;

intro /i a b c x y H/.
assert /y : b x/ /Hof/.
  {
  hypof.
  }
rewriteRaw /-> H in Hof/.
  {
  typecheck.
  }
rewriteRaw /<- H/.
Prover.pull 1;
  {
  hypof.
  }
hypof.
qed ();



lemma "rewrite_subtype_of_connectives"
  / forall i (a b c d : U i) (x : nat -> a) (y : d) .
      a <: b
      -> forall (n : nat) . c -> d & (x n : b) & d /;

intro /i a b c d x y H/.
assert /forall (n : nat) . c -> d & (x n : a) & d/ /Hof/.
  {
  intro /n Hc/.
  split.
    {
    hyp /y/.
    }
  split.
    {
    typecheck.
    }
  hyp /y/.
  }
rewriteRaw /-> H in Hof/.
rewriteRaw /<- H/.
intro /n Hc/.
split.
  {
  hyp /y/.
  }
split.
  {
  typecheck.
  }
hyp /y/.
qed ();



lemma "rewrite_subtype_of_capture"
  / forall i (a b : nat -> U i) (c d : U i) (x : forall (n : nat) . a n) (y : d) .
      (forall n . a n <: b n)
      -> forall (n : nat) . c -> d & (x n : b n) & d /;

intro /i a b c d x y H/.
assert /forall (n : nat) . c -> d & (x n : a n) & d/ /Hof/.
  {
  intro /n Hc/.
  split.
    {
    hyp /y/.
    }
  split.
    {
    typecheck.
    }
  hyp /y/.
  }
rewrite /-> H n within n in Hof/.
rewrite /<- H n within n/.
intro /n Hc/.
split.
  {
  hyp /y/.
  }
split.
  {
  typecheck.
  }
hyp /y/.
qed ();



lemma "rewrite_eeqtp_concl"
  / forall i (a b : U i) .
      a <:> b
      -> a
      -> b /;

intro /i a b Heq Ha/.
rewrite /<- Heq/.
hyp /Ha/.
qed ();



lemma "rewrite_eeqtp_hyp"
  / forall i (a b c : U i) (d : b -> U i) (x : a) .
      a <:> (b & c)
      -> (forall (y : b) . d y)
      -> d (x #1) /;

intro /i a b c d x Heq H/.
moveBefore /Heq/ /x/.
rewrite /-> Heq in x/.
destruct /x/ /y z/.
reduce /concl/.
apply /H/.
qed ();



lemma "rewrite_subtype_simple1"
  / forall i (a a' b b' : U i) .
      a <: a'
      -> b <: b'
      -> a & b
      -> a' & b' /;

intro /i a a' b b' Ha Hb H/.
destruct /H/ /H1 H2/.
split.
  {
  rewrite /<- Ha/.
  hyp /H1/.
  }

  {
  rewrite /-> Hb in H2/.
  hyp /H2/.
  }
qed ();



lemma "rewrite_subtype_simple2"
  / forall i (a a' b b' : U i) .
      a <: a'
      -> b <: b'
      -> a & b
      -> a' & b' /;

intro /i a a' b b' Ha Hb H/.
rewrite /-> Ha in H/.
rewrite /<- Hb/.
hyp /H/.
qed ();



lemma "multi_rewrite"
  / forall (m m' : nat) .
      m = m' : nat
      -> unit
      -> (m , m) = (m' , m') : (nat & nat) /;

unfold /arrow in concl at 1 0/.
intro /m m'/.
fold /_ -> _/.
fold /_ -> _/.
intro /Hm _/.
testRewrite /-> Hm in concl at 1 0/;
rewrite /-> Hm in concl at 1 0/.
reflexivity.
qed ();



lemma "generalize"
  / forall (f : nat -> nat) (m n : nat) . (forall n . f m = n : nat) -> f m = f n : nat /;

intro /f m n/.
generalize /f m/ /nat/ /x/.
generalizeAt /f n/ /nat/ [0] /y/.
intro /H/.
apply /H/.
qed ();



lemma "subst"
  / forall (n : nat) . n = 0 : nat -> n = 0 : nat /;

intro /n H/.
symmetryIn /H/.
subst /n/.
reflexivity.
qed ();



lemma "substitution"
  / forall (n : nat) . n = 0 : nat -> n = 0 : nat /;

intro /n H/.
substitution /n/ /0/.
  {
  hyp /H/.
  }
reflexivity.
qed ();



lemma "revert"
  / forall i (a : U i) (x y : a) . x = y : a -> x = y : a /;

intro /i a x y Heq/.
revert /y x Heq/.
intro /y x Heq/.
hyp /Heq/.
qed ();



lemma "extensionality"
/
  forall i (a : U i) (b c : a -> U i) (d : forall x . c x -> U i) .
    (fn t .
       forall (m n : t) .
         (forall x y . m x y #1 = n x y #1 : c x)
         -> (forall x y . m x y #2 #1 = n x y #2 #1 : d x (m x y #1))
         -> m = n : t)
    (forall (x : a) . b x -> exists (z : c x) . d x z & (x : a))
/;

reduce /concl/.
intro /i a b c d m n H1 H2/.
  {
  reintro /x y/.
  symmetry.
  apply /H1/.
  }
extensionalityAuto.
  {
  reintro /x y/.
  apply /H1/.
  }

  {
  reintro /x y Heq/.
  apply /H2/.
  }
qed ();



lemma "extensionality_arrows"
  / forall i (a : U i) (b c d e : a -> U i) .
      (fn t .
         forall (m n : t) .
           (forall x y z w . m x y z w = n x y z w : e x)
           -> m = n : t)
      (forall (x : a) . b x -> c x -t> d x -k> e x) /;

reduce /concl/.
intro /i a b c d e m n H/.
introEq /x y z w/.
apply /H/.
qed ();



lemma "extensionality_arrows_auto"
  / forall i (a : U i) (b c d e : a -> U i) .
      (fn t .
         forall (m n : t) .
           (forall x y z w . m x y z w = n x y z w : e x)
           -> m = n : t)
      (forall (x : a) . b x -> c x -t> d x -k> e x) /;

reduce /concl/.
intro /i a b c d e m n H/.
extensionalityAuto.
apply /H/.
qed ();



lemma "extensionality_future"
  / forall i (a b : U i) (m n : a -> future b) .
      (forall x .
         let next z = m x
         in
         let next z' = n x
         in
           future (z = z' : b))
      -> m = n : (a -> future b) /;

intro /i a b m n H1/.
introEq /x/.
so /H1 x/ /H2/.
clear /H1/.
revert /H2/.
generalize /m x/ /_/ /m'/.
generalize /n x/ /_/ /n'/.
intro /H2/.
clear /m n x/.
destruct /m'/ /[m'']/.
destruct /n'/ /[n'']/.
whreduce /H2/.
destruct /H2/ /[H3]/.
extensionality.
hyp /H3/.
qed ();



lemma "extensionality_future2"
  / forall i (a : U i) (b c : a -> U i)
      (m n : forall (x : a) . b x -> future (c x)) .
        (forall (x : a) (y : b x) .
           let next z = m x y 
           in
           let next z' = n x y
           in
             future (z = z' : (c x)))
        -> m = n : (forall (x : a) . b x -> future (c x)) /;
      
intro /i a b c m n H1/.
introEq /x y/.
so /H1 x y/ /H2/.
clear /H1/.
revert /H2/.
generalize /m x y/ /_/ /m'/.
generalize /n x y/ /_/ /n'/.
intro /H2/.
clear /m n y/.
destruct /m'/ /[m'']/.
destruct /n'/ /[n'']/.
whreduce /H2/.
destruct /H2/ /[H3]/.
extensionality.
hyp /H3/.
qed ();



lemma "extensionality_future_then_more"
/
  forall i (a b c : U i) (m n : a -> future (b -> c)) .
    (forall x .
       let next z = m x
       in
       let next z' = n x
       in
         future (forall y . z y = z' y : c))
    -> m = n : (a -> future (b -> c))
/;

inference.
intro /i a b c m n Heq/.
introEq /x/.
so /Heq x/ /H1/.
revert /H1/.
generalize /m x/ /_/ /m'/.
generalize /n x/ /_/ /n'/.
intro /H1/.
destruct /m'/ /[m'']/.
destruct /n'/ /[n'']/.
reduce /H1/.
destruct /H1/ /[H2]/.
extensionality.
reduce //.
introEq /y/.
apply /H2/.
qed ();



lemma "compatibility"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) (f : forall (x : a) . b x -> c -> d & e) (x x' : a) (y y' : b x) (z : c) .
      x = x' : a
      -> y = y' : b x
      -> f x' y z #1 = f x y' z #1 : d /;

intro /i a b c d e f x x' y y' z Heqx Heqy/.
compat.
  {
  symmetry.
  hyp /Heqx/.
  }

  {
  subsume /b x/.
    {
    intro /h/.
    eeqtp.
    Prover.pull 1;
      {
      hypof.
      }
    compat.
    hyp /Heqx/.
    }
  hyp /Heqy/.
  }
Prover.qed ();



lemma "reorder"
 / forall i (a : U i) (x1 x1' x2 x2' x3 x3' x4 x4' x5 x5' : a) (f : a -> a -> a -> a -> a -> a).
     x1 = x1' : a
     -> x2 = x2' : a
     -> x3 = x3' : a
     -> x4 = x4' : a
     -> x5 = x5' : a
     -> f x1 x2 x3 x4 x5 = f x1' x2' x3' x4' x5' : a /;

intro /i a x1 x1' x2 x2' x3 x3' x4 x4' x5 x5' f h1 h2 h3 h4 h5/.
Reorder.reorder compat (Reorder.rotateBackward 2)
>>> [hyp /h4/, hyp /h5/, hyp /h1/, hyp /h2/, hyp /h3/].
Prover.qed ();



lemma "refl"
  / 1 = 1 : nat /;

reflexivity.
Prover.qed ();



lemma "refl_type"
  / nat = nat : type /;

reflexivity.
Prover.qed ();



lemma "refl_subtype"
  / nat <: nat /;

reflexivity.
Prover.qed ();



lemma "symm"
  / 1 = 2 : nat /;

symmetry.
symmetry.
Prover.abandon ();



lemma "symm_type"
  / nat = bool : type /;

symmetry.
symmetry.
Prover.abandon ();



lemma "backchain"
  / forall i (a b : U i) (c d : a -> U i) (f : a -> a) (y : a) .
      (exists (z : a) . unit & (forall (x x' : a) . b -t> d z -k> d x' -> unit & (c (f x) -> d x)))
      -> d (f y) /;

intro /i a b c d f y g/.
apply /g #2/.
(* Should see:
[goal 4]
[ambiguous typing obligation]
E6842 : a

[goal 3]
c (f (f y))

[goal 2]
d E6842

[goal 1]
d (g #1)

[goal 0]
i : level
a : U i
b : U i
c : a -> U i
d : a -> U i
f : a -> a
y : a
g : exists (z : a) .
      unit
      & (forall (x : a) (x' : a) .
           b -t> d z -k> d x' -> unit & (c (f x) -> d x))
|-
b
*)
Prover.abandon ();



lemma "exploit"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : exists (y : a) . b y -> c -> (d -> e) & a) .
      b (f #1) -> c -> d -> e /;

intro /i a b c d e f x y z/.
exploit /f #2/ /H/.
  {
  hyp /x/.
  }

  {
  hyp /y/.
  }

  {
  apply /H/.
  hyp /z/.
  }
Prover.qed ();



lemma "eexploit"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : forall (y : a) . b y -> c -> (d -> e) & a)
      (w : a) .
      b w -> c -> d -> e /;

intro /i a b c d e f w x y z/.
eexploit /f/ /H/.
(* Should see:
[goal 3]
[ambiguous typing obligation]
E6984 : a

[goal 2]
e

[goal 1]
c

[goal 0]
i : level
a : U i
b : a -> U i
c : U i
d : U i
e : U i
f : forall (y : a) . b y -> c -> (d -> e) & a
w : a
x : b w
y : c
z : d
|-
b E6984
*)
  {
  hyp /x/.
  }

  {
  hyp /y/.
  }

  {
  apply /H/.
  hyp /z/.
  }

  {
  typecheck.
  }
Prover.qed ();



lemma "witness"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : exists (y : a) . b y -> c -> (d -> e) & a) .
      b (f #1) -> c -> d -> e /;

intro /i a b c d e f x y z/.
witness /f #2 __ y #1 z/.
hyp /x/.
Prover.qed ();



lemma "so"
  / forall i (a : U i) (b : a -> U i) (c d e : U i) 
      (f : exists (y : a) . b y -> c -> (d -> e) & a) .
      b (f #1) -> c -> d -> e /;

intro /i a b c d e f x y z/.
so /f #2 x __ #1 _/ /H/.
(* Should see:
[goal 2]
[ambiguous typing obligation]
E7123 : d

[goal 1]
e

[goal 0]
i : level
a : U i
b : a -> U i
c : U i
d : U i
e : U i
f : exists (y : a) . b y -> c -> (d -> e) & a
x : b (f #1)
y : c
z : d
|-
c
*)
  {
  hyp /y/.
  }

  {
  hyp /H/.
  }

  {
  RefineTactic.refine (Rule.hypothesisOf 0).
  }
Prover.qed ();



lemma "so_pattern"
  / forall i (a b c d : U i)
      (f : a -> b -> c % d) (g : c -> d).
      a -> b -> d /;

intro /i a b c d f g x y/.
so /f x __/ /(H1 | H2)/.
  {
  witness /y/.
  }

  {
  apply /g/.
  witness /H1/.
  }

  {
  witness /H2/.
  }
Prover.qed ();



lemma "nonidentical_eqtype"
  / (forall x y . unit -> squash (x = y : nat)) = (forall x y . unit -t> squash (y = x : nat)) : type /;

typecheck1.
1:{
  reintro /x/.
  typecheck1.
  1:{
    reintro /y/.
    withTypecheck $ repeat typecheck1.
    split.
      {
      intro /H/.
      symmetry.
      hyp /H/.
      }

      {
      intro /H/. 
      symmetry.
      hyp /H/.
      }
    }
    
    {
    reflexivity.
    }
  }

  {
  reflexivity.
  }
qed ();



lemma "intro_destruct"
  / forall 
      (x : exists (a : future (unit % nat)) . 
             (let next a' = a in future (exists z . a' = inr z : (unit % nat))) -> void)
      (y : { y : (unit % nat) | y = inl () : (unit % nat) }) .
      future (x #1 #prev = y : (unit % nat)) /;

intro /([ a ] f) (z H)/.
split.
unhide.
destruct /a/ /| a/.
  {
  symmetry.
  hyp /H/.
  }

  {
  so /f (next (a , ()))/ /Hfalse/.
  destruct /Hfalse/ /0/.
  }
qed ();



lemma "typecheck1"
  / forall (f : nat -> nat) (x : nat) . (forall (y : nat). f y : bool) -> f x : bool /;

intro /f x/.
introRaw /H/.
1:{
  typecheck.
  }
reintro /y/.
typecheck1 >>> [typecheck, idtac].
typecheck1.
infer /f y/ /_/.
Prover.abandon ();



lemma "typecheck2"
  / forall i (a : U i) (b : a -> U i) (f : forall (y : a) . a & b y) (x : a) . next (inl (f x #2 , x)) : future (b x & a % void) /;

intro /i a b f x/.
typecheck.
Prover.qed ();



lemma "typecheck3"
  / forall i (a : U i) (x y : a) (f : a -> unit % a) . sum_case (f x) (fn z . y) (fn z . z) : a/;

intro /i a x y f/.
typecheck.
Prover.qed ();



lemma "typecheck4"
  / forall i (a b : U i) (f : a -> b) (g : nat -> future a) . letnext (g 2) (fn y . next (f y)) : future b /;

intro /i a b f x/.
typecheck.
Prover.qed ();



lemma "typecheck5"
  / forall i (a : U i) (f : nat -> void) . abort (f 1) : a /;

intro /i a f/.
typecheck.
Prover.qed ();



lemma "and_or"
  / (unit % void) & unit /;

split.
  {
  left.
  split.
  }

  {
  split.
  }
qed ();



lemma "absurdum"
  / (exists (x : nat) . void % (unit & void) ) -> 0 = 1 : nat /;

intro /x/.
destruct /x/ /_ (0 | y 0) /.
qed ();



lemma "destruction"
  / forall i (f : (unit % nat) -> univ i) (x : (unit % nat) & f (inl ()) & (forall (x : nat) . f (inr x))) . 
      f (x #1) /;

intro /i f x/.
destruct /x/ /(| n) ht ?/.
  {
  hyp /ht/.
  }

  {
  reintro /hf/.
  exact /hf n/.
  }
qed ();



lemma "test_formation"
  / forall i (a b : U(i)) . arrow a b = tarrow a b : type /;

intro /i a b/.
typecheck1.
  {
  hypof.
  }

  {
  hypof.
  }
qed ();



lemma "rectype_formation"
  / forall i . (rec a . future (a -> a)) : U(i) /;

Typecheck.withTypecheck $ introRaw /i/.
qed ();



lemma "rectype_formation_type"
  / (rec a . future (a -> a)) : type /;

RuleTactic.recForm.
reintro /a/.
typecheck1.
typecheck1.
  {
  hypof.
  }

  {
  clear /v0/.
  hypof.
  }
qed ();


lemma "set_formation"
  / forall (i : level) . { x : nat | x = 0 : nat } = { x : nat | 0 = x : nat } : U(i) /;

intro /i/.
typecheck.
reintro /x/.
split.
  {
  intro /Heq/.
  symmetry.
  hyp /Heq/.
  }

  {
  intro /Heq/.
  symmetry.
  hyp /Heq/.
  }
qed ();



lemma "void_implies_void"
  /void -> void -> void/;

intro /x y/.
moveAfter /x/ /y/.
rename /x/ /z/.
clear /y/.
hyp /z/.
qed ();



lemma "all_whatever"
  / iforall (x : unit) . unit /;

intro /x/.
split.
qed ();



lemma "test_lrule"
  /forall (x : (exists (v : void) . void)) . (x : void) -> x : void/;

intro /x/.
introRaw /w/.
  {
  destruct /x/ /x y/.
  destruct /y/ /0/.
  }

  {
  typecheck.
  }
qed ();



lemma "foo"
  /void -> void -> void/;

apply /void_implies_void/.
qed ();



lemma "void_implies_void_form"
  / (forall (_ : void) . void -> void) : type /;

typecheck1.
  { typecheck. }
reintro /x/.
typecheck1.
  {
  typecheck1.
  }
reintro /y/.
typecheck1.
qed ();



lemma "bar"
  / forall (i : level) (a : U(i)) . a -> a /;

intro /i a x/.
hyp /x/.
qed ();
