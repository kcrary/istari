
Namespace.openModule (parseLongident /List/);


lemma "inject_no"
/
  forall i (a : U i) (x : a) .
    nil = x :: nil : list a
    -> void
/;

inference.
intro /i a x H/.
injection /H/.
qed ();



define /duo {a} x y/
/
  x :: y :: nil
//
  intersect i .
  forall (a : U i) .
    a -> a -> list a
/;

introOf /i a x y/.
unfold /duo/.
typecheck.
qed ();



lemma "unfold_duo"
/
  duo 1 2 = 1 :: 2 :: nil : list nat
/;

unfold /duo/.
reduce //.
compat.
qed ();



typedef
/
  datatype U 0
  of
    foobar : type =
    | foo : nat -> foobar
    | bar : foobar
/;


defineRaw /baz n/ /foo (n + 1)/;


lemma "baz_type"
/
  forall n . baz n : foobar
/;

unfold /baz/.
inference.
intro /n/.
induct /n/.
reintro /IH/.
typecheck.
qed ();



