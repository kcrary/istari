
Namespace.openModule (parseLongident /List/);



lemma "rewrite_leq"
/
  forall (l m n p : nat) . l <= m -> n <= p -> m <= n -> l <= p
/;

inference.
intro /l m n p Hlm Hnp Hmn/.
rewrite /-> Hnp in Hmn/.
rewrite /<- Hlm in Hmn/.
hyp /Hmn/.
qed ();



lemma "rewrite_leqz"
/
  forall (l m n p : integer) . l <z= m -> n <z= p -> m <z= n -> l <z= p
/;

inference.
intro /l m n p Hlm Hnp Hmn/.
rewrite /-> Hnp in Hmn/.
rewrite /<- Hlm in Hmn/.
hyp /Hmn/.
qed ();



lemma "rewrite_plusz"
/
  forall (m n p : integer) . n <z= p -> m +z n <z= m +z p
/;

intro /m n p Hnp/.
rewrite /<- Hnp/.
qed ();



lemma "rewrite_plusz_hyp"
/
  forall (m n p q : integer) . p <z= n -> m +z n <z= q -> m +z p <z= q
/;

intro /m n p q Hnp H/.
rewrite /<- Hnp in H/.
hyp /H/.
qed ();



lemma "rewrite_negz"
/
  forall (a b c d : integer) . b <z= a -> c <z= d -> ~z b <z= ~z d -> ~z a <z= ~z c
/;

intro /a b c d Hba Hcd H/.
rewrite /<- Hcd in H/.
rewrite /-> Hba in H/.
hyp /H/.
qed ();



lemma "destruct_hidden"
/
  forall (m n : nat) . { m <= n & unit } -> m = m : nat -> m <= n
/;

intro /m n H1 H2/.
destruct /H1/ /[(H H')]/.
auto.
qed ();



lemma "unhide_hyp"
/
  forall (m n : nat) . { m <= n } -> m <= n & unit
/;

intro /m n H/.
destruct /H/ /[H]/.
unhide.
auto.
qed ();



lemma "trivialize"
/
  forall i (a : U i) (m n : nat) .
    a
    -> (a -> m <= n)
    -> m <= n
/;

inference.
intro /i a m n Ha H/.
trivialize.
auto.
qed ();
Show.showClosed $ Option.valOf $ Constant.definition $ parseConstant /trivialize/;



lemma "trivialize_typecheck"
/
  forall i (a : U i) (m n : a) .
    m = n : a
    -> () : m = n : a
/;

inference.
intro /i a m n H/.
typecheck.
qed ();



lemma "inject_no"
/
  forall i (a : U i) (x : a) .
    nil = x :: nil : list a
    -> void
/;

inference.
intro /i a x H/.
injection /H/.
qed ();



define /duo {a} x y/
/
  x :: y :: nil
//
  intersect i .
  forall (a : U i) .
    a -> a -> list a
/;

introOf /i a x y/.
unfold /duo/.
typecheck.
qed ();



lemma "unfold_duo"
/
  duo 1 2 = 1 :: 2 :: nil : list nat
/;

unfold /duo/.
reduce //.
compat.
qed ();



typedef
/
  datatype U 0
  of
    foobar : type =
    | foo : nat -> foobar
    | bar : foobar
/;


defineRaw /baz n/ /foo (n + 1)/;


lemma "baz_type"
/
  forall n . baz n : foobar
/;

unfold /baz/.
inference.
intro /n/.
induct /n/.
reintro /IH/.
typecheck.
qed ();
