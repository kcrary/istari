
openModule /List/;
openModule /Bar/;


lemma "check_bindbar"
/
  forall i (a b : U i) (x : bar a) (f : a -> bar b) .
    (bindbar y = x in f y) : bar b
/;

intro /i a b x f/.
typecheck.
qed ();


lemma "contrapositive"
/
  forall i (a b : U i) .
    not a
    -> (b -> a)
    -> not b
/;

inference.
intro /i a b Hna Hba/.
contrapositive /Hna/.
auto.
qed ();



lemma "not_equal"
/
  1 != 2 : nat
/;

unfold /neq/.
omega.
qed ();



lemma "symbol_inequality"
/
  not (sym`"foo" = sym`"bar" : Symbol.symbol)
/;

rewrite /<- Symbol.istrue_symbol_eqb/.
reduce //.
apply /Bool.not_istrue_false/.
qed ();


lemma "symbol_eqb_test"
/
  if Symbol.symbol_eqb sym`"foo" sym`"bar" then void else unit
/;

reduce //.
split.
qed ();



lemma "length_one"
/
  forall (x : nat) . length (x :: nil) = 1 : nat
(*
  explicit` (`forall nat (fn x . eq nat (length nat (cons nat x (nil nat))) (succ zero)))
*)
/;

intro /x/.
auto.
(* qed should return an error *)
Prover.abandon ();


define /isnil {a} l/
/
  list_case l true (fn _ _ . false)
(*
  explicit` (fn a l . list_case a bool l true (fn v0 v1 . false))
*)
//
  intersect i . forall (a : U i) . list a -> bool
/;

inference.
unfold /isnil/.
introOf /i a l/.
reduce //.
destruct /l/ /| h t/.
  {
  reduce //.
  typecheck.
  }

  {
  reduce //.
  typecheck.
  }
(* qed should return an error *)
Prover.abandon ();



lemma "leqz_reflexivity"
/
  forall a . a <z= a
/;

inference.
intro /a/.
transitivity /a/.
  {
  reflexivity.
  }

  {
  auto.
  }
qed ();



lemma "rewrite_leq"
/
  forall (l m n p : nat) . l <= m -> n <= p -> m <= n -> l <= p
/;

inference.
intro /l m n p Hlm Hnp Hmn/.
rewrite /-> Hnp in Hmn/.
rewrite /<- Hlm in Hmn/.
hyp /Hmn/.
qed ();



lemma "rewrite_leqz"
/
  forall (l m n p : integer) . l <z= m -> n <z= p -> m <z= n -> l <z= p
/;

inference.
intro /l m n p Hlm Hnp Hmn/.
rewrite /-> Hnp in Hmn/.
rewrite /<- Hlm in Hmn/.
hyp /Hmn/.
qed ();



lemma "rewrite_plusz"
/
  forall (m n p : integer) . n <z= p -> m +z n <z= m +z p
/;

intro /m n p Hnp/.
rewrite /<- Hnp/.
qed ();



lemma "rewrite_plusz_hyp"
/
  forall (m n p q : integer) . p <z= n -> m +z n <z= q -> m +z p <z= q
/;

intro /m n p q Hnp H/.
rewrite /<- Hnp in H/.
hyp /H/.
qed ();



lemma "rewrite_negz"
/
  forall (a b c d : integer) . b <z= a -> c <z= d -> ~z b <z= ~z d -> ~z a <z= ~z c
/;

intro /a b c d Hba Hcd H/.
rewrite /<- Hcd in H/.
rewrite /-> Hba in H/.
hyp /H/.
qed ();



lemma "destruct_hidden"
/
  forall (m n : nat) . { m <= n & unit } -> m = m : nat -> m <= n
/;

intro /m n H1 H2/.
destruct /H1/ /[(H H')]/.
auto.
qed ();



lemma "unhide_hyp"
/
  forall (m n : nat) . { m <= n } -> m <= n & unit
/;

intro /m n H/.
destruct /H/ /[H]/.
unhide.
auto.
qed ();



lemma "trivialize"
/
  forall i (a : U i) (m n : nat) .
    a
    -> (a -> m <= n)
    -> m <= n
/;

inference.
intro /i a m n Ha H/.
trivialize.
auto.
qed ();
Show.showClosed $ Option.valOf $ Constant.definition $ parseConstant /trivialize/;



lemma "trivialize_typecheck"
/
  forall i (a : U i) (m n : a) .
    m = n : a
    -> () : m = n : a
/;

inference.
intro /i a m n H/.
typecheck.
qed ();



lemma "inject_no"
/
  forall i (a : U i) (x : a) .
    nil = x :: nil : list a
    -> void
/;

inference.
intro /i a x H/.
injection /H/.
qed ();



define /duo {a} x y/
/
  x :: y :: nil
//
  intersect i .
  forall (a : U i) .
    a -> a -> list a
/;

introOf /i a x y/.
unfold /duo/.
typecheck.
qed ();



lemma "unfold_duo"
/
  duo 1 2 = 1 :: 2 :: nil : list nat
/;

unfold /duo/.
reduce //.
compat.
qed ();



typedef
/
  datatype U 0
  of
    foobar : type =
    | foo : nat -> foobar
    | bar : foobar
/;


defineRaw /baz n/ /foo (n + 1)/;


lemma "baz_type"
/
  forall n . baz n : foobar
/;

unfold /baz/.
inference.
intro /n/.
sinduction /n/.
reintro /IH/.
typecheck.
qed ();



openModule /Wtype/;


define /natish/
/
  wtype (x : bool) . if x then void else unit
//
  U 0
/;

unfold /natish/.
typecheck.
qed ();



define /zeroish/
/
  (true , (fn _ . ()))
//
  natish
/;

unfold /zeroish , natish/.
typecheck.
reintro /x/.
destruct /x/ /0/.
qed ();



define /succish x/
/
  (false , (fn _ . x))
//
  natish -> natish
/;

unfold /succish , natish at all/.
typecheck.
qed ();



define /natrecish P hz hs n/
/
  wtype_iter bool (fn n . if n then void else unit) P
    (fn x y f .
       if x then
         hz
       else
         hs (y ()) (f ()))
    n
//
  intersect i .
  forall (P : natish -> U i) .
    P zeroish
    -> (forall (m : natish) . P m -> P (succish m))
    -> forall (n : natish) . P n
/;

inference.
assert /natish = (wtype (x : bool) . if x then void else unit) : U 0/ /Heq/.
  {
  unfold /natish/.
  typecheck.
  }
introOf /i P hz hs n/.
unfold /natish in n/.
sinduction /n/.
reintro /IH/.
destruct /n/ /x y/.
destruct /x/ /|/.
  {
  unfold /natrecish/.
  unroll /wtype_iter/.
  reduce //.
  infer /hz/ /H/.
  typecheck.
  unfold /zeroish/.
  subsume /_/.
    {
    unfold /natish/.
    apply /wtype_roll/.
    }
  reduce //.
  compat.
  introEq /x/.
    {
    reintro /x/.
    destruct /x/ /0/.
    }

    {
    destruct /x/ /0/.
    }
  }

  {
  reduce /y/.
  fold /natish in y/.
  unfold /natrecish/.
  unroll /wtype_iter/.
  reduce //.
  fold /natrecish P hz hs _/.
  typecheck.
    {
    subsume /_/.
      {
      unfold /natish/.
      apply /wtype_roll/.
      }
    reduce //.
    unfold /succish/.
    compat.
    reduce //.
    fold /natish/.
    introEq /x/.
    reduce //.
    compat.
    extensionality.
    }

    {
    apply /IH/.
    unfold /precedes/.
    reduce //.
    exists /()/.
    reflexivity.
    }
  }
qed ();



reductions
/
  natrecish P hz hs (zeroish) --> hz ;
  natrecish P hz hs (succish n) --> hs n (natrecish P hz hs n) ;
  unfolding zeroish succish natrecish
  unrolling wtype_iter
/;
