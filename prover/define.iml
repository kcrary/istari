
signature DEFINE =
   sig

      type symbol = Symbol.symbol
      type eterm = ETerm.eterm

      exception Define

      val defineRaw : (symbol * symbol option list * symbol option list) -> eterm -> unit
      val define : (symbol * symbol option list * symbol option list) -> eterm -> eterm -> unit

      val definerecRaw : (symbol * symbol option list * symbol option list) -> eterm -> unit
      val definerec : (symbol * symbol option list * symbol option list) -> eterm -> eterm -> unit

      val recordTyping : string -> unit

   end


signature DEFINE_INTERNAL =
   sig

      include DEFINE


      val recUnroller : Constant.constant -> Reduction.reduction

   end


structure DefineInternal :> DEFINE_INTERNAL =
   struct

      structure D = Directory
      structure T = Term
      structure P = ProverInternal
      structure R = Reduction
      structure S = Seq
      structure J = Judgement

      type symbol = Symbol.symbol
      type eterm = ETerm.eterm

      open CasePervasive
      open Tactic

      val withHandler = Message.withHandler
      exception Error = Message.Error

      exception Define

      fun signalDefine msg =
         raise (Message.Error (Prover.Prover,
                               String.concat
                                  [
                                  "Error: ",
                                  msg,
                                  ".\n"
                                  ]))


      fun checkClean m =
         (case P.clean m of
             NONE => ()

           | SOME P.NotGround =>
                raise (Error (Define, "Error: definition contains unresolved evars.\n"))

           | SOME P.Open =>
                raise (Error (Define, "Error: definition contains free variables.\n"))

           | SOME P.Marker =>
                raise (Error (Define, "Error: definition contains a marker.\n")))



      fun defineRaw (name, impargs, expargs) em =
         let
            do () = withHandler

            val () = P.checkpoint ()

            val args = impargs @ expargs

            val m = ETerm.closed (List.foldr ETerm.lam em args)
         
            val () = checkClean m

            val const = Namespace.declare name (SOME m)
         in
            Database.setImplicits const (List.length impargs);

            print "Constant ";
            print (Symbol.toValue name);
            print " defined.\n"
         end



      fun define (name, impargs, expargs) em ea =
         let
            do () = withHandler

            val () = P.checkpoint ()

            val args = impargs @ expargs

            val dir =
               List.foldl
                  (fns arg dir => D.bindh dir arg)
                  D.empty
                  args

            val body = em (D.idir dir)
            val a = ea D.iempty

            val m =
               List.foldr
                  (fns arg m => T.Lam (arg, m))
                  body
                  args
                      
            val jud =
               J.make
                  (S.cons (J.Let m) S.empty)
                  (* The shift should be unnecessary, since a should be closed, but do it anyway. *)
                  (T.apply2 Prim.ov (T.Sub (a, T.shift1)) (T.Var 0))

            val goal = (jud, D.literal [name])

            fun cont vs =
               withHandler
               (fn () =>
                   (case vs of
                       [v] =>
                          (* v validates =M |- 0 : A[^] *)
                          let
                             val const = Namespace.declare name (SOME m)

                             val jud' = J.make S.empty (T.apply2 Prim.ov a (T.Const const))

                             val tac =
                                (* |- const : A *)
                                refine (Rule.reduce (R.within [2] R.unfold))
                                >>
                                (* |- M : A *)
                                refine (Rule.letIntro 0 m)
                                >>
                                (* =M |- M[^] : A[^] *)
                                refine (Rule.letFold 0
                                           (T.apply2 Prim.ov (T.Sub (a, T.Shift 2)) T.zero))
                                >>
                                (* =M |- 0 : A[^] *)
                                cast jud v
                          in
                             (case execute (jud', D.empty) tac of
                                 Sum.INL v' =>
                                    (
                                    Database.enterType const jud' v';
                                    Database.setImplicits const (List.length impargs);
   
                                    print "Constant ";
                                    print (Symbol.toValue name);
                                    print " defined.\n"
                                    )

                               | Sum.INR _ =>
                                    (* This shouldn't happen. *)
                                    raise (Fail "internal definition error"))
                          end

                     | _ => raise Refine.ValidationFailure))
         in
            P.setGoals [goal] cont
         end
         


      (* if    const unfolds to fix (fn . M)
         then  red : const --> M[const . id]
      *)
      fun recUnroller const =
         (case Constant.definition const of
             NONE =>
                raise (Fail "constant has no definition")

           | SOME def =>
                termCaseX def
                /
                 | \Prim.fix\ (fn . ?) =>
                   \fnc m =>
                       let
                          val r1 =
                             R.trans 
                                [
                                (* const *)
              
                                R.unfold, 
              
                                (* fix (fn . M) *)
              
                                R.user1 Prim.unroll_fix,
              
                                (* (fn . M) (fix (fn . M)) *)
                                ]
              
                          val r2 = 
                             (* (fn . M) const *)
                             R.within [1] R.unfold
                             (* (fn . M) (fix (fn . M)) *)
                       in
                          R.trans
                             [
                             (* const *)
              
                             R.user1 
                                (R.new1 const 0 (T.app (T.Lam (NONE, m)) (T.Const const)) r1 r2),
              
                             (* (fn . M) const *)
              
                             R.beta 1
              
                             (* M[const . id] *)
                             ]
                       end\

                 | _ =>
                   \fnc => raise (Fail "constant's definition has improper form")\
                /)


      fun definerecRaw (name, impargs, expargs) em =
         let
            do () = withHandler

            val () = P.checkpoint ()

            val args = impargs @ expargs

            val m = 
               T.apply1 Prim.fix
                  (ETerm.closed
                      (List.foldr ETerm.lam em (SOME name :: args)))

            val () = checkClean m

            val const = Namespace.declare name (SOME m)

            val arity = List.length args
         in
            Database.setImplicits const (List.length impargs);
            Database.setUnroll const
               (R.trans [recUnroller const, R.beta arity]);

            print "Constant ";
            print (Symbol.toValue name);
            print " defined.\n"
         end


      fun definerec (name, impargs, expargs) em ea =
         let
            do () = withHandler

            val () = P.checkpoint ()

            val args = impargs @ expargs

            val dir =
               List.foldl
                  (fns arg dir => D.bindh dir arg)
                  (D.literal [name])
                  args

            val body = em (D.idir dir)
            val a = ea D.iempty

            val m =
               List.foldr
                  (fns arg m => T.Lam (arg, m))
                  body
                  args

            val m' = T.apply1 Prim.fix (T.Lam (SOME name, m))
                      
            val jud =
               J.make
                  (S.cons (J.Let m') S.empty)
                  (* The shift should be unnecessary, since a should be closed, but do it anyway. *)
                  (T.apply2 Prim.ov (T.Sub (a, T.shift1)) (T.Var 0))

            val goal = (jud, D.literal [name])

            val arity = List.length args

            fun cont vs =
               withHandler
               (fn () =>
                   (case vs of
                       [v] =>
                          (* v validates =M' |- 0 : A[^] *)
                          let
                             val const = Namespace.declare name (SOME m')

                             val jud' = J.make S.empty (T.apply2 Prim.ov a (T.Const const))

                             val tac =
                                (* |- const : A *)
                                refine (Rule.reduce (R.within [2] R.unfold))
                                >>
                                (* |- M' : A *)
                                refine (Rule.letIntro 0 m')
                                >>
                                (* =M' |- M'[^] : A[^] *)
                                refine (Rule.letFold 0
                                           (T.apply2 Prim.ov (T.Sub (a, T.Shift 2)) T.zero))
                                >>
                                (* =M' |- 0 : A[^] *)
                                cast jud v
                          in
                             (case execute (jud', D.empty) tac of
                                 Sum.INL v' =>
                                    (
                                    Database.enterType const jud' v';
                                    Database.setImplicits const (List.length impargs);
                                    Database.setUnroll const
                                       (R.trans [recUnroller const, R.beta arity]);
   
                                    print "Constant ";
                                    print (Symbol.toValue name);
                                    print " defined.\n"
                                    )

                               | Sum.INR _ =>
                                    (* This shouldn't happen. *)
                                    raise (Fail "internal definition error"))
                          end

                     | _ => raise Refine.ValidationFailure))
         in
            P.setGoals [goal] cont
         end
             


      fun recordTyping name =
         let
            val const = Namespace.resolve [Symbol.fromValue name]
         in
            (case Database.findType const of
                NONE =>
                   raise (Fail (String.concat ["lemma ", name, " not found in database"]))
   
              | SOME (j, v) =>
                   let
                      val () =
                         if Seq.null (J.context j) then
                            ()
                         else
                            raise (Fail (name ^ " is not a typing lemma"))

                      val (a, const') =
                         termCaseX (J.concl j)
                         /
                          | \Prim.ov\ 
                               ($as \Prim.ov\ _ (const? @ $nil))
                               \const\ =>
                            \fnc a x => (a, x)\

                          | _ =>
                            \fnc => raise (Fail (name ^ " is not a typing lemma"))\
                         /

                      (* v validates J = |- const : A
                         where A has the form const' : B
                      *)

                      val a = Normalize.simplify a
                      val jud = J.make Seq.empty a

                      val v' =
                         (case Refine.refine (Rule.inhabitant a (T.Const const)) jud of
                             ([j'], validator) =>
                                (case Refine.cast j j' of
                                    NONE =>
                                       raise (Fail "impossible")

                                  | SOME f =>
                                       (case validator [f v] of
                                           (v', []) => v'

                                         | _ => raise (Fail "impossible")))

                           | _ => raise (Fail "impossible"))
                   in
                      Database.enterType const' jud v'
                   end)
         end


   end


structure Define :> DEFINE = DefineInternal


structure ParseDefine =
   struct

      fun definePattern name expargs = (name, [], expargs)
      fun definePatternImplicits name impargs expargs = (name, impargs, expargs)

   end


grammardef Define

   rule DefinePattern ::= Ident OIdents => ParseDefine.definePattern
   rule DefinePattern ::= Ident "{" OIdents "}" OIdents => ParseDefine.definePatternImplicits

end


grammaron Define
