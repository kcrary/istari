
signature DESTRUCT =
   sig

      type hypothesis = Hyp.hypothesis
      type symbol = Symbol.symbol
      type ipattern = IntroPattern.ipattern
      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority

      val destructPriority : hypothesis -> ipattern -> priority tacticm
      val destructRaw : hypothesis -> ipattern -> tactic
      val destruct : hypothesis -> ipattern -> tactic

      val destructSetPriority : hypothesis -> symbol option -> priority tacticm
      val destructSetRaw : hypothesis -> symbol option -> tactic
      val destructSet : hypothesis -> symbol option -> tactic

      val assertLiteralPriority : Term.term -> ipattern -> priority tacticm
      val assertLiteralRaw : Term.term -> ipattern -> tactic
      val assertLiteral : Term.term -> ipattern -> tactic

      val assertPriority : ETerm.eterm -> ipattern -> priority tacticm
      val assertRaw : ETerm.eterm -> ipattern -> tactic
      val assert : ETerm.eterm -> ipattern -> tactic
      val assertThen : ETerm.eterm -> ipattern -> tactic -> tactic

   end


signature DESTRUCT_INTERNAL =
   sig

      include DESTRUCT



      (* Destruction categories are similar to priorities, but carry extra
         information for destruct:

         When the category is (Principal set), that indicates a primary premise
         (in the sense of typechecking).  Destruction should continue if there
         is more to do.  The variables that have been bound thus far are "set".

         When the category is Auxiliary, that indicates a secondary premise.
         Destruction ceases for that goal.  (A variable set is not provided because
         none is needed.)

         When the category is Tertiary, that is like Auxiliary, except the
         righthand portion of the context (starting with the variable being
         destructed) is truncated.

         If the type variable is not filled with just Directory.set, additional
         information is also passed to Principal goals.
      *)
      datatype 'a category = Principal of 'a | Auxiliary | Tertiary

      (* Passes on the sequence of variables being bound, and a category. *)
      type 'a destruct_tactic =
         (symbol Seq.seq          (* variables generated by destruction *)
          * 'a category)
         Tactic.tacticm

      val destructTactics : 
         (int                          (* hypothesis being destructed *)
          -> ipattern                  (* the pattern *)
          -> Directory.set             (* variables already in use *)
          -> Directory.set destruct_tactic)
         ConstantTable.table


      (* Assumes the directory is missing the name of hypothesis 0.  Destructs
         hypothesis 0 using the given pattern, then runs the tactic on the main
         subgoals.  Marks subgoals with priorities.
      *)
      val destruct0 : ipattern -> priority tacticm -> priority tacticm


      (* Tools for building destruct tactics.
       
         The idea is after doing the main destruction, you recursively go through the 
         the hypothesis just created, destructing them as apporopriate.  One recursively
         destructs a hypothesis using dest, and one chains them together (if there are
         multiple) using andthenp.

         We recursively destruct hypotheses from first to last.  In a way, this is unfortunate,
         because it means that a weakening pattern (_) might fail, thinking that there is 
         another hypothesis that depends on it, but actually that hypothesis is going to be
         weakened as well.  Going last to first would solve that problem, but then there
         is no way to make auxiliary premises look right, since earlier hypotheses are
         undestructed but visible.  (Going first to last means that the undestructed
         hypotheses are truncated anyway.)
      *)

      (* dest i pat set: Destruct hypothesis i using pat, where variables in set are already in use. *)
      val dest : int -> ipattern -> Directory.set -> Directory.set destruct_tactic

      (* andthenp vars tac1 tac2

         Runs tac1.  On principal subgoals, continues with tac2.  On auxiliary subgoals,
         stops but adjusts the variable sequence by prepending vars.
      *)
      val andthenp : symbol Seq.seq -> 'a destruct_tactic -> ((symbol Seq.seq * 'a) -> 'b destruct_tactic) -> 'b destruct_tactic


      (* refold J i j m r 

         if    |G2| = i
               J = G1' G2 |- C  
               (G1' doesn't matter; J is used only up to hypothesis i-1.)
               r : m --> n
         then  proves G1, G2[n . ^j] |- C[under_i (n . ^j)]
               from   G1, G2[m . ^j] |- C[under_i (m . ^j)]

      *)
      val refold : Judgement.judgement -> int -> int -> Term.term -> Reduction.reduction -> Tactic.tactic


      val destUserQuotient : int -> ipattern -> Directory.set -> Directory.set destruct_tactic
      
   end


structure DestructInternal :> DESTRUCT_INTERNAL =
   struct

      structure T = Term
      structure N = Normalize
      structure J = Judgement
      structure D = Directory
      structure S = Seq  (* ought to use tree-based sequence here *)
      structure TC = Typecheck
      structure R = Reduction

      type hypothesis = Hyp.hypothesis
      type symbol = Symbol.symbol

      structure H = ConstantTable

      open Tactic
      open IntroPattern
      open CasePervasive


      datatype 'a category = Principal of 'a | Auxiliary | Tertiary

      type 'a destruct_tactic = (symbol S.seq * 'a category) tacticm

      type action = int -> ipattern -> D.set -> D.set destruct_tactic

      val destructTactics : action H.table = H.table ()
         

      fun dest i pat set =
         (case pat of
             Wild =>
                cut (setFailure "dependency exists on hypothesis to be weakened" (refine (Rule.weaken i 1)))
                >> idtacM (S.empty, Principal set)

           | Ident vo =>
                (case D.insistAndBindSetOpt set vo of
                    SOME (v, set') =>
                       idtacM (S.cons v S.empty, Principal set')

                  | NONE =>
                       fail (String.concat ["identifier ", Symbol.toValue (Option.valOf vo), " is in use"]))

           | _ =>
                refine (Rule.whnfHardHyp i)
                >>+
                let
                   do (jud, _) = withgoal
                in
                   (case J.hypOpt jud i of
                       NONE =>
                          fail "nonexistent hypothesis"

                     | SOME (J.Tm a) =>
                          (case a of
                              T.Elim (T.Const const, spine) =>
                                 (case H.find destructTactics const of
                                     SOME tac =>
                                        tac i pat set
   
                                   | NONE =>
                                        (case Constant.opacity const of
                                            Constant.OPAQUE =>
                                               fail "undestructable type"

                                          | _ =>
                                               refine (Rule.reduceHyp i R.unfold)
                                               >>+
                                               dest i pat set))

                            | _ => fail "undestructable type")

                     | SOME (J.Tmh a) =>
                          termCaseT a
                          /| \Prim.void\ =>
                             \(fnc =>
                                  (* unhides *)
                                  refine (Rule.inhabitant (T.evar ()) T.Triv)
                                  >>
                                  refine (Rule.voidElim (T.evar ()))
                                  >>
                                  refine (Rule.hypothesis i) >> done)\

                           | _ =>
                             \(fnc =>
                                  ifthenM
                                     Typecheck.trivializePriority
                                     (fn Primary => dest i pat set
                                       | Secondary => 
                                            idtacM (S.cons (D.freshSet set) S.empty, Auxiliary))
                                     (fail "cannot unhide hypothesis"))\
                          /

                     | SOME _ =>
                          fail "this sort of hypothesis cannot be destructed")
                end)
      
      val evar = T.evar

      fun andthenp vars1 tac1 tac2 =
         andthenM tac1
         (fn (vars, cat) =>
             (case cat of
                 Principal x =>
                    tac2 (vars, x)

               | Auxiliary =>
                    idtacM (S.append vars1 vars, Auxiliary)

               | Tertiary =>
                    idtacM (S.append vars1 vars, Tertiary)))

      fun destExists i pat set =
         (case pat of
             And [p1, p2] =>
                (refine $ Rule.existsLeft i (evar ()) (evar ()) (evar ()))
                >>
                let
                   do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                   do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                in
                   idtacM (S.append vars1 vars2, Principal set2)
                end

           | _ =>
                fail "exists pattern expected")


      fun destProd i pat set =
         (case pat of
             And [p1, p2] =>
                (refine $ Rule.prodLeft i (evar ()) (evar ()) (evar ()))
                >>
                let
                   do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                   do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                in
                   idtacM (S.append vars1 vars2, Principal set2)
                end

           | _ =>
                fail "prod pattern expected")


      fun destUnion i pat set =
         (case pat of
             And [p1, p2] =>
                let
                   do (jud, _) = withgoal
                   val c = J.concl jud
                in
                   hypCaseT (J.subHyp (J.hyp jud i) (T.Shift (i+1)))
                   /| $tm \Prim.union\ ? (fn . ?) =>
                      \(fnc a b =>
                           (* union A . B, ... |- C *)
                           refine (Rule.unionElim a b c (T.Var i))
                           >>>
                              [
                              (* union A . B, ..., hide A[^i+1], B[0 . ^i+2] |- C[^2] *)
                              (cut $ setFailure "dependencies exist on union hypothesis being destructed" $
                               refine (Rule.weaken (i+2) 1))
                              >>+
                              (* ..., hide A[^i], B[0 . ^i+1] |- C[^] *)
                              refine (Rule.exchange 0 2 i)
                              >>+
                              (* hide A, B, ... |- C[something] *)
                              let
                                 do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                                 do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                              in
                                 idtacM (S.append vars1 vars2, Principal set2)
                              end,

                              (* union A . B, ... |- i : (union A . B)[^i+1] *)
                              refine (Rule.hypothesisOf i) >> done
                              ])\

                    | _ =>
                      \(fnc =>
                           fail "improper hypothesis for union destruction")\
                   /
                end

           | _ =>
                fail "union pattern expected")


      fun destIexists i pat set =
         (case pat of
             And [p1, p2] =>
                let
                   do (jud, _) = withgoal
                   val c = J.concl jud
                in
                   hypCaseT (J.subHyp (J.hyp jud i) (T.Shift (i+1)))
                   /| $tm \Prim.iexists\ ? ? (fn . ?) =>
                      \(fnc lv k a =>
                           (* iexists LV K . A, ... |- C *)
                           refine (Rule.iexistsElim a c lv k (T.Var i))
                           >>>
                              [
                              (* iexists LV K . A, ... |- K : type *)
                              refine (Rule.weaken 0 (i+1))
                              >>+
                              idtacM (S.empty, Tertiary),

                              (* iexists LV K . A, ..., K |- A : type *)
                              refine (Rule.weaken 1 (i+1))
                              >>+
                              idtacM (S.cons (D.freshSet set) S.empty, Tertiary),

                              (* iexists LV K . A, ..., hide K[^i+1], A[0 . ^i+2] |- C[^2] *)
                              (cut $ setFailure "dependencies exist on iexists hypothesis being destructed" $
                               refine (Rule.weaken (i+2) 1))
                              >>+
                              (* ..., hide K[^i], A[0 . ^i+1] |- C[^] *)
                              refine (Rule.exchange 0 2 i)
                              >>+
                              (* hide A, B, ... |- C[something] *)
                              let
                                 do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                                 do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                              in
                                 idtacM (S.append vars1 vars2, Principal set2)
                              end,

                              (* iexists LV K . A, ... |- i : (iexists LV K . A)[^i+1] *)
                              refine (Rule.hypothesisOf i) >> done
                              ])\

                    | _ =>
                      \(fnc =>
                           fail "improper hypothesis for iexists destruction")\
                   /
                end

           | _ =>
                fail "iexists pattern expected")


      fun destFuture i pat set =
         (case pat of
             And [p] =>
                (refine $ Rule.futureLeft i (evar ()) (evar ()))
                >>>
                   [
                   idtacM (S.empty, Tertiary),

                   dest i p set
                   ]

           | _ =>
                fail "future pattern expected")


      fun destVoid i pat _ =
         (case pat of
             Or [] =>
                RuleTactic.voidElim >> refine (Rule.hypothesis i) >> fail "unreachable"

           | _ => 
                fail "void pattern expected")
         

      fun destUnit tac i pat set =
         (case pat of
             And [] =>
                tac i >> idtacM (S.empty, Principal set)

           | _ => 
                fail "unit pattern expected")


      fun destBool i pat set =
         (case pat of
             Or [And [], And []] =>
                (refine $ Rule.boolLeft i (evar ())) >> idtacM (S.empty, Principal set)

           | _ =>
                fail "bool pattern expected")


      fun destSet i pat set =
         (case pat of
             And [p1, p2] =>
                (refine $ Rule.setLeft i (evar ()) (evar ()) (evar ()))
                >>>
                   [
                   let
                      val v = D.freshSet set
                   in
                      idtacM (S.cons v S.empty, Tertiary)
                   end,

                   let
                      do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                      do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                   in
                      idtacM (S.append vars1 vars2, Principal set2)
                   end
                   ]

           | _ =>
                fail "set pattern expected")


      fun destIset i pat set =
         (case pat of
             And [p1, p2] =>
                (refine $ Rule.isetLeft i (evar ()) (evar ()) (evar ()))
                >>+
                let
                   do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                   do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                in
                   idtacM (S.append vars1 vars2, Principal set2)
                end

           | _ =>
                fail "set pattern expected")


      fun varyAndBindSetPat set p =
         (case p of
             Ident symopt =>
                D.varyAndBindSet set symopt

           | _ =>
                D.freshAndBindSet set)

      fun quotientGoalTert set =
         let
            val (v, set') = D.freshAndBindSet set
            val v' = D.freshSet set'
         in
            idtacM (S.cons v (S.cons v' S.empty), Tertiary)
         end

      fun quotientGoalPrin i p1 p2 p3 set =
         let
            do (vars1, set1) = andthenp S.empty $ dest (i+2) p1 set
            do (vars2, set2) = andthenp vars1 $ dest (i+1) p2 set1
            val vars12 = S.append vars1 vars2
            do (vars3, set3) = andthenp vars12 $ dest i p3 set2
         in
            idtacM (S.append vars12 vars3, Principal set3)
         end


      fun destQuotient i pat set =
         (case pat of
             And [p] =>
                refine (Rule.quotientLeft i (evar ()) (evar ()) (evar ()))
                >>>
                   [
                   let
                      val (v, _) = varyAndBindSetPat set p
                   in
                      idtacM (S.cons v S.empty, Auxiliary)
                   end,

                   dest i p set
                   ]

           | And [p1, p2] =>
                refine (Rule.quotientLeftRefl i (evar ()) (evar ()) (evar ()))
                >>>
                   [
                   quotientGoalTert set,

                   let
                      val (v, _) = varyAndBindSetPat set p1
                   in
                      idtacM (S.cons v S.empty, Auxiliary)
                   end,

                   let
                      do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                      do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                   in
                      idtacM (S.append vars1 vars2, Principal set2)
                   end
                   ]

           | And [p1, p2, p3] =>
                goalCaseT
                /| \Prim.istp\ _ =>
                   \(fnc =>
                        refine (Rule.quotientLeftIstype i (evar ()) (evar ()) (evar ()))
                        >>>
                           [
                           quotientGoalTert set,
                           quotientGoalPrin i p1 p2 p3 set
                           ])\

                 | \Prim.eqtp\ _ _ =>
                   \(fnc =>
                        refine (Rule.quotientLeftEqtype i (evar ()) (evar ()) (evar ()) (evar ()))
                        >>>
                           [
                           quotientGoalTert set,
                           quotientGoalPrin i p1 p2 p3 set
                           ])\

                 | \Prim.ov\ _ _ =>
                   \(fnc =>
                        cut $
                        first
                           [
                           refine (Rule.quotientLeftOf i (evar ()) (evar ()) (evar ()) (evar ()))
                           >>>
                              [
                              quotientGoalTert set,
                              quotientGoalPrin i p1 p2 p3 set
                              ],

                           refine (Rule.quotientLeftOfDep i (evar ()) (evar ()) (evar ()) (evar ()))
                           >>>
                              [
                              quotientGoalTert set,
                              quotientGoalPrin i p1 p2 p3 set,
                              quotientGoalPrin i p1 p2 p3 set
                              ]
                           ])\

                 | \Prim.eq\ _ _ _ =>
                   \(fnc =>
                        cut $
                        first
                           [
                           refine (Rule.quotientLeftEq i (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))
                           >>>
                              [
                              quotientGoalTert set,
                              quotientGoalPrin i p1 p2 p3 set
                              ],

                           refine (Rule.quotientLeftEqDep i (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))
                           >>>
                              [
                              quotientGoalTert set,
                              quotientGoalPrin i p1 p2 p3 set
                              ]
                           ])\
                           
                 | _ =>
                   \(fnc =>
                        fail "conclusion has improper form for functional quotient elimination")\
                /

           | _ =>
                fail "quotient pattern expected")


      fun destUserQuotient i pat set =
         let
            do (jud, _) = withgoal
         in
            (case Judgement.hyp jud i of
                Judgement.Tm a =>
                   (case pat of
                       IntroPattern.And [p] =>
                          refine (Rule.reduceHyp i Reduction.unfold)
                          >>
                          refine (Rule.quotientLeft i (T.evar ()) (T.evar ()) (T.evar ()))
                          >>>
                             [
                             let
                                val (v, _) = varyAndBindSetPat set p
                             in
                                refine (Rule.unreduceHyp i a Reduction.unfold)
                                >>
                                idtacM (S.cons v S.empty, Auxiliary)
                             end,
                
                             dest i p set
                             ]
                
                     | IntroPattern.And [p1, p2] =>
                          refine (Rule.reduceHyp i Reduction.unfold)
                          >>
                          refine (Rule.quotientLeftRefl i (T.evar ()) (T.evar ()) (T.evar ()))
                          >>>
                             [
                             quotientGoalTert set,
                
                             let
                                val (v, _) = varyAndBindSetPat set p1
                             in
                                refine (Rule.unreduceHyp i a Reduction.unfold)
                                >>
                                idtacM (S.cons v S.empty, Auxiliary)
                             end,
                
                             let
                                do (vars1, set1) = andthenp S.empty $ dest (i+1) p1 set
                                do (vars2, set2) = andthenp vars1 $ dest i p2 set1
                             in
                                idtacM (S.append vars1 vars2, Principal set2)
                             end
                             ]
                
                     | _ =>
                          refine (Rule.reduceHyp i Reduction.unfold)
                          >> destQuotient i pat set)
      
              | _ =>
                   fail "this sort of hypothesis cannot be destructed")
         end


      fun destSum i pat set =
         (case pat of
             Or [p1, p2] =>
                (refine $ Rule.sumLeft i (evar ()) (evar ()) (evar ()))
                >>>
                   [
                   dest i p1 set,
                   dest i p2 set
                   ]

           | _ =>
                fail "sum pattern expected")


      fun destSquash i pat set =
         (case pat of
             And [p] =>
                (refine $ Rule.squashLeft i (evar ()) (evar ()))
                >>>
                   [
                   idtacM (S.empty, Tertiary),

                   dest i p set
                   ]

           | _ =>
                fail "squash pattern expected")


      (* comment in signature *)
      fun refold jud i j m r =
         let
            (* if    |G2a| = k
                     |G2b| = i-k
               then  proves G1, G2a[m . ^j], G2b[under_k (n . ^j)] |- C[under_i (n . ^j)]
                     from   G1, G2[m . ^j] |- C[under_i (m . ^j)]
            *)
            fun f k =
               if k = i then
                  (* G1, G2a[m . ^j], G2b[...] |- C[under_i (n . ^j)]
                     =
                     G1, G2[m . ^j] |- C[under_i (n . ^j)]
                                     = C[under_i+1 ^j][under_i (n . id)]
                  *)
                  
                  refine (Rule.unreduceAt i
                             (T.Sub (J.concl jud, T.under (i+1) (T.Shift j)))
                             m r)
                  (* G1, G2[m . ^j] |- C[under_i+1 ^j][under_i (m . id)]
                                     = C[under_i (m . ^j)]
                  *)
               else
                  (* G1, G2a[m . ^j], H[under_k (n . ^j)], G2b'[under_k+1 (n . ^j)] |- ...
                                    = H[under_k+1 ^j][under_k (n . id)]
                  *)
                  refine (Rule.unreduceHypAt (i-k-1) k
                             (J.subHyp (J.hyp jud (i-k-1)) (T.under (k+1) (T.Shift j)))
                             m r)
                  >>
                  (* G1, G2a[m . ^j], H[under_k+1 ^j][under_k (m . id)], G2b'[under_k+1 (n . ^j)] |- ...
                     =
                     G1, G2a[m . ^j], H[under_k (m . ^j)], G2b'[under_k+1 (n . ^j)] |- ...
                     =
                     G1, (G2a, H)[m . ^j], G2b'[under_k+1 (n . ^j)] |- ...
                  *)
                  f (k+1)
         in
            f 0
         end
             

      fun destNat i pat set =
         (case pat of
             Or [And [], p] =>
                let
                   do (jud, _) = withgoal

                   val c = J.concl jud
                   val h = J.hyp jud i
                in
                   hypCaseT h
                   / $tm \Prim.nat\ =>
                     \fnc =>
                         (* nat ... |- C *)
                         refine (Rule.subsumptionLeft i
                                    (T.Const Prim.nat)
                                    (T.apply2 Prim.sum
                                        (T.Const Prim.unit)
                                        (T.Const Prim.nat))
                                    (T.evar ()))
                         >>> [
                             refine (Rule.weaken 0 1)
                             >>
                             (* |- nat <:> unit % nat *)
                             refine Rule.natUnroll >> done,
  
                             (* unit % nat, G |- C *)
                             refine (Rule.sumLeft i (T.evar ()) (T.evar ()) (T.evar ()))
                             >>> [
                                 (* unit, G[inl 0 . ^] |- C[under_i (inl 0 . ^)] *)
                                 refine (Rule.unitLeft i (T.evar ()))
                                 >>
                                 (* G[inl () . id] |- C[under_i (inl () . id)] *)
                                 refold jud i 0 
                                    (T.Const Prim.zero)
                                    (R.user1 PrimReduction.unroll_zero)
                                 >>
                                 (* G[zero . id] |- C[under_i (zero . id)] *)
                                 idtacM (S.empty, Principal set),
                                 
                                 (* nat, G[inr 0 . ^] |- C[under_i (inr 0 . ^)] *)
                                 refold jud i 1
                                    (T.apply1 Prim.succ T.zero)
                                    (R.user1 PrimReduction.unroll_succ)
                                 >>
                                 (* nat, G[succ 0 . ^] |- C[under_i (succ 0 . ^)] *)
                                 dest i p set
                                 ]
                             ]\
                   /
                end

           | _ =>
                fail "nat pattern expected")
                           


      val () =
         let
            val insert = H.insert destructTactics
         in
            insert Prim.exists destExists;
            insert Prim.prod destProd;
            insert Prim.union destUnion;
            insert Prim.iexists destIexists;
            insert Prim.future destFuture;
            insert Prim.void destVoid;
            insert Prim.unit (destUnit (fn i => RuleTactic.refine1 $ Rule.unitLeft i));
            insert Prim.bool destBool;
            insert Prim.nat destNat;
            insert Prim.eq (destUnit (fn i => RuleTactic.refine4 $ Rule.eqLeft i));
            insert Prim.ov (destUnit (fn i => RuleTactic.refine3 $ Rule.ofLeft i));
            insert Prim.set destSet;
            insert Prim.iset destIset;
            insert Prim.quotient destQuotient;
            insert Prim.eqtp (destUnit (fn i => RuleTactic.refine3 $ Rule.eqtpLeft i));
            insert Prim.istp (destUnit (fn i => RuleTactic.refine2 $ Rule.istpLeft i));
            insert Prim.subtype (destUnit (fn i => RuleTactic.refine3 $ Rule.subtypeLeft i));
            insert Prim.sum destSum;
            insert Prim.squash destSquash
         end


      fun addvar v d = D.bind d v

      fun destructnPriority i pat =
         (* optimize some special cases *)
         (case pat of
             Ident NONE =>
                idtacM Primary

           | Ident (SOME sym) =>
                Hyp.rename (Hyp.NUMBER i) sym >> idtacM Primary

           | Wild =>
                Hyp.weaken i 1 >> idtacM Primary

           | _ =>
                let
                   do (dj, dir) = withgoal
                in
                   (case D.splitOpt dir (i+1) of
                       NONE =>
                          fail "not enough hypotheses"
          
                     | SOME ([], _) =>
                          raise (Fail "impossible")
          
                     | SOME (_ :: dirright, dirleft) =>
                          let
                             val set =
                                List.foldr
                                   (fns var set => D.bindVarySet set (SOME var))
                                   (D.set dirleft)
                                   dirright
                          in
                             andthenM (dest i pat set)
                             (fn (vars, pri) =>
                                 let
                                    val dir' = Seq.foldl addvar dirleft vars
                                    val (dir'', pri') =
                                       (case pri of
                                           Tertiary => (dir', Secondary)

                                         | Auxiliary => (D.binds dir' dirright, Secondary)

                                         | Principal _ => (D.binds dir' dirright, Primary))
                                 in
                                    chdir dir'' >> idtacM pri'
                                 end)
                          end)
                end)
          
      fun destructnRaw i pat = destructnPriority i pat >> idtac

      fun destructn i pat = Typecheck.withTypecheckSnd $ destructnPriority i pat

      fun destructPriority hyp pat =
         let
            do i = Hyp.findhyp hyp
         in
            destructnPriority i pat
         end

      fun destructRaw hyp pat = destructPriority hyp pat >> idtac

      fun destruct hyp pat = Typecheck.withTypecheckSnd $ destructPriority hyp pat
         
      (* spec in signature *)
      fun destruct0 pat tac =
         let
            do (dj, dir) = withgoal
         in
            (* optimize some special cases *)
            (case pat of
                Ident symopt =>
                   chdir (D.bindh dir symopt)
                   >> tac

              | Wild =>
                   cut (setFailure "dependency exists on hypothesis to be weakened" (refine (Rule.weaken 0 1)))
                   >> tac

              | _ =>
                   andthenM (dest 0 pat (D.set dir))
                   (fn (vars, pri) =>
                       chdir (Seq.foldl addvar dir vars)
                       >>
                       (case pri of
                           Principal _ => tac

                         | _ =>
                              (* No difference between auxiliary and tertiary since the
                                 hypothesis being destructed is last.
                              *)
                              idtacM Secondary)))
         end


      fun destructSetPriority hyp name =
         let
            do i = Hyp.findhyp hyp
            do (jud, dir) = withgoal
         in
            (case J.hyp jud i of
                J.Tm c =>
                   termCaseT (N.whnf (T.Sub (c, T.Shift (i+1))))
                   /
                    | \Prim.ov\ ($whnf \Prim.set\ ? (fn . ?)) ? =>
                      \(fnc a b m =>
                           refine (Rule.setElim a b (T.evar ()) m)
                           >>> [
                               chdir (D.bind0 dir) >> idtacM Secondary,
        
                               refine (Rule.hypothesis i) >> done,
        
                               chdir (D.bindh dir name) 
                               >>+
                               refine (Rule.assert (T.apply2 Prim.ov (T.Sub (a, T.shift1)) (T.Sub (m, T.shift1))) (T.evar ()))
                               >>> [
                                   (* M[^] : A[^] *)
                                   refine (Rule.setWeakenOf (T.Sub (a, T.shift1)) (T.Sub (b, T.underShift 1 1)) (T.Sub (m, T.shift1)))
                                   >>+
                                   (* M[^] : {A[^] | B[0 . ^2]} *)
                                   refine (Rule.hypothesis (i+1)) >> done,
 
                                   (* M[^] : A[^] |- ... *)
                                   refine (Rule.exchange 0 1 (i+1))
                                   >>+
                                   refine (Rule.weaken (i+2) 1)
                                   >>+
                                   idtacM Primary
                                   ]
                               ])\

                    | _ =>
                      \fnc => fail "hypothesis should assign some term a set type"\
                   /

              | _ => fail "hypothesis has the wrong sort")
         end

      fun destructSetRaw hyp name = destructSetPriority hyp name >> idtac

      fun destructSet hyp name = Typecheck.withTypecheckSnd $ destructSetPriority hyp name



      fun assertLiteralPriority a pat =
         let
            do (jud, _) = withgoal
         in
            refine (Rule.assert a (J.concl jud))
            >>> [
                idtacM Primary,
                destruct0 pat (idtacM Primary)
                ]
         end

      fun assertLiteralRaw a pat = assertLiteralPriority a pat >> idtac

      fun assertLiteral a pat = Typecheck.withTypecheckSnd $ assertLiteralPriority a pat

      fun assertPriority ea pat =
         let
            do a = withterm ea
         in
            assertLiteralPriority a pat
         end

      fun assertRaw ea pat = assertPriority ea pat >> idtac

      fun assert ea pat = Typecheck.withTypecheckSnd $ assertPriority ea pat

      fun assertThen ea pat tac = andthenlPad (assert ea pat) [tac] idtac

   end


structure Destruct :> DESTRUCT = DestructInternal
