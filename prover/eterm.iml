
signature ETERM =
   sig

      type eterm
      type symbol = Symbol.symbol
      type binder = symbol option

      exception UnknownConstant of symbol list

      val var     : symbol -> eterm        (* always a variable *)
      val short   : symbol -> eterm
      val long    : symbol list -> eterm   (* always a constant *)

      val shortExplicit : symbol -> eterm
      val longExplicit : symbol list -> eterm

      val const   : Constant.constant -> eterm
      val lam     : binder -> eterm -> eterm
      val app     : eterm -> eterm -> eterm
      val pair    : eterm -> eterm -> eterm
      val pi1     : eterm -> eterm
      val pi2     : eterm -> eterm
      val next    : eterm -> eterm
      val prev    : eterm -> eterm
      val triv    : eterm
      val evar    : eterm
      val integer : IntInf.int -> eterm

      val hole    : eterm
      val marker  : symbol -> eterm

      val apply1  : Constant.constant -> eterm -> eterm
      val apply2  : Constant.constant -> eterm -> eterm -> eterm
      val apply3  : Constant.constant -> eterm -> eterm -> eterm -> eterm
      val apply4  : Constant.constant -> eterm -> eterm -> eterm -> eterm -> eterm

      val appn    : eterm -> eterm list -> eterm
      val applyn  : Constant.constant -> eterm list -> eterm

      val additional : symbol option list -> eterm -> eterm

      val literal  : Term.term -> eterm
      val closed   : eterm -> Term.term
      val withidir : Directory.idirectory -> eterm -> Term.term
      val withdir  : Directory.directory -> eterm -> Term.term

      val absolute : Directory.directory -> Term.term -> eterm

      (* subst M x N = [M/x] N *)
      val subst    : eterm -> symbol -> eterm -> eterm

      val suppressImplicit : eterm -> eterm
      val withidirExplicit : Directory.idirectory -> eterm -> Term.term
      val withdirExplicit  : Directory.directory -> eterm -> Term.term

   end


structure ETerm :> ETERM =
   struct

      structure D = Directory
      structure T = Term

      type eterm = bool -> D.idirectory -> Term.term
      type symbol = Symbol.symbol
      type binder = symbol option


      fun var x _ dir = T.Var (D.lookupVar dir x)

      fun implicits n m =
         (case Int.compare n 0 of
             LESS =>
                raise (Invalid "ETerm.implicits")

           | EQUAL =>
                m

           | GREATER =>
                let
                   fun loop n acc =
                      if n = 0 then
                         acc
                      else
                         loop (n-1) (T.App (T.evar ()) :: acc)
                in
                   T.Elim (m, loop n [])
                end)

      fun shortExplicit x _ dir =
         (case D.lookup dir x of
             D.Hvar i => T.Var i
           | D.Hconst k => T.Const k)

      fun short x imps dir =
         (case D.lookup dir x of
             D.Hvar i =>
                T.Var i

           | D.Hconst const =>
                if imps then
                   implicits (Database.findImplicits const) (T.Const const)
                else
                   T.Const const)
         

      exception UnknownConstant of symbol list

      val () =
         Handler.customHandler
         (fn UnknownConstant syms =>
                (
                print "Error: unknown constant ";
                print (String.concatWith "." (List.map Symbol.toValue syms));
                print ".\n";
                true
                )
           | _ => false)
                

      fun signalUnknownConstant syms = raise (UnknownConstant syms)



      fun longExplicit syms _ _ =
         (case Namespace.resolveOpt syms of
             NONE =>
                signalUnknownConstant syms

           | SOME const =>
                T.Const const)

      fun long syms imps _ =
         (case Namespace.resolveOpt syms of
             NONE =>
                signalUnknownConstant syms

           | SOME const =>
                if imps then
                   implicits (Database.findImplicits const) (T.Const const)
                else
                   T.Const const)
         
      fun const const _ _ = T.Const const

      fun lam b m imps dir = 
         (case b of
             NONE =>
                T.Lam (NONE, m imps (D.ibind0 dir))

           | SOME x =>
                T.Lam (SOME x, m imps (D.ibind dir x)))

      fun app m1 m2 imps dir = T.Elim (m1 imps dir, [T.App (m2 imps dir)])

      fun pair m1 m2 imps dir = T.Pair (m1 imps dir, m2 imps dir)

      fun pi1 m imps dir = T.Elim (m imps dir, [T.Pi1])

      fun pi2 m imps dir = T.Elim (m imps dir, [T.Pi2])

      fun next m imps dir = T.Next (m imps dir)

      fun prev m imps dir = T.Elim (m imps dir, [T.Prev])

      fun triv _ _ = T.Triv

      fun evar _ _ = T.Evar (T.newEbind ())

      fun integer x _ _ = T.Native (T.Integer x)

      val zilch = Symbol.fromValue ""

      fun hole _ _ = T.Marker zilch

      fun marker sym _ _ = T.Marker sym

      fun apply1 const m1 imps dir = T.Elim (T.Const const, [T.App (m1 imps dir)])

      fun apply2 const m1 m2 imps dir = T.Elim (T.Const const, [T.App (m1 imps dir), T.App (m2 imps dir)])

      fun apply3 const m1 m2 m3 imps dir = T.Elim (T.Const const, [T.App (m1 imps dir), T.App (m2 imps dir), T.App (m3 imps dir)])

      fun apply4 const m1 m2 m3 m4 imps dir = T.Elim (T.Const const, [T.App (m1 imps dir), T.App (m2 imps dir), T.App (m3 imps dir), T.App (m4 imps dir)])

      fun appn m l imps dir =
         T.Elim (m imps dir,
                 List.map (fn mi => T.App (mi imps dir)) l)

      fun applyn const l imps dir =
         T.Elim (T.Const const,
                 List.map (fn mi => T.App (mi imps dir)) l)


      fun additional xs m imps dir =
         (case xs of
             [] =>
                m imps dir

           | NONE :: rest =>
                additional rest m imps (D.ibind0 dir)

           | SOME x :: rest =>
                additional rest m imps (D.ibind dir x))

      fun closed m = m true Directory.iempty

      fun literal m _ _ = m

      fun withidir idir m = m true idir

      fun withdir dir m = m true (Directory.idir dir)

      fun suppressImplicit m _ dir = m false dir
      
      fun withidirExplicit idir m = m false idir

      fun withdirExplicit dir m = m false (Directory.idir dir)


      fun absoluteMain from to depth m =
         (case Normalize.simplify m of
             T.Elim (T.Var i, spine) =>
                if i < depth then
                   T.Elim (T.Var i,
                           absoluteSpine from to depth spine)
                else
                   T.Elim (T.Var (D.lookupVar to (D.name from (i-depth)) + depth),
                           absoluteSpine from to depth spine)

           | T.Elim (T.Const const, spine) =>
                T.Elim (T.Const const,
                        absoluteSpine from to depth spine)

           | T.Elim (T.Sub (evar, s), spine) =>
                T.Elim (T.Sub (evar, absoluteSub from to depth s),
                        absoluteSpine from to depth spine)

           | T.Lam (binder, m1) =>
                T.Lam (binder,
                       absoluteMain from to (depth+1) m1)

           | T.Pair (m1, m2) =>
                T.Pair (absoluteMain from to depth m1, absoluteMain from to depth m2)

           | T.Next m1 =>
                T.Next (absoluteMain from to depth m1)

           | T.Triv => T.Triv

           | m' as T.Marker _ => m'

           | _ =>
                (* impossible in simple form *)
                raise (Fail "impossible"))

      and absoluteSpine from to depth l =
         (case l of
             [] => []

           | T.App m :: rest =>
                T.App (absoluteMain from to depth m) :: absoluteSpine from to depth rest

           | elim :: rest =>
                elim :: absoluteSpine from to depth rest)

      and absoluteSub from to depth s =
         (case s of
             T.Dot (m, s') =>
                T.Dot (absoluteMain from to depth m, absoluteSub from to depth s')

           | T.Idot (i, s') =>
                let
                   val i' = 
                      if i < depth then
                         i
                      else
                         D.lookupVar to (D.name from (i-depth)) + depth
                in
                   (case absoluteSub from to depth s' of
                       s'' as T.Shift k =>
                          if i' = k-1 then
                             T.Shift i'
                          else
                             T.Idot (i', s'')
                             
                     | s'' => 
                          T.Idot (i', s''))
                end

           | T.Shift k =>
                let
                   val sz = D.size from
                in
                   if k >= sz + depth then
                      T.Shift (k - sz + D.isize to)
                   else
                      absoluteSub from to depth (T.Idot (k, T.Shift (k+1)))
                end)

      fun absolute from m _ to = absoluteMain from to 0 m


      fun subst em sym en imps dir =
         T.Sub (en imps (D.ibind dir sym),
                T.Dot (em imps dir, T.id))

   end


structure ParseTerm =
   struct

      structure T = ETerm


      fun id x = x
      val none = NONE
      val some = SOME
      val null = []
      fun sing x = [x]
      fun duo x y = [x, y]
      fun cons x y = x :: y
      fun append x y = x @ y

      fun longid strs = map Symbol.fromValue strs

      fun bindingBare x = [(x, T.evar)]
      fun bindingAnnot xl a = map (fn x => (x, a)) xl

      val literal = T.literal

      val short = T.short
      val shortExplicit = T.shortExplicit
      fun long strs = T.long (map Symbol.fromValue strs)
      fun longExplicit strs = T.longExplicit (map Symbol.fromValue strs)
      val var = T.var


      fun level_plus n m =
         if n = 0 then
            m
         else
            T.apply1 Prim.lsucc (level_plus (n-1) m)

      fun level_max l =
         (case l of
             [] => raise (Fail "bad level")

           | [m] => m

           | m1 :: rest =>
                T.apply2 Prim.lmax m1 (level_max rest))

      fun level_lit n =
         if n = 0 then
            T.const Prim.lzero
         else
            T.apply1 Prim.lsucc (level_lit (n-1))

      fun univ m = T.apply1 Prim.univ m
      fun kind m = T.apply1 Prim.kind m



      fun lams xl m = foldr T.lam m xl

      fun forall x a b = T.apply2 Prim.forall a (T.lam x b)
      fun foralls al b = foldr (fns (x, a) b => forall x a b) b al

      fun exists x a b = T.apply2 Prim.exists a (T.lam x b)
      fun existss al b = foldr (fns (x, a) b => exists x a b) b al

      fun iforall x a b = T.apply3 Prim.iforall T.evar a (T.lam x b)
      fun iforalls al b = foldr (fns (x, a) b => iforall x a b) b al

      fun iexists x a b = T.apply3 Prim.iexists T.evar a (T.lam x b)
      fun iexistss al b = foldr (fns (x, a) b => iexists x a b) b al

      fun intersect x a b = T.apply2 Prim.intersect a (T.lam x b)
      fun intersects al b = foldr (fns (x, a) b => intersect x a b) b al

      fun foralltp x b = T.apply1 Prim.foralltp (T.lam x b)
      fun foralltps xl b = foldr foralltp b xl


      fun rec x a = T.apply1 Prim.rec (T.lam (SOME x) a)
      fun mu x a = T.apply1 Prim.mu (T.lam (SOME x) a)

      fun wtype x a b = T.apply2 Prim.wtype a (T.lam (SOME x) b)

      fun quotient x y a b = T.apply2 Prim.quotient a (T.lam (SOME x) (T.lam (SOME y) b))

      val arrow = T.apply2 Prim.arrow
      val tarrow = T.apply2 Prim.tarrow
      val karrow = T.apply2 Prim.karrow
      val guard = T.apply2 Prim.guard

      fun lett x m n = T.apply2 Prim.lett m (T.lam (SOME x) n)
      fun letnext x m n = T.apply2 Prim.letnext m (T.lam (SOME x) n)

      fun sumcase m x n y p = T.apply3 Prim.sumcase m (T.lam x n) (T.lam y p)

      fun ite b x y = T.apply3 Prim.ite b x y

      val prod = T.apply2 Prim.prod
      val sum = T.apply2 Prim.sum

      val app = T.app
      val pi1 = T.pi1
      val pi2 = T.pi2
      val prev = T.prev
      val next = T.next
      fun inl m = T.apply1 Prim.inl m
      fun inr m = T.apply1 Prim.inr m
      fun ann m a = T.apply2 Prim.ann a m

      fun ap m n = T.apply2 Prim.ap m n

      fun set x a b = T.apply2 Prim.set a (T.lam (SOME x) b)

      val squash = T.apply1 Prim.squash

      fun ov m a = T.apply2 Prim.ov a m

      val istp = T.apply1 Prim.istp

      fun eq m n a = T.apply3 Prim.eq a m n

      val eqtp = T.apply2 Prim.eqtp
      val subtype = T.apply2 Prim.subtype
      val eeqtp = T.apply2 Prim.eeqtp
      val lleq = T.apply2 Prim.lleq

      fun tuple ms =
         (case ms of
             [] => raise (Fail "precondition")

           | [m] => m

           | m :: rest =>
                T.pair m (tuple rest))

      fun number n =
         if n <= 0 then
            T.const Prim.zero
         else
            T.apply1 Prim.succ (number (n-1))

      fun integer n =
         T.integer (IntInf.fromInt n)

      fun integerLexeme str =
         (case FromString.toIntInf str of
             SOME x => T.integer x

           | NONE => raise (Fail ("invalid integer literal " ^ str)))

      val integerEmbed = T.integer

      val evar = T.evar

      fun appEvars m n =
         if n = 0 then
            m
         else
            appEvars (T.app m T.evar) (n-1)



      val zilch = Symbol.fromValue ""
      val hole = T.marker zilch

      val triv = T.triv

      val additional = T.additional 

      fun shortConstant sym = Namespace.resolve [sym]
      fun longConstant address = Namespace.resolve address



      structure U = Show.Unparsing

      fun register k arity prec unp =
         ConstantTable.insert U.unparsingTable k (arity, prec, ref true, unp)


      fun binderContent str (doms, cod) =
         U.box $
         U.append
            [
            U.box $
            U.append
               [
               U.string str,
               U.append
                  (map 
                      (fn (arg, dom) => 
                         U.append
                            [
                            U.break 1,
                            U.string "(",
                            U.box $ 
                               U.append
                               [
                               U.string arg,
                               U.break 1,
                               U.string ": ",
                               U.box $ dom 0
                               ],
                            U.string ")"
                            ])
                      doms),
               U.string " ."
               ],
            U.break 1,
            cod 0,
            ]

      fun idents args =
         U.box $
         U.append $
         (case args of
             [] =>
                (* shouldn't happen *)
                []

           | arg :: rest =>
                U.string arg
                ::
                List.foldr
                   (fns argi l => U.string " " :: U.string argi :: l)
                   []
                   rest)

      fun binderContent str (doms, cod) =
         U.box $
         U.append
            [
            U.box $
            U.append
               [
               U.string str,
               U.append
                  (map 
                      (fn (args, dom, _) => 
                         U.append
                            [
                            U.break 1,
                            U.string "(",
                            U.box $ 
                               U.append
                               [
                               idents args,
                               U.break 1,
                               U.string ": ",
                               U.box $ dom 0
                               ],
                            U.string ")"
                            ])
                      doms),
               U.string " ."
               ],
            U.break 1,
            cod 0,
            ]

      fun registerBinder const str =
         register const 2 0
         (U.wrap
             (U.fix
                 (fn unp =>
                     U.alt
                        [
                        U.wrap
                           (U.apply2 const U.showterm (U.lam unp))
                           (fn ((dom1, domt1), (arg, (doms, cod))) =>
                               (case doms of
                                   (args, dom2, domt2) :: rest =>
                                      if Simplify.same (Term.Sub (domt1, Term.shift1)) domt2 then
                                         ((arg :: args, dom2, domt1) :: rest, cod)
                                      else
                                         (([arg], dom1, domt1) :: doms, cod)

                                 | _ =>
                                      (([arg], dom1, domt1) :: doms, cod))),

                        U.wrap
                           U.show
                           (fn cod => ([], cod)),
                        ]))
             (binderContent str))

      fun registerIBinder const str =
         register const 3 0
         (U.wrap
             (U.fix
                 (fn unp =>
                     U.alt
                        [
                        U.wrap
                           (U.apply3 const U.wild U.showterm (U.lam unp))
                           (fn ((), (dom1, domt1), (arg, (doms, cod))) =>
                               (case doms of
                                   (args, dom2, domt2) :: rest =>
                                      if Simplify.same (Term.Sub (domt1, Term.shift1)) domt2 then
                                         ((arg :: args, dom2, domt1) :: rest, cod)
                                      else
                                         (([arg], dom1, domt1) :: doms, cod)

                                 | _ =>
                                      (([arg], dom1, domt1) :: doms, cod))),

                        U.wrap
                           U.show
                           (fn cod => ([], cod)),
                        ]))
             (binderContent str))

      (* right associative *)
      fun registerBinary const str prec =
         register const 2 prec
         (U.wrap
             (U.fix
                 (fn unp =>
                     U.alt
                        [
                        U.wrap
                           (U.apply2 const U.show unp)
                           (fn (dom, (doms, cod)) => (dom :: doms, cod)),

                        U.wrap
                           U.show
                           (fn cod => ([], cod)),
                        ]))
             (fn (doms, cod) =>
                 U.boxi 0 $
                 U.append
                    [
                    U.append
                       (map
                           (fn dom =>
                               U.append
                                  [
                                  dom (prec+1),
                                  U.break 1,
                                  U.string str,
                                  U.string " "
                                  ])
                           doms),
                    cod prec
                    ]))

      val () = registerBinder Prim.forall "forall"
      val () = registerBinder Prim.exists "exists"
      val () = registerIBinder Prim.iforall "iforall"
      val () = registerIBinder Prim.iexists "iexists"
      val () = registerBinder Prim.intersect "intersect"

      val () =
         register Prim.foralltp 1 0
         (U.wrap
             (U.fix
                 (fn unp =>
                     U.alt
                        [
                        U.wrap
                           (U.apply1 Prim.foralltp (U.lam unp))
                           (fn (arg, (args, cod)) => (arg :: args, cod)),

                        U.wrap
                           U.show
                           (fn cod => ([], cod))
                        ]))
             (fns (doms, cod) =>
                 U.box $
                 U.append
                    [
                    U.box $
                    U.append
                       [
                       U.string "foralltp",
                       U.append
                          (map 
                              (fn arg => 
                                 U.append
                                    [
                                    U.break 1,
                                    U.string arg
                                    ])
                              doms),
                       U.string " ."
                       ],
                    U.break 1,
                    cod 0
                    ]))

      val () =
         register Prim.rec 1 0
         (U.wrap
             (U.apply1 Prim.rec (U.lam U.show))
             (fn (arg, body) =>
                 U.append [U.string "rec ", U.string arg, U.string " .", U.break 1, body 1]))

      val () =
         register Prim.mu 1 0
         (U.wrap
             (U.apply1 Prim.mu (U.lam U.show))
             (fn (arg, body) =>
                 U.append [U.string "mu ", U.string arg, U.string " .", U.break 1, body 1]))

      val () =
         register Prim.wtype 2 0
         (U.wrap
             (U.apply2 Prim.wtype U.show (U.lam U.show))
             (fn (a, (arg, b)) =>
                 U.append [
                          U.string "wtype (",
                          U.string arg, 
                          U.string " : ",
                          U.box (a 0),
                          U.string ") .",
                          U.break 1,
                          b 1
                          ]))

      val () =
         register Prim.quotient 2 0
         (U.wrap
             (U.apply2 Prim.quotient U.show (U.lam (U.lam U.show)))
             (fn (a, (x, (y, b))) =>
                 U.append [
                          U.string "quotient (",
                          U.string x,
                          U.string " ",
                          U.string y,
                          U.break 1,
                          U.string ": ",
                          a 0,
                          U.string ") .",
                          U.break 1,
                          b 1
                          ]))

      val () = registerBinary Prim.arrow "->" 0
      val () = registerBinary Prim.tarrow "-t>" 0
      val () = registerBinary Prim.karrow "-k>" 0
      val () = registerBinary Prim.guard "-g>" 0

      fun registerLet const str =
         register const 2 0
         (U.wrap
             (U.apply2 const U.show (U.lam U.show))
             (fn (m, (x, n)) =>
                 U.append [
                          U.string str,
                          U.string x,
                          U.string " =",
                          U.break 1,
                          m 1,
                          U.string " in",
                          U.break 1,
                          n 0
                          ]))

      val () = registerLet Prim.lett "let "
      val () = registerLet Prim.letnext "let next "

      val () =
         register Prim.sumcase 3 100
         (U.wrap
             (U.apply3 Prim.sumcase U.show (U.lam U.show) (U.lam U.show))
             (fn (m, (x, n), (y, p)) =>
                 U.append
                    [
                    U.string "(",

                    U.boxi 0 $
                    U.append [
                             U.string "case ",
                             U.box (m 1),
                             U.string " of",
                             U.break 1,
                             U.string "| ",

                             U.box $
                                U.append
                                   [
                                   U.string "inl ",
                                   U.string x,
                                   U.string " .",
                                   U.break 1,
                                   U.box (n 0)
                                   ],

                             U.break 1,
                             U.string "| ",

                             U.box $
                                U.append
                                   [
                                   U.string "inr ",
                                   U.string y,
                                   U.string " .",
                                   U.break 1,
                                   U.box (p 0)
                                   ],

                             U.string ")"
                             ]
                    ]))

      val () =
         register Prim.ite 3 2
         (U.wrap
             (U.apply3 Prim.ite U.show U.show U.show)
             (fn (m, n, p) =>
                 U.boxi 0 $
                 U.append
                    [
                    U.string "if ",
                    U.box (m 2),
                    U.break 1,
                    U.string "then ",
                    U.box (n 2),
                    U.break 1,
                    U.string "else ",
                    U.box (p 3)
                    ]))

      val () =
         register Prim.inl 1 90
         (U.wrap
             (U.apply1 Prim.inl U.show)
             (fn m => U.append [U.string "inl ", m 91]))
   
      val () =
         register Prim.inr 1 90
         (U.wrap
             (U.apply1 Prim.inr U.show)
             (fn m => U.append [U.string "inr ", m 91]))

      val () =
         register Prim.ann 2 90
         (U.wrap
             (U.apply2 Prim.ann U.show U.show)
             (fn (a, m) =>
                 U.append [U.box (m 90), U.break 1, U.string ":> ", U.box (a 91)]))
   
      val () =
         register Prim.ap 2 90
         (U.wrap
             (U.apply2 Prim.ap U.show U.show)
             (fn (f, a) =>
                 (U.append
                     [
                     f 90,
                     U.break 1,
                     U.string "ap ",
                     U.box (a 91)
                     ])))
   
      val () = registerBinary Prim.sum "%" 15

      val () = registerBinary Prim.prod "&" 20

      val () =
         register Prim.ov 2 0
         (U.wrap
             (U.apply2 Prim.ov U.show U.show)
             (fn (a, m) => U.append [m 1,
                                     U.break 1, U.string ": ", a 0]))

      val () =
         register Prim.istp 1 0
         (U.wrap
             (U.apply1 Prim.istp U.show)
             (fn a => U.append [a 1,
                                U.break 1, U.string ": type"]))

      val () =
         register Prim.eq 3 30
         (U.wrap
             (U.apply3 Prim.eq U.show U.show U.show)
             (fn (a, m, n) => U.append [m 31, 
                                        U.break 1, U.string "= ", n 31, 
                                        U.break 1, U.string ": ", a 31]))

      val () =
         register Prim.eqtp 2 30
         (U.wrap
             (U.apply2 Prim.eqtp U.show U.show)
             (fn (a, b) => U.append [a 31, 
                                     U.break 1, U.string "= ", b 31, 
                                     U.break 1, U.string ": type"]))

      val () =
         register Prim.subtype 2 30
         (U.wrap
             (U.apply2 Prim.subtype U.show U.show)
             (fn (a, b) => U.append [a 31, 
                                     U.break 1, U.string "<: ", b 31]))

      val () =
         register Prim.eeqtp 2 30
         (U.wrap
             (U.apply2 Prim.eeqtp U.show U.show)
             (fn (a, b) => U.append [a 31, 
                                     U.break 1, U.string "<:> ", b 31]))

      val () =
         register Prim.set 2 100
         (U.wrap
             (U.apply2 Prim.set U.show (U.lam U.show))
             (fn (a, (arg, b)) =>
                 U.boxi 0
                    (U.append
                        [
                        U.string "{ ",
                        U.box 
                           (U.append
                               [
                               U.string arg,
                               U.string " :",
                               U.break 1,
                               a 0
                               ]),
                        U.break 1,
                        U.string "| ",
                        U.box (b 0),
                        U.string " }"
                        ])))

      val () =
         register Prim.squash 1 100
         (U.wrap
             (U.apply1 Prim.squash U.show)
             (fn a => U.append [
                               U.string "{ ",
                               a 0,
                               U.string " }"
                               ]))

      val () =
         register Prim.zero 0 100
         (U.wrap
             (U.constant Prim.zero)
             (fn () => U.string "0"))

      val () =
         register Prim.succ 1 100
         (U.wrap
             (U.fix
                 (fn unp =>
                     U.alt
                        [
                        U.wrap
                           (U.constant Prim.zero)
                           (fn () => 0),

                        U.wrap
                           (U.apply1 Prim.succ unp)
                           (fn n => n + 1)
                        ]))
             (fn n => U.string (Int.toString n)))

      datatype level_exp =
         Literal of int
       | Plus of int * level_exp
       | Max of level_exp list
       | Misc of U.content

      fun lsucc e =
         (case e of
             Literal n => Literal (n+1)
           | Plus (n, e') => Plus (n+1, e')
           | _ => Plus (1, e))

      fun lmax (e1, e2) =
         (case e2 of
             Max l => Max (e1 :: l)

           | _ => Max [e1, e2])

      fun showLevel e prec =
         (case e of
             Literal n =>
                U.string (Int.toString n)

           | Plus (n, e) =>
                U.parens (prec > 0)
                   (U.append
                       [
                       U.string (Int.toString n),
                       U.break 1,
                       U.string "+ ",
                       showLevel e 0
                       ])

           | Max [] => raise (Fail "impossible")

           | Max (e0 :: l) =>
                U.append
                   (
                   U.string "[" ::
                   showLevel e0 1 ::

                   List.foldr
                      (fns e c =>
                          U.break 1 ::
                          showLevel e 1 ::
                          c)
                      [U.string "]"]
                      l
                   )

           | Misc c => c)

      val unparseLevel =
         U.wrap
            (U.fix
                (fn unp =>
                    U.alt
                       [
                       U.wrap
                          (U.constant Prim.lzero)
                          (fn () => Literal 0),

                       U.wrap
                          (U.apply1 Prim.lsucc unp)
                          lsucc,

                       U.wrap
                          (U.apply2 Prim.lmax unp unp)
                          lmax,

                       U.wrap
                          U.show
                          (fn c => Misc (c 100))
                       ]))
            (fns e prec =>
                showLevel e (if prec > 0 then 1 else 0))

      val () =
         register Prim.univ 1 90
         (U.wrap
             (U.apply1 Prim.univ unparseLevel)
             (fn c =>
                 U.append
                    [
                    U.string "U",
                    U.break 1,
                    c 91
                    ]))

      val () =
         register Prim.lleq 2 30
         (U.wrap
             (U.apply2 Prim.lleq unparseLevel unparseLevel)
             (fn (c, d) => U.append [c 31, 
                                     U.break 1, U.string "<l= ", d 31]))

      val () =
         U.reserved :=
         List.foldl
            (fns str set => SymbolSet.insert set (Symbol.fromValue str))
            SymbolSet.empty
            ["forall", "exists", "iforall", "iexists", "inl", "inr", "rec", "wtype", "quotient"]

   end


grammardef Term

   open ParseTerm

   rule Longident  ::= AnyIdent => sing
   rule Longident  ::= LONGID => longid

   rule Numbers   ::= => null
   rule Numbers   ::= NUMBER Numbers => cons
   rule Numbersn  ::= NUMBER Numbers => cons

   rule Idents    ::= => null
   rule Idents    ::= Ident Idents => cons

   rule OIdent    ::= Ident => some
   rule OIdent    ::= "_" => none

   rule IdentPat  ::= Ident => some
   rule IdentPat  ::= "?" => none

   rule OIdents   ::= => null
   rule OIdents   ::= OIdent OIdents => cons

   rule OIdentsn  ::= OIdent OIdents => cons

   rule Binding   ::= OIdent => bindingBare
   rule Binding   ::= "(" OIdents ":" Term ")" => bindingAnnot

   rule Bindings  ::= => null
   rule Bindings  ::= Binding Bindings => append

   rule Level(0)  ::= NUMBER "+" Level(0) => level_plus
   rule Level(1)  ::= "[" Levels "]" => level_max
   rule Level(1)  ::= NUMBER => level_lit
   rule Level(1)  ::= Ident => var
   rule Level(1)  ::= "(" Level(0) ")" => id
   rule Level(1)  ::= EMBED => id

   rule Levels    ::= Level(1) => sing
   rule Levels    ::= Level(1) Levels => cons

   rule Term(0)   ::= "fn" OIdentsn "." Term(0) => lams

   rule Term(0)   ::= "forall" Bindings "." Term(0) => foralls
   rule Term(0)   ::= "exists" Bindings "." Term(0) => existss
   rule Term(0)   ::= "iforall" Bindings "." Term(0) => iforalls
   rule Term(0)   ::= "iexists" Bindings "." Term(0) => iexistss
   rule Term(0)   ::= "intersect" Bindings "." Term(0) => intersects
   rule Term(0)   ::= "foralltp" OIdents "." Term(0) => foralltps

   rule Term(0)   ::= "rec" Ident "." Term(0) => rec
   rule Term(0)   ::= "mu" Ident "." Term(0) => mu
   rule Term(0)   ::= "wtype" "(" Ident ":" Term(0) ")" "." Term(0) => wtype
   rule Term(0)   ::= "quotient" "(" Ident Ident ":" Term(0) ")" "." Term(0) => quotient

   rule Term(0)   ::= Term(1) "->" Term(0) => arrow
   rule Term(0)   ::= Term(1) "-t>" Term(0) => tarrow
   rule Term(0)   ::= Term(1) "-k>" Term(0) => karrow
   rule Term(0)   ::= Term(1) "-g>" Term(0) => guard

   rule Term(0)   ::= "let" Ident "=" Term(1) "in" Term(0) => lett
   rule Term(0)   ::= "let" "next" Ident "=" Term(1) "in" Term(0) => letnext

   rule Term(0)   ::= "case" Term(1) "of" "|" "inl" OIdent "." Term(0) "|" "inr" OIdent "." Term(0) => sumcase

   (* NB: lower precedence than equality *)
   rule Term(0)   ::= Term(1) ":" Term(0) => ov
   rule Term(0)   ::= Term(1) ":" "type" => istp

   rule Term(2)   ::= "if" Term(2) "then" Term(2) "else" Term(2) => ite

   rule Term(15)  ::= Term(16) "%" Term(15) => sum

   rule Term(20)  ::= Term(21) "&" Term(20) => prod

   rule Term(30)  ::= Term(31) "=" Term(31) ":" Term(31) => eq
   rule Term(30)  ::= Term(31) "=" Term(31) ":" "type" => eqtp
   rule Term(30)  ::= Term(31) "<:" Term(31) => subtype
   rule Term(30)  ::= Term(31) "<:>" Term(31) => eeqtp
   rule Term(30)  ::= Term(31) "<l=" Term(31) => lleq

   rule Term(90)  ::= Term(90) Term(91) => app
   rule Term(90)  ::= Term(90) "#1" => pi1
   rule Term(90)  ::= Term(90) "#2" => pi2
   rule Term(90)  ::= Term(90) "#prev" => prev
   rule Term(90)  ::= "pi1" Term(91) => pi1
   rule Term(90)  ::= "pi2" Term(91) => pi2
   rule Term(90)  ::= "prev" Term(91) => prev
   rule Term(90)  ::= "next" Term(91) => next
   rule Term(90)  ::= "inl" Term(91) => inl
   rule Term(90)  ::= "inr" Term(91) => inr
   rule Term(90)  ::= "U" Level(1) => univ
   rule Term(90)  ::= "K" Level(1) => kind

   rule Term(90)  ::= Term(90) ":>" Term(91) => ann
   rule Term(90)  ::= Term(90) "ap" Term(91) => ap
   rule Term(90)  ::= Term(90) "_#" NUMBER => appEvars

   rule Term(100) ::= "(" Term ")" => id
   rule Term(100) ::= "(" TermList ")" => tuple
   rule TermList  ::= Term(1) "," Term(1) => duo
   rule TermList  ::= Term(1) "," TermList => cons

   rule Term(100) ::= "{" Ident ":" Term "|" Term "}" => set
   rule Term(100) ::= "{" Term "}" => squash

   rule Term(100) ::= EMBED => literal
   rule Term(100) ::= "e`" EMBED => id
   rule Term(100) ::= "l`" LTerm => literal
   rule Term(100) ::= Ident => short
   rule Term(100) ::= "`" AnyIdent => shortExplicit
   rule Term(100) ::= LONGID => long
   rule Term(100) ::= "`" LONGID => longExplicit
   rule Term(100) ::= NUMBER => number
   rule Term(100) ::= "z`" NUMBER => integer
   rule Term(100) ::= "z`" LEXEME => integerLexeme
   rule Term(100) ::= "z`" EMBED => integerEmbed
   rule Term(100) ::= "_" => evar
   rule Term(100) ::= "__" => hole
   rule Term(100) ::= "(" ")" => triv
   rule Term(100) ::= "level`" Level(1) => id

   rule Term(0)   ::= "additional" OIdents "." Term(0) => additional

   rule Constant  ::= Longident => longConstant

   rule Constants ::= => null
   rule Constants ::= Constant Constants => cons

   reserved "K" "U" "additional" "ap" "case" "exists" "fn" "forall" "iexists" "iforall" "if" "in" "inl" "inl" "inr" "let" "mu" "next" "pi1" "pi2" "prev" "quotient" "rec" "then" "else" "wtype" : Ident

   default Term

end


grammaron Term
