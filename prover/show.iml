
signature UNPARSING =
   sig

      type constant = Term.constant
      type content
      type 'a unparser
      type 'a sunparser  (* unparser for spines *)
      type symbol = Symbol.symbol

      val string : string -> content
      val break : int -> content                (* n spaces that may be replaced by a linebreak *)
      val append : content list -> content
      val box : content -> content              (* box with standard indentation (2) *)
      val boxi : int -> content -> content      (* box with custom indentation *)
      val vboxi : int -> content -> content     (* vertical box with custom indentation *)
      val fboxi : int -> content -> content     (* freestyle box with custom indentation *)
      val parens : bool -> content -> content   (* parenthesize the content if the boolean is true *)


      (* 1. show will not match the entire term
         2. the returned content takes the precedence as an argument
         3. showterm returns both the content and the term itself
      *)
      val show : (int -> content) unparser
      val showterm : ((int -> content) * Term.term) unparser

      val wild : unit unparser
      val variable : int -> unit unparser
      val constant : constant -> unit unparser
      val path : constant -> 'a sunparser -> 'a unparser

      val null : unit sunparser
      val app : 'a unparser -> 'b sunparser -> ('a * 'b) sunparser

      val lam : 'a unparser -> (string * 'a) unparser
      val integer : IntInf.int unparser
      val symbol : Symbol.symbol unparser
     
      val lift : (unit -> 'a unparser) -> 'a unparser
      val wrap : 'a unparser -> ('a -> 'b) -> 'b unparser
      val alt : 'a unparser list -> 'a unparser
      val fix : ('a unparser -> 'a unparser) -> 'a unparser
      val fail : 'a unparser

      (* wrapcond fails if the wrapper returns NONE *)
      val wrapcond : 'a unparser -> ('a -> 'b option) -> 'b unparser

      val apply1 : constant -> 'a unparser -> 'a unparser
      val apply2 : constant -> 'a unparser -> 'b unparser -> ('a * 'b) unparser
      val apply3 : constant -> 'a unparser -> 'b unparser -> 'c unparser -> ('a * 'b * 'c) unparser
      val apply4 : constant -> 'a unparser -> 'b unparser -> 'c unparser -> 'd unparser -> ('a * 'b * 'c * 'd) unparser
      val apply5 : constant -> 'a unparser -> 'b unparser -> 'c unparser -> 'd unparser -> 'e unparser -> ('a * 'b * 'c * 'd * 'e) unparser

      (* fails if Show.showImplicits is set *)
      val ifNoImplicits : 'a unparser -> 'a unparser



      (* Tables *)

      (* arity, precedence, whether it is enabled, the unparser *)
      val unparsingTable : (int * int * bool ref * content unparser) ConstantTable.table

      (* quote these constants *)
      val reserved : SymbolSet.set ref

   end


signature SHOW =
   sig

      structure Unparsing : UNPARSING

      type goal = Judgement.judgement * Directory.directory

      val showClosed : Term.term -> unit

      val show : Directory.directory -> Term.term -> unit
      val showIndent : int -> Directory.directory -> Term.term -> unit
      val showPrefixed : string -> Directory.directory -> Term.term -> unit
      val showPP : PrettyPrint.ppstream -> Directory.directory -> Term.term -> unit

      val showGoal : goal -> unit
      val showGoalIndent : int -> goal -> unit
      val showContext : Judgement.context -> Directory.directory -> unit


      val showLiteral : Term.term -> unit
      val showLiteralPP : PrettyPrint.ppstream -> Term.term -> unit
      val showLiteralSub : Term.sub -> unit
      val showLiteralGoal : Judgement.judgement -> unit

      val showSubstitutions : bool ref
      val showImplicits : bool ref
      val showLiteralBinders : bool ref
      val showVeryLiteral : bool ref

      val enable : Constant.constant -> bool -> unit
      val disableAll : bool ref
      val sugarFnind : bool ref

      (* determines how certain arithmetic operations are displayed *)
      val arithmetic : Symbol.symbol CheckpointedRef.cref

   end


structure ShowInternal
   :> sig
         include SHOW

         type 'a unparser_ = bool -> int -> Directory.directory -> Term.term -> 'a
         type content_ = PrettyPrint.ppstream -> unit

         exception NoMatch

         val exposeUnparser : 'a Unparsing.unparser -> 'a unparser_
         val hideUnparser : 'a unparser_ -> 'a Unparsing.unparser
         val exposeContent : Unparsing.content -> content_
         val hideContent : content_ -> Unparsing.content
      end
   =
   struct

      structure CR = CheckpointedRef
      structure D = Directory
      structure ET = ETerm
      structure J = Judgement
      structure N = Normalize
      structure PP = PrettyPrint
      structure S = Seq
      structure SD = SymbolDict
      structure T = Term

      structure IS = RedBlackSet (structure Elem = IntOrdered)
                   

      type goal = Judgement.judgement * Directory.directory


      val indent = 2
      val width = 80

      fun showTop indent f =
         let
            val pp = PP.makeStreamIndent TextIO.stdOut width indent
         in
            PP.openBox pp PP.Consistent indent;
            f pp;
            PP.closeBox pp;
            PP.flush pp;
            print "\n"
         end

      val precMin = 0
      val precLam = 0
      val precConstituent = 1
      val precApp = 90
      val precSub = 99

      fun lparen pp prec prec' =
         if prec' < prec then
            PP.print pp "("
         else
            ()

      fun rparen pp prec prec' =
         if prec' < prec then
            PP.print pp ")"
         else
            ()


      val reserved = ref SymbolSet.empty

      fun showAddress pp address =
         (case address of
             [] =>
                (* This shouldn't happen, but fail gracefully. *)
                ()

           | [sym] =>
                PP.print pp (Symbol.toValue sym)

           | sym :: rest =>
                (
                PP.print pp (Symbol.toValue sym);
                PP.print pp ".";
                showAddress pp rest
                ))


      val arithmetic = CR.new (Symbol.fromValue "nat")

      val integerSym = Symbol.fromValue "integer"
      val naturalSym = Symbol.fromValue "natural"

      fun showNative pp native =
         (case native of
             T.Integer x =>
                (
                if 
                   Symbol.eq (CR.deref arithmetic, integerSym)
                   orelse
                      (Symbol.eq (CR.deref arithmetic, naturalSym) 
                       andalso 
                       IntInf.<= 0I x)
                then
                   ()
                else
                   PP.print pp "z`";
       
                if IntInf.< x 0I then
                   (
                   PP.print pp "-";
                   PP.print pp (IntInf.toString (IntInf.~ x))
                   )
                else
                   PP.print pp (IntInf.toString x)
                )

           | T.Symbol sym =>
                (* Will eventually be more sophisticated than this. *)
                (
                PP.print pp "sym`\"";
                PP.print pp (Symbol.toValue sym);
                PP.print pp "\""
                ))
                
                


      val showLiteralBinders = ref false
      val showVeryLiteral = ref false
      val showSubstitutions = ref false

      (* if !showVeryLiteral then s = id

         'evars' is for cycle detection because it's barely possible for there to be
         a cycle in the raw, unsimplified syntax via the substitutions.  (The occurs check
         is run on simplified code wherein substitutions are already carried out.)
         If !showVeryLiteral=false, raw substitutions aren't shown so 'evars' is
         ignored.
      *)
      fun showLiteralMain pp evars prec m s spine =
         (case m of
             T.Var i =>
                (case T.substVar i s of
                    T.Idx j =>
                       showWithLiteralSpine pp evars prec
                          (fn _ => PP.print pp (Int.toString j))
                          spine

                  | T.Term n =>
                       showLiteralMain pp evars prec n T.id spine)

           | T.Const const =>
                showWithLiteralSpine pp evars prec
                   (fn _ => showAddress pp (Namespace.name const))
                   spine

           | T.Elim (m1, spine') =>
                showLiteralMain pp evars prec m1 s (T.ssubst spine' s @ spine)

           | T.Lam (bo, m1) =>
                let
                   val str =
                      if !showLiteralBinders then
                         (case bo of
                             NONE => "_ "
   
                           | SOME sym => Symbol.toValue sym ^ " ")
                      else
                         ""
                in
                   showWithLiteralSpine pp evars prec
                      (fn prec' =>
                          (
                          PP.openBox pp PP.Consistent indent;
                          lparen pp prec' precLam;
                          PP.print pp "fn ";
                          PP.print pp str;
                          PP.print pp ".";
                          PP.break pp 1;
                          showLiteralMain pp evars precLam m1 (T.under 1 s) [];
                          rparen pp prec' precLam;
                          PP.closeBox pp
                          ))
                      spine
                end

           | T.Pair _ =>
                showWithLiteralSpine pp evars prec
                   (fn _ =>
                       (
                       PP.print pp "(";
                       PP.openBox pp PP.Consistent 0;
                       showLiteralTuple pp evars m s;  (* prints the close parenthesis *)
                       PP.closeBox pp
                       ))
                    spine
                
           | T.Next m1 =>
                showWithLiteralSpine pp evars prec
                   (fn prec' =>
                       (
                       PP.openBox pp PP.Consistent indent;
                       lparen pp prec' precApp;
                       PP.print pp "next";
                       PP.break pp 1;
                       showLiteralMain pp evars (precApp+1) m1 s [];
                       rparen pp prec' precApp;
                       PP.closeBox pp
                       ))
                   spine

           | T.Triv =>
                showWithLiteralSpine pp evars prec
                   (fn _ => PP.print pp "()")
                   spine

           | T.Sub (m1, s') =>
                if !showVeryLiteral then
                   (* by precondition, s = id *)
                   showWithLiteralSpine pp evars prec
                      (fn _ =>
                          (
                          PP.openBox pp PP.Consistent indent;
                          lparen pp prec precSub;
                          showLiteralMain pp evars precSub m1 T.id [];
                          PP.break pp 0;
                          PP.print pp "[";
                          PP.openBox pp PP.Consistent indent;
                          showLiteralSubMain pp evars s';
                          PP.closeBox pp;
                          PP.print pp "]";
                          rparen pp prec precSub;
                          PP.closeBox pp
                          ))
                      spine
                else
                   showLiteralMain pp evars prec m1 (T.compose s' s) spine

           | T.Evar eb =>
                (case T.readEbind eb of
                    SOME m1 =>
                       if !showVeryLiteral then
                          let
                             val enum = T.ebindToInt eb
                          in
                             if IS.member evars enum then
                                showWithLiteralSpine pp evars prec
                                   (fn _ => PP.print pp "~cycle~")
                                   spine
                             else
                                showLiteralMain pp (IS.insert evars enum) prec m1 s spine
                          end
                       else
                          showLiteralMain pp evars prec m1 s spine

                  | NONE =>
                       showWithLiteralSpine pp evars prec
                          (fn _ =>
                              (
                              PP.print pp "E";
                              PP.print pp (Int.toString (T.ebindToInt eb));
                              showSub pp s
                              ))
                          spine)

           | T.Native x =>
                showWithLiteralSpine pp evars prec
                   (fn _ => showNative pp x)
                   spine

           | T.Marker sym =>
                showWithLiteralSpine pp evars prec
                   (fn _ =>
                       (
                       PP.print pp "_";
                       PP.print pp (Symbol.toValue sym);
                       PP.print pp "_"
                       ))
                   spine)


      and showWithLiteralSpine pp evars prec f spine =
         (case spine of
             [] => f prec

           | _ =>
                (
                lparen pp prec precApp;
                PP.openBox pp PP.Consistent indent;
                f precApp;
                showLiteralSpine pp evars spine;
                PP.closeBox pp;
                rparen pp prec precApp
                ))
                

      and showLiteralTuple pp evars m s =
         (case m of
             T.Pair (m1, m2) =>
                (
                PP.openBox pp PP.Consistent indent;
                showLiteralMain pp evars precConstituent m1 s [];
                PP.print pp " ,";
                PP.closeBox pp;
                PP.break pp 1;
                showLiteralTuple pp evars m2 s
                )

           | _ =>
                (
                PP.openBox pp PP.Consistent indent;
                showLiteralMain pp evars precConstituent m s [];
                PP.print pp ")";
                PP.closeBox pp
                ))


      and showLiteralSpine pp evars spine =
         (case spine of
             [] => ()

           | elim :: rest =>
                (
                PP.break pp 1;

                (case elim of
                    T.App m =>
                       showLiteralMain pp evars (precApp+1) m T.id []

                  | T.Pi1 => PP.print pp "#1"
                  | T.Pi2 => PP.print pp "#2"
                  | T.Prev => PP.print pp "#prev");

                showLiteralSpine pp evars rest
                ))


      and showLiteralSubMain pp evars s =
         (case s of
             T.Shift i =>
                (
                PP.print pp "^";
                PP.print pp (Int.toString i)
                )

           | T.Dot (m, s) =>
                (
                showLiteralMain pp evars precSub m T.id [];
                PP.print pp " .";
                PP.break pp 1;
                showLiteralSubMain pp evars s
                )
                
           | T.Idot (i, s) =>
                (
                PP.print pp (Int.toString i);
                PP.print pp " .";
                PP.break pp 1;
                showLiteralSubMain pp evars s
                ))


      and showSub pp s =
         if !showSubstitutions then
            (case s of
                T.Shift 0 => ()

              | _ =>
                   (
                   PP.print pp "[";
                   PP.openBox pp PP.Consistent 0;
                   showLiteralSubMain pp IS.empty s;
                   PP.closeBox pp;
                   PP.print pp "]"
                   ))
         else
            ()


      fun showLiteral m =
         showTop 0 (fn pp => showLiteralMain pp IS.empty precMin m T.id [])

      fun showLiteralPP pp m =
         showLiteralMain pp IS.empty precMin m T.id []

      fun showLiteralSub s =
         showTop 0 (fn pp => showLiteralSubMain pp IS.empty s)


      fun showLiteralHyp pp hyp =
         (case hyp of
             J.Tm a => 
                showLiteralMain pp IS.empty precMin a T.id []

           | J.Tml a =>
                showLiteralMain pp IS.empty precMin a T.id []

           | J.Tmh a =>
                showLiteralMain pp IS.empty precMin a T.id []

           | J.Tmlh a =>
                showLiteralMain pp IS.empty precMin a T.id []

           | J.Tp =>
                PP.print pp "type"

           | J.Tpl =>
                PP.print pp "type"

           | J.Tph =>
                PP.print pp "type"

           | J.Let a =>
                showLiteralMain pp IS.empty precMin a T.id [])


      fun hypLiteralCategory hyp =
         (case hyp of
             J.Tm _ => ""

           | J.Tml _ => "(later) "

           | J.Tmh _ => "(hidden) "

           | J.Tmlh _ => "(later hidden) "

           | J.Tp => ""

           | J.Tpl => "(later) "

           | J.Tph => "(hidden) "

           | J.Let _ => "= ")

      fun showLiteralHyps pp hyps =
         (case S.expose hyps of
             S.Nil => ()

           | S.Cons (hyp, rest) =>
                (
                showLiteralHyps pp rest;
                PP.print pp (hypLiteralCategory hyp);
                PP.openBox pp PP.Consistent indent;
                showLiteralHyp pp hyp;
                PP.closeBox pp;
                PP.newline pp
                ))

      fun showLiteralGoalIndent indent jud =
         showTop indent
         (fn pp =>
             (
             showLiteralHyps pp (J.context jud);
             PP.print pp "|-";
             PP.newline pp;
             PP.openBox pp PP.Consistent indent;
             showLiteralMain pp IS.empty precMin (J.concl jud) T.id []
             ))

      val showLiteralGoal = showLiteralGoalIndent 0
         


      
      type content = PP.ppstream -> unit

      exception NoMatch

      type 'a unparser =
         bool                    (* are we matching the entire term?
                                    (There's no use for the show combinator to match an entire
                                    term because that would result in looping)
                                 *)
         -> int                  (* "margin": the index to start naming unnamed free variables at *)
         -> Directory.directory  (* the directory *)
         -> T.term               (* term to unparse *)
         -> 'a

      structure H = ConstantTable

      (* arity, precedence, unparser, enabled *)
      val unparsingTable : (int * int * bool ref * content unparser) H.table = H.table ()

      fun enable const enabled =
         let
            val (_, _, r, _) = H.lookup unparsingTable const
         in
            r := enabled
         end

      val disableAll = ref false

      (* Actually used in Datatype, not Show, but belongs here because it's a control for show. *)
      val sugarFnind = ref true

      type 'a unparser_ = 'a unparser
      fun exposeUnparser x = x
      fun hideUnparser x = x
      type content_ = content
      fun exposeContent x = x
      fun hideContent x = x


      val showImplicits = ref false

      fun collectLams m s acc =
         (case m of
             T.Var i =>
                (case T.substVar i s of
                    T.Idx j =>
                       (List.rev acc, T.Var j)

                  | T.Term m' =>
                       collectLams m' T.id acc)

           | T.Lam (b, m1) =>
                collectLams m1 (T.under 1 s) (b :: acc)

           | T.Sub (m1, s') =>
                collectLams m1 (T.compose s' s) acc

           | T.Evar eb =>
                (case T.readEbind eb of
                    NONE => 
                       (List.rev acc, T.Sub (m, s))

                  | SOME m' =>
                       collectLams m' s acc)

           | _ => 
                (List.rev acc, T.Sub (m, s)))


      fun trimSpine n spine =
         if n = 0 then
            SOME spine
         else
            (case spine of
                T.App _ :: rest =>
                   trimSpine (n-1) rest

              | _ => NONE)


      (* margin: number to start naming unnamed free variables at 
         dir: names of free variables
      *)
      fun showMain pp margin dir prec m s spine =
         (case m of
             T.Var i =>
                (case T.substVar i s of
                    T.Idx j =>
                       showRootSpine pp margin dir prec (T.Var j) T.id spine

                  | T.Term m' =>
                       showMain pp margin dir prec m' T.id spine)

           | T.Const const =>
                (case H.find unparsingTable const of
                    SOME (arity, kprec, enabled, unp) =>
                       if !enabled andalso not (!disableAll) then
                          (case List.splitOpt spine arity of
                              NONE =>
                                 showRootSpine pp margin dir prec m T.id spine
   
                            | SOME (spine1, spine2) =>
                                 (try
                                     let
                                        val c = unp true margin dir (T.Elim (T.Const const, spine1))
                                     in
                                        showWithSpine pp margin dir prec spine2
                                        (fn prec' =>
                                            (
                                            lparen pp prec' kprec;
                                            PP.openBox pp PP.Consistent indent;
                                            c pp;
                                            PP.closeBox pp;
                                            rparen pp prec' kprec
                                            ))
                                     end
                                  with
                                     NoMatch => showRootSpine pp margin dir prec m T.id spine))
                       else
                          showRootSpine pp margin dir prec m T.id spine

                  | NONE =>
                       showRootSpine pp margin dir prec m T.id spine)

           | T.Elim (m1, spine') =>
                showMain pp margin dir prec m1 s (T.ssubst spine' s @ spine)

           | T.Sub (m1, s') =>
                showMain pp margin dir prec m1 (T.compose s' s) spine

           | T.Evar eb =>
                (case T.readEbind eb of
                    NONE =>
                       showRootSpine pp margin dir prec m s spine

                  | SOME m1 =>
                       showMain pp margin dir prec m1 s spine)

           | _ =>
                showRootSpine pp margin dir prec m s spine)

      (* m is an intro, or var/const and s=id, or a free evar *)
      and showRootSpine pp margin dir prec m s spine =
         (case m of
             T.Const const =>
                (* If a constant's name is a reserved word, quote it.
                   Otherwise, skip implicit arguments.
                   If the implicit arguments aren't there, quote the name.
                *)
                let
                   val addr = Namespace.name const

                   val quote =
                      (case addr of
                          [sym] => SymbolSet.member (!reserved) sym
                        | _ => false)

                   val (quote', spine') =
                      if quote then
                         (true, spine)
                      else
                         if !showImplicits then
                            (false, spine)
                         else
                            (case trimSpine (Database.findImplicits const) spine of
                                NONE =>
                                   (true, spine)
   
                              | SOME spine' =>
                                   (false, spine'))
                in
                   showWithSpine pp margin dir prec spine'
                   (fn prec' =>
                       (
                       if quote' then
                          PP.print pp "`"
                       else
                          ();

                       showAddress pp addr
                       ))
                end

           | _ =>
                showWithSpine pp margin dir prec spine
                (fn prec' => showRoot pp margin dir prec' m s))

      (* m is an intro, or var and s=id, or a free evar *)
      and showRoot pp margin dir prec m s =
         (case m of
             T.Var i =>
                (* by precondition, s = id *)
                (case Directory.nameOpt dir i of
                    SOME sym =>
                       PP.print pp (Symbol.toValue sym)

                  | NONE =>
                       (
                       PP.print pp "~";
                       PP.print pp (Int.toString (i - Directory.size dir + margin));
                       PP.print pp "~"
                       ))

           | T.Const const =>
                raise (Fail "precondition")

           | T.Evar e =>
                (
                PP.print pp "E";
                PP.print pp (Int.toString (T.ebindToInt e));
                showSub pp s
                )

           | T.Lam _ =>
                let
                   val (bs, m1) = collectLams m s []
                in
                   PP.openBox pp PP.Consistent indent;
                   lparen pp prec precLam;
                   PP.print pp "fn ";
                   
                   let
                      fun loop dir bs =
                         (case bs of
                             [] => dir

                           | b :: rest =>
                                let
                                   val (sym, dir') = D.varyAndBind dir b
                                in
                                   PP.print pp (Symbol.toValue sym);
                                   PP.print pp " ";
                                   loop dir' rest
                                end)

                      val dir' = loop dir bs
                   in
                      PP.print pp ".";
                      PP.break pp 1;
                      showMain pp margin dir' precLam m1 T.id [];
                      rparen pp prec precLam;
                      PP.closeBox pp
                   end
                end

           | T.Pair _ =>
                (
                PP.print pp "(";
                PP.openBox pp PP.Consistent 0;
                showTuple pp margin dir (N.simplify (T.Sub (m, s)));  (* prints the close parenthesis *)
                PP.closeBox pp
                )

           | T.Next m1 =>
                (
                PP.openBox pp PP.Consistent indent;
                lparen pp prec precApp;
                PP.print pp "next";
                PP.break pp 1;
                showMain pp margin dir (precApp+1) m1 s [];
                rparen pp prec precApp;
                PP.closeBox pp
                )

           | T.Triv =>
                PP.print pp "()"

           | T.Native x =>
                showNative pp x

           | T.Marker sym =>
                (
                PP.print pp "_";
                PP.print pp (Symbol.toValue sym);
                PP.print pp "_"
                )

           | T.Elim _ => raise (Fail "precondition")

           | T.Sub _ => raise (Fail "precondition"))


      and showTuple pp margin dir m =
         (case m of
             T.Pair (m1, m2) =>
                (
                PP.openBox pp PP.Consistent indent;
                showMain pp margin dir precConstituent m1 T.id [];
                PP.print pp ",";
                PP.closeBox pp;
                PP.break pp 1;
                showTuple pp margin dir (N.simplify m2)
                )

           | _ =>
                (
                PP.openBox pp PP.Consistent indent;
                showMain pp margin dir precConstituent m T.id [];
                PP.print pp ")";
                PP.closeBox pp
                ))

      and showWithSpine pp margin dir prec spine f =
         (case spine of
             [] => f prec

           | _ :: _ =>
                (
                lparen pp prec precApp;
                PP.openBox pp PP.Consistent indent;
                f precApp;
                showSpine pp margin dir spine;
                PP.closeBox pp;
                rparen pp prec precApp
                ))

      and showSpine pp margin dir spine =
         (case spine of
             [] => ()

           | elim :: rest =>
                (
                PP.break pp 1;

                (case elim of
                    T.App m =>
                       showMain pp margin dir (precApp+1) m T.id []

                  | T.Pi1 => PP.print pp "#1"
                  | T.Pi2 => PP.print pp "#2"
                  | T.Prev => PP.print pp "#prev");

                showSpine pp margin dir rest
                ))

      fun showPP pp dir m =
         showMain pp 0 dir precMin m T.id []

      fun showIndent indent dir m =
         showTop indent
         (fn pp => showPP pp dir m)

      fun showPrefixed str dir m =
         (
         print str;
         showIndent (String.length str) dir m
         )

      val show = showIndent 0

      fun showClosed m = showIndent 0 Directory.empty m



      structure Unparsing =
         struct

            type constant = T.constant
            type content = content
            type 'a unparser = 'a unparser
            type 'a sunparser = int -> Directory.directory -> T.elim list -> 'a
            type symbol = Symbol.symbol

            fun string str pp = PP.print pp str

            fun break n pp = PP.break pp n

            fun append l pp =
               List.app (fn c => c pp) l

            fun box c pp =
               (
               PP.openBox pp PP.Consistent indent;
               c pp;
               PP.closeBox pp
               )

            fun boxi i c pp =
               (
               PP.openBox pp PP.Consistent i;
               c pp;
               PP.closeBox pp
               )

            fun vboxi i c pp =
               (
               PP.openBox pp PP.Vertical i;
               c pp;
               PP.closeBox pp
               )

            fun fboxi i c pp =
               (
               PP.openBox pp PP.Freestyle i;
               c pp;
               PP.closeBox pp
               )

            fun parens b c pp =
               (
               if b then
                  (
                  PP.print pp "(";
                  PP.openBox pp PP.Consistent indent
                  )
               else
                  ();

               c pp;

               if b then
                  (
                  PP.closeBox pp;
                  PP.print pp ")"
                  )
               else
                  ()
               )
              
            fun show entire margin dir m =
               if entire then
                  raise NoMatch
               else
                  (fns prec pp => showMain pp margin dir prec m T.id [])

            fun showterm entire margin dir m =
               (show entire margin dir m, m)


            fun wild _ _ _ _ = ()

            fun variable i _ _ _ m =
               (case N.simplify m of
                   T.Elim (T.Var j, []) =>
                      if i = j then
                         ()
                      else
                         raise NoMatch

                 | _ => raise NoMatch)

            fun constant const _ _ _ m =
               (case N.simplify m of
                   T.Elim (T.Const const', []) =>
                      if Constant.eq (const, const') then
                         ()
                      else
                         raise NoMatch

                 | _ => raise NoMatch)

            fun lam unp _ margin dir m =
               (case N.simplify m of
                   T.Lam (b, n) =>
                      let
                         val (sym, dir') = D.varyAndBind dir b

                         val x = unp false margin dir' n
                      in
                         (Symbol.toValue sym, x)
                      end

                 | _ => raise NoMatch)

            fun integer _ _ _ m =
               (case N.simplify m of
                   T.Native (T.Integer x) => x

                 | _ => raise NoMatch)
                   
            fun symbol _ _ _ m =
               (case N.simplify m of
                   T.Native (T.Symbol sym) => sym

                 | _ => raise NoMatch)
                   
            fun path const unp _ margin dir m =
               (case N.simplify m of
                   T.Elim (T.Const const', spine) =>
                      if Constant.eq (const, const') then
                         unp margin dir spine
                      else
                         raise NoMatch

                 | _ => raise NoMatch)

            fun null _ _ spine =
               (case spine of
                   [] => ()

                 | _ :: _ => raise NoMatch)

            fun app unp1 unp2 margin dir spine =
               (case spine of
                   T.App m :: rest =>
                      let
                         val x = unp1 false margin dir m
                         val y = unp2 margin dir rest
                      in
                         (x, y)
                      end

                 | _ => raise NoMatch)

            fun lift f entire margin dir m = f () entire margin dir m
               
            fun wrap unp f entire margin dir m = f (unp entire margin dir m)

            fun wrapcond unp f entire margin dir m =
               (case f (unp entire margin dir m) of
                   NONE => raise NoMatch

                 | SOME x => x)

            fun alt l entire margin dir m =
               let
                  fun loop l =
                     (case l of
                         [] => raise NoMatch

                       | unp :: rest =>
                            (try
                                unp entire margin dir m
                             with
                                NoMatch => loop rest))
               in
                  loop l
               end

            fun fix f entire margin dir m = f (fix f) entire margin dir m

            fun fail _ _ _ _ = raise NoMatch

            fun apply1 const unp =
               wrap
               (path const (app unp null))
               (fn (x, ()) => x)

            fun apply2 const unp1 unp2 =
               wrap
               (path const (app unp1 (app unp2 null)))
               (fn (x, (y, ())) => (x, y))

            fun apply3 const unp1 unp2 unp3 =
               wrap
               (path const (app unp1 (app unp2 (app unp3 null))))
               (fn (x, (y, (z, ()))) => (x, y, z))

            fun apply4 const unp1 unp2 unp3 unp4 =
               wrap
               (path const (app unp1 (app unp2 (app unp3 (app unp4 null)))))
               (fn (w, (x, (y, (z, ())))) => (w, x, y, z))

            fun apply5 const unp1 unp2 unp3 unp4 unp5 =
               wrap
               (path const (app unp1 (app unp2 (app unp3 (app unp4 (app unp5 null))))))
               (fn (v, (w, (x, (y, (z, ()))))) => (v, w, x, y, z))

            fun ifNoImplicits unp entire margin dir m =
               if !showImplicits then
                  raise NoMatch
               else
                  unp entire margin dir m



            val unparsingTable = unparsingTable
            val reserved = reserved

         end



      fun showHyp pp hyp margin dir =
         (case hyp of
             J.Tm a => 
                showMain pp margin dir precMin a T.id []

           | J.Tml a =>
                showMain pp margin dir precMin a T.id []

           | J.Tmh a =>
                showMain pp margin dir precMin a T.id []

           | J.Tmlh a =>
                showMain pp margin dir precMin a T.id []

           | J.Tp =>
                PP.print pp "type"

           | J.Tpl =>
                PP.print pp "type"

           | J.Tph =>
                PP.print pp "type"

           | J.Let m =>
                showMain pp margin dir precMin m T.id [])


      fun hypCategory hyp =
         (case hyp of
             J.Tm _ => " : "

           | J.Tml _ => " (later) : "

           | J.Tmh _ => " (hidden) : "

           | J.Tmlh _ => " (later hidden) : "

           | J.Tp => " : "

           | J.Tpl => " (later) : "

           | J.Tph => " (hidden) : "

           | J.Let _ => " = ")


      fun showHypsMargin pp hyps margin =
         (case S.expose hyps of
             S.Nil => ()

           | S.Cons (hyp, rest) =>
                (
                showHypsMargin pp rest (margin+1);
                PP.print pp "~";
                PP.print pp (Int.toString margin);
                PP.print pp "~";
                PP.print pp (hypCategory hyp);
                PP.openBox pp PP.Consistent indent;
                showHyp pp hyp (margin+1) D.empty;
                PP.closeBox pp;
                PP.newline pp
                ))


      fun letrecOf hyp =
         (case hyp of
             J.Let m =>
                (case N.simplify m of
                    T.Elim (T.Const const, [T.App n]) =>
                       if Constant.eq (const, Prim.fix) then
                          (case N.simplify n of
                              T.Lam (_, body) => SOME body

                            | _ => NONE)
                       else
                          NONE

                  | _ => NONE)

           | _ => NONE)
                       

      fun showHyps pp hyps dir =
         (case S.expose hyps of
             S.Nil => ()

           | S.Cons (hyp, rest) =>
                (* special case for letrec *)
                let
                   val letrec = letrecOf hyp
                in
                   (case D.exposeOpt dir of
                       SOME (x, dir') =>
                          (
                          showHyps pp rest dir';
                          PP.print pp (Symbol.toValue x);

                          (case letrec of
                              NONE =>
                                 (
                                 PP.print pp (hypCategory hyp);
                                 PP.openBox pp PP.Consistent indent;
                                 showHyp pp hyp 0 dir'
                                 )

                            | SOME body =>
                                 (
                                 PP.print pp " =rec= ";
                                 PP.openBox pp PP.Consistent indent;
                                 showPP pp dir body
                                 ));

                          PP.closeBox pp;
                          PP.newline pp
                          )
   
                     | NONE =>
                          (* This can't happen unless someone has mucked up the directory. *)
                          showHypsMargin pp hyps 0)
                end)


               

      fun showGoalIndent indent (jud, dir) =
         showTop indent
         (fn pp =>
             (
             showHyps pp (J.context jud) dir;
             PP.print pp "|-";
             PP.newline pp;
             PP.openBox pp PP.Consistent indent;
             showMain pp 0 dir precMin (J.concl jud) T.id []
             ))

      val showGoal = showGoalIndent 0

      fun showContext ctx dir =
         showTop 0
         (fn pp => showHyps pp ctx dir)

   end


structure Show 
   :> SHOW 
      where type Unparsing.content = ShowInternal.Unparsing.content
      where type 'a Unparsing.unparser = 'a ShowInternal.Unparsing.unparser
      where type 'a Unparsing.sunparser = 'a ShowInternal.Unparsing.sunparser
 = ShowInternal
