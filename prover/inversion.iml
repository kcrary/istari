
signature INVERSION =
   sig

      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority
      type hypothesis = Hyp.hypothesis

      val destructThinPriority : hypothesis -> IntroPattern.ipattern -> priority tacticm
      val destructThinRaw : hypothesis -> IntroPattern.ipattern -> tactic
      val destructThin : hypothesis -> IntroPattern.ipattern -> tactic

      val destructThinCautiousPriority : hypothesis -> IntroPattern.ipattern -> priority tacticm
      val destructThinCautiousRaw : hypothesis -> IntroPattern.ipattern -> tactic
      val destructThinCautious : hypothesis -> IntroPattern.ipattern -> tactic

      val inversionPriority : hypothesis -> priority tacticm
      val inversionRaw : hypothesis -> tactic
      val inversion : hypothesis -> tactic

      val mimicPriority : hypothesis list -> priority tacticm
      val mimicRaw : hypothesis list -> tactic
      val mimic : hypothesis list -> tactic

   end


structure Inversion :> INVERSION =
   struct

      structure D = Directory
      structure IP = IntroPattern
      structure J = Judgement
      structure N = Normalize
      structure S = Seq
      structure T = Term

      open Tactic
      open CasePervasive

      type hypothesis = Hyp.hypothesis


      fun withsize tac (goal as (jud, _)) fk sk =
         tac (Seq.length (J.context jud)) goal fk sk


      (* Perform injection or substitution, where possible, on hypotheses
         n down through stop (inclusive).  Only substitute for variables
         between stop and lid (inclusive).
      *)
      fun injections cautious lid stop n =
         if n < stop then
            idtacM Primary
         else
            goalHypCaseT n
            /| $tm
                  (| \Prim.eq\ _ var? var? =>
                     \(fnc i j =>
                          if i = j then
                             Hyp.clear [Hyp.NUMBER n]
                             >>
                             (* one hypothesis deleted *)
                             injections cautious (lid-1) stop (n-1)
                          else if i <= lid then
                             (* Make sure the left-hand equand is a new variable (i.e.,
                                introduced by destruction).  Note that stop <= n < i.

                                Note that the rhs is made of up index variables for the
                                hypothesis that was destructed, all of which must be old
                                variables, so there won't be a dependency problem subsituted
                                j for i.
                             *)
                             ifthenM
                                (EqualityTacticInternal.substMain false cautious i n (T.Var j))

                                (* two hypotheses deleted: one equality, one variable *)
                                (fn Primary => injections cautious (lid-2) stop (n-1)
                                  | pri => idtacM pri)

                                (* substitution failed, skip it *)
                                (lift (fn () => injections cautious lid stop (n-1)))
                          else
                             injections cautious lid stop (n-1))\
                             
                   | \Prim.eq\ _ var? ? =>
                     \(fnc i m =>
                          if i <= lid then
                             first
                                [
                                EqualityTacticInternal.substMain false cautious i n m,
                                idtacM Primary
                                ]
                             >>!
                             injections cautious (lid-2) stop (n-1)
                          else
                             injections cautious lid stop (n-1))\
   
                   | \Prim.eq\ _ (const? @ _) (const? @ _) =>
                     \(fnc _ _ =>
                          let
                             do sz = withsize
                          in
                             ifthenM
                                (EqualityTactic.injectionPriority (Hyp.NUMBER n))
                                (fn pri =>
                                    (case pri of
                                        Primary =>
                                           let
                                              do sz' = withsize
                                              val new = sz' - sz
                                           in
                                              Hyp.clear [Hyp.NUMBER (n + new)]
                                              >>
                                              Hyp.exchange 0 new n
                                              >>
                                              injections cautious (lid - 1 + new) stop (n - 1 + new)
                                           end
      
                                      | _ => idtacM pri))
                                (injections cautious lid stop (n-1))
                          end)\
                  )

             | _ =>
               \(fnc =>
                    injections cautious lid stop (n-1))\
            /
         

      fun names set pats num acc =
         if num = 0 then
            List.rev acc
         else
            let
               val (symopt, pats') =
                  (case pats of
                      IP.Ident symopt :: pats' => (symopt, pats')

                    | _ :: pats' => raise (Tryf "inversion pattern expected")

                    | [] => (NONE, []))

               val (sym, set') = D.insistAndBindSet set symopt
            in
               names set' pats' (num-1) (sym :: acc)
            end


      fun destructThinMain cautious n pat set =
         (case pat of
             IP.Or pats =>
                let
                   do sz = withsize
                   do (_, dir) = withgoal

                   (* This part is just fixing up the variable names. *)
                   fun post pat =
                      (case pat of
                          IP.And pats' =>
                             let
                                do sz' = withsize
                                val num = sz' - sz + 1
                                do (_, dir) = withgoal

                                val (front, back) = D.split dir n
                                val back' = D.shift back num
    
                                do vs =
                                   tryf (fn () => names set pats' num [])
                             in
                                chdir (D.binds (D.binds back' vs) front)
                                >> 
                                idtacM Primary
                             end

                        | _ => fail "inversion pattern expected")
                in
                   andthenlPadPri
                      (Destruct.destructPriority (Hyp.NUMBER n) (IP.Or [])
                       >>!
                       let
                          do sz' = withsize
                          val first = n + sz' - sz
                       in
                          injections cautious first n first
                       end)
                      (List.map post pats)
                      (post (IP.And []))
                end

           | _ =>
                fail "inversion pattern expected")


      fun destructThinGeneral cautious hyp pat =
         let
            do n = Hyp.findhyp hyp
            do (_, dir) = withgoal
            val set = D.removeSet (D.set dir) (D.name dir n)
         in
            destructThinMain cautious n pat set
         end

      fun destructThinPriority hyp pat = destructThinGeneral false hyp pat

      fun destructThinRaw hyp pat = destructThinPriority hyp pat >> idtac

      fun destructThin hyp pat = Typecheck.withTypecheckSnd $ destructThinPriority hyp pat

      fun destructThinCautiousPriority hyp pat = destructThinGeneral true hyp pat

      fun destructThinCautiousRaw hyp pat = destructThinCautiousPriority hyp pat >> idtac

      fun destructThinCautious hyp pat = Typecheck.withTypecheckSnd $ destructThinCautiousPriority hyp pat


      fun inversionPriority hyp =
         let
            do (_, dir) = withgoal
         in
            Hyp.copy hyp NONE
            >>
            destructThinMain false 0 (IP.Or []) (D.set dir)
         end
         
      fun inversionRaw hyp = inversionPriority hyp >> idtac

      fun inversion hyp = Typecheck.withTypecheckSnd $ inversionPriority hyp



      (* heq : hyp = M : A *)
      fun mimicMain hyp heq =
         let
            do i = Hyp.findhyp hyp
         in
            destructThinGeneral true hyp (IntroPattern.Or [])
            >>!
            let
               do (jud, _) = withgoal
               val oldsz = S.length (J.context jud)
            in
               EqualityTactic.injectionPriority heq
               >>!
               let
                  do (jud, dir) = withgoal
                  val newsz = S.length (J.context jud)
                  val new = newsz - oldsz
                  val newsyms = D.suffix dir new
               in
                  Hyp.exchange 0 new i
                  >>+
                  Hyp.clear [heq]
                  >>+
                  (* heq is definitely after where we just put the new stuff *)
                  mimicLoop newsyms
               end
            end
         end

      and mimicLoop newsyms =
         (case newsyms of
             [] =>
                idtacM Primary

           | heq :: rest =>
                let
                   do (_, dir) = withgoal
                   val j = D.lookupVar (D.idir dir) heq
                in
                   goalHypCaseT j
                   /| $tm \Prim.eq\ _ var? (const? @ _) =>
                      \(fnc i _ =>
                           ifthenM
                              (mimicMain (Hyp.NAME (D.name dir i)) (Hyp.NAME heq))
                              (fn Primary => mimicLoop rest
                                | Secondary => idtacM Secondary)
                              (lift (fn () => mimicLoop rest)))\

                    | _ =>
                      \(fnc =>
                           mimicLoop rest)\
                   /
                end)

         
      fun mimicPriority hyps =
         (case hyps of
             [] =>
                idtacM Primary

           | hyp :: rest =>
                let
                   do (_, dir) = withgoal

                   do i = Hyp.findhyp hyp
                in
                   first
                      [
                      goalContextnCaseT
                      /| $tm \Prim.eq\ _ ($var \i\) ? =>
                         \(fnc j m =>
                              first
                                 [
                                 (* might as well try this first *)
                                 EqualityTacticInternal.substMain false true i j m,
   
                                 let
                                    do (_, dir) = withgoal
                                    val heq = Hyp.NAME (D.name dir j)
                                 in
                                    mimicMain hyp heq
                                 end
                                 ])\
   
                       | $tm \Prim.eq\ _ ? ($var \i\) =>
                         \(fnc j m =>
                              first
                                 [
                                 (* might as well try this first *)
                                 EqualityTacticInternal.substMain true true i j m,
   
                                 let
                                    do (_, dir) = withgoal
                                    val heq = Hyp.NAME (D.name dir j)
                                 in
                                    EqualityTactic.symmetryInPriority heq
                                    >>!
                                    (* now heq : (hyp = M : A) *)
                                    mimicMain hyp heq
                                 end
                                 ])\
                      /,

                      fail "no eligible equality hypothesis found"
                      ]
                   >>!
                   mimicPriority rest
                end)

      fun mimicRaw hyps = mimicPriority hyps >> idtac

      fun mimic hyps =
         Typecheck.withTypecheckSnd $ mimicPriority hyps

   end
