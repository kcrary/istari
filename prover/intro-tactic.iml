
signature INTRO_TACTIC =
   sig

      type symbol = Symbol.symbol
      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority

      val introPriority : IntroPattern.ipattern list -> priority tacticm
      val introRaw : IntroPattern.ipattern list -> tactic
      val intro : IntroPattern.ipattern list -> tactic

      val introsPriority : priority tacticm
      val introsRaw : tactic
      val intros : tactic

      val split : tactic
      val splitn : int -> tactic

      val leftPriority : priority tacticm
      val leftRaw : tactic
      val left : tactic

      val rightPriority : priority tacticm
      val rightRaw : tactic
      val right : tactic

      val existsPriority : ETerm.eterm -> priority tacticm
      val existsRaw : ETerm.eterm -> tactic
      val exists : ETerm.eterm -> tactic

      val exactPriority : ETerm.eterm -> priority tacticm
      val exactRaw : ETerm.eterm -> tactic
      val exact : ETerm.eterm -> tactic

      val introOfPriority : IntroPattern.ipattern list -> priority tacticm
      val introOfRaw : IntroPattern.ipattern list -> tactic
      val introOf : IntroPattern.ipattern list -> tactic

      val existsOfPriority : ETerm.eterm -> priority tacticm
      val existsOfRaw : ETerm.eterm -> tactic
      val existsOf : ETerm.eterm -> tactic

      val contrapositivePriority : Hyp.hypothesis -> priority tacticm
      val contrapositiveRaw : Hyp.hypothesis -> tactic
      val contrapositive : Hyp.hypothesis -> tactic

      val proveLambda : tactic

   end


signature INTRO_TACTIC_INTERNAL =
   sig

      include INTRO_TACTIC


      (* A tactic to introduce the type, and a function to find the identifier to use (if any). *)
      val introTactics : (Tactic.priority Tactic.tacticm * (Term.term -> Term.binder)) ConstantTable.table

      val splitTactics : tactic ConstantTable.table

      val existsTactics : (Term.term -> Tactic.priority Tactic.tacticm) ConstantTable.table

   end


structure IntroTacticInternal :> INTRO_TACTIC_INTERNAL =
   struct

      structure D = DestructInternal
      structure DI = Directory
      structure H = ConstantTable
      structure J = Judgement
      structure N = Normalize
      structure R = Reduction
      structure RT = RuleTactic
      structure S = Seq
      structure T = Term
      structure TC = Typecheck

      type term = Term.term
      type symbol = Symbol.symbol
      val evar = Term.evar

      open Tactic
      open CasePervasive


      val introTactics : (priority tacticm * (T.term -> T.binder)) H.table = H.table ()
      val splitTactics : tactic H.table = H.table ()
      val existsTactics : (term -> priority tacticm) H.table = H.table ()



      (* n: number of unfolds already *)
      fun findIntroTactic n a =
         let
            val a' = N.whnf a
         in
            (case a' of
                T.Elim (T.Const const, spine) =>
                   (case H.find introTactics const of
                       SOME (tac, binder) =>
                          let
                             val tac' =
                                if n = 0 then
                                   tac
                                else
                                   refine (Rule.reduce 
                                              (R.trans
                                                  (Int.natrecUp 
                                                      (fns _ l => R.unfold :: l)
                                                      [] n)))
                                   >>+
                                   tac
                          in
                             SOME (tac', binder, a')
                          end

                     | NONE =>
                          (case Constant.definition const of
                              SOME m => 
                                 findIntroTactic 
                                    (case Constant.opacity const of
                                        Constant.HARD => n+1

                                      | _ =>
                                           (* by construction, can't be opaque *)
                                           n)
                                    (T.Elim (m, spine))

                            | NONE => NONE))

              | _ => NONE)
         end


      fun introPriority pats =
         (case pats of
             nil => idtacM Primary

           | pat :: rest =>
                let
                   do (jud, dir) = withgoal
                   val a = Judgement.concl jud
                in
                   (case findIntroTactic 0 a of
                       SOME (tac, binder, a') =>
                          let
                             val pat' =
                                (case pat of
                                    IntroPattern.Ident NONE =>
                                       IntroPattern.Ident
                                          (Option.map
                                              (Directory.vary dir)
                                              (binder a'))
          
                                  | _ => pat)
          
                             do tc = andthenM tac
                          in
                             (case tc of
                                 Secondary =>
                                    idtacM Secondary
          
                               | Primary =>
                                    D.destruct0 pat' (introPriority rest))
                          end
          
                     | NONE => fail "conclusion not introable")
                end)

      fun introRaw pats = introPriority pats >> idtac

      fun intro pats = Typecheck.withTypecheckSnd $ introPriority pats

      fun introsPriority goal fk sk =
         ifthenM 
            (introPriority [IntroPattern.Ident NONE])
            (fn pri =>
                (case pri of
                    Primary => introsPriority

                  | Secondary => idtacM Secondary))
            (idtacM Primary)
            goal fk sk

      val introsRaw = introsPriority >> idtac

      val intros = Typecheck.withTypecheckSnd introsPriority



      val introLet =
         goalCaseT
         / \Prim.lett\ ? (fn . ?) =>
           \(fnc m c =>
                (* let M (fn . C) *)
                refine (Rule.letIntro 0 m)
                >>
                (* =M |- let M[^] (fn . C[0 . ^2]) *)
                refine (Rule.letFold 0 (T.apply2 Prim.lett T.zero (T.Sub (T.Lam (NONE, c), T.Shift 2))))
                >>
                (* =M |- let 0 (fn . C[0 . ^2]) *)
                refine (Rule.reduce (R.trans [R.unfold, R.beta 3]))
                >>
                (* =M |- C *)
                idtacM Primary)\
         /


      val () =
         let
            val insert = H.insert introTactics
            fun nobinder _ = NONE
         in
            insert Prim.forall 
               (RT.refine2 Rule.forallIntro >>> [idtacM Secondary, idtacM Primary],
                RT.binder [2]);

            insert Prim.arrow 
               (RT.refine2 Rule.arrowIntro >>> [idtacM Secondary, idtacM Primary],
                nobinder);

            insert Prim.tarrow 
               (RT.refine2 Rule.tarrowIntro >>> [idtacM Secondary, idtacM Secondary, idtacM Primary],
                nobinder);

            insert Prim.karrow 
               (RT.refine2 Rule.karrowIntro >>> [idtacM Secondary, idtacM Secondary, idtacM Primary],
                nobinder);

            insert Prim.intersect
               (RT.refine2 Rule.intersectIntro >>> [idtacM Secondary, idtacM Primary],
                RT.binder [2]);

            insert Prim.guard
               (RT.refine2 Rule.guardIntro >>> [idtacM Secondary, idtacM Primary],
                nobinder);

            insert Prim.foralltp
               (RT.refine1 Rule.foralltpIntro >>> [idtacM Primary],
                RT.binder [1]);

            insert Prim.iforall 
               (RT.refine3 Rule.iforallIntro >>> [idtacM Secondary, idtacM Primary],
                RT.binder [3]);

            insert Prim.subtype 
               (RT.refine2 Rule.subtypeEstablish >>> [idtacM Secondary, idtacM Secondary, idtacM Primary],
                nobinder);

            insert Prim.lett
               (introLet, RT.binder [1])
         end



      val split =
         let
            do const = withHeadConst "conclusion not splitable"
         in
            (case H.find splitTactics const of
                SOME tac => tac

              | NONE => fail "conclusion not splitable")
         end

      fun splitn n =
         if n = 0 then
            idtac
          else
            split >>> [idtac, splitn (n-1)]



      val leftPriority =
         let
            do const = withHeadConst "conclusion not leftable"
         in
            if Constant.eq (const, Prim.sum) then
               RuleTactic.sumIntro1
               >>> [idtacM Secondary, idtacM Primary]
            else
               fail "conclusion not leftable"
         end

      val leftRaw = leftPriority >> idtac

      val left = Typecheck.withTypecheckSnd leftPriority

      val rightPriority =
         let
            do const = withHeadConst "conclusion not rightable"
         in
            if Constant.eq (const, Prim.sum) then
               RuleTactic.sumIntro2
               >>> [idtacM Secondary, idtacM Primary]
            else
               fail "conclusion not rightable"
         end

      val rightRaw = rightPriority >> idtac

      val right = Typecheck.withTypecheckSnd rightPriority



      fun existsPriority em =
         let
            do const = withHeadConst "conclusion not existsable"
            do m = withterm em
         in
            (case H.find existsTactics const of
                SOME tac => tac m

              | NONE => fail "conclusion not existsable")
         end

      fun existsRaw m = existsPriority m >> idtac

      fun exists m = Typecheck.withTypecheckSnd $ existsPriority m

      val addbind =
         let
            do (_, dir) = withgoal
         in
            chdir (Directory.bind0 dir)
         end

      val () =
         let
            val insert = H.insert splitTactics
         in
            insert Prim.prod RuleTactic.prodIntro;
            insert Prim.unit RuleTactic.unitIntro;
            insert Prim.future RuleTactic.futureIntro;
            insert Prim.squash RuleTactic.squashIntro
         end

      val () =
         let
            val insert = H.insert existsTactics
         in
            insert Prim.exists 
               (fn m =>
                   refine (Rule.existsIntro (evar ()) (evar ()) m)
                   >>> [addbind >> idtacM Secondary, idtacM Secondary, idtacM Primary]);

            insert Prim.set 
               (fn m => 
                   refine (Rule.setIntro (evar ()) (evar ()) m)
                   >>> [addbind >> idtacM Secondary, idtacM Secondary, idtacM Primary]);

            insert Prim.iset 
               (fn m => 
                   refine (Rule.isetIntro (evar ()) (evar ()) m)
                   >>> [addbind >> idtacM Secondary, idtacM Secondary, idtacM Primary]);

            insert Prim.iexists 
               (fn b =>
                   refine (Rule.iexistsIntro (evar ()) b (evar ()) (evar ()))
                   >>> [
                       idtacM Secondary, 
                       addbind >> idtacM Secondary, 
                       idtacM Secondary,
                       idtacM Primary
                       ]);

            insert Prim.union
               (fn m =>
                   refine (Rule.unionIntro (evar ()) (evar ()) m)
                   >>> [addbind >> idtacM Secondary, idtacM Secondary, idtacM Primary])
         end



      fun existsOfPriority em =
         let
            do m = withterm em
         in
            goalCaseT
            /| \Prim.ov\ ? _ =>
               \(fnc a =>
                    termCaseT (N.whnfHard a)
                    /| \Prim.union\ _ (fn ? . _) =>
                       \(fnc binder =>
                            refine (Rule.unionIntroOf (T.evar ()) (T.evar ()) m (T.evar ()))
                            >>> [
                                (* A |- B : type *)
                                withgoal
                                (fn (_, dir) => chdir (DI.bindVary dir binder) >>+ idtacM Secondary),

                                (* M : A *)
                                idtacM Secondary,

                                (* N : B[M . id] *)
                                idtacM Primary
                                ])\

                     | \Prim.iexists\ _ _ (fn ? . _) =>
                       \(fnc binder =>
                            refine (Rule.iexistsIntroOf (T.evar ()) m (T.evar ()) (T.evar ()) (T.evar ()))
                            >>> [
                                (* K : kind i *)
                                idtacM Secondary,

                                (* K |- A : type *)
                                withgoal
                                (fn (_, dir) => chdir (DI.bindVary dir binder) >>+ idtacM Secondary),

                                (* M : K *)
                                idtacM Secondary,

                                (* M : A[M . id] *)
                                idtacM Primary
                                ])\

                     | _ =>
                       \(fnc =>
                            fail "existsOf is not supported for this type")\
                    /)\

             | _ =>
               \(fnc =>
                    fail "not a conclusion for existsOf")\
            /
         end

      fun existsOfRaw em = existsOfPriority em >> idtac

      fun existsOf em = Typecheck.withTypecheckSnd (existsOfPriority em)



      fun exactRaw em =
         let
            do m = withterm em
         in
            refine $ Rule.inhabitant (T.evar ()) m
         end

      fun exactPriority em = exactRaw em >> idtacM Secondary

      fun exact em = Typecheck.withTypecheckSnd $ (exactRaw em >> idtacM Secondary)



      (* proveLambdaLoop m lamtac

         if    lamtac proves G |- lam . N : A (for arbitrary G, N)
         then  tactic attempts to prove M : A, possibly unfolding constants
      *)
      fun proveLambdaLoop ctx m arrtac =
         termCase (N.whnf m)
         /| fn . _ =>
            \(fnc => arrtac)\

          | \Prim.pause\ _ =>
            \(fnc => 
                 (* Don't unfold pause, to avoid looping. *)
                 fail "not a lambda")\

          | \Prim.fix\ @ $ap ? _ =>
            \(fnc f =>
                 (* Unroll fix explicitly, since we aren't unfolding pause. *)
                 let
                    val tac = proveLambdaLoop ctx (T.app f m) arrtac
                 in
                    Tactic.replaceConcl (T.apply2 Prim.ov (T.evar ()) m)
                    >> refine (Rule.reduce (R.within [2] (R.user1 PrimReduction.unroll_fix)))
                    >> tac
                 end)\

          | const? @ ? =>
            \(fnc const spine =>
                 (case Constant.definition const of
                     NONE =>
                        fail "not a lambda"
 
                   | SOME n =>
                        let
                           val tac = proveLambdaLoop ctx (T.Elim (n, spine)) arrtac
                        in
                           Tactic.replaceConcl (T.apply2 Prim.ov (T.evar ()) m)
                           >> refine (Rule.reduce (R.within [2] R.unfold))
                           >> tac
                        end))\

          | var? @ ? =>
            \(fnc var spine =>
                 (case S.nthOpt ctx var of
                     SOME (J.Let n) =>
                        let
                           val tac =
                              proveLambdaLoop ctx (T.Elim (T.Sub (n, T.Shift (var+1)), spine)) arrtac
                        in
                           refine (Rule.letUnfold var 
                                      (T.apply2 Prim.ov 
                                          (T.Sub (T.evar (), T.shift1))
                                          (T.Elim (T.Var 0, T.ssubst spine T.shift1))))
                           >> tac
                        end

                   | _ =>
                        fail "not a lambda"))\

          | _ =>
            \(fnc =>
                 fail "not a lambda")\
         /
              

      fun proveLambdaArrow ctx m =
         proveLambdaLoop ctx m
            (lift 
                (fn () => 
                    (* G |- lam . N : void -> whatever *)
                    refine (Rule.arrowIntroOf (T.Const Prim.void) (T.evar ()) (T.evar ()))
                    >>> [
                        (* void : type *)
                        refine Rule.voidForm,
    
                        (* void |- whatever *)
                        refine (Rule.voidElim (T.evar ()))
                        >>
                        (* void |- void *)
                        refine (Rule.hypothesis 0)
                        ]))

      fun proveLambdaPi ctx m =
         proveLambdaLoop ctx m
            (lift 
                (fn () => 
                    (* G |- lam . N : forall void . whatever *)
                    refine (Rule.forallIntroOf (T.Const Prim.void) (T.evar ()) (T.evar ()))
                    >>> [
                        (* void : type *)
                        refine Rule.voidForm,
    
                        (* void |- whatever *)
                        refine (Rule.voidElim (T.evar ()))
                        >>
                        (* void |- void *)
                        refine (Rule.hypothesis 0)
                        ]))


      val proveLambda =
         let
            do (jud, _) = withgoal
            val ctx = J.context jud
         in
            goalCaseT
            /| \Prim.ov\ (\Prim.arrow\ \Prim.void\ _) ? =>
               \(fnc m =>
                    proveLambdaArrow ctx m)\

             | \Prim.ov\ (\Prim.forall\ \Prim.void\ _) ? =>
               \(fnc m => 
                    proveLambdaPi ctx m)\

             | _ =>
               \(fnc =>
                    fail "not a proveLambda goal")\
            /
         end



      fun introOfPriority pats =
         (case pats of
             nil => idtacM Primary

           | pat :: rest =>
                goalCaseT
                /| \Prim.ov\ ? _ =!>
                   \(fnc a =>
                        termCaseT (N.whnfHard a)
                        /| \Prim.intersect\ _ (fn ? . _) =>
                           \(fnc binder =>
                                let
                                   val pat' =
                                      (case pat of
                                          IntroPattern.Ident NONE =>
                                             IntroPattern.Ident binder
        
                                        | _ => pat)
                                in
                                   refine (Rule.intersectIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
                                   >>> [
                                       idtacM Secondary,
        
                                       D.destruct0 pat' (introOfPriority rest)
                                       ]
                                end)\

                           | \Prim.guard\ _ _ =>
                             \(fnc =>
                                  refine (Rule.guardIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
                                  >>> [
                                      idtacM Secondary,
          
                                      D.destruct0 pat (introOfPriority rest)
                                      ])\

                           | \Prim.forall\ _ (fn ? . _) =>
                             \(fnc binder =>
                                  let
                                     val pat' =
                                        (case pat of
                                            IntroPattern.Ident NONE =>
                                               IntroPattern.Ident binder
          
                                          | _ => pat)
                                  in
                                     refine (Rule.forallOfExt (T.evar ()) (T.Const Prim.void) (T.evar ()) (T.evar ()) (T.evar ()))
                                     >>> [
                                         idtacM Secondary,

                                         attempt proveLambda >> idtacM Secondary,
             
                                         D.destruct0 pat' (introOfPriority rest)
                                         ]
                                  end)\

                           | \Prim.arrow\ _ _ =>
                             \(fnc =>
                                  refine (Rule.arrowOfExt (T.evar ()) (T.Const Prim.void) (T.evar ()) (T.evar ()) (T.evar ()))
                                  >>> [
                                      idtacM Secondary,

                                      attempt proveLambda >> idtacM Secondary,
          
                                      D.destruct0 pat (introOfPriority rest)
                                      ])\

                           | \Prim.foralltp\ (fn ? . _) =>
                             \(fnc binder =>
                                  let
                                     val pat' =
                                        (case pat of
                                            IntroPattern.Ident NONE =>
                                               IntroPattern.Ident binder
          
                                          | _ => pat)
                                  in
                                     refine (Rule.foralltpIntroOf (T.evar ()) (T.evar ()))
                                     >>> [
                                         D.destruct0 pat' (introOfPriority rest)
                                         ]
                                  end)\

                           | \Prim.tarrow\  _ _ =>
                             \(fnc =>
                                  refine (Rule.tarrowOfExt (T.evar ()) (T.Const Prim.void) (T.evar ()) (T.evar ()) (T.evar ()))
                                  >>> [
                                      idtacM Secondary,

                                      idtacM Secondary,

                                      attempt proveLambda >> idtacM Secondary,
          
                                      D.destruct0 pat (introOfPriority rest)
                                      ])\

                           | \Prim.karrow\ _ _ =>
                             \(fnc =>
                                  refine (Rule.karrowOfExt (T.evar ()) (T.Const Prim.void) (T.evar ()) (T.evar ()) (T.evar ()))
                                  >>> [
                                      idtacM Secondary,

                                      idtacM Secondary,

                                      attempt proveLambda >> idtacM Secondary,
          
                                      D.destruct0 pat (introOfPriority rest)
                                      ])\
                                  
                           | _ =>
                             \(fnc =>
                                  fail "introOf is not supported for this type")\
                          /)\

                 | _ =>
                   \(fnc =>
                        fail "not a conclusion for introOf")\
                /)

      fun introOfRaw pats = introOfPriority pats >> idtac

      fun introOf pats = Typecheck.withTypecheckSnd $ introOfPriority pats



      fun contrapositivePriority hyp =
         let
            do n = Hyp.findhyp hyp

            do (_, dir) = withgoal

            val (dir3, dir12) = DI.split dir n
            val (sym, dir1) = DI.expose dir12
            val dir' = DI.bind (DI.binds dir1 dir3) sym
         in
            setFailure "hypothesis and conclusion are not in contrapositive configuration" $
            cut $
            (* A -> C ... |- B -> C[..] *)
            refine (Rule.arrowIntro (T.evar ()) (T.evar ()))
            >>> [
                (* A -> C ... | B : type *)
                idtacM Secondary,

                (* A -> C ... B |- C *)
                refine (Rule.arrowElim (T.evar ()) (T.evar ()))
                >>> [
                    (* A -> C ... B |- A[..] -> C[..] *)
                    refine (Rule.hypothesis (n+1)) >> done,

                    (* A -> C ... B |- A[..] *)
                    refine (Rule.weaken (n+1) 1)
                    >>
                    (* ... B[..] |- A[..] *)
                    chdir dir'
                    >>
                    idtacM Primary
                    ]
                ]
         end

      fun contrapositiveRaw hyp = contrapositivePriority hyp >> idtac

      fun contrapositive hyp = Typecheck.withTypecheckSnd $ contrapositivePriority hyp

   end


structure IntroTactic :> INTRO_TACTIC = IntroTacticInternal
