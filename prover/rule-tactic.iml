
(* Tactics corresponding to primitive rules that can be used without supplying any arguments. 
   Unlike the primitive rules, these manage the directory properly.
*)

signature RULE_TACTIC =
   sig

      type tactic = Tactic.tactic

      val refine1 : (Term.term -> Rule.rule) -> tactic
      val refine2 : (Term.term -> Term.term -> Rule.rule) -> tactic
      val refine3 : (Term.term -> Term.term -> Term.term -> Rule.rule) -> tactic
      val refine4 : (Term.term -> Term.term -> Term.term -> Term.term -> Rule.rule) -> tactic
      val refine5 : (Term.term -> Term.term -> Term.term -> Term.term -> Term.term -> Rule.rule) -> tactic
      val refine6 : (Term.term -> Term.term -> Term.term -> Term.term -> Term.term -> Term.term -> Rule.rule) -> tactic
      val binder : int list -> Term.term -> Term.binder

      val forallForm : tactic
      val forallEq : tactic
      val forallFormUniv : tactic
      val forallEqUniv : tactic
      val forallSub : tactic
      val forallIntroOf : tactic
      val forallIntroEq : tactic
      val forallIntro : tactic
      val arrowForm : tactic
      val arrowEq : tactic
      val arrowFormUniv : tactic
      val arrowEqUniv : tactic
      val arrowForallEq : tactic
      val arrowForallEqUniv : tactic
      val arrowSub : tactic
      val arrowForallSub : tactic
      val forallArrowSub : tactic
      val arrowIntroOf : tactic
      val arrowIntroEq : tactic
      val arrowIntro : tactic
      val tarrowKind : tactic
      val tarrowKindEq : tactic
      val tarrowForm : tactic
      val tarrowEq : tactic
      val tarrowFormUniv : tactic
      val tarrowEqUniv : tactic
      val tarrowArrowEq : tactic
      val tarrowArrowEqUniv : tactic
      val tarrowForallEq : tactic
      val tarrowForallEqUniv : tactic
      val tarrowIntroOf : tactic
      val karrowKind : tactic
      val karrowKindEq : tactic
      val karrowForm : tactic
      val karrowEq : tactic
      val karrowFormUniv : tactic
      val karrowEqUniv : tactic
      val karrowArrowEq : tactic
      val karrowArrowEqUniv : tactic
      val karrowForallEq : tactic
      val karrowForallEqUniv : tactic
      val karrowIntroOf : tactic
      val intersectForm : tactic
      val intersectEq : tactic
      val intersectFormUniv : tactic
      val intersectEqUniv : tactic
      val intersectIntroOf : tactic
      val intersectIntroEq : tactic
      val intersectIntro : tactic
      val guardForm : tactic
      val guardEq : tactic
      val guardFormUniv : tactic
      val guardEqUniv : tactic
      val guardIntroOf : tactic
      val guardIntroEq : tactic
      val guardIntro : tactic
      val guardElimOf : tactic
      val guardElimEq : tactic
      val guardSatEq : tactic
      val foralltpForm : tactic
      val foralltpEq : tactic
      val foralltpIntroOf : tactic
      val foralltpIntroEq : tactic
      val foralltpIntro : tactic
      val existsForm : tactic
      val existsEq : tactic
      val existsFormUniv : tactic
      val existsEqUniv : tactic
      val existsSub : tactic
      val existsIntroOf : tactic
      val existsIntroEq : tactic
      val existsIntro : tactic
      val prodKind : tactic
      val prodKindEq : tactic
      val prodForm : tactic
      val prodEq : tactic
      val prodFormUniv : tactic
      val prodEqUniv : tactic
      val prodSub : tactic
      val prodExistsSub : tactic
      val existsProdSub : tactic
      val prodIntroOf : tactic
      val prodIntroEq : tactic
      val prodIntro : tactic
      val futureKind : tactic
      val futureKindEq : tactic
      val futureForm : tactic
      val futureEq : tactic
      val futureFormUniv : tactic
      val futureEqUniv : tactic
      val futureSub : tactic
      val futureIntroOf : tactic
      val futureIntroEq : tactic
      val futureIntro : tactic
      val setForm : tactic
      val setEq : tactic
      val setFormUniv : tactic
      val setEqUniv : tactic
      val setIntroOfSquash : tactic
      val setSubElim : tactic
      val isetForm : tactic
      val isetEq : tactic
      val isetFormUniv : tactic
      val isetEqUniv : tactic
      val isetIntroOfSquash : tactic
      val isetSubElim : tactic
      val quotientForm : tactic
      val quotientEq : tactic
      val quotientFormUniv : tactic
      val quotientEqUniv : tactic
      val quotientIntroOf : tactic
      val quotientIntroEq : tactic
      val recKind : tactic 
      val recKindEq : tactic
      val recForm : tactic
      val recEq : tactic
      val recFormUniv : tactic
      val recEqUniv : tactic
      val recUnroll : tactic
      val recBisimilar : tactic
      val voidForm : tactic
      val voidEq : tactic
      val voidFormUniv : tactic
      val voidEqUniv : tactic
      val voidElim : tactic
      val voidSub : tactic
      val unitKind : tactic
      val unitKindEq : tactic
      val unitForm : tactic
      val unitEq : tactic
      val unitFormUniv : tactic
      val unitEqUniv : tactic
      val unitIntroOf : tactic
      val unitIntro : tactic
      val unitExt : tactic
      val boolForm : tactic
      val boolEq : tactic
      val boolFormUniv : tactic
      val boolEqUniv : tactic
      val boolIntro1Of : tactic
      val boolIntro2Of : tactic
      val muForm : tactic
      val muEq : tactic
      val muFormUniv : tactic
      val muEqUniv : tactic
      val muUnroll : tactic
      val checkPositive : tactic
      val checkNegative : tactic
      val iforallForm : tactic
      val iforallEq : tactic
      val iforallFormUniv : tactic
      val iforallEqUniv : tactic
      val iforallIntroOf : tactic
      val iforallIntroEq : tactic
      val iforallIntro : tactic
      val iexistsForm : tactic
      val iexistsEq : tactic
      val iexistsFormUniv : tactic
      val iexistsEqUniv : tactic
      val iexistsIntroOf : tactic
      val iexistsIntroEq : tactic
      val iexistsIntro : tactic
      val eqForm : tactic
      val eqEq : tactic
      val eqFormUniv : tactic
      val eqEqUniv : tactic
      val eqIntro : tactic
      val eqExt : tactic
      val eqRefl : tactic
      val eqSymm : tactic
      val ofForm : tactic
      val ofEq : tactic
      val ofFormUniv : tactic
      val ofEqUniv : tactic
      val ofIntro : tactic
      val ofExt : tactic
      val univKind : tactic
      val univKindEq : tactic
      val univForm : tactic
      val univEq : tactic
      val univFormUniv : tactic
      val univEqUniv : tactic
      val univSub : tactic
      val kindForm : tactic
      val kindEq : tactic
      val kindFormUniv : tactic
      val kindEqUniv : tactic
      val eqtpForm : tactic
      val eqtpEq : tactic
      val eqtpFormUniv : tactic
      val eqtpEqUniv : tactic
      val eqtpIntro : tactic
      val eqtpExt : tactic
      val eqtpRefl : tactic
      val eqtpSymm : tactic
      val istpForm : tactic
      val istpEq : tactic
      val istpFormUniv : tactic
      val istpEqUniv : tactic
      val istpIntro : tactic
      val istpExt : tactic
      val subtypeForm : tactic
      val subtypeEq : tactic
      val subtypeFormUniv : tactic
      val subtypeEqUniv : tactic
      val subtypeIntro : tactic
      val subtypeExt : tactic
      val subtypeRefl : tactic
      val subtypeEstablish : tactic
      val sumForm : tactic
      val sumEq : tactic
      val sumFormUniv : tactic
      val sumEqUniv : tactic
      val sumSub : tactic
      val sumIntro1Of : tactic
      val sumIntro1Eq : tactic
      val sumIntro1 : tactic
      val sumIntro2Of : tactic
      val sumIntro2Eq : tactic
      val sumIntro2 : tactic
      val natForm : tactic
      val natEq : tactic
      val natFormUniv : tactic
      val natEqUniv : tactic
      val squashForm : tactic
      val squashEq : tactic
      val squashFormUniv : tactic
      val squashEqUniv : tactic
      val squashIntro : tactic
      val squashIntroOfSquash : tactic
      val squashExt : tactic
      val squashSub : tactic
      val levelForm : tactic
      val levelEq : tactic
      val levelFormUniv : tactic
      val levelEqUniv : tactic
      val lleqForm : tactic
      val lleqEq : tactic
      val lleqFormUniv : tactic
      val lleqEqUniv : tactic
      val integerForm : tactic
      val integerEq : tactic
      val integerFormUniv : tactic
      val integerEqUniv : tactic
      val integerIntroOf : tactic
      val integerIntroEq : tactic
      val symbolForm : tactic
      val symbolEq : tactic
      val symbolFormUniv : tactic
      val symbolEqUniv : tactic
      val symbolIntroOf : tactic
      val symbolIntroEq : tactic

   end


structure RuleTactic :> RULE_TACTIC =
   struct

      structure J = Judgement
      structure T = Term
      structure D = Directory

      type rule = Rule.rule
      type term = Term.term

      open Tactic

      fun andthenBindOn pos tac = 
         andthenOn pos tac
            let
               do (_, dir) = withgoal
            in
               chdir (Directory.bind0 dir)
            end

      fun addbinds i dir =
         if i = 0 then
            dir
         else
            addbinds (i-1) (Directory.bind0 dir)

      fun andthenBindsOn n pos tac =
         let
            do (_, dir) = withgoal
         in
            andthenOn pos tac (chdir (addbinds n dir))
         end

      fun andthenBindsSequel l dir0 i diri =
         (case l of
             [] => []

           | j :: t =>
                if j = 0 then
                   idtac :: andthenBindsSequel t dir0 i diri
                else
                   let
                      val dirj =
                         if j >= i then
                            addbinds (j - i) diri
                         else
                            addbinds j dir0
                   in
                      chdir dirj :: andthenBindsSequel t dir0 j dirj
                   end)

      fun andthenBinds l tac =
         let
            do (_, dir) = withgoal
         in
            andthenl tac (andthenBindsSequel l dir 0 dir)
         end

      fun evar () = Term.evar ()

      fun refine0 f = lift (fn () => refine $ f)
      fun refine1 f = lift (fn () => refine $ f (evar ()))
      fun refine2 f = lift (fn () => refine $ f (evar ()) (evar ()))
      fun refine3 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()))
      fun refine4 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()) (evar ()))
      fun refine5 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))
      fun refine6 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))
      fun refine7 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))
      fun refine8 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))
      fun refine9 f = lift (fn () => refine $ f (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()) (evar ()))

      exception Subterm

      fun subtermSpine i elims =
         (case elims of
             [] =>
                raise Subterm

           | T.App m :: rest =>
                if i = 0 then
                   m
                else
                   subtermSpine (i-1) rest

           | _ :: rest =>
                if i = 0 then
                   raise Subterm
                else
                   subtermSpine (i-1) rest)

      fun subterm l m =
         (case l of
             [] => m

           | i :: rest =>
                (case Normalize.whnf m of
                    T.Elim (m0, spine) =>
                       (case Int.compare i 0 of
                           LESS => raise Subterm

                         | EQUAL => subterm rest m0

                         | GREATER => subterm rest (subtermSpine (i-1) spine))

                  | T.Lam (_, m1) =>
                       if i = 0 then
                          subterm rest m1
                       else
                          raise Subterm

                  | T.Pair (m1, m2) =>
                       if i = 0 then
                          subterm rest m1
                       else if i = 1 then
                          subterm rest m2
                       else
                          raise Subterm

                  | T.Next m1 =>
                       if i = 0 then
                          subterm rest m1
                       else
                          raise Subterm

                  | _ =>
                       raise Subterm))

      fun binder l m =
         try
            (case Normalize.whnf (subterm l m) of
                T.Lam (b, _) => b

              | _ => NONE)
         with
            Subterm => NONE
             

      fun binddir l tac (goal as (jud, dir)) fk sk =
         tac (Directory.bindVary dir (binder l (J.concl jud))) goal fk sk


                              

      val forallForm =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine2 Rule.forallForm)
               (chdir dir)
         end

      val forallEq =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine4 Rule.forallEq)
               (chdir dir)
         end

      val forallFormUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine3 Rule.forallFormUniv)
               (chdir dir)
         end

      val forallEqUniv =
         let
            do dir = binddir [3, 2]
         in
            andthenOn 1
               (refine5 Rule.forallEqUniv)
               (chdir dir)
         end

      val forallSub =
         let
            do dir1 = binddir [1, 2]
            do dir2 = binddir [2, 2]
         in
            andthenl (refine4 Rule.forallSub)
               [idtac, chdir dir2, chdir dir1]
         end

      val forallIntroOf =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1 
               (refine3 Rule.forallIntroOf)
               (chdir dir)
         end

      val forallIntroEq =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1 
               (refine4 Rule.forallIntroEq)
               (chdir dir)
         end

      val forallIntro =
         let
            do dir = binddir [2]
         in
            andthenOn 1 
               (refine2 Rule.forallIntro)
               (chdir dir)
         end

      val arrowForm = andthenBindOn 1 $ refine2 Rule.arrowForm
      val arrowEq = andthenBindOn 1 $ refine4 Rule.arrowEq
      val arrowFormUniv = andthenBindOn 1 $ refine3 Rule.arrowFormUniv
      val arrowEqUniv = andthenBindOn 1 $ refine5 Rule.arrowEqUniv
      val arrowSub = refine4 Rule.arrowSub

      val arrowForallEq =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine4 Rule.arrowForallEq)
               (chdir dir)
         end

      val arrowForallEqUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine5 Rule.arrowForallEqUniv)
               (chdir dir)
         end

      val arrowForallSub =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine4 Rule.arrowForallSub)
               (chdir dir)
         end

      val forallArrowSub =
         let
            do dir = binddir [1, 2]
         in
            andthenl
               (refine4 Rule.forallArrowSub)
               [idtac, chdir dir, chdir dir]
         end

      val arrowIntroOf =
         let
            do dir = binddir [2]
         in
            andthenOn 1
               (refine3 Rule.arrowIntroOf)
               (chdir dir)
         end

      val arrowIntroEq =
         let
            do dir = binddir [2]
         in
            andthenOn 1
               (refine4 Rule.arrowIntroEq)
               (chdir dir)
         end

      val arrowIntro = andthenBindOn 1 $ refine2 Rule.arrowIntro

      val tarrowKindEq = refine5 Rule.tarrowKindEq
      val tarrowEq = refine4 Rule.tarrowEq
      val tarrowKind = refine3 Rule.tarrowKind
      val tarrowForm = refine2 Rule.tarrowForm
      val tarrowFormUniv = refine3 Rule.tarrowFormUniv
      val tarrowEqUniv = refine5 Rule.tarrowEqUniv
      val tarrowArrowEq = refine4 Rule.tarrowArrowEq
      val tarrowArrowEqUniv = refine5 Rule.tarrowArrowEqUniv

      val tarrowForallEq =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine4 Rule.tarrowForallEq)
               (chdir dir)
         end

      val tarrowForallEqUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine5 Rule.tarrowForallEqUniv)
               (chdir dir)
         end

      val tarrowIntroOf =
         let
            do dir = binddir [2]
         in
            andthenOn 2
               (refine3 Rule.tarrowIntroOf)
               (chdir dir)
         end

      val karrowKind = refine3 Rule.karrowKind
      val karrowKindEq = refine5 Rule.karrowKindEq
      val karrowForm = refine2 Rule.karrowForm
      val karrowEq = refine4 Rule.karrowEq
      val karrowFormUniv = refine3 Rule.karrowFormUniv
      val karrowEqUniv = refine5 Rule.karrowEqUniv
      val karrowArrowEq = refine4 Rule.karrowArrowEq
      val karrowArrowEqUniv = refine5 Rule.karrowArrowEqUniv

      val karrowForallEq =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine4 Rule.karrowForallEq)
               (chdir dir)
         end

      val karrowForallEqUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine5 Rule.karrowForallEqUniv)
               (chdir dir)
         end

      val karrowIntroOf =
         let
            do dir = binddir [2]
         in
            andthenOn 2
               (refine3 Rule.karrowIntroOf)
               (chdir dir)
         end

      val intersectForm =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine2 Rule.intersectForm)
               (chdir dir)
         end

      val intersectEq =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine4 Rule.intersectEq)
               (chdir dir)
         end

      val intersectFormUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine3 Rule.intersectFormUniv)
               (chdir dir)
         end

      val intersectEqUniv =
         let
            do dir = binddir [3, 2]
         in
            andthenOn 1
               (refine5 Rule.intersectEqUniv)
               (chdir dir)
         end

      val intersectIntroOf =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine3 Rule.intersectIntroOf)
               (chdir dir)
         end

      val intersectIntroEq =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine4 Rule.intersectIntroEq)
               (chdir dir)
         end

      val intersectIntro =
         let
            do dir = binddir [2]
         in
            andthenOn 1 
               (refine2 Rule.intersectIntro)
               (chdir dir)
         end

      val guardForm = andthenBindOn 1 $ refine2 Rule.guardForm
      val guardEq = andthenBindOn 1 $ refine4 Rule.guardEq
      val guardFormUniv = andthenBindOn 1 $ refine3 Rule.guardFormUniv
      val guardEqUniv = andthenBindOn 1 $ refine5 Rule.guardEqUniv
      val guardIntroOf = andthenBindOn 1 $ refine3 Rule.guardIntroOf
      val guardIntroEq = andthenBindOn 1 $ refine4 Rule.guardIntroEq
      val guardIntro = andthenBindOn 1 $ refine2 Rule.guardIntro
      val guardElimOf = refine3 Rule.guardElimOf
      val guardElimEq = refine4 Rule.guardElimEq
      val guardSatEq = refine2 Rule.guardSatEq

      val foralltpForm =
         let
            do dir = binddir [1, 1]
         in
            andthen
               (refine1 Rule.foralltpForm)
               (chdir dir)
         end

      val foralltpEq =
         let
            do dir = binddir [2, 1]
         in
            andthen
               (refine2 Rule.foralltpEq)
               (chdir dir)
         end

      val foralltpIntroOf =
         let
            do dir = binddir [1, 1]
         in
            andthen
               (refine2 Rule.foralltpIntroOf)
               (chdir dir)
         end

      val foralltpIntroEq =
         let
            do dir = binddir [1, 1]
         in
            andthen
               (refine3 Rule.foralltpIntroEq)
               (chdir dir)
         end

      val foralltpIntro =
         let
            do dir = binddir [1]
         in
            andthen
               (refine1 Rule.foralltpIntro)
               (chdir dir)
         end

      val existsForm =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine2 Rule.existsForm)
               (chdir dir)
         end

      val existsEq =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine4 Rule.existsEq)
               (chdir dir)
         end

      val existsFormUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine3 Rule.existsFormUniv)
               (chdir dir)
         end

      val existsEqUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine5 Rule.existsEqUniv)
               (chdir dir)
         end

      val existsSub =
         let
            do dir1 = binddir [1, 2]
            do dir2 = binddir [2, 2]
         in
            andthenl (refine4 Rule.existsSub)
               [idtac, chdir dir1, chdir dir2]
         end

      val existsIntroOf =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 0
               (refine4 Rule.existsIntroOf)
               (chdir dir)
         end

      val existsIntroEq =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 0
               (refine6 Rule.existsIntroEq)
               (chdir dir)
         end

      val existsIntro =
         let
            do dir = binddir [2]
         in
            andthenOn 0
               (refine3 Rule.existsIntro)
               (chdir dir)
         end

      val prodKind = refine3 Rule.prodKind
      val prodKindEq = refine5 Rule.prodKindEq
      val prodEq = refine4 Rule.prodEq
      val prodForm = refine2 Rule.prodForm
      val prodFormUniv = refine3 Rule.prodFormUniv
      val prodEqUniv = refine5 Rule.prodEqUniv
      val prodExistsEq = refine4 Rule.prodExistsEq
      val prodExistsEqUniv = refine5 Rule.prodExistsEqUniv
      val prodSub = refine4 Rule.prodSub

      val prodExistsSub =
         let
            do dir = binddir [2, 2]
         in
            andthenl
               (refine4 Rule.prodExistsSub)
               [idtac, chdir dir, idtac, chdir dir]
         end

      val existsProdSub =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine4 Rule.existsProdSub)
               (chdir dir)
         end

      val prodIntroOf = refine4 Rule.prodIntroOf
      val prodIntroEq = refine6 Rule.prodIntroEq
      val prodIntro = refine2 Rule.prodIntro

      val futureKind = refine2 Rule.futureKind
      val futureKindEq = refine3 Rule.futureKindEq
      val futureEq = refine2 Rule.futureEq
      val futureForm = refine1 Rule.futureForm
      val futureFormUniv = refine2 Rule.futureFormUniv
      val futureEqUniv = refine3 Rule.futureEqUniv
      val futureSub = refine2 Rule.futureSub
      val futureIntroOf = refine2 Rule.futureIntroOf
      val futureIntroEq = refine3 Rule.futureIntroEq
      val futureIntro = refine1 Rule.futureIntro

      val setForm =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine2 Rule.setForm)
               (chdir dir)
         end

      val setEq =
         let
            do dir = binddir [1, 2]
            do dir' = binddir [2, 2]
         in
            refine4 Rule.setEq
            >>> [idtac, chdir dir, chdir dir', chdir (D.bind0 dir), chdir (D.bind0 dir')]
         end

      val setFormUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine3 Rule.setFormUniv)
               (chdir dir)
         end

      val setEqUniv =
         let
            do dir = binddir [2, 2]
            do dir' = binddir [3, 2]
         in
            refine5 Rule.setEqUniv
            >>> [idtac, chdir dir, chdir dir', chdir (D.bind0 dir), chdir (D.bind0 dir')]
         end

      val setIntroOfSquash =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 0
               (refine3 Rule.setIntroOfSquash)
               (chdir dir)
         end

      val setSubElim = 
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine3 Rule.setSubElim)
               (chdir dir)
         end

      val isetForm =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine2 Rule.isetForm)
               (chdir dir)
         end

      val isetEq =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine4 Rule.isetEq)
               (chdir dir)
         end

      val isetFormUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine3 Rule.isetFormUniv)
               (chdir dir)
         end

      val isetEqUniv =
         let
            do dir = binddir [2, 2]
         in
            andthenOn 1
               (refine5 Rule.isetEqUniv)
               (chdir dir)
         end

      val isetSubElim = 
         let
            do dir = binddir [1, 2]
         in
            andthenOn 1
               (refine3 Rule.isetSubElim)
               (chdir dir)
         end

      val isetIntroOfSquash =
         let
            do dir = binddir [1, 2]
         in
            andthenOn 0
               (refine3 Rule.isetIntroOfSquash)
               (chdir dir)
         end

      val squashIntroOfSquash = refine1 Rule.squashIntroOfSquash

      val quotientForm =
         let
            do (jud, dir) = withgoal
            val a = J.concl jud
            val x = binder [1, 2] a
            val y = binder [1, 2, 0] a

            val dir' = D.bindVary (D.bindVary dir x) y
            val dir'' = D.bind0 dir'
            val dir''' = D.bind0 (D.bind0 dir'')
         in
            refine2 Rule.quotientForm
            >>> [idtac,
                 chdir dir',
                 chdir dir'',
                 chdir dir''']
         end

      val quotientEq =
         let
            do (jud, dir) = withgoal
            val a = J.concl jud
            val x = binder [1, 2] a
            val y = binder [1, 2, 0] a

            val dir' = D.bindVary (D.bindVary dir x) y
            val dir'' = D.bind0 dir'
            val dir''' = D.bind0 (D.bind0 dir'')
         in
            refine4 Rule.quotientEq
            >>> [idtac,
                 chdir dir',
                 chdir dir',
                 chdir dir'',
                 chdir dir'',
                 chdir dir'',
                 chdir dir''']
         end
            
      val quotientFormUniv =
         let
            do (jud, dir) = withgoal
            val a = J.concl jud
            val x = binder [2, 2] a
            val y = binder [2, 2, 0] a

            val dir' = D.bindVary (D.bindVary dir x) y
            val dir'' = D.bind0 dir'
            val dir''' = D.bind0 (D.bind0 dir'')
         in
            refine3 Rule.quotientFormUniv
            >>> [idtac,
                 chdir dir',
                 chdir dir'',
                 chdir dir''']
         end

      val quotientEqUniv =
         let
            do (jud, dir) = withgoal
            val a = J.concl jud
            val x = binder [1, 2] a 
            val y = binder [1, 2, 0] a

            val dir' = D.bindVary (D.bindVary dir x) y
            val dir'' = D.bind0 dir'
            val dir''' = D.bind0 (D.bind0 dir'')
         in
            refine5 Rule.quotientEqUniv
            >>> [idtac,
                 chdir dir',
                 chdir dir',
                 chdir dir'',
                 chdir dir'',
                 chdir dir'',
                 chdir dir''']
         end
            
      val quotientIntroOf = refine3 Rule.quotientIntroOf

      val quotientIntroEq = refine4 Rule.quotientIntroEq

      val recKind =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 1
               (refine2 Rule.recKind)
               (chdir dir)
         end

      val recKindEq =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 1
               (refine3 Rule.recKindEq)
               (chdir dir)
         end

      val recForm =
         let
            do dir = binddir [1, 1]
         in
            andthen
               (refine1 Rule.recForm)
               (chdir dir)
         end

      val recEq =
         let
            do dir = binddir [1, 1]
         in
            andthen
               (refine2 Rule.recEq)
               (chdir dir)
         end

      val recFormUniv =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 1
               (refine2 Rule.recFormUniv)
               (chdir dir)
         end

      val recEqUniv =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 1
               (refine3  Rule.recEqUniv)
               (chdir dir)
         end

      val recUnroll =
         let
            do dir = binddir [1, 1]
         in
            andthen
               (refine1 Rule.recUnroll)
               (chdir dir)
         end

      val recBisimilar =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 0
               (refine2 Rule.recBisimilar)
               (chdir dir)
         end

      val voidForm = refine0 Rule.voidForm
      val voidEq = refine0 Rule.voidEq
      val voidFormUniv = refine1 Rule.voidFormUniv
      val voidEqUniv = refine1 Rule.voidEqUniv
      val voidElim = refine1 Rule.voidElim
      val voidSub = refine1 Rule.voidSub
      val unitKind = refine1 Rule.unitKind
      val unitKindEq = refine1 Rule.unitKindEq
      val unitForm = refine0 Rule.unitForm
      val unitEq = refine0 Rule.unitEq
      val unitFormUniv = refine1 Rule.unitFormUniv
      val unitEqUniv = refine1 Rule.unitEqUniv
      val unitIntroOf = refine0 Rule.unitIntroOf
      val unitIntro = refine0 Rule.unitIntro
      val unitExt = refine2 Rule.unitExt
      val boolForm = refine0 Rule.boolForm
      val boolEq = refine0 Rule.boolEq
      val boolFormUniv = refine1 Rule.boolFormUniv
      val boolEqUniv = refine1 Rule.boolEqUniv
      val boolIntro1Of = refine0 Rule.boolIntro1Of
      val boolIntro2Of = refine0 Rule.boolIntro2Of

      val muForm =
         let
            do dir = binddir [1, 1]
         in
            andthenOn 0
               (refine1 Rule.muForm)
               (chdir dir)
         end

      val muEq =
         let
            do dir = binddir [1, 1]
         in
            andthenOn 0
               (refine2 Rule.muEq)
               (chdir dir)
         end

      val muFormUniv =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 1
               (refine2 Rule.muFormUniv)
               (chdir dir)
         end

      val muEqUniv =
         let
            do dir = binddir [2, 1]
         in
            andthenOn 1
               (refine3 Rule.muEqUniv)
               (chdir dir)
         end

      val muUnroll =
         let
            do dir = binddir [1, 1]
         in
            andthenOn 0
               (refine1 Rule.muUnroll)
               (chdir dir)
         end

      val checkPositive = refine0 Rule.checkPositive
      val checkNegative = refine0 Rule.checkNegative

      val iforallForm =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1
               (refine3 Rule.iforallForm)
               (chdir dir)
         end

      val iforallEq =
         let
            do dir = binddir [2, 3]
         in
            andthenOn 1
               (refine5 Rule.iforallEq)
               (chdir dir)
         end

      val iforallFormUniv =
         let
            do dir = binddir [2, 3]
         in
            andthenOn 2
               (refine4 Rule.iforallFormUniv)
               (chdir dir)
         end

      val iforallEqUniv =
         let
            do dir = binddir [3, 3]
         in
            andthenOn 2
               (refine6 Rule.iforallEqUniv)
               (chdir dir)
         end

      val iforallIntroOf =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1 
               (refine4 Rule.iforallIntroOf)
               (chdir dir)
         end

      val iforallIntroEq =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1 
               (refine5 Rule.iforallIntroEq)
               (chdir dir)
         end

      val iforallIntro =
         let
            do dir = binddir [3]
         in
            andthenOn 1 
               (refine3 Rule.iforallIntro)
               (chdir dir)
         end

      val iexistsForm =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1
               (refine3 Rule.iexistsForm)
               (chdir dir)
         end

      val iexistsEq =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1
               (refine5 Rule.iexistsEq)
               (chdir dir)
         end

      val iexistsFormUniv =
         let
            do dir = binddir [2, 3]
         in
            andthenOn 2
               (refine4 Rule.iexistsFormUniv)
               (chdir dir)
         end

      val iexistsEqUniv =
         let
            do dir = binddir [2, 3]
         in
            andthenOn 2
               (refine6 Rule.iexistsEqUniv)
               (chdir dir)
         end

      val iexistsIntroOf =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1
               (refine5 Rule.iexistsIntroOf)
               (chdir dir)
         end

      val iexistsIntroEq =
         let
            do dir = binddir [1, 3]
         in
            andthenOn 1
               (refine6 Rule.iexistsIntroEq)
               (chdir dir)
         end

      val iexistsIntro =
         let
            do dir = binddir [3]
         in
            andthenOn 1
               (refine4 Rule.iexistsIntro)
               (chdir dir)
         end

      val eqForm = refine3 Rule.eqForm
      val eqEq = refine6 Rule.eqEq
      val eqFormUniv = refine4 Rule.eqFormUniv
      val eqEqUniv = refine7 Rule.eqEqUniv
      val eqIntro = refine3 Rule.eqIntro
      val eqExt = refine5 Rule.eqExt
      val eqRefl = refine2 Rule.eqRefl
      val eqSymm = refine3 Rule.eqSymm
      val ofForm = refine2 Rule.ofForm
      val ofEq = refine4 Rule.ofEq
      val ofFormUniv = refine3 Rule.ofFormUniv
      val ofEqUniv = refine5 Rule.ofEqUniv
      val ofIntro = refine2 Rule.ofIntro
      val ofExt = refine4 Rule.ofExt
      val univKind = refine2 Rule.univKind
      val univKindEq = refine3 Rule.univKindEq
      val univForm = refine1 Rule.univForm
      val univEq = refine2 Rule.univEq
      val univFormUniv = refine2 Rule.univFormUniv
      val univEqUniv = refine3 Rule.univEqUniv
      val univSub = refine2 Rule.univSub
      val kindForm = refine1 Rule.kindForm
      val kindEq = refine2 Rule.kindEq
      val kindFormUniv = refine2 Rule.kindFormUniv
      val kindEqUniv = refine3 Rule.kindEqUniv
      val eqtpForm = refine2 Rule.eqtpForm
      val eqtpEq = refine4 Rule.eqtpEq
      val eqtpFormUniv = refine3 Rule.eqtpFormUniv
      val eqtpEqUniv = refine5 Rule.eqtpEqUniv
      val eqtpIntro = refine2 Rule.eqtpIntro
      val eqtpExt = refine4 Rule.eqtpExt
      val eqtpRefl = refine1 Rule.eqtpRefl
      val eqtpSymm = refine2 Rule.eqtpSymm
      val istpForm = refine1 Rule.istpForm
      val istpEq = refine2 Rule.istpEq
      val istpFormUniv = refine2 Rule.istpFormUniv
      val istpEqUniv = refine3 Rule.istpEqUniv
      val istpIntro = refine1 Rule.istpIntro
      val istpExt = refine3 Rule.istpExt
      val subtypeForm = refine2 Rule.subtypeForm
      val subtypeEq = refine4 Rule.subtypeEq
      val subtypeFormUniv = refine3 Rule.subtypeFormUniv
      val subtypeEqUniv = refine5 Rule.subtypeEqUniv
      val subtypeIntro = refine2 Rule.subtypeIntro
      val subtypeExt = refine4 Rule.subtypeExt
      val subtypeEstablish = andthenBindOn 2 $ refine2 Rule.subtypeEstablish
      val subtypeRefl = refine1 Rule.subtypeRefl
      val sumForm = refine2 Rule.sumForm
      val sumEq = refine4 Rule.sumEq
      val sumFormUniv = refine3 Rule.sumFormUniv
      val sumEqUniv = refine5 Rule.sumEqUniv
      val sumSub = refine4 Rule.sumSub
      val sumIntro1Of = refine3 Rule.sumIntro1Of
      val sumIntro1Eq = refine4 Rule.sumIntro1Eq
      val sumIntro1 = refine2 Rule.sumIntro1
      val sumIntro2Of = refine3 Rule.sumIntro2Of
      val sumIntro2Eq = refine4 Rule.sumIntro2Eq
      val sumIntro2 = refine2 Rule.sumIntro2
      val natForm = refine0 Rule.natForm
      val natEq = refine0 Rule.natEq
      val natFormUniv = refine1 Rule.natFormUniv
      val natEqUniv = refine1 Rule.natEqUniv
      val levelForm = refine0 Rule.levelForm
      val levelEq = refine0 Rule.levelEq
      val levelFormUniv = refine1 Rule.levelFormUniv
      val levelEqUniv = refine1 Rule.levelEqUniv
      val lleqForm = refine2 Rule.lleqForm
      val lleqEq = refine4 Rule.lleqEq
      val lleqFormUniv = refine3 Rule.lleqFormUniv
      val lleqEqUniv = refine5 Rule.lleqEqUniv
      val squashForm = refine1 Rule.squashForm
      val squashFormUniv = refine2 Rule.squashFormUniv

      val squashEq =
         let
            do (_, dir) = withgoal
            val dir' = D.bind0 dir
         in
            refine2 Rule.squashEq
            >>> [idtac, idtac, chdir dir', chdir dir']
         end

      val squashEqUniv =
         let
            do (_, dir) = withgoal
            val dir' = D.bind0 dir
         in
            refine3 Rule.squashEqUniv
            >>> [idtac, idtac, chdir dir', chdir dir']
         end

      val squashIntro = refine1 Rule.squashIntro
      val squashExt = refine3 Rule.squashExt
      val squashSub = refine2 Rule.squashSub

      val integerForm = refine0 Rule.integerForm
      val integerEq = refine0 Rule.integerEq
      val integerFormUniv = refine1 Rule.integerFormUniv
      val integerEqUniv = refine1 Rule.integerEqUniv
      val integerIntroOf = refine0 Rule.integerIntroOf
      val integerIntroEq = refine0 Rule.integerIntroEq

      val symbolForm = refine0 Rule.symbolForm
      val symbolEq = refine0 Rule.symbolEq
      val symbolFormUniv = refine1 Rule.symbolFormUniv
      val symbolEqUniv = refine1 Rule.symbolEqUniv
      val symbolIntroOf = refine0 Rule.symbolIntroOf
      val symbolIntroEq = refine0 Rule.symbolIntroEq

   end
