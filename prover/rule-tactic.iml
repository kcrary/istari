(* Tactics corresponding to primitive rules.

   - Parameters that cannot be inferred from the conclusion are taken as arguments.
     The comment indicates those arguments and their order.

   - Unlike the primitive rules, these manage the directory properly.


   This file is generated by Rulegen.
*)

signature RULE_TACTIC =
   sig

      type tactic = Tactic.tactic
      type term = Term.term

      type tactic1 = term -> tactic
      type tactic2 = term -> tactic1
      type tactic3 = term -> tactic2
      type tactic4 = term -> tactic3
      type tactic5 = term -> tactic4
      type tactic6 = term -> tactic5
      type tactic7 = term -> tactic6
      type tactic8 = term -> tactic7

      val binder : int list -> Term.term -> Term.binder

      val forallForm : tactic
      val forallEq : tactic
      val forallFormUniv : tactic
      val forallEqUniv : tactic
      val forallSub : tactic
      val forallIntroOf : tactic
      val forallIntroEq : tactic
      val forallIntro : tactic
      val forallElimOf : tactic4                  (* A B M P *)
      val forallElimEq : tactic6                  (* A B M N P Q *)
      val forallElim : tactic3                    (* A B P *)
      val forallEta : tactic
      val forallExt : tactic
      val forallOfExt : tactic2                   (* A' B' *)
      val forallFormInv1 : tactic1                (* B *)
      val forallFormInv2 : tactic3                (* A B M *)
      val arrowForm : tactic
      val arrowEq : tactic
      val arrowFormUniv : tactic
      val arrowEqUniv : tactic
      val arrowForallEq : tactic
      val arrowForallEqUniv : tactic
      val arrowSub : tactic
      val arrowForallSub : tactic
      val forallArrowSub : tactic
      val arrowIntroOf : tactic
      val arrowIntroEq : tactic
      val arrowIntro : tactic
      val arrowElimOf : tactic3                   (* A M P *)
      val arrowElimEq : tactic5                   (* A M N P Q *)
      val arrowElim : tactic1                     (* A *)
      val arrowEta : tactic
      val arrowExt : tactic
      val arrowOfExt : tactic2                    (* A' B' *)
      val arrowFormInv1 : tactic1                 (* B *)
      val arrowFormInv2 : tactic2                 (* A M *)
      val tarrowKind : tactic
      val tarrowKindEq : tactic
      val tarrowForm : tactic
      val tarrowEq : tactic
      val tarrowFormUniv : tactic
      val tarrowEqUniv : tactic
      val tarrowArrowEq : tactic
      val tarrowArrowEqUniv : tactic
      val tarrowForallEq : tactic
      val tarrowForallEqUniv : tactic
      val tarrowIntroOf : tactic
      val tarrowIntroEq : tactic
      val tarrowIntro : tactic
      val tarrowElimOf : tactic3                  (* A M P *)
      val tarrowElimEq : tactic5                  (* A M N P Q *)
      val tarrowElim : tactic1                    (* A *)
      val tarrowEta : tactic
      val tarrowExt : tactic
      val tarrowOfExt : tactic2                   (* A' B' *)
      val karrowKind : tactic
      val karrowKindEq : tactic
      val karrowForm : tactic
      val karrowEq : tactic
      val karrowFormUniv : tactic
      val karrowEqUniv : tactic
      val karrowArrowEq : tactic
      val karrowArrowEqUniv : tactic
      val karrowForallEq : tactic
      val karrowForallEqUniv : tactic
      val karrowIntroOf : tactic
      val karrowIntroEq : tactic
      val karrowIntro : tactic
      val karrowElimOf : tactic3                  (* A M P *)
      val karrowElimEq : tactic5                  (* A M N P Q *)
      val karrowElim : tactic1                    (* A *)
      val karrowEta : tactic
      val karrowExt : tactic
      val karrowOfExt : tactic2                   (* A' B' *)
      val intersectForm : tactic
      val intersectEq : tactic
      val intersectFormUniv : tactic
      val intersectEqUniv : tactic
      val intersectSub : tactic
      val intersectIntroOf : tactic
      val intersectIntroEq : tactic
      val intersectIntro : tactic
      val intersectElimOf : tactic3               (* A B P *)
      val intersectElimEq : tactic3               (* A B P *)
      val intersectElim : tactic3                 (* A B P *)
      val intersectFormInv1 : tactic1             (* B *)
      val intersectFormInv2 : tactic3             (* A B M *)
      val guardForm : tactic
      val guardEq : tactic
      val guardFormUniv : tactic
      val guardEqUniv : tactic
      val guardIntroOf : tactic
      val guardIntroEq : tactic
      val guardIntro : tactic
      val guardElimOf : tactic1                   (* A *)
      val guardElimEq : tactic1                   (* A *)
      val guardElim : tactic1                     (* A *)
      val guardSatEq : tactic
      val guardSub : tactic
      val guardSubIntro : tactic
      val coguardForm : tactic
      val coguardEq : tactic
      val coguardFormUniv : tactic
      val coguardEqUniv : tactic
      val coguardIntroEq : tactic
      val coguardIntroOf : tactic
      val coguardIntroOfSquash : tactic
      val coguardIntro : tactic
      val coguardElim1 : tactic1                  (* B *)
      val coguardElim2Eq : tactic1                (* A *)
      val coguardElim2Of : tactic1                (* A *)
      val coguardElim2 : tactic1                  (* A *)
      val coguardLeft : int -> tactic
      val coguardSatEq : tactic
      val coguardSub : tactic
      val coguardSubElim : tactic
      val existsForm : tactic
      val existsEq : tactic
      val existsFormUniv : tactic
      val existsEqUniv : tactic
      val existsSub : tactic
      val existsIntroOf : tactic
      val existsIntroEq : tactic
      val existsIntro : tactic1                   (* M *)
      val existsElim1Of : tactic1                 (* B *)
      val existsElim1Eq : tactic1                 (* B *)
      val existsElim1 : tactic1                   (* B *)
      val existsElim2Of : tactic2                 (* A B *)
      val existsElim2Eq : tactic2                 (* A B *)
      val existsEta : tactic
      val existsExt : tactic
      val existsLeft : int -> tactic
      val existsFormInv1 : tactic1                (* B *)
      val existsFormInv2 : tactic3                (* A B M *)
      val existsFormInv2Eq : tactic4              (* A B M N *)
      val prodKind : tactic
      val prodKindEq : tactic
      val prodForm : tactic
      val prodEq : tactic
      val prodFormUniv : tactic
      val prodEqUniv : tactic
      val prodExistsEq : tactic2                  (* A' B' *)
      val prodExistsEqUniv : tactic2              (* A' B' *)
      val prodSub : tactic
      val prodExistsSub : tactic
      val existsProdSub : tactic
      val prodIntroOf : tactic
      val prodIntroEq : tactic
      val prodIntro : tactic
      val prodElim1Of : tactic1                   (* B *)
      val prodElim1Eq : tactic1                   (* B *)
      val prodElim1 : tactic1                     (* B *)
      val prodElim2Of : tactic1                   (* A *)
      val prodElim2Eq : tactic1                   (* A *)
      val prodElim2 : tactic1                     (* A *)
      val prodEta : tactic
      val prodExt : tactic
      val prodLeft : int -> tactic
      val prodFormInv1 : tactic1                  (* B *)
      val prodFormInv2 : tactic1                  (* A *)
      val unionForm : tactic
      val unionEq : tactic
      val unionFormUniv : tactic
      val unionEqUniv : tactic
      val unionSub : tactic
      val unionIntroOf : tactic1                  (* M *)
      val unionIntroEq : tactic1                  (* M *)
      val unionIntro : tactic1                    (* M *)
      val unionElimOf : tactic4                   (* A B M P *)
      val unionElimEq : tactic6                   (* A B M N P Q *)
      val unionElim : tactic3                     (* A B M *)
      val unionElimOfDep : tactic5                (* A B C M P *)
      val unionElimEqDep : tactic7                (* A B C M N P Q *)
      val unionElimDep : tactic4                  (* A B C M *)
      val unionElimIstype : tactic4               (* A B C M *)
      val unionElimEqtype : tactic6               (* A B C D M N *)
      val sumForm : tactic
      val sumEq : tactic
      val sumFormUniv : tactic
      val sumEqUniv : tactic
      val sumSub : tactic
      val sumIntro1Of : tactic
      val sumIntro1Eq : tactic
      val sumIntro1 : tactic
      val sumIntro2Of : tactic
      val sumIntro2Eq : tactic
      val sumIntro2 : tactic
      val sumElimOf : tactic3                     (* A B C *)
      val sumElimOfNondep : tactic2               (* A B *)
      val sumElimEq : tactic3                     (* A B C *)
      val sumElim : tactic4                       (* A B C M *)
      val sumElimNondep : tactic2                 (* A B *)
      val sumElimIstype : tactic2                 (* A B *)
      val sumElimEqtype : tactic2                 (* A B *)
      val sumContradiction : tactic4              (* A B M N *)
      val sumInjection1 : tactic1                 (* B *)
      val sumInjection2 : tactic1                 (* A *)
      val sum_caseType : tactic
      val sumFormInv1 : tactic1                   (* B *)
      val sumFormInv2 : tactic1                   (* A *)
      val futureKind : tactic
      val futureKindEq : tactic
      val futureForm : tactic
      val futureEq : tactic
      val futureFormUniv : tactic
      val futureEqUniv : tactic
      val futureSub : tactic
      val futureIntroOf : tactic
      val futureIntroEq : tactic
      val futureIntro : tactic
      val futureElimOf : tactic4                  (* A B M P *)
      val futureElimOfLetnext : tactic2           (* A B *)
      val futureElimOfLetnextNondep : tactic1     (* A *)
      val futureElimEq : tactic6                  (* A B M N P Q *)
      val futureElim : tactic3                    (* A B M *)
      val futureElimIstype : tactic3              (* A B M *)
      val futureElimIstypeLetnext : tactic1       (* A *)
      val futureElimEqtype : tactic5              (* A B C M N *)
      val futureEta : tactic
      val futureExt : tactic
      val futureLeft : int -> tactic
      val futureInjection : tactic
      val recKind : tactic
      val recKindEq : tactic
      val recForm : tactic
      val recEq : tactic
      val recFormUniv : tactic
      val recEqUniv : tactic
      val recUnroll : tactic
      val recUnrollUniv : tactic
      val recBisimilar : tactic
      val muForm : tactic
      val muEq : tactic
      val muFormUniv : tactic
      val muEqUniv : tactic
      val muUnroll : tactic
      val muUnrollUniv : tactic1                  (* I *)
      val muInd : tactic3                         (* A B M *)
      val muIndUniv : tactic4                     (* A B I M *)
      val voidForm : tactic
      val voidEq : tactic
      val voidFormUniv : tactic
      val voidEqUniv : tactic
      val voidElim : tactic
      val voidSub : tactic
      val abortType : tactic
      val unitKind : tactic
      val unitKindEq : tactic
      val unitForm : tactic
      val unitEq : tactic
      val unitFormUniv : tactic
      val unitEqUniv : tactic
      val unitIntroOf : tactic
      val unitIntro : tactic
      val unitExt : tactic
      val unitLeft : int -> tactic
      val boolForm : tactic
      val boolEq : tactic
      val boolFormUniv : tactic
      val boolEqUniv : tactic
      val boolIntro1Of : tactic
      val boolIntro2Of : tactic
      val boolElimOf : tactic1                    (* A *)
      val boolElimOfNondep : tactic
      val boolElimEq : tactic1                    (* A *)
      val boolElim : tactic2                      (* A M *)
      val boolElimIstype : tactic
      val boolElimEqtype : tactic
      val boolLeft : int -> tactic
      val boolContradiction : tactic
      val iteType : tactic
      val natForm : tactic
      val natEq : tactic
      val natFormUniv : tactic
      val natEqUniv : tactic
      val natElimEq : tactic1                     (* A *)
      val natElimEqtype : tactic
      val natUnroll : tactic
      val natContradiction : tactic1              (* M *)
      val natInjection : tactic
      val zeroType : tactic
      val succType : tactic
      val univKind : tactic
      val univKindEq : tactic
      val univForm : tactic
      val univEq : tactic
      val univFormUniv : tactic
      val univFormUnivSucc : tactic
      val univEqUniv : tactic
      val univCumulativeOf : tactic1              (* I *)
      val univCumulativeEq : tactic1              (* I *)
      val univCumulativeSuccOf : tactic
      val univSub : tactic
      val univForgetOf : tactic1                  (* I *)
      val univForgetEq : tactic1                  (* I *)
      val univIntroEqtype : tactic
      val univFormInv : tactic
      val kindForm : tactic
      val kindEq : tactic
      val kindFormUniv : tactic
      val kindEqUniv : tactic
      val kindForgetOf : tactic
      val kindForgetEq : tactic
      val kindUnivSub : tactic
      val levelForm : tactic
      val levelEq : tactic
      val levelFormUniv : tactic
      val levelEqUniv : tactic
      val lleqForm : tactic
      val lleqEq : tactic
      val lleqFormUniv : tactic
      val lleqEqUniv : tactic
      val lzeroLevel : tactic
      val lsuccLevel : tactic
      val lsuccEq : tactic
      val lmaxLevel : tactic
      val lmaxEq : tactic
      val lleqRefl : tactic
      val lleqTrans : tactic1                     (* N *)
      val lleqZero : tactic
      val lleqSucc : tactic
      val lleqIncrease : tactic
      val lleqMaxL : tactic
      val lleqMaxR1 : tactic
      val lleqMaxR2 : tactic
      val lleqResp : tactic2                      (* M' N' *)
      val lsuccMaxDistTrans : tactic
      val lzeroType : tactic
      val lsuccType : tactic
      val lmaxType : tactic
      val eqForm : tactic
      val eqEq : tactic
      val eqFormUniv : tactic
      val eqEqUniv : tactic
      val eqIntro : tactic
      val eqElim : tactic1                        (* P *)
      val eqTrivialize : tactic
      val eqExt : tactic
      val eqLeft : int -> tactic
      val eqRefl : tactic
      val eqSymm : tactic
      val eqTrans : tactic1                       (* N *)
      val eqFormInv1 : tactic2                    (* M N *)
      val eqFormInv2 : tactic1                    (* N *)
      val eqFormInv3 : tactic1                    (* M *)
      val ofForm : tactic
      val ofEq : tactic
      val ofFormUniv : tactic
      val ofEqUniv : tactic
      val ofIntro : tactic
      val ofElim : tactic1                        (* P *)
      val ofTrivialize : tactic
      val ofExt : tactic
      val ofLeft : int -> tactic
      val ofEquand1 : tactic1                     (* N *)
      val ofEquand2 : tactic1                     (* M *)
      val eqtpForm : tactic
      val eqtpEq : tactic
      val eqtpFormUniv : tactic
      val eqtpEqUniv : tactic
      val eqtpIntro : tactic
      val eqtpElim : tactic1                      (* P *)
      val eqtpExt : tactic
      val eqtpLeft : int -> tactic
      val eqtpFunct : tactic4                     (* A B M N *)
      val eqtpFunctType : tactic3                 (* A B B' *)
      val equivalenceOf : tactic1                 (* A *)
      val equivalenceEq : tactic1                 (* A *)
      val equivalence : tactic1                   (* A *)
      val equivalenceLeft : int -> tactic1        (* B *)
      val equivalenceLeftAlt : int -> tactic1     (* B *)
      val eqtpRefl : tactic
      val eqtpSymm : tactic
      val eqtpTrans : tactic1                     (* B *)
      val istpForm : tactic
      val istpEq : tactic
      val istpFormUniv : tactic
      val istpEqUniv : tactic
      val istpIntro : tactic
      val istpElim : tactic1                      (* P *)
      val istpExt : tactic
      val istpLeft : int -> tactic
      val inhabitedForm : tactic
      val subtypeForm : tactic
      val subtypeEq : tactic
      val subtypeFormUniv : tactic
      val subtypeEqUniv : tactic
      val subtypeIntro : tactic
      val subtypeElim : tactic1                   (* P *)
      val subtypeExt : tactic
      val subtypeLeft : int -> tactic
      val subtypeEstablish : tactic
      val subsumptionOf : tactic1                 (* A *)
      val subsumptionEq : tactic1                 (* A *)
      val subsumption : tactic1                   (* A *)
      val subsumptionAlt : tactic1                (* A *)
      val subsumptionLeft : int -> tactic1        (* B *)
      val subsumptionLeftAlt : int -> tactic1     (* B *)
      val subsumptionLast : int -> tactic2        (* B C *)
      val tighten : int -> tactic1                (* B *)
      val subtypeRefl : tactic
      val subtypeReflEqtype : tactic
      val subtypeTrans : tactic1                  (* B *)
      val subtypeIstp1 : tactic1                  (* B *)
      val subtypeIstp2 : tactic1                  (* A *)
      val eeqtpForm : tactic
      val eeqtpEq : tactic
      val eeqtpFormUniv : tactic
      val eeqtpEqUniv : tactic
      val setForm : tactic
      val setEq : tactic
      val setFormUniv : tactic
      val setEqUniv : tactic
      val setWeakenOf : tactic1                   (* B *)
      val setWeakenEq : tactic1                   (* B *)
      val setWeaken : tactic1                     (* B *)
      val setIntroOf : tactic
      val setIntroEq : tactic
      val setIntro : tactic1                      (* M *)
      val setIntroOfSquash : tactic
      val squashIntroOfSquash : tactic
      val setElim : tactic3                       (* A B M *)
      val setLeft : int -> tactic
      val setSquash : tactic
      val setFormInv : tactic1                    (* B *)
      val setSubElim : tactic
      val isetForm : tactic
      val isetEq : tactic
      val isetFormUniv : tactic
      val isetEqUniv : tactic
      val isetWeakenOf : tactic1                  (* B *)
      val isetWeakenEq : tactic1                  (* B *)
      val isetWeaken : tactic1                    (* B *)
      val isetIntroOf : tactic
      val isetIntroEq : tactic
      val isetIntro : tactic1                     (* M *)
      val isetIntroOfSquash : tactic
      val isetElim : tactic3                      (* A B M *)
      val isetLeft : int -> tactic
      val isetFormInv1 : tactic1                  (* B *)
      val isetFormInv2 : tactic3                  (* A B M *)
      val isetSubElim : tactic
      val squashForm : tactic
      val squashEq : tactic
      val squashFormUniv : tactic
      val squashEqUniv : tactic
      val squashIntroOf : tactic
      val squashIntro : tactic
      val squashElim : tactic2                    (* A M *)
      val squashExt : tactic
      val squashLeft : int -> tactic
      val squashSub : tactic
      val quotientForm : tactic
      val quotientEq : tactic
      val quotientFormUniv : tactic
      val quotientEqUniv : tactic
      val quotientIntroOf : tactic
      val quotientIntroEq : tactic
      val quotientElimOf : tactic5                (* A B C M P *)
      val quotientElimEq : tactic7                (* A B C M N P Q *)
      val quotientElimIstype : tactic4            (* A B C M *)
      val quotientElimEqtype : tactic6            (* A B C D M N *)
      val quotientDescent : tactic4               (* A B M N *)
      val quotientLeft : int -> tactic
      val quotientLeftRefl : int -> tactic
      val quotientLeftIstype : int -> tactic
      val quotientLeftEqtype : int -> tactic
      val quotientLeftOf : int -> tactic1         (* C *)
      val quotientLeftEq : int -> tactic1         (* C *)
      val quotientLeftOfDep : int -> tactic
      val quotientLeftEqDep : int -> tactic
      val quotientFormInv : tactic1               (* B *)
      val iforallForm : tactic
      val iforallEq : tactic
      val iforallFormUniv : tactic
      val iforallEqUniv : tactic
      val iforallIntroOf : tactic
      val iforallIntroEq : tactic
      val iforallIntro : tactic
      val iforallElimOf : tactic4                 (* A I K P *)
      val iforallElimEq : tactic4                 (* A I K P *)
      val iforallElim : tactic4                   (* A I K P *)
      val foralltpForm : tactic
      val foralltpEq : tactic
      val foralltpIntroOf : tactic
      val foralltpIntroEq : tactic
      val foralltpIntro : tactic
      val foralltpElimOf : tactic2                (* A B *)
      val foralltpElimEq : tactic2                (* A B *)
      val foralltpElim : tactic2                  (* A B *)
      val iexistsForm : tactic
      val iexistsEq : tactic
      val iexistsFormUniv : tactic
      val iexistsEqUniv : tactic
      val iexistsIntroOf : tactic1                (* B *)
      val iexistsIntroEq : tactic1                (* B *)
      val iexistsIntro : tactic1                  (* B *)
      val iexistsElimOf : tactic5                 (* A I K M P *)
      val iexistsElimEq : tactic7                 (* A I K M N P Q *)
      val iexistsElim : tactic4                   (* A I K M *)
      val iexistsElimOfDep : tactic6              (* A B I K M P *)
      val iexistsElimEqDep : tactic8              (* A B I K M N P Q *)
      val iexistsElimDep : tactic5                (* A B I K M *)
      val iexistsElimIstype : tactic5             (* A B I K M *)
      val iexistsElimEqtype : tactic7             (* A B C I K M N *)
      val substitution : int -> tactic1           (* M *)
      val substitutionSimple : int -> tactic2     (* B M *)
      val generalize : tactic3                    (* A B M *)
      val assert : tactic1                        (* A *)
      val assert' : tactic1                       (* A *)
      val inhabitant : tactic1                    (* M *)
      val letForm : tactic1                       (* A *)
      val accInd : tactic6                        (* A B I M N R *)
      val sequalForm : tactic
      val sequalIntroOf : tactic
      val sequalIntro : tactic
      val sequalTrivialize : tactic
      val sequalExt : tactic
      val sequalLeft : int -> tactic
      val sequalEq : tactic
      val sequalEqtp : tactic
      val sequivalence : tactic1                  (* A *)
      val sequivalenceLeft : int -> tactic1       (* B *)
      val substitutionSyntactic : int -> tactic1  (* M *)
      val sequalSymm : tactic
      val sequalTrans : tactic1                   (* N *)
      val sequalCompat : tactic3                  (* M N P *)
      val partialForm : tactic
      val partialEq : tactic
      val partialFormUniv : tactic
      val partialEqUniv : tactic
      val partialSub : tactic
      val partialStrict : tactic
      val partialStrictConverse : tactic
      val partialIdem : tactic
      val haltsForm : tactic1                     (* A *)
      val haltsEq : tactic1                       (* A *)
      val haltsFormUniv : tactic1                 (* A *)
      val haltsEqUniv : tactic1                   (* A *)
      val partialIntroBottomOf : tactic
      val bottomDiverges : tactic
      val partialExt : tactic
      val partialElimEq : tactic
      val partialElimOf : tactic
      val haltsTrivialize : tactic
      val haltsExt : tactic
      val haltsLeft : int -> tactic
      val fixpointInductionEq : tactic
      val fixpointInductionOf : tactic
      val partialFormInv : tactic
      val seqBind : tactic1                       (* A *)
      val activeApp : tactic3                     (* A M N *)
      val activeAppSeq : tactic2                  (* A N *)
      val appHaltsInv : tactic1                   (* N *)
      val activePi1 : tactic1                     (* A *)
      val activePi1Seq : tactic1                  (* A *)
      val pi1HaltsInv : tactic
      val activePi2 : tactic1                     (* A *)
      val activePi2Seq : tactic1                  (* A *)
      val pi2HaltsInv : tactic
      val prevHaltsInv : tactic
      val activeCase : tactic1                    (* A *)
      val activeCaseSeq : tactic1                 (* A *)
      val caseHaltsInv : tactic2                  (* P R *)
      val seqHaltsSequal : tactic
      val seqHaltsInv : tactic1                   (* N *)
      val totalStrict : tactic
      val voidStrict : tactic
      val unitTotal : tactic
      val unitStrict : tactic
      val boolTotal : tactic
      val boolStrict : tactic
      val forallTotal : tactic2                   (* A B *)
      val forallStrict : tactic
      val arrowTotal : tactic2                    (* A B *)
      val arrowStrict : tactic
      val intersectStrict : tactic
      val existsTotal : tactic2                   (* A B *)
      val existsStrict : tactic
      val prodTotal : tactic2                     (* A B *)
      val prodStrict : tactic
      val sumTotal : tactic2                      (* A B *)
      val sumStrict : tactic
      val futureTotal : tactic1                   (* A *)
      val futureStrict : tactic
      val setStrict : tactic
      val isetStrict : tactic
      val natTotal : tactic
      val natStrict : tactic
      val typeHalts : tactic
      val uptypeForm : tactic
      val uptypeEq : tactic
      val uptypeFormUniv : tactic
      val uptypeEqUniv : tactic
      val uptypeTrivialize : tactic
      val uptypeExt : tactic
      val uptypeLeft : int -> tactic
      val uptypeEeqtp : tactic1                   (* A *)
      val uptypeUnitary : tactic
      val voidUptype : tactic
      val unitUptype : tactic
      val boolUptype : tactic
      val forallUptype : tactic
      val arrowUptype : tactic
      val intersectUptype : tactic
      val existsUptype : tactic
      val prodUptype : tactic
      val sumUptype : tactic
      val futureUptype : tactic
      val eqUptype : tactic
      val ofUptype : tactic
      val eqtpUptype : tactic
      val istpUptype : tactic
      val subtypeUptype : tactic
      val setUptype : tactic
      val isetUptype : tactic
      val muUptype : tactic
      val muUptypeUniv : tactic1                  (* I *)
      val recUptype : tactic
      val recUptypeUniv : tactic1                 (* I *)
      val natUptype : tactic
      val uptypeFormInv : tactic
      val admissForm : tactic
      val admissEq : tactic
      val admissFormUniv : tactic
      val admissEqUniv : tactic
      val admissTrivialize : tactic
      val admissExt : tactic
      val admissLeft : int -> tactic
      val admissEeqtp : tactic1                   (* A *)
      val uptypeAdmiss : tactic
      val partialAdmiss : tactic
      val voidAdmiss : tactic
      val unitAdmiss : tactic
      val boolAdmiss : tactic
      val forallAdmiss : tactic
      val arrowAdmiss : tactic
      val intersectAdmiss : tactic
      val existsAdmissUptype : tactic
      val prodAdmiss : tactic
      val sumAdmiss : tactic
      val futureAdmiss : tactic
      val eqAdmiss : tactic
      val ofAdmiss : tactic
      val eqtpAdmiss : tactic
      val istpAdmiss : tactic
      val subtypeAdmiss : tactic
      val recAdmiss : tactic
      val recAdmissUniv : tactic1                 (* I *)
      val natAdmiss : tactic
      val admissFormInv : tactic
      val partialType : tactic
      val haltsType : tactic
      val admissType : tactic
      val uptypeType : tactic
      val seqType : tactic
      val eeqtpRefl : tactic
      val eeqtpSymm : tactic
      val eeqtpTrans : tactic1                    (* B *)
      val weakenEqtpEeqtp : tactic
      val weakenSubtypeArrow : tactic
      val weakenEeqtpIff : tactic
      val compatGuardEqtp1 : tactic
      val compatSetEqtp0 : tactic
      val forallEeq : tactic
      val existsEeq : tactic
      val arrowEeq : tactic
      val prodEeq : tactic
      val sumEeq : tactic
      val futureEeq : tactic
      val intersectEeq : tactic
      val unionEeq : tactic
      val compatGuardEeq1 : tactic
      val compatSetEeq0 : tactic
      val compatIsetEeq0 : tactic
      val compatIsetIff1 : tactic
      val compatForallSubtype0 : tactic
      val compatForallSubtype1 : tactic
      val compatExistsSubtype0 : tactic
      val compatExistsSubtype1 : tactic
      val compatIntersectSubtype0 : tactic
      val compatIntersectSubtype1 : tactic
      val compatUnionSubtype0 : tactic
      val compatUnionSubtype1 : tactic
      val compatGuardArrow0 : tactic
      val compatGuardSubtype1 : tactic
      val compatSetSubtype0 : tactic
      val compatSetArrow1 : tactic
      val compatIsetSubtype0 : tactic
      val compatIsetArrow1 : tactic
      val compatForallIff1 : tactic
      val compatExistsIff1 : tactic
      val compatArrowIff0 : tactic
      val compatArrowIff1 : tactic
      val compatProdIff0 : tactic
      val compatProdIff1 : tactic
      val compatSumIff0 : tactic
      val compatSumIff1 : tactic
      val compatFutureIff : tactic
      val compatForallArrow1 : tactic
      val compatExistsArrow1 : tactic
      val compatArrowArrow0 : tactic
      val compatArrowArrow1 : tactic
      val compatProdArrow0 : tactic
      val compatProdArrow1 : tactic
      val compatSumArrow0 : tactic
      val compatSumArrow1 : tactic
      val compatFutureArrow : tactic
      val compatForallEntails1 : tactic1          (* B *)
      val compatArrowEntails1 : tactic1           (* B *)
      val compatProdEntails0 : tactic1            (* A *)
      val compatProdEntails1 : tactic1            (* B *)
      val integerForm : tactic
      val integerEq : tactic
      val integerFormUniv : tactic
      val integerEqUniv : tactic
      val integerToDefType : tactic
      val integerFromDefType : tactic
      val integerIsomorphism1 : tactic
      val integerIsomorphism2 : tactic
      val pluszSpec : tactic
      val negzSpec : tactic
      val eqzbSpec : tactic
      val leqzbSpec : tactic
      val timeszSpec : tactic
      val integerTotal : tactic
      val integerStrict : tactic
      val integerUptype : tactic
      val integerAdmiss : tactic
      val integerSequal : tactic
      val symbolForm : tactic
      val symbolEq : tactic
      val symbolFormUniv : tactic
      val symbolEqUniv : tactic
      val symbol_eqbType : tactic
      val symbol_eqbSpec1 : tactic
      val symbol_eqbSpec2 : tactic
      val symbolTotal : tactic
      val symbolStrict : tactic
      val symbolUptype : tactic
      val symbolAdmiss : tactic
      val symbolSequal : tactic

      val sumLeft : int -> tactic
      val checkPositive : tactic
      val checkNegative : tactic
      val integerIntroOf : tactic
      val integerIntroEq : tactic
      val symbolIntroOf : tactic
      val symbolIntroEq : tactic

   end


structure RuleTactic :> RULE_TACTIC =
   struct

      structure J = Judgement
      structure T = Term
      structure D = Directory

      type rule = Rule.rule
      type term = Term.term

      open Tactic

      type tactic1 = term -> tactic
      type tactic2 = term -> tactic1
      type tactic3 = term -> tactic2
      type tactic4 = term -> tactic3
      type tactic5 = term -> tactic4
      type tactic6 = term -> tactic5
      type tactic7 = term -> tactic6
      type tactic8 = term -> tactic7

      exception Subterm

      fun subtermSpine i elims =
         (case elims of
             [] =>
                raise Subterm

           | T.App m :: rest =>
                if i = 0 then
                   m
                else
                   subtermSpine (i-1) rest

           | _ :: rest =>
                if i = 0 then
                   raise Subterm
                else
                   subtermSpine (i-1) rest)

      fun subterm l m =
         (case l of
             [] => m

           | i :: rest =>
                (case Normalize.whnf m of
                    T.Elim (m0, spine) =>
                       (case Int.compare i 0 of
                           LESS => raise Subterm

                         | EQUAL => subterm rest m0

                         | GREATER => subterm rest (subtermSpine (i-1) spine))

                  | T.Lam (_, m1) =>
                       if i = 0 then
                          subterm rest m1
                       else
                          raise Subterm

                  | T.Pair (m1, m2) =>
                       if i = 0 then
                          subterm rest m1
                       else if i = 1 then
                          subterm rest m2
                       else
                          raise Subterm

                  | T.Next m1 =>
                       if i = 0 then
                          subterm rest m1
                       else
                          raise Subterm

                  | _ =>
                       raise Subterm))

      fun binder l m =
         try
            (case Normalize.whnf (subterm l m) of
                T.Lam (b, _) => b

              | _ => NONE)
         with
            Subterm => NONE

      fun rebind left n right set =
         let
            val (l, _) =
               Int.natrecUp
                  (fns _ (l, set) =>
                      let
                         val (sym, set') = D.freshAndBindSet set
                      in
                         (sym :: l, set')
                      end)
                  ([], set)
                  n
         in
            D.binds (D.binds left (List.rev l)) right
         end

      val forallForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val forallEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val forallFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val forallEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val forallSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val forallIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val forallIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val forallIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallIntro (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, ] (J.concl jud), ]),
                ]
         end

      fun forallElimOf xA xB xM xP =
         let
         in
            refine (Rule.forallElimOf xA xB xM xP)
         end

      fun forallElimEq xA xB xM xN xP xQ =
         let
         in
            refine (Rule.forallElimEq xA xB xM xN xP xQ)
         end

      fun forallElim xA xB xP =
         let
         in
            refine (Rule.forallElim xA xB xP)
         end

      val forallEta =
         let
            do () = lift
         in
            refine (Rule.forallEta (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val forallExt =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      fun forallOfExt xA' xB' =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.forallOfExt (T.evar ()) xA' (T.evar ()) xB' (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      fun forallFormInv1 xB =
         let
         in
            refine (Rule.forallFormInv1 (T.evar ()) xB)
         end

      fun forallFormInv2 xA xB xM =
         let
         in
            refine (Rule.forallFormInv2 xA xB xM)
         end

      val arrowForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowForallEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowForallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowForallEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowForallEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowSub =
         let
            do () = lift
         in
            refine (Rule.arrowSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val arrowForallSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowForallSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                idtac,
                ]
         end

      val forallArrowSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallArrowSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val arrowIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val arrowIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowIntro (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun arrowElimOf xA xM xP =
         let
         in
            refine (Rule.arrowElimOf xA (T.evar ()) xM xP)
         end

      fun arrowElimEq xA xM xN xP xQ =
         let
         in
            refine (Rule.arrowElimEq xA (T.evar ()) xM xN xP xQ)
         end

      fun arrowElim xA =
         let
         in
            refine (Rule.arrowElim xA (T.evar ()))
         end

      val arrowEta =
         let
            do () = lift
         in
            refine (Rule.arrowEta (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val arrowExt =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun arrowOfExt xA' xB' =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.arrowOfExt (T.evar ()) xA' (T.evar ()) xB' (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun arrowFormInv1 xB =
         let
         in
            refine (Rule.arrowFormInv1 (T.evar ()) xB)
         end

      fun arrowFormInv2 xA xM =
         let
         in
            refine (Rule.arrowFormInv2 xA (T.evar ()) xM)
         end

      val tarrowKind =
         let
            do () = lift
         in
            refine (Rule.tarrowKind (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowKindEq =
         let
            do () = lift
         in
            refine (Rule.tarrowKindEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowForm =
         let
            do () = lift
         in
            refine (Rule.tarrowForm (T.evar ()) (T.evar ()))
         end

      val tarrowEq =
         let
            do () = lift
         in
            refine (Rule.tarrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowFormUniv =
         let
            do () = lift
         in
            refine (Rule.tarrowFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowEqUniv =
         let
            do () = lift
         in
            refine (Rule.tarrowEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowArrowEq =
         let
            do () = lift
         in
            refine (Rule.tarrowArrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowArrowEqUniv =
         let
            do () = lift
         in
            refine (Rule.tarrowArrowEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowForallEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowForallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val tarrowForallEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowForallEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val tarrowIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val tarrowIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val tarrowIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowIntro (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun tarrowElimOf xA xM xP =
         let
         in
            refine (Rule.tarrowElimOf xA (T.evar ()) xM xP)
         end

      fun tarrowElimEq xA xM xN xP xQ =
         let
         in
            refine (Rule.tarrowElimEq xA (T.evar ()) xM xN xP xQ)
         end

      fun tarrowElim xA =
         let
         in
            refine (Rule.tarrowElim xA (T.evar ()))
         end

      val tarrowEta =
         let
            do () = lift
         in
            refine (Rule.tarrowEta (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val tarrowExt =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun tarrowOfExt xA' xB' =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.tarrowOfExt (T.evar ()) xA' (T.evar ()) xB' (T.evar ()))
            >>> [
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val karrowKind =
         let
            do () = lift
         in
            refine (Rule.karrowKind (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowKindEq =
         let
            do () = lift
         in
            refine (Rule.karrowKindEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowForm =
         let
            do () = lift
         in
            refine (Rule.karrowForm (T.evar ()) (T.evar ()))
         end

      val karrowEq =
         let
            do () = lift
         in
            refine (Rule.karrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowFormUniv =
         let
            do () = lift
         in
            refine (Rule.karrowFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowEqUniv =
         let
            do () = lift
         in
            refine (Rule.karrowEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowArrowEq =
         let
            do () = lift
         in
            refine (Rule.karrowArrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowArrowEqUniv =
         let
            do () = lift
         in
            refine (Rule.karrowArrowEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowForallEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowForallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val karrowForallEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowForallEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val karrowIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val karrowIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val karrowIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowIntro (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun karrowElimOf xA xM xP =
         let
         in
            refine (Rule.karrowElimOf xA (T.evar ()) xM xP)
         end

      fun karrowElimEq xA xM xN xP xQ =
         let
         in
            refine (Rule.karrowElimEq xA (T.evar ()) xM xN xP xQ)
         end

      fun karrowElim xA =
         let
         in
            refine (Rule.karrowElim xA (T.evar ()))
         end

      val karrowEta =
         let
            do () = lift
         in
            refine (Rule.karrowEta (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val karrowExt =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun karrowOfExt xA' xB' =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.karrowOfExt (T.evar ()) xA' (T.evar ()) xB' (T.evar ()))
            >>> [
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val intersectForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val intersectIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectIntro (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, ] (J.concl jud), ]),
                ]
         end

      fun intersectElimOf xA xB xP =
         let
         in
            refine (Rule.intersectElimOf xA xB (T.evar ()) xP)
         end

      fun intersectElimEq xA xB xP =
         let
         in
            refine (Rule.intersectElimEq xA xB (T.evar ()) (T.evar ()) xP)
         end

      fun intersectElim xA xB xP =
         let
         in
            refine (Rule.intersectElim xA xB xP)
         end

      fun intersectFormInv1 xB =
         let
         in
            refine (Rule.intersectFormInv1 (T.evar ()) xB)
         end

      fun intersectFormInv2 xA xB xM =
         let
         in
            refine (Rule.intersectFormInv2 xA xB xM)
         end

      val guardForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardIntro (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun guardElimOf xA =
         let
         in
            refine (Rule.guardElimOf xA (T.evar ()) (T.evar ()))
         end

      fun guardElimEq xA =
         let
         in
            refine (Rule.guardElimEq xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun guardElim xA =
         let
         in
            refine (Rule.guardElim xA (T.evar ()))
         end

      val guardSatEq =
         let
            do () = lift
         in
            refine (Rule.guardSatEq (T.evar ()) (T.evar ()))
         end

      val guardSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val guardSubIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.guardSubIntro (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val coguardForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.coguardForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val coguardEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.coguardEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val coguardFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.coguardFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val coguardEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.coguardEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val coguardIntroEq =
         let
            do () = lift
         in
            refine (Rule.coguardIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val coguardIntroOf =
         let
            do () = lift
         in
            refine (Rule.coguardIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val coguardIntroOfSquash =
         let
            do () = lift
         in
            refine (Rule.coguardIntroOfSquash (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val coguardIntro =
         let
            do () = lift
         in
            refine (Rule.coguardIntro (T.evar ()) (T.evar ()))
         end

      fun coguardElim1 xB =
         let
         in
            refine (Rule.coguardElim1 (T.evar ()) xB)
         end

      fun coguardElim2Eq xA =
         let
         in
            refine (Rule.coguardElim2Eq xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun coguardElim2Of xA =
         let
         in
            refine (Rule.coguardElim2Of xA (T.evar ()) (T.evar ()))
         end

      fun coguardElim2 xA =
         let
         in
            refine (Rule.coguardElim2 xA (T.evar ()))
         end

      fun coguardLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.coguardLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir left,
                chdir (rebind left 2 right set),
                ]
         end

      val coguardSatEq =
         let
            do () = lift
         in
            refine (Rule.coguardSatEq (T.evar ()) (T.evar ()))
         end

      val coguardSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.coguardSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val coguardSubElim =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.coguardSubElim (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val existsForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val existsEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val existsFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val existsEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val existsSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val existsIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsIntroOf (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      val existsIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun existsIntro xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.existsIntro (T.evar ()) (T.evar ()) xM)
            >>> [
                chdir (D.bindsVary dir [binder [2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun existsElim1Of xB =
         let
         in
            refine (Rule.existsElim1Of (T.evar ()) xB (T.evar ()))
         end

      fun existsElim1Eq xB =
         let
         in
            refine (Rule.existsElim1Eq (T.evar ()) xB (T.evar ()) (T.evar ()))
         end

      fun existsElim1 xB =
         let
         in
            refine (Rule.existsElim1 (T.evar ()) xB)
         end

      fun existsElim2Of xA xB =
         let
         in
            refine (Rule.existsElim2Of xA xB (T.evar ()))
         end

      fun existsElim2Eq xA xB =
         let
         in
            refine (Rule.existsElim2Eq xA xB (T.evar ()) (T.evar ()))
         end

      val existsEta =
         let
            do () = lift
         in
            refine (Rule.existsEta (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val existsExt =
         let
            do () = lift
         in
            refine (Rule.existsExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun existsLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.existsLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 2 right set),
                ]
         end

      fun existsFormInv1 xB =
         let
         in
            refine (Rule.existsFormInv1 (T.evar ()) xB)
         end

      fun existsFormInv2 xA xB xM =
         let
         in
            refine (Rule.existsFormInv2 xA xB xM)
         end

      fun existsFormInv2Eq xA xB xM xN =
         let
         in
            refine (Rule.existsFormInv2Eq xA xB xM xN)
         end

      val prodKind =
         let
            do () = lift
         in
            refine (Rule.prodKind (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodKindEq =
         let
            do () = lift
         in
            refine (Rule.prodKindEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodForm =
         let
            do () = lift
         in
            refine (Rule.prodForm (T.evar ()) (T.evar ()))
         end

      val prodEq =
         let
            do () = lift
         in
            refine (Rule.prodEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodFormUniv =
         let
            do () = lift
         in
            refine (Rule.prodFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodEqUniv =
         let
            do () = lift
         in
            refine (Rule.prodEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun prodExistsEq xA' xB' =
         let
         in
            refine (Rule.prodExistsEq (T.evar ()) xA' (T.evar ()) xB')
         end

      fun prodExistsEqUniv xA' xB' =
         let
         in
            refine (Rule.prodExistsEqUniv (T.evar ()) xA' (T.evar ()) xB' (T.evar ()))
         end

      val prodSub =
         let
            do () = lift
         in
            refine (Rule.prodSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodExistsSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.prodExistsSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val existsProdSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsProdSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                ]
         end

      val prodIntroOf =
         let
            do () = lift
         in
            refine (Rule.prodIntroOf (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodIntroEq =
         let
            do () = lift
         in
            refine (Rule.prodIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodIntro =
         let
            do () = lift
         in
            refine (Rule.prodIntro (T.evar ()) (T.evar ()))
         end

      fun prodElim1Of xB =
         let
         in
            refine (Rule.prodElim1Of (T.evar ()) xB (T.evar ()))
         end

      fun prodElim1Eq xB =
         let
         in
            refine (Rule.prodElim1Eq (T.evar ()) xB (T.evar ()) (T.evar ()))
         end

      fun prodElim1 xB =
         let
         in
            refine (Rule.prodElim1 (T.evar ()) xB)
         end

      fun prodElim2Of xA =
         let
         in
            refine (Rule.prodElim2Of xA (T.evar ()) (T.evar ()))
         end

      fun prodElim2Eq xA =
         let
         in
            refine (Rule.prodElim2Eq xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun prodElim2 xA =
         let
         in
            refine (Rule.prodElim2 xA (T.evar ()))
         end

      val prodEta =
         let
            do () = lift
         in
            refine (Rule.prodEta (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodExt =
         let
            do () = lift
         in
            refine (Rule.prodExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun prodLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.prodLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 2 right set),
                ]
         end

      fun prodFormInv1 xB =
         let
         in
            refine (Rule.prodFormInv1 (T.evar ()) xB)
         end

      fun prodFormInv2 xA =
         let
         in
            refine (Rule.prodFormInv2 xA (T.evar ()))
         end

      val unionForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.unionForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val unionEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.unionEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val unionFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.unionFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val unionEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.unionEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val unionSub =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.unionSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      fun unionIntroOf xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionIntroOf (T.evar ()) (T.evar ()) xM (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun unionIntroEq xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionIntroEq (T.evar ()) (T.evar ()) xM (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun unionIntro xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionIntro (T.evar ()) (T.evar ()) xM)
            >>> [
                chdir (D.bindsVary dir [binder [2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun unionElimOf xA xB xM xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimOf xA xB (T.evar ()) xM xP)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElimEq xA xB xM xN xP xQ =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimEq xA xB (T.evar ()) xM xN xP xQ)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElim xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElim xA xB (T.evar ()) xM)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElimOfDep xA xB xC xM xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimOfDep xA xB xC xM xP)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElimEqDep xA xB xC xM xN xP xQ =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimEqDep xA xB xC xM xN xP xQ)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElimDep xA xB xC xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimDep xA xB xC xM)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElimIstype xA xB xC xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimIstype xA xB xC xM)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun unionElimEqtype xA xB xC xD xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.unionElimEqtype xA xB xC xD xM xN)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      val sumForm =
         let
            do () = lift
         in
            refine (Rule.sumForm (T.evar ()) (T.evar ()))
         end

      val sumEq =
         let
            do () = lift
         in
            refine (Rule.sumEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumFormUniv =
         let
            do () = lift
         in
            refine (Rule.sumFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumEqUniv =
         let
            do () = lift
         in
            refine (Rule.sumEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumSub =
         let
            do () = lift
         in
            refine (Rule.sumSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumIntro1Of =
         let
            do () = lift
         in
            refine (Rule.sumIntro1Of (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumIntro1Eq =
         let
            do () = lift
         in
            refine (Rule.sumIntro1Eq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumIntro1 =
         let
            do () = lift
         in
            refine (Rule.sumIntro1 (T.evar ()) (T.evar ()))
         end

      val sumIntro2Of =
         let
            do () = lift
         in
            refine (Rule.sumIntro2Of (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumIntro2Eq =
         let
            do () = lift
         in
            refine (Rule.sumIntro2Eq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumIntro2 =
         let
            do () = lift
         in
            refine (Rule.sumIntro2 (T.evar ()) (T.evar ()))
         end

      fun sumElimOf xA xB xC =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElimOf xA xB xC (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumElimOfNondep xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElimOfNondep xA xB (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumElimEq xA xB xC =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElimEq xA xB xC (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumElim xA xB xC xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElim xA xB xC xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumElimNondep xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElimNondep xA xB (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumElimIstype xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElimIstype xA xB (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumElimEqtype xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.sumElimEqtype xA xB (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun sumContradiction xA xB xM xN =
         let
         in
            refine (Rule.sumContradiction xA xB (T.evar ()) xM xN)
         end

      fun sumInjection1 xB =
         let
         in
            refine (Rule.sumInjection1 (T.evar ()) xB (T.evar ()) (T.evar ()))
         end

      fun sumInjection2 xA =
         let
         in
            refine (Rule.sumInjection2 xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sum_caseType =
         let
         in
            refine (Rule.sum_caseType)
         end

      fun sumFormInv1 xB =
         let
         in
            refine (Rule.sumFormInv1 (T.evar ()) xB)
         end

      fun sumFormInv2 xA =
         let
         in
            refine (Rule.sumFormInv2 xA (T.evar ()))
         end

      val futureKind =
         let
            do () = lift
         in
            refine (Rule.futureKind (T.evar ()) (T.evar ()))
         end

      val futureKindEq =
         let
            do () = lift
         in
            refine (Rule.futureKindEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val futureForm =
         let
            do () = lift
         in
            refine (Rule.futureForm (T.evar ()))
         end

      val futureEq =
         let
            do () = lift
         in
            refine (Rule.futureEq (T.evar ()) (T.evar ()))
         end

      val futureFormUniv =
         let
            do () = lift
         in
            refine (Rule.futureFormUniv (T.evar ()) (T.evar ()))
         end

      val futureEqUniv =
         let
            do () = lift
         in
            refine (Rule.futureEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val futureSub =
         let
            do () = lift
         in
            refine (Rule.futureSub (T.evar ()) (T.evar ()))
         end

      val futureIntroOf =
         let
            do () = lift
         in
            refine (Rule.futureIntroOf (T.evar ()) (T.evar ()))
         end

      val futureIntroEq =
         let
            do () = lift
         in
            refine (Rule.futureIntroEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val futureIntro =
         let
            do () = lift
         in
            refine (Rule.futureIntro (T.evar ()))
         end

      fun futureElimOf xA xB xM xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimOf xA xB xM xP)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElimOfLetnext xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimOfLetnext xA xB (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElimOfLetnextNondep xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimOfLetnextNondep xA (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElimEq xA xB xM xN xP xQ =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimEq xA xB xM xN xP xQ)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElim xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElim xA xB xM)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElimIstype xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimIstype xA xB xM)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElimIstypeLetnext xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimIstypeLetnext xA (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun futureElimEqtype xA xB xC xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.futureElimEqtype xA xB xC xM xN)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val futureEta =
         let
            do () = lift
         in
            refine (Rule.futureEta (T.evar ()) (T.evar ()))
         end

      val futureExt =
         let
            do () = lift
         in
            refine (Rule.futureExt (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun futureLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.futureLeft i (T.evar ()) (T.evar ()))
            >>> [
                chdir left,
                chdir (rebind left 1 right set),
                ]
         end

      val futureInjection =
         let
            do () = lift
         in
            refine (Rule.futureInjection (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val recKind =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recKind (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recKindEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recKindEq (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recForm (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recEq (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recFormUniv (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recUnroll =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recUnroll (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recUnrollUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recUnrollUniv (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val recBisimilar =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recBisimilar (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val muForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.muForm (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val muEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.muEq (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      val muFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.muFormUniv (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val muEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.muEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      val muUnroll =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.muUnroll (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun muUnrollUniv xI =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.muUnrollUniv (T.evar ()) xI)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun muInd xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.muInd xA xB xM)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, NONE, NONE, ]),
                idtac,
                ]
         end

      fun muIndUniv xA xB xI xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.muIndUniv xA xB xI xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, NONE, NONE, ]),
                idtac,
                ]
         end

      val voidForm =
         let
         in
            refine (Rule.voidForm)
         end

      val voidEq =
         let
         in
            refine (Rule.voidEq)
         end

      val voidFormUniv =
         let
            do () = lift
         in
            refine (Rule.voidFormUniv (T.evar ()))
         end

      val voidEqUniv =
         let
            do () = lift
         in
            refine (Rule.voidEqUniv (T.evar ()))
         end

      val voidElim =
         let
            do () = lift
         in
            refine (Rule.voidElim (T.evar ()))
         end

      val voidSub =
         let
            do () = lift
         in
            refine (Rule.voidSub (T.evar ()))
         end

      val abortType =
         let
         in
            refine (Rule.abortType)
         end

      val unitKind =
         let
            do () = lift
         in
            refine (Rule.unitKind (T.evar ()))
         end

      val unitKindEq =
         let
            do () = lift
         in
            refine (Rule.unitKindEq (T.evar ()))
         end

      val unitForm =
         let
         in
            refine (Rule.unitForm)
         end

      val unitEq =
         let
         in
            refine (Rule.unitEq)
         end

      val unitFormUniv =
         let
            do () = lift
         in
            refine (Rule.unitFormUniv (T.evar ()))
         end

      val unitEqUniv =
         let
            do () = lift
         in
            refine (Rule.unitEqUniv (T.evar ()))
         end

      val unitIntroOf =
         let
         in
            refine (Rule.unitIntroOf)
         end

      val unitIntro =
         let
         in
            refine (Rule.unitIntro)
         end

      val unitExt =
         let
            do () = lift
         in
            refine (Rule.unitExt (T.evar ()) (T.evar ()))
         end

      fun unitLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.unitLeft i (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      val boolForm =
         let
         in
            refine (Rule.boolForm)
         end

      val boolEq =
         let
         in
            refine (Rule.boolEq)
         end

      val boolFormUniv =
         let
            do () = lift
         in
            refine (Rule.boolFormUniv (T.evar ()))
         end

      val boolEqUniv =
         let
            do () = lift
         in
            refine (Rule.boolEqUniv (T.evar ()))
         end

      val boolIntro1Of =
         let
         in
            refine (Rule.boolIntro1Of)
         end

      val boolIntro2Of =
         let
         in
            refine (Rule.boolIntro2Of)
         end

      fun boolElimOf xA =
         let
         in
            refine (Rule.boolElimOf xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val boolElimOfNondep =
         let
            do () = lift
         in
            refine (Rule.boolElimOfNondep (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun boolElimEq xA =
         let
         in
            refine (Rule.boolElimEq xA (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun boolElim xA xM =
         let
         in
            refine (Rule.boolElim xA xM)
         end

      val boolElimIstype =
         let
            do () = lift
         in
            refine (Rule.boolElimIstype (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val boolElimEqtype =
         let
            do () = lift
         in
            refine (Rule.boolElimEqtype (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun boolLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.boolLeft i (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                chdir (rebind left 0 right set),
                ]
         end

      val boolContradiction =
         let
            do () = lift
         in
            refine (Rule.boolContradiction (T.evar ()))
         end

      val iteType =
         let
         in
            refine (Rule.iteType)
         end

      val natForm =
         let
         in
            refine (Rule.natForm)
         end

      val natEq =
         let
         in
            refine (Rule.natEq)
         end

      val natFormUniv =
         let
            do () = lift
         in
            refine (Rule.natFormUniv (T.evar ()))
         end

      val natEqUniv =
         let
            do () = lift
         in
            refine (Rule.natEqUniv (T.evar ()))
         end

      fun natElimEq xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.natElimEq xA (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val natElimEqtype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.natElimEqtype (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val natUnroll =
         let
         in
            refine (Rule.natUnroll)
         end

      fun natContradiction xM =
         let
         in
            refine (Rule.natContradiction (T.evar ()) xM)
         end

      val natInjection =
         let
            do () = lift
         in
            refine (Rule.natInjection (T.evar ()) (T.evar ()))
         end

      val zeroType =
         let
         in
            refine (Rule.zeroType)
         end

      val succType =
         let
         in
            refine (Rule.succType)
         end

      val univKind =
         let
            do () = lift
         in
            refine (Rule.univKind (T.evar ()) (T.evar ()))
         end

      val univKindEq =
         let
            do () = lift
         in
            refine (Rule.univKindEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val univForm =
         let
            do () = lift
         in
            refine (Rule.univForm (T.evar ()))
         end

      val univEq =
         let
            do () = lift
         in
            refine (Rule.univEq (T.evar ()) (T.evar ()))
         end

      val univFormUniv =
         let
            do () = lift
         in
            refine (Rule.univFormUniv (T.evar ()) (T.evar ()))
         end

      val univFormUnivSucc =
         let
            do () = lift
         in
            refine (Rule.univFormUnivSucc (T.evar ()))
         end

      val univEqUniv =
         let
            do () = lift
         in
            refine (Rule.univEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun univCumulativeOf xI =
         let
         in
            refine (Rule.univCumulativeOf (T.evar ()) xI (T.evar ()))
         end

      fun univCumulativeEq xI =
         let
         in
            refine (Rule.univCumulativeEq (T.evar ()) (T.evar ()) xI (T.evar ()))
         end

      val univCumulativeSuccOf =
         let
            do () = lift
         in
            refine (Rule.univCumulativeSuccOf (T.evar ()) (T.evar ()))
         end

      val univSub =
         let
            do () = lift
         in
            refine (Rule.univSub (T.evar ()) (T.evar ()))
         end

      fun univForgetOf xI =
         let
         in
            refine (Rule.univForgetOf (T.evar ()) xI)
         end

      fun univForgetEq xI =
         let
         in
            refine (Rule.univForgetEq (T.evar ()) (T.evar ()) xI)
         end

      val univIntroEqtype =
         let
            do () = lift
         in
            refine (Rule.univIntroEqtype (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val univFormInv =
         let
            do () = lift
         in
            refine (Rule.univFormInv (T.evar ()))
         end

      val kindForm =
         let
            do () = lift
         in
            refine (Rule.kindForm (T.evar ()))
         end

      val kindEq =
         let
            do () = lift
         in
            refine (Rule.kindEq (T.evar ()) (T.evar ()))
         end

      val kindFormUniv =
         let
            do () = lift
         in
            refine (Rule.kindFormUniv (T.evar ()) (T.evar ()))
         end

      val kindEqUniv =
         let
            do () = lift
         in
            refine (Rule.kindEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val kindForgetOf =
         let
            do () = lift
         in
            refine (Rule.kindForgetOf (T.evar ()) (T.evar ()))
         end

      val kindForgetEq =
         let
            do () = lift
         in
            refine (Rule.kindForgetEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val kindUnivSub =
         let
            do () = lift
         in
            refine (Rule.kindUnivSub (T.evar ()) (T.evar ()))
         end

      val levelForm =
         let
         in
            refine (Rule.levelForm)
         end

      val levelEq =
         let
         in
            refine (Rule.levelEq)
         end

      val levelFormUniv =
         let
            do () = lift
         in
            refine (Rule.levelFormUniv (T.evar ()))
         end

      val levelEqUniv =
         let
            do () = lift
         in
            refine (Rule.levelEqUniv (T.evar ()))
         end

      val lleqForm =
         let
            do () = lift
         in
            refine (Rule.lleqForm (T.evar ()) (T.evar ()))
         end

      val lleqEq =
         let
            do () = lift
         in
            refine (Rule.lleqEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lleqFormUniv =
         let
            do () = lift
         in
            refine (Rule.lleqFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lleqEqUniv =
         let
            do () = lift
         in
            refine (Rule.lleqEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lzeroLevel =
         let
         in
            refine (Rule.lzeroLevel)
         end

      val lsuccLevel =
         let
            do () = lift
         in
            refine (Rule.lsuccLevel (T.evar ()))
         end

      val lsuccEq =
         let
            do () = lift
         in
            refine (Rule.lsuccEq (T.evar ()) (T.evar ()))
         end

      val lmaxLevel =
         let
            do () = lift
         in
            refine (Rule.lmaxLevel (T.evar ()) (T.evar ()))
         end

      val lmaxEq =
         let
            do () = lift
         in
            refine (Rule.lmaxEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lleqRefl =
         let
            do () = lift
         in
            refine (Rule.lleqRefl (T.evar ()))
         end

      fun lleqTrans xN =
         let
         in
            refine (Rule.lleqTrans (T.evar ()) xN (T.evar ()))
         end

      val lleqZero =
         let
            do () = lift
         in
            refine (Rule.lleqZero (T.evar ()))
         end

      val lleqSucc =
         let
            do () = lift
         in
            refine (Rule.lleqSucc (T.evar ()) (T.evar ()))
         end

      val lleqIncrease =
         let
            do () = lift
         in
            refine (Rule.lleqIncrease (T.evar ()) (T.evar ()))
         end

      val lleqMaxL =
         let
            do () = lift
         in
            refine (Rule.lleqMaxL (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lleqMaxR1 =
         let
            do () = lift
         in
            refine (Rule.lleqMaxR1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lleqMaxR2 =
         let
            do () = lift
         in
            refine (Rule.lleqMaxR2 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun lleqResp xM' xN' =
         let
         in
            refine (Rule.lleqResp (T.evar ()) xM' (T.evar ()) xN')
         end

      val lsuccMaxDistTrans =
         let
            do () = lift
         in
            refine (Rule.lsuccMaxDistTrans (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val lzeroType =
         let
         in
            refine (Rule.lzeroType)
         end

      val lsuccType =
         let
         in
            refine (Rule.lsuccType)
         end

      val lmaxType =
         let
         in
            refine (Rule.lmaxType)
         end

      val eqForm =
         let
            do () = lift
         in
            refine (Rule.eqForm (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqEq =
         let
            do () = lift
         in
            refine (Rule.eqEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqFormUniv =
         let
            do () = lift
         in
            refine (Rule.eqFormUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqEqUniv =
         let
            do () = lift
         in
            refine (Rule.eqEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqIntro =
         let
            do () = lift
         in
            refine (Rule.eqIntro (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun eqElim xP =
         let
         in
            refine (Rule.eqElim (T.evar ()) (T.evar ()) (T.evar ()) xP)
         end

      val eqTrivialize =
         let
            do () = lift
         in
            refine (Rule.eqTrivialize (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqExt =
         let
            do () = lift
         in
            refine (Rule.eqExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun eqLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.eqLeft i (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      val eqRefl =
         let
            do () = lift
         in
            refine (Rule.eqRefl (T.evar ()) (T.evar ()))
         end

      val eqSymm =
         let
            do () = lift
         in
            refine (Rule.eqSymm (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun eqTrans xN =
         let
         in
            refine (Rule.eqTrans (T.evar ()) (T.evar ()) xN (T.evar ()))
         end

      fun eqFormInv1 xM xN =
         let
         in
            refine (Rule.eqFormInv1 (T.evar ()) xM xN)
         end

      fun eqFormInv2 xN =
         let
         in
            refine (Rule.eqFormInv2 (T.evar ()) (T.evar ()) xN)
         end

      fun eqFormInv3 xM =
         let
         in
            refine (Rule.eqFormInv3 (T.evar ()) xM (T.evar ()))
         end

      val ofForm =
         let
            do () = lift
         in
            refine (Rule.ofForm (T.evar ()) (T.evar ()))
         end

      val ofEq =
         let
            do () = lift
         in
            refine (Rule.ofEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val ofFormUniv =
         let
            do () = lift
         in
            refine (Rule.ofFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val ofEqUniv =
         let
            do () = lift
         in
            refine (Rule.ofEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val ofIntro =
         let
            do () = lift
         in
            refine (Rule.ofIntro (T.evar ()) (T.evar ()))
         end

      fun ofElim xP =
         let
         in
            refine (Rule.ofElim (T.evar ()) (T.evar ()) xP)
         end

      val ofTrivialize =
         let
            do () = lift
         in
            refine (Rule.ofTrivialize (T.evar ()) (T.evar ()))
         end

      val ofExt =
         let
            do () = lift
         in
            refine (Rule.ofExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun ofLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.ofLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      fun ofEquand1 xN =
         let
         in
            refine (Rule.ofEquand1 (T.evar ()) (T.evar ()) xN)
         end

      fun ofEquand2 xM =
         let
         in
            refine (Rule.ofEquand2 (T.evar ()) xM (T.evar ()))
         end

      val eqtpForm =
         let
            do () = lift
         in
            refine (Rule.eqtpForm (T.evar ()) (T.evar ()))
         end

      val eqtpEq =
         let
            do () = lift
         in
            refine (Rule.eqtpEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqtpFormUniv =
         let
            do () = lift
         in
            refine (Rule.eqtpFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqtpEqUniv =
         let
            do () = lift
         in
            refine (Rule.eqtpEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eqtpIntro =
         let
            do () = lift
         in
            refine (Rule.eqtpIntro (T.evar ()) (T.evar ()))
         end

      fun eqtpElim xP =
         let
         in
            refine (Rule.eqtpElim (T.evar ()) (T.evar ()) xP)
         end

      val eqtpExt =
         let
            do () = lift
         in
            refine (Rule.eqtpExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun eqtpLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.eqtpLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      fun eqtpFunct xA xB xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.eqtpFunct xA xB xM xN)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun eqtpFunctType xA xB xB' =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.eqtpFunctType xA xB xB')
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun equivalenceOf xA =
         let
         in
            refine (Rule.equivalenceOf xA (T.evar ()) (T.evar ()))
         end

      fun equivalenceEq xA =
         let
         in
            refine (Rule.equivalenceEq xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun equivalence xA =
         let
         in
            refine (Rule.equivalence xA (T.evar ()))
         end

      fun equivalenceLeft i xB =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.equivalenceLeft i (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, ]),
                chdir (rebind left 1 right set),
                ]
         end

      fun equivalenceLeftAlt i xB =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.equivalenceLeftAlt i (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                ]
         end

      val eqtpRefl =
         let
            do () = lift
         in
            refine (Rule.eqtpRefl (T.evar ()))
         end

      val eqtpSymm =
         let
            do () = lift
         in
            refine (Rule.eqtpSymm (T.evar ()) (T.evar ()))
         end

      fun eqtpTrans xB =
         let
         in
            refine (Rule.eqtpTrans (T.evar ()) xB (T.evar ()))
         end

      val istpForm =
         let
            do () = lift
         in
            refine (Rule.istpForm (T.evar ()))
         end

      val istpEq =
         let
            do () = lift
         in
            refine (Rule.istpEq (T.evar ()) (T.evar ()))
         end

      val istpFormUniv =
         let
            do () = lift
         in
            refine (Rule.istpFormUniv (T.evar ()) (T.evar ()))
         end

      val istpEqUniv =
         let
            do () = lift
         in
            refine (Rule.istpEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val istpIntro =
         let
            do () = lift
         in
            refine (Rule.istpIntro (T.evar ()))
         end

      fun istpElim xP =
         let
         in
            refine (Rule.istpElim (T.evar ()) xP)
         end

      val istpExt =
         let
            do () = lift
         in
            refine (Rule.istpExt (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun istpLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.istpLeft i (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      val inhabitedForm =
         let
            do () = lift
         in
            refine (Rule.inhabitedForm (T.evar ()))
         end

      val subtypeForm =
         let
            do () = lift
         in
            refine (Rule.subtypeForm (T.evar ()) (T.evar ()))
         end

      val subtypeEq =
         let
            do () = lift
         in
            refine (Rule.subtypeEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val subtypeFormUniv =
         let
            do () = lift
         in
            refine (Rule.subtypeFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val subtypeEqUniv =
         let
            do () = lift
         in
            refine (Rule.subtypeEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val subtypeIntro =
         let
            do () = lift
         in
            refine (Rule.subtypeIntro (T.evar ()) (T.evar ()))
         end

      fun subtypeElim xP =
         let
         in
            refine (Rule.subtypeElim (T.evar ()) (T.evar ()) xP)
         end

      val subtypeExt =
         let
            do () = lift
         in
            refine (Rule.subtypeExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun subtypeLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.subtypeLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      val subtypeEstablish =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.subtypeEstablish (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun subsumptionOf xA =
         let
         in
            refine (Rule.subsumptionOf xA (T.evar ()) (T.evar ()))
         end

      fun subsumptionEq xA =
         let
         in
            refine (Rule.subsumptionEq xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun subsumption xA =
         let
         in
            refine (Rule.subsumption xA (T.evar ()))
         end

      fun subsumptionAlt xA =
         let
         in
            refine (Rule.subsumptionAlt xA (T.evar ()))
         end

      fun subsumptionLeft i xB =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.subsumptionLeft i (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, ]),
                chdir (rebind left 1 right set),
                ]
         end

      fun subsumptionLeftAlt i xB =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.subsumptionLeftAlt i (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                ]
         end

      fun subsumptionLast i xB xC =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.subsumptionLast i (T.evar ()) xB xC)
            >>> [
                chdir (D.bindsVary left [NONE, ]),
                chdir (D.bindsVary left [NONE, ]),
                ]
         end

      fun tighten i xB =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.tighten i (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                ]
         end

      val subtypeRefl =
         let
            do () = lift
         in
            refine (Rule.subtypeRefl (T.evar ()))
         end

      val subtypeReflEqtype =
         let
            do () = lift
         in
            refine (Rule.subtypeReflEqtype (T.evar ()) (T.evar ()))
         end

      fun subtypeTrans xB =
         let
         in
            refine (Rule.subtypeTrans (T.evar ()) xB (T.evar ()))
         end

      fun subtypeIstp1 xB =
         let
         in
            refine (Rule.subtypeIstp1 (T.evar ()) xB)
         end

      fun subtypeIstp2 xA =
         let
         in
            refine (Rule.subtypeIstp2 xA (T.evar ()))
         end

      val eeqtpForm =
         let
            do () = lift
         in
            refine (Rule.eeqtpForm (T.evar ()) (T.evar ()))
         end

      val eeqtpEq =
         let
            do () = lift
         in
            refine (Rule.eeqtpEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eeqtpFormUniv =
         let
            do () = lift
         in
            refine (Rule.eeqtpFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val eeqtpEqUniv =
         let
            do () = lift
         in
            refine (Rule.eeqtpEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val setForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val setEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val setFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val setEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      fun setWeakenOf xB =
         let
         in
            refine (Rule.setWeakenOf (T.evar ()) xB (T.evar ()))
         end

      fun setWeakenEq xB =
         let
         in
            refine (Rule.setWeakenEq (T.evar ()) xB (T.evar ()) (T.evar ()))
         end

      fun setWeaken xB =
         let
         in
            refine (Rule.setWeaken (T.evar ()) xB)
         end

      val setIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      val setIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun setIntro xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.setIntro (T.evar ()) (T.evar ()) xM)
            >>> [
                chdir (D.bindsVary dir [binder [2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      val setIntroOfSquash =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setIntroOfSquash (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      val squashIntroOfSquash =
         let
            do () = lift
         in
            refine (Rule.squashIntroOfSquash (T.evar ()))
         end

      fun setElim xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.setElim xA xB (T.evar ()) xM)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun setLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.setLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, ]),
                chdir (rebind left 2 right set),
                ]
         end

      val setSquash =
         let
            do () = lift
         in
            refine (Rule.setSquash (T.evar ()) (T.evar ()))
         end

      fun setFormInv xB =
         let
         in
            refine (Rule.setFormInv (T.evar ()) xB)
         end

      val setSubElim =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setSubElim (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val isetForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val isetEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val isetFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val isetEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      fun isetWeakenOf xB =
         let
         in
            refine (Rule.isetWeakenOf (T.evar ()) xB (T.evar ()))
         end

      fun isetWeakenEq xB =
         let
         in
            refine (Rule.isetWeakenEq (T.evar ()) xB (T.evar ()) (T.evar ()))
         end

      fun isetWeaken xB =
         let
         in
            refine (Rule.isetWeaken (T.evar ()) xB)
         end

      val isetIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      val isetIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun isetIntro xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.isetIntro (T.evar ()) (T.evar ()) xM)
            >>> [
                chdir (D.bindsVary dir [binder [2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      val isetIntroOfSquash =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetIntroOfSquash (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun isetElim xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.isetElim xA xB (T.evar ()) xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun isetLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.isetLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 2 right set),
                ]
         end

      fun isetFormInv1 xB =
         let
         in
            refine (Rule.isetFormInv1 (T.evar ()) xB)
         end

      fun isetFormInv2 xA xB xM =
         let
         in
            refine (Rule.isetFormInv2 xA xB xM)
         end

      val isetSubElim =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetSubElim (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val squashForm =
         let
            do () = lift
         in
            refine (Rule.squashForm (T.evar ()))
         end

      val squashEq =
         let
            do () = lift
         in
            refine (Rule.squashEq (T.evar ()) (T.evar ()))
         end

      val squashFormUniv =
         let
            do () = lift
         in
            refine (Rule.squashFormUniv (T.evar ()) (T.evar ()))
         end

      val squashEqUniv =
         let
            do () = lift
         in
            refine (Rule.squashEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val squashIntroOf =
         let
            do () = lift
         in
            refine (Rule.squashIntroOf (T.evar ()))
         end

      val squashIntro =
         let
            do () = lift
         in
            refine (Rule.squashIntro (T.evar ()))
         end

      fun squashElim xA xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.squashElim xA (T.evar ()) xM)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val squashExt =
         let
            do () = lift
         in
            refine (Rule.squashExt (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun squashLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.squashLeft i (T.evar ()) (T.evar ()))
            >>> [
                chdir left,
                chdir (rebind left 1 right set),
                ]
         end

      val squashSub =
         let
            do () = lift
         in
            refine (Rule.squashSub (T.evar ()) (T.evar ()))
         end

      val quotientForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientForm (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, NONE, binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val quotientEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, NONE, binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val quotientFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientFormUniv (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, NONE, binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val quotientEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [NONE, NONE, binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val quotientIntroOf =
         let
            do () = lift
         in
            refine (Rule.quotientIntroOf (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val quotientIntroEq =
         let
            do () = lift
         in
            refine (Rule.quotientIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun quotientElimOf xA xB xC xM xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientElimOf xA xB xC xM xP)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, NONE, ]),
                ]
         end

      fun quotientElimEq xA xB xC xM xN xP xQ =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientElimEq xA xB xC xM xN xP xQ)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, ]),
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, NONE, ]),
                ]
         end

      fun quotientElimIstype xA xB xC xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientElimIstype xA xB xC xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, NONE, ]),
                ]
         end

      fun quotientElimEqtype xA xB xC xD xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientElimEqtype xA xB xC xD xM xN)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, NONE, ]),
                ]
         end

      fun quotientDescent xA xB xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.quotientDescent xA xB (T.evar ()) xM xN)
            >>> [
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                idtac,
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun quotientLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                ]
         end

      fun quotientLeftRefl i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftRefl i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 1 right set),
                chdir (rebind left 2 right set),
                ]
         end

      fun quotientLeftIstype i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftIstype i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 3 right set),
                ]
         end

      fun quotientLeftEqtype i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftEqtype i (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 3 right set),
                ]
         end

      fun quotientLeftOf i xC =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftOf i (T.evar ()) (T.evar ()) xC (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 3 right set),
                ]
         end

      fun quotientLeftEq i xC =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftEq i (T.evar ()) (T.evar ()) xC (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 3 right set),
                ]
         end

      fun quotientLeftOfDep i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftOfDep i (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 3 right set),
                chdir (rebind left 3 right set),
                ]
         end

      fun quotientLeftEqDep i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.quotientLeftEqDep i (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary left [NONE, NONE, ]),
                chdir (rebind left 3 right set),
                chdir (rebind left 3 right set),
                ]
         end

      fun quotientFormInv xB =
         let
         in
            refine (Rule.quotientFormInv (T.evar ()) xB)
         end

      val iforallForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallForm (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                ]
         end

      val iforallEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                ]
         end

      val iforallFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallFormUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [binder [2, 3, ] (J.concl jud), ]),
                ]
         end

      val iforallEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [binder [2, 3, ] (J.concl jud), ]),
                ]
         end

      val iforallIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallIntroOf (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                ]
         end

      val iforallIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallIntroEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                ]
         end

      val iforallIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallIntro (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [3, ] (J.concl jud), ]),
                ]
         end

      fun iforallElimOf xA xI xK xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallElimOf xA xI xK (T.evar ()) xP)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      fun iforallElimEq xA xI xK xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallElimEq xA xI xK (T.evar ()) (T.evar ()) xP)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      fun iforallElim xA xI xK xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iforallElim xA xI xK xP)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      val foralltpForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpForm (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val foralltpEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpEq (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val foralltpIntroOf =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpIntroOf (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val foralltpIntroEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpIntroEq (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val foralltpIntro =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpIntro (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun foralltpElimOf xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpElimOf xA xB (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      fun foralltpElimEq xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpElimEq xA xB (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      fun foralltpElim xA xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.foralltpElim xA xB)
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                idtac,
                ]
         end

      val iexistsForm =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsForm (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                ]
         end

      val iexistsEq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                ]
         end

      val iexistsFormUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsFormUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [binder [2, 3, ] (J.concl jud), ]),
                ]
         end

      val iexistsEqUniv =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsEqUniv (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [binder [2, 3, ] (J.concl jud), ]),
                ]
         end

      fun iexistsIntroOf xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsIntroOf (T.evar ()) xB (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun iexistsIntroEq xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsIntroEq (T.evar ()) xB (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 3, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun iexistsIntro xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsIntro (T.evar ()) xB (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [3, ] (J.concl jud), ]),
                idtac,
                idtac,
                ]
         end

      fun iexistsElimOf xA xI xK xM xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimOf xA (T.evar ()) xI xK xM xP)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElimEq xA xI xK xM xN xP xQ =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimEq xA (T.evar ()) xI xK xM xN xP xQ)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElim xA xI xK xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElim xA (T.evar ()) xI xK xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElimOfDep xA xB xI xK xM xP =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimOfDep xA xB xI xK xM xP)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElimEqDep xA xB xI xK xM xN xP xQ =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimEqDep xA xB xI xK xM xN xP xQ)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElimDep xA xB xI xK xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimDep xA xB xI xK xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElimIstype xA xB xI xK xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimIstype xA xB xI xK xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun iexistsElimEqtype xA xB xC xI xK xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.iexistsElimEqtype xA xB xC xI xK xM xN)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun substitution i xM =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.substitution i (T.evar ()) (T.evar ()) xM)
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                chdir (rebind left 0 right set),
                ]
         end

      fun substitutionSimple i xB xM =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.substitutionSimple i (T.evar ()) xB xM)
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 0 right set),
                ]
         end

      fun generalize xA xB xM =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.generalize xA xB xM)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun assert xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.assert xA (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun assert' xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.assert' xA (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun inhabitant xM =
         let
         in
            refine (Rule.inhabitant (T.evar ()) xM)
         end

      fun letForm xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.letForm xA (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      fun accInd xA xB xI xM xN xR =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.accInd xA xB xI xM xN xR)
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                idtac,
                ]
         end

      val sequalForm =
         let
            do () = lift
         in
            refine (Rule.sequalForm (T.evar ()))
         end

      val sequalIntroOf =
         let
            do () = lift
         in
            refine (Rule.sequalIntroOf (T.evar ()))
         end

      val sequalIntro =
         let
            do () = lift
         in
            refine (Rule.sequalIntro (T.evar ()))
         end

      val sequalTrivialize =
         let
            do () = lift
         in
            refine (Rule.sequalTrivialize (T.evar ()) (T.evar ()))
         end

      val sequalExt =
         let
            do () = lift
         in
            refine (Rule.sequalExt (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun sequalLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.sequalLeft i (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      val sequalEq =
         let
            do () = lift
         in
            refine (Rule.sequalEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sequalEqtp =
         let
            do () = lift
         in
            refine (Rule.sequalEqtp (T.evar ()) (T.evar ()))
         end

      fun sequivalence xA =
         let
         in
            refine (Rule.sequivalence xA (T.evar ()))
         end

      fun sequivalenceLeft i xB =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.sequivalenceLeft i (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 1 right set),
                ]
         end

      fun substitutionSyntactic i xM =
         let
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.substitutionSyntactic i (T.evar ()) (T.evar ()) xM)
            >>> [
                chdir (rebind left 1 right set),
                chdir (rebind left 0 right set),
                ]
         end

      val sequalSymm =
         let
            do () = lift
         in
            refine (Rule.sequalSymm (T.evar ()) (T.evar ()))
         end

      fun sequalTrans xN =
         let
         in
            refine (Rule.sequalTrans (T.evar ()) xN (T.evar ()))
         end

      fun sequalCompat xM xN xP =
         let
         in
            refine (Rule.sequalCompat xM xN xP)
         end

      val partialForm =
         let
            do () = lift
         in
            refine (Rule.partialForm (T.evar ()))
         end

      val partialEq =
         let
            do () = lift
         in
            refine (Rule.partialEq (T.evar ()) (T.evar ()))
         end

      val partialFormUniv =
         let
            do () = lift
         in
            refine (Rule.partialFormUniv (T.evar ()) (T.evar ()))
         end

      val partialEqUniv =
         let
            do () = lift
         in
            refine (Rule.partialEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val partialSub =
         let
            do () = lift
         in
            refine (Rule.partialSub (T.evar ()) (T.evar ()))
         end

      val partialStrict =
         let
            do () = lift
         in
            refine (Rule.partialStrict (T.evar ()))
         end

      val partialStrictConverse =
         let
            do () = lift
         in
            refine (Rule.partialStrictConverse (T.evar ()))
         end

      val partialIdem =
         let
            do () = lift
         in
            refine (Rule.partialIdem (T.evar ()))
         end

      fun haltsForm xA =
         let
         in
            refine (Rule.haltsForm xA (T.evar ()))
         end

      fun haltsEq xA =
         let
         in
            refine (Rule.haltsEq xA (T.evar ()) (T.evar ()))
         end

      fun haltsFormUniv xA =
         let
         in
            refine (Rule.haltsFormUniv xA (T.evar ()) (T.evar ()))
         end

      fun haltsEqUniv xA =
         let
         in
            refine (Rule.haltsEqUniv xA (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val partialIntroBottomOf =
         let
            do () = lift
         in
            refine (Rule.partialIntroBottomOf (T.evar ()))
         end

      val bottomDiverges =
         let
         in
            refine (Rule.bottomDiverges)
         end

      val partialExt =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.partialExt (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val partialElimEq =
         let
            do () = lift
         in
            refine (Rule.partialElimEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val partialElimOf =
         let
            do () = lift
         in
            refine (Rule.partialElimOf (T.evar ()) (T.evar ()))
         end

      val haltsTrivialize =
         let
            do () = lift
         in
            refine (Rule.haltsTrivialize (T.evar ()))
         end

      val haltsExt =
         let
            do () = lift
         in
            refine (Rule.haltsExt (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun haltsLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.haltsLeft i (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      val fixpointInductionEq =
         let
            do () = lift
         in
            refine (Rule.fixpointInductionEq (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val fixpointInductionOf =
         let
            do () = lift
         in
            refine (Rule.fixpointInductionOf (T.evar ()) (T.evar ()))
         end

      val partialFormInv =
         let
            do () = lift
         in
            refine (Rule.partialFormInv (T.evar ()))
         end

      fun seqBind xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.seqBind xA (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun activeApp xA xM xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activeApp xA (T.evar ()) xM xN)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun activeAppSeq xA xN =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activeAppSeq xA (T.evar ()) (T.evar ()) xN)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun appHaltsInv xN =
         let
         in
            refine (Rule.appHaltsInv (T.evar ()) xN)
         end

      fun activePi1 xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activePi1 xA (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun activePi1Seq xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activePi1Seq xA (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val pi1HaltsInv =
         let
            do () = lift
         in
            refine (Rule.pi1HaltsInv (T.evar ()))
         end

      fun activePi2 xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activePi2 xA (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun activePi2Seq xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activePi2Seq xA (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val pi2HaltsInv =
         let
            do () = lift
         in
            refine (Rule.pi2HaltsInv (T.evar ()))
         end

      val prevHaltsInv =
         let
            do () = lift
         in
            refine (Rule.prevHaltsInv (T.evar ()))
         end

      fun activeCase xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activeCase xA (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun activeCaseSeq xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.activeCaseSeq xA (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun caseHaltsInv xP xR =
         let
         in
            refine (Rule.caseHaltsInv (T.evar ()) xP xR)
         end

      val seqHaltsSequal =
         let
            do () = lift
         in
            refine (Rule.seqHaltsSequal (T.evar ()) (T.evar ()))
         end

      fun seqHaltsInv xN =
         let
         in
            refine (Rule.seqHaltsInv (T.evar ()) xN)
         end

      val totalStrict =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.totalStrict (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                ]
         end

      val voidStrict =
         let
         in
            refine (Rule.voidStrict)
         end

      val unitTotal =
         let
            do () = lift
         in
            refine (Rule.unitTotal (T.evar ()))
         end

      val unitStrict =
         let
         in
            refine (Rule.unitStrict)
         end

      val boolTotal =
         let
            do () = lift
         in
            refine (Rule.boolTotal (T.evar ()))
         end

      val boolStrict =
         let
         in
            refine (Rule.boolStrict)
         end

      fun forallTotal xA xB =
         let
         in
            refine (Rule.forallTotal xA xB (T.evar ()))
         end

      val forallStrict =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallStrict (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 1, 2, ] (J.concl jud), ]),
                ]
         end

      fun arrowTotal xA xB =
         let
         in
            refine (Rule.arrowTotal xA xB (T.evar ()))
         end

      val arrowStrict =
         let
            do () = lift
         in
            refine (Rule.arrowStrict (T.evar ()) (T.evar ()))
         end

      val intersectStrict =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectStrict (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 1, 2, ] (J.concl jud), ]),
                ]
         end

      fun existsTotal xA xB =
         let
         in
            refine (Rule.existsTotal xA xB (T.evar ()))
         end

      val existsStrict =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsStrict (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 1, 2, ] (J.concl jud), ]),
                ]
         end

      fun prodTotal xA xB =
         let
         in
            refine (Rule.prodTotal xA xB (T.evar ()))
         end

      val prodStrict =
         let
            do () = lift
         in
            refine (Rule.prodStrict (T.evar ()) (T.evar ()))
         end

      fun sumTotal xA xB =
         let
         in
            refine (Rule.sumTotal xA xB (T.evar ()))
         end

      val sumStrict =
         let
            do () = lift
         in
            refine (Rule.sumStrict (T.evar ()) (T.evar ()))
         end

      fun futureTotal xA =
         let
         in
            refine (Rule.futureTotal xA (T.evar ()))
         end

      val futureStrict =
         let
            do () = lift
         in
            refine (Rule.futureStrict (T.evar ()))
         end

      val setStrict =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setStrict (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [2, 1, 2, ] (J.concl jud), ]),
                idtac,
                ]
         end

      val isetStrict =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetStrict (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [binder [2, 1, 2, ] (J.concl jud), ]),
                idtac,
                ]
         end

      val natTotal =
         let
            do () = lift
         in
            refine (Rule.natTotal (T.evar ()))
         end

      val natStrict =
         let
         in
            refine (Rule.natStrict)
         end

      val typeHalts =
         let
            do () = lift
         in
            refine (Rule.typeHalts (T.evar ()))
         end

      val uptypeForm =
         let
            do () = lift
         in
            refine (Rule.uptypeForm (T.evar ()))
         end

      val uptypeEq =
         let
            do () = lift
         in
            refine (Rule.uptypeEq (T.evar ()) (T.evar ()))
         end

      val uptypeFormUniv =
         let
            do () = lift
         in
            refine (Rule.uptypeFormUniv (T.evar ()) (T.evar ()))
         end

      val uptypeEqUniv =
         let
            do () = lift
         in
            refine (Rule.uptypeEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val uptypeTrivialize =
         let
            do () = lift
         in
            refine (Rule.uptypeTrivialize (T.evar ()))
         end

      val uptypeExt =
         let
            do () = lift
         in
            refine (Rule.uptypeExt (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun uptypeLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.uptypeLeft i (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      fun uptypeEeqtp xA =
         let
         in
            refine (Rule.uptypeEeqtp xA (T.evar ()))
         end

      val uptypeUnitary =
         let
            do () = lift
         in
            refine (Rule.uptypeUnitary (T.evar ()))
         end

      val voidUptype =
         let
         in
            refine (Rule.voidUptype)
         end

      val unitUptype =
         let
         in
            refine (Rule.unitUptype)
         end

      val boolUptype =
         let
         in
            refine (Rule.boolUptype)
         end

      val forallUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallUptype (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val arrowUptype =
         let
            do () = lift
         in
            refine (Rule.arrowUptype (T.evar ()) (T.evar ()))
         end

      val intersectUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectUptype (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val existsUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsUptype (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val prodUptype =
         let
            do () = lift
         in
            refine (Rule.prodUptype (T.evar ()) (T.evar ()))
         end

      val sumUptype =
         let
            do () = lift
         in
            refine (Rule.sumUptype (T.evar ()) (T.evar ()))
         end

      val futureUptype =
         let
            do () = lift
         in
            refine (Rule.futureUptype (T.evar ()))
         end

      val eqUptype =
         let
            do () = lift
         in
            refine (Rule.eqUptype (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val ofUptype =
         let
            do () = lift
         in
            refine (Rule.ofUptype (T.evar ()) (T.evar ()))
         end

      val eqtpUptype =
         let
            do () = lift
         in
            refine (Rule.eqtpUptype (T.evar ()) (T.evar ()))
         end

      val istpUptype =
         let
            do () = lift
         in
            refine (Rule.istpUptype (T.evar ()))
         end

      val subtypeUptype =
         let
            do () = lift
         in
            refine (Rule.subtypeUptype (T.evar ()) (T.evar ()))
         end

      val setUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.setUptype (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val isetUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.isetUptype (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val muUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.muUptype (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      fun muUptypeUniv xI =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.muUptypeUniv (T.evar ()) xI)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                idtac,
                ]
         end

      val recUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recUptype (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                ]
         end

      fun recUptypeUniv xI =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.recUptypeUniv (T.evar ()) xI)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                ]
         end

      val natUptype =
         let
         in
            refine (Rule.natUptype)
         end

      val uptypeFormInv =
         let
            do () = lift
         in
            refine (Rule.uptypeFormInv (T.evar ()))
         end

      val admissForm =
         let
            do () = lift
         in
            refine (Rule.admissForm (T.evar ()))
         end

      val admissEq =
         let
            do () = lift
         in
            refine (Rule.admissEq (T.evar ()) (T.evar ()))
         end

      val admissFormUniv =
         let
            do () = lift
         in
            refine (Rule.admissFormUniv (T.evar ()) (T.evar ()))
         end

      val admissEqUniv =
         let
            do () = lift
         in
            refine (Rule.admissEqUniv (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val admissTrivialize =
         let
            do () = lift
         in
            refine (Rule.admissTrivialize (T.evar ()))
         end

      val admissExt =
         let
            do () = lift
         in
            refine (Rule.admissExt (T.evar ()) (T.evar ()) (T.evar ()))
         end

      fun admissLeft i =
         let
            do () = lift
            do (jud, dir) = withgoal
            val (right, dir') = D.split dir i
            val left = D.shift dir' 1
            val set = D.set dir
         in
            refine (Rule.admissLeft i (T.evar ()) (T.evar ()))
            >>> [
                chdir (rebind left 0 right set),
                ]
         end

      fun admissEeqtp xA =
         let
         in
            refine (Rule.admissEeqtp xA (T.evar ()))
         end

      val uptypeAdmiss =
         let
            do () = lift
         in
            refine (Rule.uptypeAdmiss (T.evar ()))
         end

      val partialAdmiss =
         let
            do () = lift
         in
            refine (Rule.partialAdmiss (T.evar ()))
         end

      val voidAdmiss =
         let
         in
            refine (Rule.voidAdmiss)
         end

      val unitAdmiss =
         let
         in
            refine (Rule.unitAdmiss)
         end

      val boolAdmiss =
         let
         in
            refine (Rule.boolAdmiss)
         end

      val forallAdmiss =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallAdmiss (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val arrowAdmiss =
         let
            do () = lift
         in
            refine (Rule.arrowAdmiss (T.evar ()) (T.evar ()))
         end

      val intersectAdmiss =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectAdmiss (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val existsAdmissUptype =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsAdmissUptype (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val prodAdmiss =
         let
            do () = lift
         in
            refine (Rule.prodAdmiss (T.evar ()) (T.evar ()))
         end

      val sumAdmiss =
         let
            do () = lift
         in
            refine (Rule.sumAdmiss (T.evar ()) (T.evar ()))
         end

      val futureAdmiss =
         let
            do () = lift
         in
            refine (Rule.futureAdmiss (T.evar ()))
         end

      val eqAdmiss =
         let
            do () = lift
         in
            refine (Rule.eqAdmiss (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val ofAdmiss =
         let
            do () = lift
         in
            refine (Rule.ofAdmiss (T.evar ()) (T.evar ()))
         end

      val eqtpAdmiss =
         let
            do () = lift
         in
            refine (Rule.eqtpAdmiss (T.evar ()) (T.evar ()))
         end

      val istpAdmiss =
         let
            do () = lift
         in
            refine (Rule.istpAdmiss (T.evar ()))
         end

      val subtypeAdmiss =
         let
            do () = lift
         in
            refine (Rule.subtypeAdmiss (T.evar ()) (T.evar ()))
         end

      val recAdmiss =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.recAdmiss (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                ]
         end

      fun recAdmissUniv xI =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.recAdmissUniv (T.evar ()) xI)
            >>> [
                idtac,
                chdir (D.bindsVary dir [NONE, ]),
                chdir (D.bindsVary dir [NONE, NONE, ]),
                ]
         end

      val natAdmiss =
         let
         in
            refine (Rule.natAdmiss)
         end

      val admissFormInv =
         let
            do () = lift
         in
            refine (Rule.admissFormInv (T.evar ()))
         end

      val partialType =
         let
         in
            refine (Rule.partialType)
         end

      val haltsType =
         let
         in
            refine (Rule.haltsType)
         end

      val admissType =
         let
         in
            refine (Rule.admissType)
         end

      val uptypeType =
         let
         in
            refine (Rule.uptypeType)
         end

      val seqType =
         let
         in
            refine (Rule.seqType)
         end

      val eeqtpRefl =
         let
            do () = lift
         in
            refine (Rule.eeqtpRefl (T.evar ()))
         end

      val eeqtpSymm =
         let
            do () = lift
         in
            refine (Rule.eeqtpSymm (T.evar ()) (T.evar ()))
         end

      fun eeqtpTrans xB =
         let
         in
            refine (Rule.eeqtpTrans (T.evar ()) xB (T.evar ()))
         end

      val weakenEqtpEeqtp =
         let
            do () = lift
         in
            refine (Rule.weakenEqtpEeqtp (T.evar ()) (T.evar ()))
         end

      val weakenSubtypeArrow =
         let
            do () = lift
         in
            refine (Rule.weakenSubtypeArrow (T.evar ()) (T.evar ()))
         end

      val weakenEeqtpIff =
         let
            do () = lift
         in
            refine (Rule.weakenEeqtpIff (T.evar ()) (T.evar ()))
         end

      val compatGuardEqtp1 =
         let
            do () = lift
         in
            refine (Rule.compatGuardEqtp1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSetEqtp0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatSetEqtp0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val forallEeq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.forallEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val existsEeq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.existsEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val arrowEeq =
         let
            do () = lift
         in
            refine (Rule.arrowEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val prodEeq =
         let
            do () = lift
         in
            refine (Rule.prodEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val sumEeq =
         let
            do () = lift
         in
            refine (Rule.sumEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val futureEeq =
         let
            do () = lift
         in
            refine (Rule.futureEeq (T.evar ()) (T.evar ()))
         end

      val intersectEeq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.intersectEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val unionEeq =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.unionEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val compatGuardEeq1 =
         let
            do () = lift
         in
            refine (Rule.compatGuardEeq1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSetEeq0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatSetEeq0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val compatIsetEeq0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatIsetEeq0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val compatIsetIff1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatIsetIff1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatForallSubtype0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatForallSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val compatForallSubtype1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatForallSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatExistsSubtype0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatExistsSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatExistsSubtype1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatExistsSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatIntersectSubtype0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatIntersectSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [1, 2, ] (J.concl jud), ]),
                ]
         end

      val compatIntersectSubtype1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatIntersectSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatUnionSubtype0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatUnionSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatUnionSubtype1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatUnionSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatGuardArrow0 =
         let
            do () = lift
         in
            refine (Rule.compatGuardArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatGuardSubtype1 =
         let
            do () = lift
         in
            refine (Rule.compatGuardSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSetSubtype0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatSetSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatSetArrow1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatSetArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatIsetSubtype0 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatIsetSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatIsetArrow1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatIsetArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatForallIff1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatForallIff1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatExistsIff1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatExistsIff1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatArrowIff0 =
         let
            do () = lift
         in
            refine (Rule.compatArrowIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatArrowIff1 =
         let
            do () = lift
         in
            refine (Rule.compatArrowIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatProdIff0 =
         let
            do () = lift
         in
            refine (Rule.compatProdIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatProdIff1 =
         let
            do () = lift
         in
            refine (Rule.compatProdIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSumIff0 =
         let
            do () = lift
         in
            refine (Rule.compatSumIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSumIff1 =
         let
            do () = lift
         in
            refine (Rule.compatSumIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatFutureIff =
         let
            do () = lift
         in
            refine (Rule.compatFutureIff (T.evar ()) (T.evar ()))
         end

      val compatForallArrow1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatForallArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatExistsArrow1 =
         let
            do () = lift
            do (jud, dir) = withgoal
         in
            refine (Rule.compatExistsArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtac,
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                chdir (D.bindsVary dir [binder [2, 2, ] (J.concl jud), ]),
                ]
         end

      val compatArrowArrow0 =
         let
            do () = lift
         in
            refine (Rule.compatArrowArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatArrowArrow1 =
         let
            do () = lift
         in
            refine (Rule.compatArrowArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatProdArrow0 =
         let
            do () = lift
         in
            refine (Rule.compatProdArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatProdArrow1 =
         let
            do () = lift
         in
            refine (Rule.compatProdArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSumArrow0 =
         let
            do () = lift
         in
            refine (Rule.compatSumArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatSumArrow1 =
         let
            do () = lift
         in
            refine (Rule.compatSumArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         end

      val compatFutureArrow =
         let
            do () = lift
         in
            refine (Rule.compatFutureArrow (T.evar ()) (T.evar ()))
         end

      fun compatForallEntails1 xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.compatForallEntails1 (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, binder [2, ] (J.concl jud), ]),
                idtac,
                ]
         end

      fun compatArrowEntails1 xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.compatArrowEntails1 (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun compatProdEntails0 xA =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.compatProdEntails0 xA (T.evar ()) (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      fun compatProdEntails1 xB =
         let
            do (jud, dir) = withgoal
         in
            refine (Rule.compatProdEntails1 (T.evar ()) xB (T.evar ()))
            >>> [
                chdir (D.bindsVary dir [NONE, ]),
                idtac,
                ]
         end

      val integerForm =
         let
         in
            refine (Rule.integerForm)
         end

      val integerEq =
         let
         in
            refine (Rule.integerEq)
         end

      val integerFormUniv =
         let
            do () = lift
         in
            refine (Rule.integerFormUniv (T.evar ()))
         end

      val integerEqUniv =
         let
            do () = lift
         in
            refine (Rule.integerEqUniv (T.evar ()))
         end

      val integerToDefType =
         let
         in
            refine (Rule.integerToDefType)
         end

      val integerFromDefType =
         let
         in
            refine (Rule.integerFromDefType)
         end

      val integerIsomorphism1 =
         let
         in
            refine (Rule.integerIsomorphism1)
         end

      val integerIsomorphism2 =
         let
         in
            refine (Rule.integerIsomorphism2)
         end

      val pluszSpec =
         let
         in
            refine (Rule.pluszSpec)
         end

      val negzSpec =
         let
         in
            refine (Rule.negzSpec)
         end

      val eqzbSpec =
         let
         in
            refine (Rule.eqzbSpec)
         end

      val leqzbSpec =
         let
         in
            refine (Rule.leqzbSpec)
         end

      val timeszSpec =
         let
         in
            refine (Rule.timeszSpec)
         end

      val integerTotal =
         let
            do () = lift
         in
            refine (Rule.integerTotal (T.evar ()))
         end

      val integerStrict =
         let
         in
            refine (Rule.integerStrict)
         end

      val integerUptype =
         let
         in
            refine (Rule.integerUptype)
         end

      val integerAdmiss =
         let
         in
            refine (Rule.integerAdmiss)
         end

      val integerSequal =
         let
            do () = lift
         in
            refine (Rule.integerSequal (T.evar ()) (T.evar ()))
         end

      val symbolForm =
         let
         in
            refine (Rule.symbolForm)
         end

      val symbolEq =
         let
         in
            refine (Rule.symbolEq)
         end

      val symbolFormUniv =
         let
            do () = lift
         in
            refine (Rule.symbolFormUniv (T.evar ()))
         end

      val symbolEqUniv =
         let
            do () = lift
         in
            refine (Rule.symbolEqUniv (T.evar ()))
         end

      val symbol_eqbType =
         let
         in
            refine (Rule.symbol_eqbType)
         end

      val symbol_eqbSpec1 =
         let
            do () = lift
         in
            refine (Rule.symbol_eqbSpec1 (T.evar ()) (T.evar ()))
         end

      val symbol_eqbSpec2 =
         let
            do () = lift
         in
            refine (Rule.symbol_eqbSpec2 (T.evar ()) (T.evar ()))
         end

      val symbolTotal =
         let
            do () = lift
         in
            refine (Rule.symbolTotal (T.evar ()))
         end

      val symbolStrict =
         let
         in
            refine (Rule.symbolStrict)
         end

      val symbolUptype =
         let
         in
            refine (Rule.symbolUptype)
         end

      val symbolAdmiss =
         let
         in
            refine (Rule.symbolAdmiss)
         end

      val symbolSequal =
         let
            do () = lift
         in
            refine (Rule.symbolSequal (T.evar ()) (T.evar ()))
         end


      fun sumLeft i = refine (Rule.sumLeft i (T.evar ()) (T.evar ()) (T.evar ()))
      val checkPositive = refine Rule.checkPositive
      val checkNegative = refine Rule.checkNegative
      val integerIntroOf = refine Rule.integerIntroOf
      val integerIntroEq = refine Rule.integerIntroEq
      val symbolIntroOf = refine Rule.symbolIntroOf
      val symbolIntroEq = refine Rule.symbolIntroEq

   end
