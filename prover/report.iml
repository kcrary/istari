
signature REPORT =
   sig

      val showAll : unit -> unit
      val showModule : Namespace.address -> unit
      val show : Namespace.address -> unit
      val showType : Namespace.address -> unit

      (* These require the UI. *)

      val insertApp : Namespace.address -> unit
      val insertIntros : unit -> unit

   end


structure Report :> REPORT =
   struct

      open CasePervasive

      fun printAddress address =
         (case address of
             [] =>
                (* This shouldn't happen, but fail gracefully. *)
                ()

           | [sym] =>
                print (Symbol.toValue sym)

           | sym :: rest =>
                (
                print (Symbol.toValue sym);
                print ".";
                printAddress rest
                ))


      structure SLO =
         ListOrdered (structure Ordered =
                         struct
                            type t = Symbol.symbol
                            val eq = Symbol.eq

                            fun compare (s, s') =
                               String.compare (Symbol.toValue s) (Symbol.toValue s')
                         end)


      fun showConstants address = 
         List.app
            (fn (address, _, _) =>
                (
                printAddress address;
                print "\n"
                ))
            (Juliasort.sort 
                (fn ((a1, _, _), (a2, _, _)) => SLO.compare (a1, a2))
                (Namespace.dump address))


      fun showAll () =
         (
         print "\nEnvironment contains: \n";
         showConstants []
         )


      fun showModule addr =
         if Namespace.moduleExists addr then
            (
            print "\nModule ";
            printAddress addr;
            print " contains: \n";
            showConstants addr
            )
         else
            print "Module does not exist.\n\n"



      fun argumentCount a acc =
         termCase a
         /| \Prim.intersect\ _ (fn . ?) =>
            \(fnc b => argumentCount b acc)\

          | \Prim.forall\ _ (fn . ?) =>
            \(fnc b => argumentCount b (1 + acc))\

          | _ =>
            \(fnc => acc)\
         /


      fun beginInsert () = print "\x01i"
      fun endInsert () = print "\x02"

      fun showConstant showDef showApp addr =
         (case Namespace.resolveOpt addr of
             NONE =>
                print "\nNo such constant.\n"

           | SOME const =>
                let
                   val implicits = Database.findImplicits const

                   val topt =
                      (case Database.findType const of
                          NONE => NONE

                        | SOME (jud, _) =>
                             if Seq.null (Judgement.context jud) then
                                termCase (Judgement.concl jud)
                                /| \Prim.ov\ ? \const\ =>
                                   \(fnc a => SOME a)\
      
                                 | _ =>
                                   \(fnc => NONE)\
                                /
                             else
                                NONE)
                in
                   print "\n";
                   print (Namespace.toString const);

                   if implicits = 0 then
                      print "\n"
                   else
                      (
                      print "  [";
                      print (Int.toString implicits);
                      print " implicit arguments]\n"
                      );

                   if showDef then
                      (case Constant.definition const of
                          NONE => ()
      
                        | SOME m =>
                             Show.showPrefixed "  = " Directory.empty m)
                   else
                      ();

                   (case topt of
                       NONE =>
                          print " is untyped.\n"

                     | SOME t =>
                          (
                          Show.showPrefixed "  : " Directory.empty t;

                          if showApp then
                             (
                             beginInsert ();
                             (case Int.max 0 (argumentCount t 0 - implicits) of
                                 0 => print " "

                               | 1 => print " _ "

                               | n =>
                                    (
                                    print " _# ";
                                    print (Int.toString n);
                                    print " "
                                    ));
                             endInsert ()
                             )
                          else 
                             ()
                          ))
                end)
                          

      val show = showConstant true false
      val showType = showConstant false false
      val insertApp = showConstant false true



      fun generateIntros dir a acc =
         termCase a
         /| ( \Prim.intersect\ _ (fn ? . ?)
            | \Prim.forall\ _ (fn ? . ?)
            | \Prim.lett\ _ (fn ? . ?)
            ) =>
            \(fnc binder b =>
                 let
                    val (sym, dir') = Directory.varyAndBind dir binder
                 in
                    generateIntros dir' b (sym :: acc)
                 end)\

          | \Prim.arrow\ _ ? =>
            \(fnc b =>
                 let
                    val (sym, dir') = Directory.freshAndBind dir
                 in
                    generateIntros dir' b (sym :: acc)
                 end)\

          | _ =>
            \(fnc => List.rev acc)\
         /

      fun insertIntros () =
         let
            val (jud, dir) = Prover.currentGoal ()
            val syms = generateIntros dir (Judgement.concl jud) []
         in
            (case syms of
                [] => ()

              | sym :: rest =>
                   (
                   beginInsert ();
       
                   print (Symbol.toValue sym);

                   List.app
                      (fn sym =>
                          (
                          print " ";
                          print (Symbol.toValue sym)
                          ))
                      rest;
       
                   endInsert ()
                   ))
         end

   end
