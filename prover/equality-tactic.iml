
signature EQUALITY_TACTIC =
   sig

      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority
      type hypothesis = Hyp.hypothesis

      val reflexivityPriority : priority tacticm
      val reflexivityRaw : tactic
      val reflexivity : tactic

      val symmetryPriority : priority tacticm
      val symmetryRaw : tactic
      val symmetry : tactic

      val symmetryInPriority : hypothesis -> priority tacticm
      val symmetryInRaw : hypothesis -> tactic
      val symmetryIn : hypothesis -> tactic

      val transitivityPriority : ETerm.eterm -> priority tacticm
      val transitivityRaw : ETerm.eterm -> tactic
      val transitivity : ETerm.eterm -> tactic
      val etransitivity : tactic

      val compatPriority : priority tacticm
      val compatRaw : tactic
      val compat : tactic

      val injectionPriority : hypothesis -> priority tacticm
      val injectionRaw : hypothesis -> tactic
      val injection : hypothesis -> tactic

      val decompEq : int -> ETerm.eterm -> tactic

      val applyEqPriority : ETerm.eterm -> ETerm.eterm -> hypothesis -> Symbol.symbol option -> priority tacticm
      val applyEqRaw : ETerm.eterm -> ETerm.eterm -> hypothesis -> Symbol.symbol option -> tactic
      val applyEq : ETerm.eterm -> ETerm.eterm -> hypothesis -> Symbol.symbol option -> tactic

      val introEqPriority : Symbol.symbol option list -> priority tacticm
      val introEqRaw : Symbol.symbol option list -> tactic
      val introEq : Symbol.symbol option list -> tactic

      val extensionalityAutoRaw : tactic
      val extensionalityAuto : tactic

      val extensionalityPriority : priority tacticm
      val extensionalityRaw : tactic
      val extensionality : tactic

      val existsEqPriority : ETerm.eterm -> priority tacticm
      val existsEqRaw : ETerm.eterm -> tactic
      val existsEq : ETerm.eterm -> tactic

      val univIntroEqtype : tactic

      val substitutionLiteralPriority : int -> Term.term -> priority tacticm
      val substitutionLiteral : int -> Term.term -> tactic

      val substitutionPriority : hypothesis -> ETerm.eterm -> priority tacticm
      val substitutionRaw : hypothesis -> ETerm.eterm -> tactic
      val substitution : hypothesis -> ETerm.eterm -> tactic

      val substPriority : hypothesis list -> priority tacticm
      val substStrictPriority : hypothesis list -> priority tacticm
      val substRaw : hypothesis list -> tactic
      val substStrictRaw : hypothesis list -> tactic
      val subst : hypothesis list -> tactic
      val substStrict : hypothesis list -> tactic
      val substCautiousPriority : hypothesis list -> priority tacticm
      val substCautiousStrictPriority : hypothesis list -> priority tacticm
      val substCautiousRaw : hypothesis list -> tactic
      val substCautiousStrictRaw : hypothesis list -> tactic
      val substCautious : hypothesis list -> tactic
      val substCautiousStrict : hypothesis list -> tactic

      val substAll : tactic

      val ofEquands : hypothesis -> IntroPattern.ipattern -> tactic

   end


signature EQUALITY_TACTIC_INTERNAL =
   sig

      include EQUALITY_TACTIC


      (* substMain reverse cautious i j m

         hypothesis j has type (i = m : A), or the reverse if reverse=true

         Will not move hypotheses to make substitution possible.
         Will not substitute into the conclusion if cautious=true.
      *)
      val substMain : bool -> bool -> int -> int -> Term.term -> priority tacticm


      val injectionSum : int -> tactic
      val injectionExists : int -> tactic
      val injectionProd : int -> tactic
      val injectionSet : int -> priority tacticm


      (* Tables *)

      val reflexivityTactics : priority tacticm ConstantTable.table

      (* takes a tactic for the primary subgoal as its argument *)
      val symmetryTactics : (priority tacticm -> priority tacticm) ConstantTable.table  

      (* takes the mediating term as its argument *)
      val transitivityTactics : (Term.term -> priority tacticm) ConstantTable.table

      (* take the hypothesis number to inject as its argument *)
      val injectionTactics : (int -> priority tacticm) ConstantTable.table

      val extensionalityTactics : priority tacticm ConstantTable.table

      (* an extensionality tactic to be used by reflexivity *)
      val trivialExtensionalityTactics : tactic ConstantTable.table

   end



structure EqualityTacticInternal :> EQUALITY_TACTIC_INTERNAL =
   struct

      structure D = Directory
      structure H = ConstantTable
      structure IP = IntroPattern
      structure J = Judgement
      structure N = Normalize
      structure R = Reduction
      structure T = Term
      structure TC = Typecheck

      open Tactic
      open CasePervasive

      type priority = priority
      type hypothesis = Hyp.hypothesis


      val reflexivityTactics : priority tacticm H.table = H.table ()

      val reflexivityPriority =
         let
            do const = withHeadConst "not a reflexivity goal"
         in
            (case H.find reflexivityTactics const of
                SOME tac => 
                   cut $ setFailure "not a reflexive instance" tac

              | NONE => fail "not a reflexivity goal")
         end

      val reflexivityRaw = reflexivityPriority >> idtac

      val reflexivity = TC.withTypecheckSnd reflexivityPriority

      
      val trivialExtensionalityTactics : tactic H.table = H.table ()

      val eqReflexive =
         let
            do () = lift
         in
            cut $ setFailure "terms do not unify" $
            first
               [
               refine (Rule.eqRefl (T.evar ()) (T.evar ())),

               goalCaseT
               /| \Prim.eq\ (const? @ _) _ _ =>
                  \(fnc const =>
                       (case H.find trivialExtensionalityTactics const of
                           SOME tac =>
                              tac
      
                         | NONE =>
                              fail "trivial extensionality"))\
      
                | _ =>
                  \(fnc =>
                       fail "trivial extensionality")\
               /
               ]
         end

      val () =
         (
         H.insert reflexivityTactics Prim.eq 
            (eqReflexive >> idtacM Secondary);

         H.insert reflexivityTactics Prim.eqtp 
            (cut (setFailure "types do not unify" RuleTactic.eqtpRefl) >> idtacM Secondary);

         H.insert reflexivityTactics Prim.subtype
            (cut (setFailure "types do not unify" RuleTactic.subtypeRefl) >> idtacM Secondary);

         H.insert reflexivityTactics Prim.eeqtp 
            (cut (setFailure "types do not unify" RuleTactic.eeqtpRefl) >> idtacM Secondary)
         )
         


      val symmetryTactics : (priority tacticm -> priority tacticm) H.table = H.table ()

      val symmetryPriority =
         let
            do const = withHeadConst "not a symmetry goal"
         in
            (case H.find symmetryTactics const of
                SOME tacfn => tacfn (idtacM Primary)

              | NONE => fail "not a symmetry goal")
         end

      (* No typechecking goals are generated for the built-in types (eq and eqtp),
         but there might be some for ones added by the user.
      *)
      val symmetryRaw = symmetryPriority >> idtac

      val symmetry = TC.withTypecheckSnd symmetryPriority

      fun symmetryInLiteral i =
         let
            do (dj, _) = withgoal
         in
            (case J.hypOpt dj i of
                NONE =>
                   (* just found this hypothesis *)
                   raise (Fail "impossible")

              | SOME (J.Tm a) =>
                   (case N.simplify a of
                       T.Elim (T.Const const, spine) =>
                          (case H.find symmetryTactics const of
                              SOME tacfn =>
                                 (case List.rev spine of
                                     T.App n :: T.App m :: revleft =>
                                        let
                                           val a' = 
                                              T.Sub (T.Elim (T.Const const,
                                                             List.revAppend revleft [T.App n, T.App m]),
                                                     T.Shift (i+1))
                                        in
                                           refine (Rule.assert a' (J.concl dj))
                                           >>> [
                                               tacfn (refine (Rule.hypothesis i) >> done),

                                               refine (Rule.weaken (i+1) 1)
                                               >> refine (Rule.exchange 0 1 i)
                                               >> idtacM Primary
                                               ]
                                        end
              
                                   | _ =>
                                        fail "hypothesis not symmetrizable")

                            | NONE =>
                                 fail "hypothesis not symmetrizable")
       
                     | _ =>
                          fail "hypothesis not symmetrizable")

              | _ =>
                   fail "hypothesis not symmetrizable")
         end

      fun symmetryInPriority name =
         let
            do i = Hyp.findhyp name
         in
            symmetryInLiteral i
         end

      fun symmetryInRaw name = symmetryInPriority name >> idtac

      fun symmetryIn name = TC.withTypecheckSnd $ symmetryInPriority name



      val () =
         List.app
            (fn (const, f) => H.insert symmetryTactics const f)
            [
            (Prim.eq, (fn tac => RuleTactic.eqSymm >> tac)),
            (Prim.eqtp, (fn tac => RuleTactic.eqtpSymm >> tac)),
            (Prim.eeqtp, (fn tac => RuleTactic.eeqtpSymm >> tac)),
            ]



      val transitivityTactics : (T.term -> priority tacticm) H.table = H.table ()

      fun transitivityPriority em =
         let
            do m = withterm em
            do const = withHeadConst "not a transitivity goal"
         in
            (case H.find transitivityTactics const of
                SOME tac => tac m

              | NONE => fail "not a transitivity goal")
         end

      fun transitivityRaw em = transitivityPriority em >> idtac

      (* No typechecking goals are generated for the built-in types (eq and eqtp),
         but there might be some for ones added by the user.
      *)
      fun transitivity em = TC.withTypecheckSnd $ transitivityPriority em

      val etransitivity = transitivity ETerm.evar


      val () =
         (
         H.insert transitivityTactics Prim.eq
            (fn m =>
                refine (Rule.eqTrans (T.evar ()) (T.evar ()) m (T.evar ()))
                >> idtacM Primary);

         H.insert transitivityTactics Prim.eqtp
            (fn m => 
                refine (Rule.eqtpTrans (T.evar ()) m (T.evar ()))
                >> idtacM Primary);

         H.insert transitivityTactics Prim.subtype
            (fn m => 
                refine (Rule.subtypeTrans (T.evar ()) m (T.evar ()))
                >> idtacM Primary);

         H.insert transitivityTactics Prim.eeqtp
            (fn m => 
                refine (Rule.eeqtpTrans (T.evar ()) m (T.evar ()))
                >> idtacM Primary)
         )




      val idtacPri =
         goalCaseT
         /| \Prim.ov\ _ _ =>
            \(fnc => idtacM Secondary)\

          | \Prim.istp\ _ =>
            \(fnc => idtacM Secondary)\

          | _ =>
            \(fnc => idtacM Primary)\
         /
           
      fun seqOption l = List.findmap (fn z => z) l
             


      fun sequalCompatLoop const prev spine1 spine2 =
         (case (spine1, spine2) of
             ([], []) =>
                idtac

           | (T.App m1 :: rest1, T.App m2 :: rest2) =>
                if Unify.unify1 m1 m2 then
                   sequalCompatLoop const (T.App m1 :: prev) rest1 rest2
                else
                   (* const @ rev prev :: m1 :: rest1 =sequal= const @ rev prev :: m2 :: rest2 *)
                   refine (Rule.sequalTrans 
                              (T.evar ())
                              (T.Elim (T.Const const, 
                                       List.revAppend prev (T.App m2 :: rest1)))
                              (T.evar ()))
                   >>> [
                       (* const @ rev prev :: m1 :: rest1 =sequal= const @ rev prev :: m2 :: rest1 *)
                       (* ssubst doesn't care that prev is backward *)
                       refine (Rule.sequalCompat m1 m2
                                  (T.Elim (T.Const const,
                                           List.revAppend 
                                              (T.ssubst prev T.shift1)
                                              (T.App T.zero :: T.ssubst rest1 T.shift1)))),
   
                       (* const @ rev prev :: m2 :: rest1 =sequal= const @ rev prev :: m2 :: rest2 *)
                       sequalCompatLoop const (T.App m2 :: prev) rest1 rest2
                       ]

           | (T.Pi1 :: rest1, T.Pi1 :: rest2) =>
                sequalCompatLoop const (T.Pi1 :: prev) rest1 rest2

           | (T.Pi2 :: rest1, T.Pi2 :: rest2) =>
                sequalCompatLoop const (T.Pi2 :: prev) rest1 rest2

           | (T.Prev :: rest1, T.Prev :: rest2) =>
                sequalCompatLoop const (T.Prev :: prev) rest1 rest2

           | _ =>
                fail "incompatible paths")


      fun compatPriorityMain () =
         let
            do (jud, dir) = withgoal
         in
            termCaseT (J.concl jud)
            /| \Prim.eq\ @ $ap ? $ap (\Prim.inl\ ?)
                  (| $ap (\Prim.inl\ ?) $nil =>
                     \(fnc b m n =>
                          termCaseT b
                          /| \Prim.sum\ ? ? =>
                             \(fnc b1 b2 =>
                                  refine (Rule.sumIntro1Eq b1 b2 m n)
                                  >>> [
                                      idtacM Secondary,
                                      idtacM Primary
                                      ])\

                           | _ =>
                             \(fnc => fail "result type mismatch")\
                          /)\

                   | _ =>
                     \(fnc _ _ => fail "incompatible forms")\
                  )

             | \Prim.eq\ @ $ap ? $ap (\Prim.inr\ ?)
                  (| $ap (\Prim.inr\ ?) $nil =>
                     \(fnc b m n =>
                          termCaseT b
                          /| \Prim.sum\ ? ? =>
                             \(fnc b1 b2 =>
                                  refine (Rule.sumIntro2Eq b1 b2 m n)
                                  >>> [
                                      idtacM Secondary,
                                      idtacM Primary
                                      ])\

                           | _ =>
                             \(fnc => fail "result type mismatch")\
                          /)\

                   | _ =>
                     \(fnc _ _ => fail "incompatible forms")\
                  )

             | \Prim.eq\ ? ($as (_ @ _)) ($as (_ @ _)) =>
               \(fnc b m n =>
                    (case
                        (try
                            Sum.INL (Infer.compat (J.context jud) m n (fns _ _ => idtac))
                         with
                            Infer.Mismatch (_, _, msg) =>
                               Sum.INR ("inference failed: " ^ msg)
 
                          | Infer.NotPath msg =>
                               Sum.INR ("inference failed: " ^ msg)
 
                          | Infer.Clash =>
                               Sum.INR "incompatible paths"

                          | Infer.Ambiguous _ =>
                               Sum.INR "inference failed: a prefix of the path has an evar head")
                     of
                        Sum.INL (a, tac) =>
                           if Unify.unify1 a b then
                              tac >> idtacPri
                           else
                              (* G |- M = N : B *)
                              refine (Rule.subsumptionEq a b m n)
                              >>> [
                                  (* G |- A <: B *)
                                  idtacM Secondary,
 
                                  (* G |- M = N : A *)
                                  tac >> idtacPri
                                  ]
 
                      | Sum.INR msg => fail msg))\

             | \Prim.eq\ ? (? , ?) (? , ?) =>
               \(fnc b m1 m2 n1 n2 =>
                    termCaseT b
                    /| \Prim.prod\ ? ? =>
                       \(fnc b1 b2 =>
                            refine (Rule.prodIntroEq b1 b2 m1 n1 m2 n2)
                            >> idtacM Primary)\

                     | \Prim.exists\ ? (fn ? . ?) =>
                       \(fnc b1 binder b2 =>
                            refine (Rule.existsIntroEq b1 b2 m1 n1 m2 n2)
                            >>> [
                                chdir (D.bindVary dir binder) >> idtacM Secondary,
                                idtacM Primary,
                                idtacM Primary
                                ])\

                     | _ =>
                       \(fnc => fail "result type mismatch")\
                    /)\

             | \Prim.eq\ ? (fn ? . ?) (fn ? . ?) =>
               \(fnc b binder1 m binder2 n =>
                    termCaseT b
                    /| \Prim.arrow\ ? ? =>
                       \(fnc dom cod =>
                            refine (Rule.arrowIntroEq dom cod m n)
                            >>> [
                                idtacM Secondary,

                                chdir (D.bindVary dir (seqOption [binder1, binder2]))
                                >> idtacM Primary
                                ])\

                     | \Prim.forall\ ? (fn ? . ?) =>
                       \(fnc dom binder cod =>
                            refine (Rule.forallIntroEq dom cod m n)
                            >>> [
                                idtacM Secondary,

                                chdir (D.bindVary dir (seqOption [binder, binder1, binder2]))
                                >> idtacM Primary
                                ])\

                     | \Prim.forallfut\ ? (fn ? . ?) =>
                       \(fnc dom binder cod =>
                            refine (Rule.forallfutIntroEq dom cod m n)
                            >>> [
                                idtacM Secondary,

                                chdir (D.bindVary dir (seqOption [binder, binder1, binder2]))
                                >> idtacM Primary
                                ])\

                     | _ =>
                       \(fnc => fail "result type mismatch")\
                    /)\

             | \Prim.eq\ ? (next ?) (next ?) =>
               \(fnc b m n =>
                    termCaseT b
                    /| \Prim.future\ ? =>
                       \(fnc b1 =>
                            refine (Rule.futureIntroEq b1 (T.evar ()) (T.evar ()))
                            >> idtacM Primary)\

                     | _ =>
                       \(fnc => fail "result type mismatch")\
                    /)\

             | \Prim.eq\ _ _ _ =>
               \(fnc => fail "incompatible forms")\

             | \Prim.sequal\ (const? @ ?) (const? @ ?) =>
               \(fnc const spine const' spine' =>
                    if Constant.eq (const, const') then
                       sequalCompatLoop const [] spine spine'
                       >> idtacM Primary
                    else
                       fail "incompatible paths")\

             | \Prim.sequal\ (? , ?) (? , ?) =>
               \(fnc m1 m2 n1 n2 =>
                    (* (m1, m2) =sequal= (n1, n2) *)
                    refine (Rule.sequalTrans
                               (T.evar ())
                               (T.Pair (n1, m2))
                               (T.evar ()))
                    >>> [
                        (* (m1, m2) =sequal= (n1, m2) *)
                        refine (Rule.sequalCompat m1 n1
                                   (T.Pair (T.zero, T.Sub (m2, T.shift1))))
                        >>+ idtacM Primary,

                        (* (n1, m2) =sequal= (n1, n2) *)
                        refine (Rule.sequalCompat m2 n2
                                   (T.Pair (T.Sub (n1, T.shift1), T.zero)))
                        >>+ idtacM Primary
                        ])\

             | \Prim.sequal\ (next ?) (next ?) =>
               \(fnc m n =>
                    refine (Rule.sequalCompat m n (T.Next T.zero))
                    >>+ idtacM Primary)\

               (* No sequal case for Lam *)

             | \Prim.eqtp\ ? ? =>
               \(fnc a b =>
                    (* G |- A = B : type *)
                    refine (Rule.univForgetEq a b (T.evar ()))
                    >>
                    (* G |- A = B : U i *)
                    compatPriorityMain ())\

             | _ =>
               \(fnc => fail "not a compatibility goal")\
            /
         end

      val compatPriority = lift compatPriorityMain

      val compatRaw = compatPriority >> idtac

      val compat =
         (* The cut prevents bad explosion.  We only need to cut the first, but
            compatPriority can't usefully backtrack, so it's more efficient to
            cut the whole thing.
         *)
         TC.withTypecheckSnd $
         cut $
         compatPriority
         >>=
         (fn tc => first [reflexivityPriority, idtacM tc])



      fun splitLast l acc =
         (case l of
             [] => raise (Fail "precondition")

           | [x] => (List.rev acc, x)

           | h :: t => splitLast t (h :: acc))


      exception DecompError of string
      fun decompEqLoop n t head1 head2 rspine1 rspine2 =
         if n = 0 then
            (t,
             replaceConcl (T.apply3 Prim.eq 
                              t
                              (T.Elim (head1, List.rev rspine1))
                              (T.Elim (head2, List.rev rspine2))))
         else
            (case (rspine1, rspine2) of
                (elim1 :: rest1, elim2 :: rest2) =>
                    let
                       val (t', tac) = decompEqLoop (n-1) t head1 head2 rest1 rest2
                       val m = T.Elim (head1, List.rev rest1)
                       val n = T.Elim (head2, List.rev rest2)
                    in
                       (case (elim1, elim2) of
                           (T.App p, T.App q) =>
                              termCase (N.whnfHard t')
                              /| \Prim.arrow\ ? ? =>
                                 \(fnc a b =>
                                      (b, 
                                       refine (Rule.arrowElimEq a b m n p q)
                                       >>> [tac, idtac]))\
       
                               | \Prim.forall\ ? (fn . ?) =>
                                 \(fnc a b =>
                                      (T.Sub (b, T.Dot (p, T.id)),
                                       refine (Rule.forallElimEq a b m n p q)
                                       >>> [tac, idtac]))\
       
                               | \Prim.forallfut\ ? (fn . ?) =>
                                 \(fnc a b =>
                                      (T.Sub (b, T.Dot (p, T.id)),
                                       refine (Rule.forallfutElimEq a b m n p q)
                                       >>> [tac, idtac]))\
       
                               | _ =>
                                 \(fnc => raise (DecompError "elims do not match given type"))\
                              /

                         | (T.Pi1, T.Pi1) =>
                              termCase (N.whnfHard t')
                              /| \Prim.prod\ ? ? =>
                                 \(fnc a b =>
                                      (a,
                                       refine (Rule.prodElim1Eq a b m n) >> tac))\
       
                               | \Prim.exists\ ? (fn . ?) =>
                                 \(fnc a b =>
                                      (a,
                                       refine (Rule.existsElim1Eq a b m n) >> tac))\
       
                               | _ =>
                                 \(fnc => raise (DecompError "elims do not match given type"))\
                              /

                         | (T.Pi2, T.Pi2) =>
                              termCase (N.whnfHard t')
                              /| \Prim.prod\ ? ? =>
                                 \(fnc a b =>
                                      (b,
                                       refine (Rule.prodElim2Eq a b m n) >> tac))\
       
                               | \Prim.exists\ ? (fn . ?) =>
                                 \(fnc a b =>
                                      (T.Sub (b, T.Dot (T.pi1 m, T.id)),
                                       refine (Rule.existsElim2Eq a b m n) >> tac))\
       
                               | _ =>
                                 \(fnc => raise (DecompError "elims do not match given type"))\
                              /

                         | (T.Prev, T.Prev) =>
                              raise (DecompError "cannot decompose prev with decompEq")

                         | _ => raise (DecompError "elims do not match"))
                    end

              | ([], _) => raise (DecompError "insufficient elims in left-hand equand")
              | (_, []) => raise (DecompError "insufficient elims in right-hand equand"))
                       

      fun decompEq n et =
         let
            do (jud, dir) = withgoal

            val t = ETerm.withdir dir et
         in
            termCaseT (J.concl jud)
            /| \Prim.eq\ ? ? ? =>
               \(fnc c e1 e2 =>
                    (case (e1, e2) of
                        (T.Elim (head1, spine1), T.Elim (head2, spine2)) =>
                           (try
                               let
                                  val (t', tac) =
                                     decompEqLoop n t head1 head2 (List.rev spine1) (List.rev spine2)
                               in
                                  if Unify.unify1 t' c then
                                     tac
                                  else
                                     raise (DecompError "mismatch with given type")
                               end
                            with DecompError msg => fail msg)

                      | _ => fail "not a decompEq goal"))\

             | _ =>
               \(fnc => fail "not a decompEq goal")\
            /
         end



      fun applyEqPriority ef eb hyp symopt =
         let
            do i = Hyp.findhyp hyp
            do (jud, dir) = withgoal
            val f = ETerm.withdir dir ef
            val b = ETerm.withdir dir eb
         in
            goalHypCaseT i
            /| $tm \Prim.eq\ ? ? ? =>
               \(fnc a m n =>
                    refine (Rule.assert 
                               (T.apply3 Prim.eq b (T.app f m) (T.app f n))
                               (T.evar ()))
                    >>> [
                        (* F M = F N : B *)
                        refine (Rule.arrowElimEq a b f f m n)
                        >>> [
                            (* F = F : A -> B *)
                            refine (Rule.eqRefl (T.evar ()) (T.evar ()))
                            >>+
                            (* F : A -> B *)
                            idtacM Secondary,

                            (* M = N : A *)
                            refine (Rule.hypothesis i) >> done
                            ],

                        (* F M = F N : B |- J *)
                        chdir (D.bindh dir symopt) >> idtacM Primary
                        ])\

             | $tm _ =>
               \(fnc =>
                    fail "hypothesis does not contain an equality")\

             | _ =>
               \(fnc =>
                    fail "hypothesis has the wrong sort")\
            /
         end

      fun applyEqRaw ef eb hyp symopt = applyEqPriority ef eb hyp symopt >> idtac

      fun applyEq ef eb hyp symopt = TC.withTypecheckSnd $ applyEqPriority ef eb hyp symopt



      fun assert a = refine (Rule.assert a (T.evar ()))

      fun assert2 a b =
         refine (Rule.assert a (T.evar ()))
         >>> [
             idtac,
             refine (Rule.assert (T.Sub (b, T.shift1)) (T.evar ()))
             >>> [
                 refine (Rule.weaken 0 1),
                 idtac
                 ]
             ]



      val extensionalityTactics : priority tacticm H.table = H.table ()
         
      val extensionalityPriority =
         goalCaseT
         /| \Prim.eq\ (const? @ _) _ _ =>
            \(fnc const =>
                 (case H.find extensionalityTactics const of
                     SOME tac =>
                        tac
                        
                   | NONE =>
                        fail "extensionality is not supported for this type"))\

          | _ =>
            \(fnc =>
                 fail "not an extensionality goal")\
         /

      val extensionalityRaw = extensionalityPriority >> idtac

      val extensionality = TC.withTypecheckSnd $ extensionalityPriority



      val forallExt =
         goalCaseT
         /
         \Prim.eq\ ($as (\Prim.forall\ ? (fn ? . ?))) ? ? =>
         \(fnc ab a binder b m n =>
              refine (Rule.forallExt' a (T.Const Prim.void) (T.Const Prim.void) b (T.evar ()) (T.evar ()) m n)
              >>> [
                  idtacM Secondary,
                  attempt IntroTactic.proveLambda >> idtacM Secondary,
                  attempt IntroTactic.proveLambda >> idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Primary)
                  ])\
         /

      val forallfutExt =
         goalCaseT
         /
         \Prim.eq\ ($as (\Prim.forallfut\ ? (fn ? . ?))) ? ? =>
         \(fnc ab a binder b m n =>
              refine (Rule.forallfutExt' a (T.Const Prim.void) (T.Const Prim.void) b (T.evar ()) (T.evar ()) m n)
              >>> [
                  idtacM Secondary,
                  attempt IntroTactic.proveLambda >> idtacM Secondary,
                  attempt IntroTactic.proveLambda >> idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Primary)
                  ])\
         /

      val parametricExt =
         goalCaseT
         /
         \Prim.eq\ ($as (\Prim.parametric\ ? (fn ? . ?))) ? ? =>
         \(fnc ab a binder b m n =>
              refine (Rule.parametricExt' a (T.Const Prim.void) (T.Const Prim.void) b (T.evar ()) (T.evar ()) m n)
              >>> [
                  idtacM Secondary,

                  attempt
                     (refine (Rule.parametricIntroOfForall (T.evar ()) (T.evar ()) (T.evar ()))
                      >>> [IntroTactic.proveLambda, Irrelevance.proveIrrelevant])
                     >> idtacM Secondary,

                  attempt
                     (refine (Rule.parametricIntroOfForall (T.evar ()) (T.evar ()) (T.evar ()))
                      >>> [IntroTactic.proveLambda, Irrelevance.proveIrrelevant])
                     >> idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Primary)
                  ])\
         /

      val arrowExt =
         goalCaseT
         /
         \Prim.eq\ (\Prim.arrow\ ? ?) ? ? =>
         \(fnc a b m n =>
              refine (Rule.arrowExt' a (T.Const Prim.void) (T.Const Prim.void) b (T.evar ()) (T.evar ()) m n)
              >>> [
                  idtacM Secondary,
                  attempt IntroTactic.proveLambda >> idtacM Secondary,
                  attempt IntroTactic.proveLambda >> idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bind0 dir) >>+ idtacM Primary)
                  ])\
         /

      fun tkarrowExt rule =
         goalCaseT
         /
         \Prim.eq\ (\Prim.arrow\ ? ?) ? ? =>
         \(fnc a b m n =>
              refine (rule a b m n)
              >>> [
                  idtacM Secondary,
                  idtacM Secondary,
                  idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bind0 dir) >>+ idtacM Primary)
                  ])\
         /

      val intersectExt =
         goalCaseT
         /
         \Prim.eq\ (\Prim.intersect\ ? (fn ? . ?)) ? ? =>
         \(fnc a binder b m n =>
              refine (Rule.intersectIntroEq a b m n)
              >>> [
                  idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Primary)
                  ])\
         /

      val intersectfutExt =
         goalCaseT
         /
         \Prim.eq\ (\Prim.intersectfut\ ? (fn ? . ?)) ? ? =>
         \(fnc a binder b m n =>
              refine (Rule.intersectfutIntroEq a b m n)
              >>> [
                  idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Primary)
                  ])\
         /

      val iforallExt =
         goalCaseT
         /
         \Prim.eq\ (\Prim.iforall\ ? ? (fn ? . ?)) ? ? =>
         \(fnc i k binder a m n =>
              refine (Rule.iforallIntroEq a i k m n)
              >>> [
                  idtacM Secondary,

                  withgoal
                  (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Primary)
                  ])\
         /

      val existsExt =
         goalCaseT
         /
         \Prim.eq\ ($as (\Prim.exists\ ? (fn ? . ?))) ? ? =>
         \(fnc ab a binder b m n =>
              refine (Rule.existsExt a b m n)
              >>> [
                  replaceConcl (T.apply2 Prim.ov ab m) >>+ idtacM Secondary,
                  replaceConcl (T.apply2 Prim.ov ab n) >>+ idtacM Secondary,

                  idtacM Primary,
                  idtacM Primary
                  ])\
         /

      val prodExt =
         goalCaseT
         /
         \Prim.eq\ ($as (\Prim.prod\ ? ?)) ? ? =>
         \(fnc ab a b m n =>
              refine (Rule.prodExt a b m n)
              >>> [
                  replaceConcl (T.apply2 Prim.ov ab m) >>+ idtacM Secondary,
                  replaceConcl (T.apply2 Prim.ov ab n) >>+ idtacM Secondary,

                  idtacM Primary,
                  idtacM Primary
                  ])\
         /

      val futureExt =
         let
            do () = lift
         in
            refine (Rule.futureExt (T.evar ()) (T.evar ()) (T.evar ()))
            >>> [
                idtacM Secondary,
                idtacM Secondary,
   
                idtacM Primary
                ]
         end

      val setExt =
         goalCaseT
         / \Prim.eq\ (\Prim.set\ ? (fn ? . ?)) ? ? =>
           \(fnc a binder b m n =>
                refine (Rule.setIntroEqSquash a b m n)
                >>> [
                    withgoal
                    (fn (_, dir) => chdir (D.bindVary dir binder) >> idtacM Secondary),

                    idtacM Primary,

                    idtacM Primary
                    ])\
         /

      val isetExt =
         goalCaseT
         / \Prim.eq\ (\Prim.iset\ ? (fn ? . ?)) ? ? =>
           \(fnc a binder b m n =>
                refine (Rule.isetIntroEqSquash a b m n)
                >>> [
                    withgoal
                    (fn (_, dir) => chdir (D.bindVary dir binder) >> idtacM Secondary),

                    idtacM Primary,

                    idtacM Primary
                    ])\
         /

      val quotientExt =
         goalCaseT
         / \Prim.eq\ ($as (\Prim.quotient\ ? (fn . fn . ?))) ? ? =>
           \(fnc q a b m n =>
                refine (Rule.quotientIntroEq a b m n)
                >>> [
                    replaceConcl (T.apply1 Prim.istp q)
                    >> idtacM Secondary,

                    idtacM Secondary,
                    idtacM Secondary,
                    idtacM Primary
                    ])\
         /

      fun unitExt tac = tac >> idtacM Secondary
             
      structure RT = RuleTactic

      val () =
         List.app
            (fn (const, tac) => H.insert extensionalityTactics const tac)
            [
            (Prim.forall, forallExt),
            (Prim.forallfut, forallfutExt),
            (Prim.arrow, arrowExt),
            (Prim.tarrow, tkarrowExt Rule.tarrowExt),
            (Prim.karrow, tkarrowExt Rule.karrowExt),
            (Prim.parametric, parametricExt),
            (Prim.intersect, intersectExt),
            (Prim.intersectfut, intersectfutExt),
            (Prim.iforall, iforallExt),
            (Prim.exists, existsExt),
            (Prim.prod, prodExt),
            (Prim.future, futureExt),
            (Prim.set, setExt),
            (Prim.iset, isetExt),
            (Prim.quotient, quotientExt),
            (Prim.unit, unitExt RT.unitExt),
            (Prim.eq, unitExt RT.eqExt),
            (Prim.ov, unitExt RT.ofExt),
            (Prim.eqtp, unitExt RT.eqtpExt),
            (Prim.istp, unitExt RT.istpExt),
            (Prim.subtype, unitExt RT.subtypeExt),
            (Prim.squash, unitExt RT.squashExt),
            (Prim.isquash, unitExt RT.isquashExt),
            ]



      (* Each ExtAuto tactic expects a goal of the form
         ..., (M : A), (N : A) |- M = N : A (ignoring shifts),
         and a directory that is missing those last two hypotheses.
         It calls tac(s) on the primary subgoal(s), which will look similar.
      *)

      fun forallExtAuto binder a b m n tac =
         refine (Rule.forallExt a b m n)
         >>> [
             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,
             
             assert2 
                (T.apply2 Prim.ov b (T.app (T.Sub (m, T.shift1)) T.zero))
                (T.apply2 Prim.ov b (T.app (T.Sub (n, T.shift1)) T.zero))
             >>> [
                 refine (Rule.forallElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 2) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 refine (Rule.forallElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 1) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],
                 
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2) 
                     >>+ tac)
                 ]
             ]


      fun forallfutExtAuto binder a b m n tac =
         refine (Rule.forallfutExt a b m n)
         >>> [
             (* promote |- A : type *)
             refine (Rule.weaken 0 2)
             >>+
             idtacM Secondary,

             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,
             
             assert2 
                (T.apply2 Prim.ov b (T.app (T.Sub (m, T.shift1)) T.zero))
                (T.apply2 Prim.ov b (T.app (T.Sub (n, T.shift1)) T.zero))
             >>> [
                 refine (Rule.forallfutElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 2) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 refine (Rule.forallfutElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 1) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],
                 
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2) 
                     >>+ tac)
                 ]
             ]


      fun parametricExtAuto binder a b m n tac =
         refine (Rule.parametricExt a b m n)
         >>> [
             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,
             
             assert2 
                (T.apply2 Prim.ov b (T.apply2 Prim.paramapp (T.Sub (m, T.shift1)) T.zero))
                (T.apply2 Prim.ov b (T.apply2 Prim.paramapp (T.Sub (n, T.shift1)) T.zero))
             >>> [
                 refine (Rule.parametricElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 2) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 refine (Rule.parametricElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 1) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],
                 
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2) 
                     >>+ tac)
                 ]
             ]


      fun arrowExtAuto binder a b m n tac =
         refine (Rule.arrowExt a b m n)
         >>> [
             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,
             
             assert2
                (T.apply2 Prim.ov (T.Sub (b, T.shift1)) (T.app (T.Sub (m, T.shift1)) T.zero))
                (T.apply2 Prim.ov (T.Sub (b, T.shift1)) (T.app (T.Sub (n, T.shift1)) T.zero))
             >>> [
                 refine (Rule.arrowElimOf
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.shift1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 2) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 refine (Rule.arrowElimOf
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.shift1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 1) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],
                 
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2) 
                     >>+ tac)
                 ]
             ]


      fun tkarrowExtAuto extrule elimrule binder a b m n tac =
         refine (extrule a b m n)
         >>> [
             refine (Rule.weaken 0 2) >>+ idtacM Secondary,

             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,
             
             assert2
                (T.apply2 Prim.ov (T.Sub (b, T.shift1)) (T.app (T.Sub (m, T.shift1)) T.zero))
                (T.apply2 Prim.ov (T.Sub (b, T.shift1)) (T.app (T.Sub (n, T.shift1)) T.zero))
             >>> [
                 refine (elimrule
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.shift1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 2) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 refine (elimrule
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.shift1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 1) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],
                 
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2) 
                     >>+ tac)
                 ]
             ]


      fun intersectExtAuto binder a b m n tac =
         refine (Rule.intersectIntroEq a b m n)
         >>> [
             (* ... |- A : type *)
             refine (Rule.intersectFormInv1 a b)
             >>+
             (* ... |- intersect A . B : type *)
             refine (Rule.inhabitedForm (T.evar ()))
             >>+
             (* ... |- intersect A . B *)
             refine (Rule.inhabitant (T.evar ()) n)
             >>+
             (* ... |- N : intersect A . B *)
             refine (Rule.hypothesis 0) >> done,
             
             (* ..., A |- M[^] = N[^] : B *)
             assert2
                (T.apply2 Prim.ov b (T.Sub (m, T.shift1)))
                (T.apply2 Prim.ov b (T.Sub (n, T.shift1)))
             >>> [
                 (* ..., A |- M[^] : B = B[0 . ^2][0 . id] *)
                 refine (Rule.intersectElimOf
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.underShift 1 1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     (* ..., A |- M[^] : intersect A[^] . B[0 . ^2] *)
                     refine (Rule.hypothesis 2) >> done,

                     (* ..., A |- 0 : A[^] *)
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 (* ..., A |- N[^] : B = B[0 . ^2][0 . id] *)
                 refine (Rule.intersectElimOf
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.underShift 1 1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     (* ..., A |- N[^] : intersect A[^] . B[0 . ^2] *)
                     refine (Rule.hypothesis 1) >> done,

                     (* ..., A |- 0 : A[^] *)
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 (* ..., A, (M[^] : B), (N[^2] : B[0 . ^2]) |- ... *)
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2)
                     >>+ tac)
                 ]
             ]


      fun intersectfutExtAuto binder a b m n tac =
         refine (Rule.intersectfutIntroEq a b m n)
         >>> [
             (* promote |- A : type *)
             refine (Rule.weaken 0 2)
             >>+
             idtacM Secondary,

             assert2 
                (T.apply2 Prim.ov b (T.Sub (m, T.shift1)))
                (T.apply2 Prim.ov b (T.Sub (n, T.shift1)))
             >>> [
                 refine (Rule.intersectfutElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (m, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 2) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 refine (Rule.intersectfutElimOf 
                            (T.Sub (a, T.shift1))
                            (T.Sub (b, T.under 1 T.shift1))
                            (T.Sub (n, T.shift1))
                            T.zero)
                 >>> [
                     refine (Rule.hypothesis 1) >> done,
                     refine (Rule.hypothesisOf 0) >> done
                     ],
                 
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+ refine (Rule.weaken 3 2) 
                     >>+ tac)
                 ]
             ]


      fun guardExtAuto binder a b m n tac =
         refine (Rule.guardIntroEq a b m n)
         >>> [
             (* ... |- A : type *)
             refine (Rule.weaken 0 2)
             >>+
             idtacM Secondary,

             (* ..., A |- M[^] = N[^] : B[^] *)
             assert2 
                (T.apply2 Prim.ov (T.Sub (b, T.shift1)) (T.Sub (m, T.shift1)))
                (T.apply2 Prim.ov (T.Sub (b, T.shift1)) (T.Sub (n, T.shift1)))
             >>> [
                 (* ..., A |- M[^] : B[^] *)
                 refine (Rule.guardElimOf (T.Sub (a, T.shift1)) (T.evar ()) (T.evar ()))
                 >>> [
                     (* ..., A |- M[^] : A[^] -g> B[^] *)
                     refine (Rule.hypothesis 2) >> done,

                     (* ..., A |- A[^] *)
                     refine (Rule.hypothesis 0) >> done
                     ],

                 (* ..., A |- N[^] : B[^] *)
                 refine (Rule.guardElimOf (T.Sub (a, T.shift1)) (T.evar ()) (T.evar ()))
                 >>> [
                     (* ..., A |- N[^] : A[^] -g> B[^] *)
                     refine (Rule.hypothesis 1) >> done,

                     (* ..., A |- A[^] *)
                     refine (Rule.hypothesis 0) >> done
                     ],

                 (* ..., A, (M[^] : B[^]), (N[^2] : B[^2]) |- M[^3] = N[^3] : B[^3] *)
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bindh dir binder)
                     >>+
                     refine (Rule.weaken 3 2)
                     >>+
                     tac)
                 ]
             ]


      fun existsExtAuto a b m n tac1 tac2 =
         assert (T.apply3 Prim.eq a (T.pi1 m) (T.pi1 n))
         >>> [
             (* M #1 = N #1 : A *)
             assert2
                (T.apply2 Prim.ov a (T.pi1 m))
                (T.apply2 Prim.ov a (T.pi1 n))
             >>> [
                 (* M #1 : A *)
                 refine (Rule.existsElim1Of a b m)
                 >>+
                 (* M : exists A . B *)
                 refine (Rule.hypothesis 1) >> done,

                 (* N #1 : A *)
                 refine (Rule.existsElim1Of a b n)
                 >>+
                 refine (Rule.hypothesis 0) >> done,

                 refine (Rule.weaken 2 2)
                 >>+
                 tac1,
                 ],

             refine (Rule.existsExt 
                        (T.Sub (a, T.shift1))
                        (T.Sub (b, T.under 1 T.shift1))
                        (T.Sub (m, T.shift1))
                        (T.Sub (n, T.shift1)))
             >>> [
                 refine (Rule.hypothesis 2) >> done,
                 refine (Rule.hypothesis 1) >> done,
                 refine (Rule.hypothesis 0) >> done,

                 assert2
                    (T.apply2 
                        Prim.ov
                        (T.Sub (b, T.Dot (T.pi1 (T.Sub (m, T.shift1)), T.shift1)))
                        (T.pi2 (T.Sub (m, T.shift1))))
                    (T.apply2 
                        Prim.ov
                        (T.Sub (b, T.Dot (T.pi1 (T.Sub (m, T.shift1)), T.shift1)))
                        (T.pi2 (T.Sub (n, T.shift1))))
                 >>> [
                     (* M[^] #2 : B[M[^] #1 . ^] *)
                     refine (Rule.existsElim2Of 
                                (T.Sub (a, T.shift1))
                                (T.Sub (b, T.under 1 T.shift1))
                                (T.Sub (m, T.shift1)))
                     >>+ refine (Rule.hypothesis 2)
                     >> done,

                     (* N[^] #2 : B[M[^] #1 . ^] *)
                     refine (Rule.equivalenceOf
                                (T.Sub (b, T.Dot (T.pi1 (T.Sub (n, T.shift1)), T.shift1)))
                                (T.Sub (b, T.Dot (T.pi1 (T.Sub (m, T.shift1)), T.shift1)))
                                (T.pi2 (T.Sub (n, T.shift1))))
                     >>> [
                         refine (Rule.eqtpSymm (T.evar ()) (T.evar ()))
                         >>+
                         (* B[M[^] #1 . ^] = B[N[^] #1 . ^] : type *)
                         refine (Rule.existsFormInv2Eq
                                    (T.Sub (a, T.shift1))
                                    (T.Sub (b, T.under 1 T.shift1))
                                    (T.pi1 (T.Sub (m, T.shift1)))
                                    (T.pi1 (T.Sub (n, T.shift1))))
                         >>> [
                             (* exists A[^] . B[0 . ^2] : type *)
                             refine (Rule.inhabitedForm (T.evar ()))
                             >>+ refine (Rule.inhabitant (T.evar ()) (T.evar ()))
                             >>+ refine (Rule.hypothesis 2)
                             >> done,

                             refine (Rule.hypothesis 0) >> done
                             ],

                         refine (Rule.existsElim2Of 
                                    (T.Sub (a, T.shift1))
                                    (T.Sub (b, T.under 1 T.shift1))
                                    (T.Sub (n, T.shift1)))
                         >>+ refine (Rule.hypothesis 1)
                         >> done
                         ],

                     withgoal
                     (fn (_, dir) =>
                         chdir (D.bind0 dir)
                         >>+ refine (Rule.weaken 3 2) 
                         >>+ tac2)
                     ]
                 ]
             ]
             

      fun prodExtAuto a b m n tac1 tac2 =
         refine (Rule.prodExt a b m n)
         >>> [
             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,
             
             assert2
                (T.apply2 Prim.ov a (T.pi1 m))
                (T.apply2 Prim.ov a (T.pi1 n))
             >>> [
                 refine (Rule.prodElim1Of a b m)
                 >>+
                 refine (Rule.hypothesis 1) >> done,

                 refine (Rule.prodElim1Of a b n)
                 >>+
                 refine (Rule.hypothesis 0) >> done,

                 refine (Rule.weaken 2 2)
                 >>+
                 tac1
                 ],

             assert2
                (T.apply2 Prim.ov b (T.pi2 m))
                (T.apply2 Prim.ov b (T.pi2 n))
             >>> [
                 refine (Rule.prodElim2Of a b m)
                 >>+
                 refine (Rule.hypothesis 1) >> done,

                 refine (Rule.prodElim2Of a b n)
                 >>+
                 refine (Rule.hypothesis 0) >> done,

                 refine (Rule.weaken 2 2) 
                 >>+ 
                 tac2
                 ]
             ]


      fun setExtAuto a b m n tac =
         (* ... |- m = n : set a . b *)
         assert (T.apply2 Prim.forall a (T.Lam (NONE, T.apply1 Prim.istp b)))
         >>> [
             (* ... |- forall a . (b : type) *)
             refine (Rule.forallIntro a (T.apply1 Prim.istp b))
             >>> [
                 (* ... |- a : type *)
                 refine (Rule.setFormInv a b)
                 >>+
                 (* ... |- set a . b : type *)
                 refine (Rule.inhabitedForm (T.evar ()))
                 >>+
                 (* ... |- set a . b *)
                 refine (Rule.inhabitant (T.evar ()) m)
                 >>+
                 (* ... |- m : set a . b *)
                 refine (Rule.hypothesis 1) >> done,

                 (* a |- b : type *)
                 withgoal
                 (fn (_, dir) =>
                     chdir (D.bind0 dir)
                     >>
                     refine (Rule.weaken 1 2)
                     >>
                     idtacM Secondary),
                 ],

             (* ... forall a . (b : type) |- m[^] = n[^] : set a[^] . b[0 . ^2] *)
             refine (Rule.setElim
                        (T.Sub (a, T.shift1))
                        (T.Sub (b, T.under 1 T.shift1))
                        (T.evar ())
                        (T.Sub (m, T.shift1)))
             >>> [
                 (* ... forall a . (b : type), a[^] |- b[0 . ^2] *)
                 refine (Rule.forallElim 
                            (T.Sub (a, T.Shift 2))
                               (T.apply1 Prim.istp (T.Sub (b, T.under 1 (T.Shift 2))))
                            T.zero)
                 >>> [
                     (* ... forall a . (b : type), a[^] |- forall a[^2] . (b[0 . ^3] : type) *)
                     refine (Rule.hypothesis 1) >> done,

                     (* ... forall a . (b : type), a[^] |- 0 : a[^2] *)
                     refine (Rule.hypothesisOf 0) >> done,
                     ],

                 (* ... forall a . (b : type) |- m[^] : set a[^] . b[0 . ^2] *)
                 refine (Rule.hypothesis 2) >> done,

                 (* ... forall a . (b : type), b[0 . ^2][m[^] . id] (hidden) |- m[^2] = n[^2] : set a[^2] . b[0 . ^3]
                    ... forall a . (b : type), b[m[^] . ^] (hidden) |- m[^2] = n[^2] : set a[^2] . b[0 . ^3]
                 *)
                 refine (Rule.setIntroEq 
                            (T.Sub (a, T.Shift 2))
                            (T.Sub (b, T.under 1 (T.Shift 2)))
                            (T.Sub (m, T.Shift 2))
                            (T.Sub (n, T.Shift 2)))
                 >>> [
                     (* ... forall a . (b : type), __, a[^2] |- b[0 . ^3] : type 
                                                              = b[0 . ^4][0 . id]
                     *)
                     refine (Rule.forallElim 
                                (T.Sub (a, T.Shift 3))
                                (T.apply1 Prim.istp (T.Sub (b, T.under 1 (T.Shift 3))))
                                T.zero)
                     >>> [
                         (* ... forall a . (b : type), __, a[^2] |- forall a[^3] . (b[0 . ^4] : type) *)
                         refine (Rule.hypothesis 2) >> done,

                         (* ... forall a . (b : type), __, a[^2] |- 0 : a[^3] *)
                         refine (Rule.hypothesisOf 0) >> done
                         ],

                     (* ... __, __ |- m[^2] = n[^2] : a[^2] *)
                     assert2
                        (T.apply2 Prim.ov (T.Sub (a, T.Shift 2)) (T.Sub (m, T.Shift 2)))
                        (T.apply2 Prim.ov (T.Sub (a, T.Shift 2)) (T.Sub (n, T.Shift 2)))
                     >>> [
                         refine (Rule.setWeakenOf 
                                    (T.evar ())
                                    (T.Sub (b, T.under 1 (T.Shift 2)))
                                    (T.evar ()))
                         >>+
                         refine (Rule.hypothesis 3) >> done,

                         refine (Rule.setWeakenOf 
                                    (T.evar ())
                                    (T.Sub (b, T.under 1 (T.Shift 2)))
                                    (T.evar ()))
                         >>+
                         refine (Rule.hypothesis 2) >> done,

                         refine (Rule.weaken 2 4)
                         >>+
                         tac
                         ],

                     (* ... forall a . (b : type), b[m[^] . ^] |- b[0 . ^3][m[^2] . id]
                                                                = b[m[^2] . ^2]
                     *)
                     refine (Rule.hypothesis 0) >> done
                     ]
                 ]
             ]


      fun isetExtAuto a b m n tac =
         (* ... |- m = n : iset a . b *)
         refine (Rule.isetElim a b (T.evar ()) m)
         >>> [
             (* ... |- m : set a . b *)
             refine (Rule.hypothesis 1) >> done,

             (* ... b[m . id] (hidden) |- m[^] = n[^] : set a[^] . b[0 . ^2] *)
             refine (Rule.isetIntroEq 
                        (T.Sub (a, T.Shift 1))
                        (T.Sub (b, T.under 1 (T.Shift 1)))
                        (T.Sub (m, T.Shift 1))
                        (T.Sub (n, T.Shift 1)))
             >>> [
                 (* ... __, a[^] |- b[0 . ^2] : type *)
                 refine (Rule.isetFormInv2
                            (T.Sub (a, T.Shift 2))
                            (T.Sub (b, T.under 1 (T.Shift 2)))
                            T.zero)
                 >>> [
                     (* ... __, a[^] |- iset a[^2] . b[0 . ^3] : type *)
                     refine (Rule.weaken 0 2)
                     >>+
                     (* ... |- iset a . b : type *)
                     refine (Rule.inhabitedForm (T.evar ()))
                     >>+
                     (* ... |- iset a . b *) 
                     refine (Rule.inhabitant (T.evar ()) m)
                     >>+
                     (* ... |- m : iset a . b *)
                     refine (Rule.hypothesis 1) >> done,
                     
                     (* ... __, a[^] |- 0 : a[^2] *)
                     refine (Rule.hypothesisOf 0) >> done
                     ],

                 (* ... __ |- m[^] = n[^] : a[^] *)
                 assert2
                    (T.apply2 Prim.ov (T.Sub (a, T.shift1)) (T.Sub (m, T.shift1)))
                    (T.apply2 Prim.ov (T.Sub (a, T.shift1)) (T.Sub (n, T.shift1)))
                 >>> [
                     (* ... __ |- m[^] : a[^] *)
                     refine (Rule.isetWeakenOf 
                                (T.evar ())
                                (T.Sub (b, T.under 1 (T.Shift 1)))
                                (T.evar ()))
                     >>+
                     (* ... __ |- m : iset a[^] . b[0 . ^2] *)
                     refine (Rule.hypothesis 2) >> done,

                     (* ... __ |- n[^] : a[^] *)
                     refine (Rule.isetWeakenOf 
                                (T.evar ())
                                (T.Sub (b, T.under 1 (T.Shift 1)))
                                (T.evar ()))
                     >>+
                     (* ... __ |- n[^] : iset a[^] . b[0 . ^2] *)
                     refine (Rule.hypothesis 1) >> done,

                     refine (Rule.weaken 2 3)
                     >>+
                     tac
                     ],

                 (* ... b[m . id] |- b[0 . ^2][m[^] . id]
                                   = b[m[^] . ^]
                 *)
                 refine (Rule.hypothesis 0) >> done
                 ]
             ]


      fun unitExtAuto exttac =
         exttac
         >>> [
             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done
             ]


      val squashExtAuto =
         refine (Rule.squashExt (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             refine (Rule.hypothesis 1) >> done,
             refine (Rule.hypothesis 0) >> done,

             refine (Rule.weaken 0 2) >>+ idtacM Secondary
             ]


      fun introEqLoop l =
         (case l of
             [] =>
                refine (Rule.weaken 0 2) >>+ idtacM Primary

           | ident :: rest =>
                goalCaseT
                /| \Prim.eq\ ? ? ? =>
                   \(fnc ab m n =>
                        termCaseT (N.whnfHard ab)
                        /| \Prim.forall\ ? (fn . ?) =>
                           \(fnc a b =>
                                forallExtAuto ident a b m n (introEqLoop rest))\

                         | \Prim.parametric\ ? (fn . ?) =>
                           \(fnc a b =>
                                parametricExtAuto ident a b m n (introEqLoop rest))\

                         | \Prim.arrow\ ? ? =>
                           \(fnc a b =>
                                arrowExtAuto ident a b m n (introEqLoop rest))\

                         | \Prim.forallfut\ ? (fn . ?) =>
                           \(fnc a b =>
                                forallfutExtAuto ident a b m n (introEqLoop rest))\

                         | \Prim.tarrow\ ? ? =>
                           \(fnc a b =>
                                tkarrowExtAuto Rule.tarrowExt Rule.tarrowElimOf ident a b m n (introEqLoop rest))\

                         | \Prim.karrow\ ? ? =>
                           \(fnc a b =>
                                tkarrowExtAuto Rule.karrowExt Rule.karrowElimOf ident a b m n (introEqLoop rest))\

                         | \Prim.intersect\ ? (fn . ?) =>
                           \(fnc a b =>
                                intersectExtAuto ident a b m n (introEqLoop rest))\

                         | \Prim.intersectfut\ ? (fn . ?) =>
                           \(fnc a b =>
                                intersectfutExtAuto ident a b m n (introEqLoop rest))\

                         | \Prim.guard\ ? ? =>
                           \(fnc a b =>
                                guardExtAuto ident a b m n (introEqLoop rest))\

                         | _ =>
                           \(fnc => 
                                fail "introEq is not supported for this type")\
                        /)\

                 | _ =>
                   \(fnc =>
                        fail "not an introEq goal")\
                /)

      fun introEqPriority l =
         goalCaseT
         /| \Prim.eq\ ? ? ? =>
            \(fnc a m n =>
                 assert2
                    (T.apply2 Prim.ov a m)
                    (T.apply2 Prim.ov a n)
                 >>> [
                     idtacM Secondary,
                     idtacM Secondary,
                     introEqLoop l
                     ])\

          | _ =>
            \(fnc =>
                 fail "not an introEq goal")\
         /

      fun introEqRaw l = introEqPriority l >> idtac

      fun introEq l = TC.withTypecheckSnd $ introEqPriority l



      fun extensionalityAutoMain () =
         let
            val loop = lift extensionalityAutoMain
         in
            goalCaseT
            /| \Prim.eq\ ? ? ? =>
               \(fnc ab m n =>
                    termCaseT (N.whnf ab)
                    /| \Prim.forall\ ? (fn . ?) =>
                       \(fnc a b =>
                            forallExtAuto NONE a b m n loop)\
   
                     | \Prim.parametric\ ? (fn . ?) =>
                       \(fnc a b =>
                            parametricExtAuto NONE a b m n loop)\
   
                     | \Prim.arrow\ ? ? =>
                       \(fnc a b =>
                            arrowExtAuto NONE a b m n loop)\
   
                     | \Prim.forallfut\ ? (fn . ?) =>
                       \(fnc a b =>
                            forallfutExtAuto NONE a b m n loop)\
   
                     | \Prim.tarrow\ ? ? =>
                       \(fnc a b =>
                            tkarrowExtAuto Rule.tarrowExt Rule.tarrowElimOf NONE a b m n loop)\
   
                     | \Prim.karrow\ ? ? =>
                       \(fnc a b =>
                            tkarrowExtAuto Rule.karrowExt Rule.karrowElimOf NONE a b m n loop)\
   
                     | \Prim.intersect\ ? (fn . ?) =>
                       \(fnc a b =>
                            intersectExtAuto NONE a b m n loop)\
   
                     | \Prim.intersectfut\ ? (fn . ?) =>
                       \(fnc a b =>
                            intersectfutExtAuto NONE a b m n loop)\
   
                     | \Prim.exists\ ? (fn . ?) =>
                       \(fnc a b =>
                            existsExtAuto a b m n loop loop)\

                     | \Prim.prod\ ? ? =>
                       \(fnc a b =>
                            prodExtAuto a b m n loop loop)\

                     | \Prim.set\ ? (fn . ?) =>
                       \(fnc a b =>
                            setExtAuto a b m n loop)\

                     | \Prim.iset\ ? (fn . ?) =>
                       \(fnc a b =>
                            isetExtAuto a b m n loop)\

                     | \Prim.unit\ =>
                       \(fnc =>
                            unitExtAuto RT.unitExt)\

                     | \Prim.eq\ _ _ _ =>
                       \(fnc =>
                            unitExtAuto RT.eqExt)\

                     | \Prim.ov\ _ _ =>
                       \(fnc =>
                            unitExtAuto RT.ofExt)\

                     | \Prim.eqtp\ _ _ =>
                       \(fnc =>
                            unitExtAuto RT.eqtpExt)\

                     | \Prim.istp\ _ =>
                       \(fnc =>
                            unitExtAuto RT.istpExt)\

                     | \Prim.subtype\ _ _ =>
                       \(fnc =>
                            unitExtAuto RT.subtypeExt)\

                     | \Prim.squash\ _ =>
                       \(fnc =>
                            squashExtAuto)\

                     | (\Prim.manual\ _ | \Prim.manualf\ _ | \Prim.manuals\ _) =>
                       \(fnc =>
                            (* __, __ |- M = N : manual A *)
                            refine (Rule.weaken 0 2)
                            >>+
                            refine (Rule.reduce
                                       (R.within [1] (R.trans [R.unfold, R.beta 1])))
                            >>+
                            idtacM Primary)\

                     | _ =>
                       \(fnc =>
                            (* __, __ |- M = N : A *)
                            refine (Rule.weaken 0 2)
                            >>+
                            idtacM Primary)\
                    /)\

             | _ =>
               \(fnc =>
                    raise (Fail "unexpected goal in extensionalityAuto"))\
            /
         end


      val extensionalityAutoPriority =
         goalCaseT
         /| \Prim.eq\ ? ? ? =>
            \(fnc a m n =>
                 assert2
                    (T.apply2 Prim.ov a m)
                    (T.apply2 Prim.ov a n)
                 >>> [
                     idtacM Secondary,
                     idtacM Secondary,
                     extensionalityAutoMain ()
                     ])\

          | _ =>
            \(fnc =>
                 fail "not an extensionalityAuto goal")\
         /

      val extensionalityAutoRaw = extensionalityAutoPriority >> idtac

      val extensionalityAuto = TC.withTypecheckSnd extensionalityAutoPriority



      fun existsEqPriority em =
         let
            do m = withterm em
         in
            goalCaseT
            /| \Prim.eq\ ? _ _ =>
               \(fnc a =>
                    termCaseT (N.whnfHard a)
                    /| \Prim.union\ _ (fn ? . _) =>
                       \(fnc binder =>
                            refine (Rule.unionIntroEq (T.evar ()) (T.evar ()) m (T.evar ()) (T.evar ()))
                            >>> [
                                (* A |- B : type *)
                                withgoal
                                (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Secondary),

                                (* M : A *)
                                idtacM Secondary,

                                (* N = N' : B[M . id] *)
                                idtacM Primary
                                ])\

                     | \Prim.iexists\ _ _ (fn ? . _) =>
                       \(fnc binder =>
                            refine (Rule.iexistsIntroEq (T.evar ()) m (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                            >>> [
                                (* K : kind i *)
                                idtacM Secondary,

                                (* K |- A : type *)
                                withgoal
                                (fn (_, dir) => chdir (D.bindVary dir binder) >>+ idtacM Secondary),

                                (* M : K *)
                                idtacM Secondary,

                                (* M = N : A[M . id] *)
                                idtacM Primary
                                ])\

                     | _ =>
                       \(fnc =>
                            fail "existsEq is not supported for this type")\
                    /)\

             | _ =>
               \(fnc =>
                    fail "not an existsEq goal")\
            /
         end

      fun existsEqRaw em = existsEqPriority em >> idtac

      fun existsEq em = Typecheck.withTypecheckSnd (existsEqPriority em)



      val univIntroEqtype = RuleTactic.univIntroEqtype


      fun substitutionLiteralPriority i m =
         let
            val m' = T.evar ()

            val maingoal =
               let
                  do (_, dir) = withgoal
  
                  (* We just used hypothesis i, so it has to be in the directory unless it is corrupt. *)
                  val (d3, d12) = D.split dir i
               in
                  chdir (List.foldl (fns sym d => D.bind d sym) (D.tl d12) d3)
                  >> idtacM Primary
               end
         in
            if Unify.unify1 m (T.Sub (m', T.Shift (i+1))) then
               cut $
               first
                  [
                  (* If the substitute variable doesn't appear in the conclusion,
                     use the better rule.
                  *)
                  refine (Rule.substitutionSimple i (T.evar ()) (T.evar ()) m')
                  >>> [
                      idtacM Primary,
                      maingoal
                      ],

                  refine (Rule.substitution i (T.evar ()) (T.evar ()) m')
                  >>> [
                      idtacM Secondary,
                      idtacM Primary,
                      maingoal
                      ]
                   ]
            else
               fail "substitutend depends on later hypotheses"
         end
                
      fun substitutionLiteral i m = substitutionLiteralPriority i m >> idtac
                
      fun substitutionPriority hyp em =
         let
            do i = Hyp.findhyp hyp
            do m = withterm em
         in
            substitutionLiteralPriority i m
         end

      fun substitutionRaw hyp em = substitutionPriority hyp em >> idtac

      fun substitution hyp em =
         TC.withTypecheckSnd $ substitutionPriority hyp em



      fun substMain reverse cautious i j m =
         let
            val m' = T.evar ()

            val eqgoal =
               cut $ setFailure "type mismatch in substitution" $
                  (if reverse then
                      refine (Rule.eqSymm (T.evar ()) (T.evar ()) (T.evar ()))
                      >> refine (Rule.hypothesis j) >> done
                   else
                      refine (Rule.hypothesis j) >> done)

            val maingoal =
               let
                  do (_, dir) = withgoal
  
                  (* We just used hypotheses i and j, so they have to be there.
                     They also have to be in the directory unless it is corrupt.
                     Moreover, j depends on i, so j < i
                  *)
                  val (d5, d1234) = D.split dir j
                  val (d3, d12) = D.split (D.tl d1234) (i - j - 1)
                  val d1 = D.tl d12
  
                  val dir' =
                     List.foldl
                        (fns sym d => D.bind d sym)
                        (List.foldl 
                            (fns sym d => D.bind d sym)
                            d1
                            d3)
                        d5
               in
                  refine (Rule.weaken j 1)
                  >> chdir dir'
                  >> idtacM Primary
               end
         in
            if Unify.unify1 m (T.Sub (m', T.Shift (i+1))) then
               cut $
               first
                  [
                  (* If the substitution variable doesn't appear in the conclusion,
                     use the better rule.
                  *)
                  refine (Rule.substitutionSimple i (T.evar ()) (T.evar ()) m')
                  >>> [
                      eqgoal,
                      maingoal
                      ],
   
                  if cautious then
                     fail "in cautious substitution, variable appears in conclusion"
                  else
                     refine (Rule.substitution i (T.evar ()) (T.evar ()) m')
                     >>> [
                         idtacM Secondary,
                         eqgoal,
                         maingoal
                         ]
                  ]
            else
               fail "substitutend depends on later hypotheses"
         end


      fun synsubstMain reverse i j m =
         let
            val m' = T.evar ()

            val eqgoal =
               cut $ setFailure "type mismatch in substitution" $
                  (if reverse then
                      refine (Rule.sequalSymm (T.evar ()) (T.evar ()))
                      >> refine (Rule.hypothesis j) >> done
                   else
                      refine (Rule.hypothesis j) >> done)

            val maingoal =
               let
                  do (_, dir) = withgoal
  
                  (* We just used hypotheses i and j, so they have to be there.
                     They also have to be in the directory unless it is corrupt.
                     Moreover, j depends on i, so j < i
                  *)
                  val (d5, d1234) = D.split dir j
                  val (d3, d12) = D.split (D.tl d1234) (i - j - 1)
                  val d1 = D.tl d12
  
                  val dir' =
                     List.foldl
                        (fns sym d => D.bind d sym)
                        (List.foldl 
                            (fns sym d => D.bind d sym)
                            d1
                            d3)
                        d5
               in
                  refine (Rule.weaken j 1)
                  >> chdir dir'
                  >> idtacM Primary
               end
         in
            if Unify.unify1 m (T.Sub (m', T.Shift (i+1))) then
               refine (Rule.substitutionSyntactic i (T.evar ()) (T.evar ()) m')
               >>> [
                   eqgoal,
                   maingoal
                   ]
            else
               fail "substitutend depends on later hypotheses"
         end


      fun substFlexPriority strict cautious hyps =
         (case hyps of
             [] =>
                idtacM Primary

           | hyp :: rest =>
                let
                   do i = Hyp.findhyp hyp
                in
                   first
                      [
                      goalHypCaseT i
                      / $let _ =>
                        \(fnc =>
                             let
                                do (_, dir) = withgoal
                                val (d3, d12) = D.split dir i
                             in
                                refine (Rule.letSubst i)
                                >> chdir (D.binds (D.tl d12) d3)
                                >> idtacM Primary
                             end)\
                      /,
       
                      goalContextnCaseT
                      /| $tm \Prim.eq\ _ ($var \i\) ? =>
                         \(fnc j m =>
                              if strict then
                                 substMain false cautious i j m
                              else
                                 Hyp.moveTermDeps m i
                                 >>+
                                 (* j cannot have moved, but i and m are probably different now *)
                                 goalHypCaseT j
                                 / $tm \Prim.eq\ _ var? ? =>
                                   \(fnc i' m' =>
                                        substMain false cautious i' j m')\
                                 /)\
         
                       | $tm \Prim.eq\ _ ? ($var \i\) =>
                         \(fnc j m =>
                              if strict then
                                 substMain true cautious i j m
                              else
                                 Hyp.moveTermDeps m i
                                 >>+
                                 (* j cannot have moved, but i and m are probably different now *)
                                 goalHypCaseT j
                                 / $tm \Prim.eq\ _ ? var? =>
                                   \(fnc m' i' =>
                                        substMain true cautious i' j m')\
                                 /)\

                       | $tm \Prim.sequal\ ($var \i\) ? =>
                         \(fnc j m =>
                              if strict then
                                 synsubstMain false i j m
                              else
                                 Hyp.moveTermDeps m i
                                 >>+
                                 (* j cannot have moved, but i and m are probably different now *)
                                 goalHypCaseT j
                                 / $tm \Prim.sequal\ var? ? =>
                                   \(fnc i' m' =>
                                        synsubstMain false i' j m')\
                                 /)\

                       | $tm \Prim.sequal\ ? ($var \i\) =>
                         \(fnc j m =>
                              if strict then
                                 synsubstMain true i j m
                              else
                                 Hyp.moveTermDeps m i
                                 >>+
                                 (* j cannot have moved, but i and m are probably different now *)
                                 goalHypCaseT j
                                 / $tm \Prim.sequal\ ? var? =>
                                   \(fnc m' i' =>
                                        synsubstMain true i' j m')\
                                 /)\
                      /,
       
                      fail "no eligible equality hypothesis found"
                      ]
                   >>!
                   substFlexPriority strict cautious rest
                end)

      val substPriority = substFlexPriority false false

      fun substRaw hyp = substPriority hyp >> idtac

      fun subst hyp =
         TC.withTypecheckSnd $ substPriority hyp

      val substStrictPriority = substFlexPriority true false

      fun substStrictRaw hyp = substStrictPriority hyp >> idtac

      fun substStrict hyp =
         TC.withTypecheckSnd $ substStrictPriority hyp

      val substCautiousPriority = substFlexPriority false true

      fun substCautiousRaw hyp = substCautiousPriority hyp >> idtac

      fun substCautious hyp =
         TC.withTypecheckSnd $ substCautiousPriority hyp

      val substCautiousStrictPriority = substFlexPriority true true

      fun substCautiousStrictRaw hyp = substCautiousStrictPriority hyp >> idtac

      fun substCautiousStrict hyp =
         TC.withTypecheckSnd $ substCautiousStrictPriority hyp

      val substAll =
         repeat $
         goalContextnCaseT
         / $tm (\Prim.eq\ _ var? _ | \Prim.eq\ _ _ var?) =>
           \(fnc _ x => subst [Hyp.NUMBER x])\
         /


      fun ofEquands hyp pat =
         let
            do i = Hyp.findhyp hyp
            do (_, dir) = withgoal
         in
            (case pat of
                IP.And [pat1, pat2] =>
                   goalHypCaseT i
                   /| $tm \Prim.eq\ ? ? ? =>
                      \(fnc a m n =>
                           let
                              do (do1, i', s, dir1) =
                                 tryf
                                 (fn () =>
                                     (case pat1 of
                                         IP.Wild => 
                                            (false, i, T.id, dir)
    
                                       | IP.Ident symopt =>
                                            (true, i+1, T.shift1, D.bindh dir symopt)
    
                                       | _ =>
                                            raise (Tryf "unexpected pattern for ofEquands")))

                              do (do2, dir2) =
                                 tryf
                                 (fn () =>
                                     (case pat2 of
                                         IP.Wild =>
                                            (false, dir1)
    
                                       | IP.Ident symopt =>
                                            (true, D.bindh dir1 symopt)
    
                                       | _ =>
                                            raise (Tryf "unexpected pattern for ofEquands")))
                           in
                              (if do1 then
                                  refine (Rule.assert (T.apply2 Prim.ov a m) (T.evar ()))
                                  >>> [
                                      (* M : A *)
                                      refine (Rule.ofEquand1 (T.evar ()) (T.evar ()) (T.evar ()))
                                      >>+
                                      (* M = N : A *)
                                      refine (Rule.hypothesis i) >> done,
 
                                      idtac
                                      ]
                               else
                                  idtac)
                              >>+
                              (if do2 then
                                  refine (Rule.assert (T.Sub (T.apply2 Prim.ov a n, s)) (T.evar ()))
                                  >>> [
                                      refine (Rule.ofEquand2 (T.evar ()) (T.evar ()) (T.evar ()))
                                      >>+
                                      refine (Rule.hypothesis i') >> done,
 
                                      idtac
                                      ]
                               else
                                  idtac)
                              >>+
                              chdir dir2
                           end)\

                    | _ =>
                      \(fnc =>
                           fail "not an equality hypothesis")\
                   /

              | _ =>
                   fail "unexpected pattern for ofEquands")
         end



      val injectionTactics : (int -> priority tacticm) H.table = H.table ()

      fun injectionPriority hyp =
         let
            do i = Hyp.findhyp hyp
            do (jud, _) = withgoal
         in
            hypCaseT (J.hyp jud i)
            /| $tm \Prim.eq\ ($whnfHard $as const? @ _) ? ? =>
               \(fnc a const m n =>
                    (case H.find injectionTactics const of
                        SOME tac => 
                           replaceHyp i (J.Tm (T.apply3 Prim.eq a m n))
                           >>+
                           tac i
   
                      | NONE => fail "not an injectible hypothesis"))\
   
             | _ =>
               \(fnc => fail "not an injectible hypothesis")\
            /
         end

      fun injectionRaw hyp = injectionPriority hyp >> idtac

      fun injection hyp = TC.withTypecheckSnd $ injectionPriority hyp



      (* i : M = N : bool *)
      fun injectionBool i =
         goalHypCaseT i
         / $tm \Prim.eq\ @ $ap \Prim.bool\
           (
              $ap \Prim.tru\ $ap \Prim.fals\ $nil =>
              \(fnc =>
                   refine (Rule.voidElim (T.evar ()))
                   >>
                   (* void *)
                   refine (Rule.equivalence (T.Const Prim.unit) (T.Const Prim.void))
                   >>> [
                       (* unit = void : type *)
                       refine (Rule.boolElimEqtype
                                  (T.Const Prim.unit) (T.Const Prim.unit)
                                  (T.Const Prim.void) (T.Const Prim.void)
                                  (T.Const Prim.tru) (T.Const Prim.fals))
                       >>> [
                           (* true = false : bool *)
                           refine (Rule.hypothesis i),

                           (* A |- unit = unit : type *)
                           refine Rule.unitEq,
  
                           (* A |- void = void : type *)
                           refine Rule.voidEq 
                           ],

                       (* unit *)
                       refine Rule.unitIntro
                       ])\

            | $ap \Prim.fals\ $ap \Prim.tru\ $nil =>
              \(fnc =>
                   refine (Rule.voidElim (T.evar ()))
                   >>
                   (* void *)
                   refine (Rule.equivalence (T.Const Prim.unit) (T.Const Prim.void))
                   >>> [
                       (* unit = void : type *)
                       refine (Rule.boolElimEqtype
                                  (T.Const Prim.void) (T.Const Prim.void)
                                  (T.Const Prim.unit) (T.Const Prim.unit)
                                  (T.Const Prim.fals) (T.Const Prim.tru))
                       >>> [
                           (* false = true : bool *)
                           refine (Rule.hypothesis i),

                           (* A |- void = void : type *)
                           refine Rule.voidEq,

                           (* A |- unit = unit : type *)
                           refine Rule.unitEq
                           ],

                       (* unit *)
                       refine Rule.unitIntro
                       ])\

            | $ap \Prim.tru\ $ap \Prim.tru\ $nil =>
              \(fnc => idtac)\

            | $ap \Prim.tru\ $ap \Prim.tru\ $nil =>
              \(fnc => idtac)\
           )

          | _ => \(fnc => fail "not an injection expression")\
         /


      (* i : M = N : nat *)
      fun injectionNat i =
         goalHypCaseT i
         / $tm \Prim.eq\ @ $ap \Prim.nat\
           (
              $ap \Prim.zero\ $ap \Prim.zero\ $nil =>
              \(fnc => idtac)\

            | $ap \Prim.zero\ $ap (\Prim.succ\ ?) $nil =>
              \(fnc n =>
                   refine (Rule.natContradiction (T.evar ()) n)
                   >>+
                   refine (Rule.hypothesis i))\

            | $ap (\Prim.succ\ ?) $ap \Prim.zero\ $nil =>
              \(fnc n =>
                   refine (Rule.natContradiction (T.evar ()) n)
                   >>+
                   refine (Rule.eqSymm (T.evar ()) (T.evar ()) (T.evar ()))
                   >>+
                   refine (Rule.hypothesis i))\

            | $ap (\Prim.succ\ ?) $ap (\Prim.succ\ ?) $nil =>
              \(fnc m n =>
                   refine (Rule.assert' (T.apply3 Prim.eq (T.Const Prim.nat) m n) (T.evar ()))
                   >>> [
                       (* M = N : nat *)
                       refine (Rule.natInjection m n)
                       >>+
                       (* succ M = succ N : nat *)
                       refine (Rule.hypothesis i),

                       withgoal (fn (_, dir) => chdir (D.bind0 dir))
                       ])\
           )

          | _ => \(fnc => fail "not an injection expression")\
         /



      (* i : M = N : A % B *)
      fun injectionSum i =
         goalHypCaseT i
         / $tm \Prim.eq\ @ $ap (\Prim.sum\ ? ?)
           (
              $ap (\Prim.inl\ ?) $ap (\Prim.inl\ ?) $nil =>
              \(fnc a b m n =>
                   refine (Rule.assert' (T.apply3 Prim.eq a m n) (T.evar ()))
                   >>> [
                       (* M = N : A *)
                       refine (Rule.sumInjection1 a b m n)
                       >>+
                       (* inl M = inl N : A % B *)
                       refine (Rule.hypothesis i),

                       withgoal (fn (_, dir) => chdir (D.bind0 dir))
                       ])\

            | $ap (\Prim.inr\ ?) $ap (\Prim.inr\ ?) $nil =>
              \(fnc a b m n =>
                   refine (Rule.assert' (T.apply3 Prim.eq b m n) (T.evar ()))
                   >>> [
                       (* M = N : B *)
                       refine (Rule.sumInjection2 a b m n)
                       >>+
                       (* inr M = inr N : A % B *)
                       refine (Rule.hypothesis i),

                       withgoal (fn (_, dir) => chdir (D.bind0 dir))
                       ])\

            | $ap (\Prim.inl\ ?) $ap (\Prim.inr\ ?) $nil =>
              \(fnc a b m n =>
                   refine (Rule.sumContradiction a b (T.evar ()) m n)
                   >>+
                   refine (Rule.hypothesis i))\
                 
            | $ap (\Prim.inr\ ?) $ap (\Prim.inl\ ?) $nil =>
              \(fnc a b m n =>
                   refine (Rule.sumContradiction a b (T.evar ()) n m)
                   >>+
                   refine (Rule.eqSymm (T.evar ()) (T.evar ()) (T.evar ()))
                   >>+
                   refine (Rule.hypothesis i))\
           )

          | _ => \(fnc => fail "not an injection expression")\
         /


      (* i : M = N : exists A . B *)
      fun injectionExists i =
         goalHypCaseT i
         /| $tm \Prim.eq\ (\Prim.exists\ ? (fn . ?)) ($as (? , ?)) ($as (? , ?)) =>
            \(fnc a b m m1 m2 n n1 n2 =>
                 refine (Rule.assert (T.apply3 Prim.eq a m1 n1) (T.evar ()))
                 >>> [
                     (* M1 = N1 : A *)
                     refine (Rule.existsElim1Eq a b m n)
                     >>
                     (* M = N : exists A . B *)
                     refine (Rule.hypothesis i),

                     (* M1 = N1 : A |- C *)
                     refine (Rule.assert 
                                (T.apply3 Prim.eq 
                                    (T.Sub (b, T.Dot (T.Sub (m1, T.shift1), T.shift1)))
                                    (T.Sub (m2, T.shift1))
                                    (T.Sub (n2, T.shift1)))
                                (T.evar ()))
                     >>> [
                         (* blah |- M2[^] = N2[^] : B[M1[^] . ^] *)
                         refine (Rule.existsElim2Eq
                                    (T.Sub (a, T.shift1))
                                    (T.Sub (b, T.under 1 T.shift1))
                                    (T.Sub (m, T.shift1))
                                    (T.Sub (n, T.shift1)))
                         >>
                         (* blah |- M[^] = N[^] : (exists A . B)[^] *)
                         refine (Rule.hypothesis (i+1)),

                         withgoal (fn (_, dir) => chdir (D.bind0 (D.bind0 dir)))
                         ]
                     ])\

          | _ => \(fnc => fail "not an injection expression")\
         /


      (* i : M = N : A & B *)
      fun injectionProd i =
         goalHypCaseT i
         /| $tm \Prim.eq\ (\Prim.prod\ ? ?) ($as (? , ?)) ($as (? , ?)) =>
            \(fnc a b m m1 m2 n n1 n2 =>
                 refine (Rule.assert (T.apply3 Prim.eq a m1 n1) (T.evar ()))
                 >>> [
                     (* M1 = N1 : A *)
                     refine (Rule.prodElim1Eq a b m n)
                     >>
                     (* M = N : A & B *)
                     refine (Rule.hypothesis i),

                     (* M1 = N1 : A |- C *)
                     refine (Rule.assert 
                                (T.apply3 Prim.eq 
                                    (T.Sub (b, T.shift1))
                                    (T.Sub (m2, T.shift1))
                                    (T.Sub (n2, T.shift1)))
                                (T.evar ()))
                     >>> [
                         (* blah |- M2[^] = N2[^] : B[^] *)
                         refine (Rule.prodElim2Eq
                                    (T.Sub (a, T.shift1))
                                    (T.Sub (b, T.shift1))
                                    (T.Sub (m, T.shift1))
                                    (T.Sub (n, T.shift1)))
                         >>
                         (* blah |- M[^] = N[^] : (A & B)[^] *)
                         refine (Rule.hypothesis (i+1)),

                         withgoal (fn (_, dir) => chdir (D.bind0 (D.bind0 dir)))
                         ]
                     ])\

          | _ => \(fnc => fail "not an injection expression")\
         /


      (* i : M = N : { A | B } *)
      fun injectionSet i =
         let
            do (_, dir) = withgoal
         in
            goalHypCaseT i
            /| $tm \Prim.eq\ (\Prim.set\ ? (fn . ?)) ? ? =>
               \(fnc a b m n =>
                    (* |- C *)
                    refine (Rule.assert (T.apply2 Prim.forall a (T.Lam (NONE, T.apply1 Prim.istp b))) (T.evar ()))
                    >>> [
                        (* |- forall A . (B : type) *)
                        refine (Rule.forallIntro (T.evar ()) (T.evar ()))
                        >>> [
                            (* |- A : type *)
                            refine (Rule.setFormInv a b)
                            >>
                            (* |- set A . B : type *)
                            refine (Rule.inhabitedForm (T.evar ()))
                            >>
                            (* |- set A . B *)
                            refine (Rule.inhabitant (T.evar ()) m)
                            >>
                            (* |- M : set A . B *)
                            refine (Rule.ofEquand1 (T.evar ()) m n)
                            >>
                            (* |- M = N : set A . B *)
                            refine (Rule.hypothesis i) >> done,

                            (* A |- B : type *)
                            chdir (D.bind0 dir) >> idtacM Secondary
                            ],

                        (* forall A . (B : type) |- C[^] *)
                        refine (Rule.assert (T.Sub (T.apply3 Prim.eq a m n, T.shift1)) (T.evar ()))
                        >>> [
                            (* forall A . (B : type) |- M[^] = N[^] : A[^] *)
                            refine (Rule.setWeakenEq (T.Sub (a, T.shift1)) (T.Sub (b, T.under 1 T.shift1)) (T.Sub (m, T.shift1)) (T.Sub (n, T.shift1)))
                            >>
                            refine (Rule.hypothesis (i+1)) >> done,

                            (* forall A . (B : type), M[^] = N[^] : A[^] |- C[^2] *)
                            refine (Rule.setElim (T.Sub (a, T.Shift 2)) (T.Sub (b, T.under 1 (T.Shift 2))) (T.evar ()) (T.Sub (m, T.Shift 2)))
                            >>> [
                                (* forall A . (B : type), M[^] = N[^] : A[^], A[^2] |- B[0 . ^3] : type
                                                                                     = (B[0 . ^ 4] : type)[0 . id]
                                *)
                                refine (Rule.forallElim (T.Sub (a, T.Shift 3)) (T.apply1 Prim.istp (T.Sub (b, T.under 1 (T.Shift 3)))) T.zero)
                                >>> [
                                    refine (Rule.hypothesis 2) >> done,

                                    refine (Rule.hypothesisOf 0) >> done
                                    ],
                                
                                (* forall A . (B : type), M[^] = N[^] : A[^] |- M[^2] : set A[^2] . B[0 . ^3] *)
                                refine (Rule.ofEquand1 (T.evar ()) (T.evar ()) (T.Sub (n, T.Shift 2)))
                                >>
                                (* forall A . (B : type), M[^] = N[^] : A[^] |- M[^2] = N[^2] : set A[^2] . B[0 . ^3] *)
                                refine (Rule.hypothesis (i+2)) >> done,
                                
                                (* forall A . (B : type), M[^] = N[^] : A[^], B[M[^2] . ^2] |- C[^3] *)
                                refine (Rule.setElim (T.Sub (a, T.Shift 3)) (T.Sub (b, T.under 1 (T.Shift 3))) (T.evar ()) (T.Sub (n, T.Shift 3)))
                                >>> [
                                    (* forall A . (B : type), M[^] = N[^] : A[^], B[M[^2] . ^2], A[^3] |- B[0 . ^4] : type
                                                                                                        = (B[0 . ^ 5] : type)[0 . id]
                                    *)
                                    refine (Rule.forallElim (T.Sub (a, T.Shift 4)) (T.apply1 Prim.istp (T.Sub (b, T.under 1 (T.Shift 4)))) T.zero)
                                    >>> [
                                        refine (Rule.hypothesis 3) >> done,
    
                                        refine (Rule.hypothesisOf 0) >> done
                                        ],
                                    
                                    (* forall A . (B : type), M[^] = N[^] : A[^], B[M[^2] . ^2] |- M[^3] : set A[^3] . B[0 . ^4] *)
                                    refine (Rule.ofEquand2 (T.evar ()) (T.Sub (m, T.Shift 3)) (T.evar ()))
                                    >>
                                    (* forall A . (B : type), M[^] = N[^] : A[^], B[M[^2] . ^2] |- M[^3] = N[^3] : set A[^3] . B[0 . ^4] *)
                                    refine (Rule.hypothesis (i+3)) >> done,
                                    
                                    (* forall A . (B : type), M[^] = N[^] : A[^], B[M[^2] . ^2], B[N[^3] . ^3] |- C[^4] *)
                                    refine (Rule.weaken 3 1)
                                    >>
                                    (* M = N : A, B[M[^] . ^], B[N[^2] . ^2] |- C[^3] *)
                                    chdir (D.bind0s dir 3) >> idtacM Primary
                                    ]
                                ]
                            ]
                        ])\
             | _ => \(fnc => fail "not an injection expression")\
            /
         end


      (* i : M = N : quotient A (fn . fn . B) *)
      fun injectionQuotient i =
         let
            do (_, dir) = withgoal
         in
            goalHypCaseT i
            /| $tm \Prim.eq\ (\Prim.quotient\ ? (fn . fn . ?)) ? ? =>
               \(fnc a b m n =>
                    (* |- C *)
                    refine (Rule.quotientDescent a b (T.evar ()) m n)
                    >>> [
                        (* A, A[^] |- B : type *)
                        chdir (D.bind0s dir 2) >> idtacM Secondary,

                        (* C : type *)
                        idtacM Secondary,

                        (* M : A *)
                        idtacM Secondary,

                        (* N : A *)
                        idtacM Secondary,

                        (* M = N : quotient A (fn . fn . B) *)
                        refine (Rule.hypothesis i) >> done,

                        (* B [N . M . id]  |- C[^] *)
                        chdir (D.bind0 dir) >> idtacM Primary
                        ])\

             | _ => \(fnc => fail "not an injection expression")\
            /
         end


      (* i : next M = next N : future A *)
      fun injectionFuture i =
         goalHypCaseT i
         /| $tm \Prim.eq\ (\Prim.future\ ?) (next ?) (next ?) =>
            \(fnc a m n =>
                 refine (Rule.assert (T.apply1 Prim.future (T.apply3 Prim.eq a m n)) (T.evar ()))
                 >>>
                    [
                    (* future (M = N : A) *)
                    refine (Rule.futureInjection a m n)
                    >>>
                       [
                       (* promote |- A : type *)
                       idtacM Secondary,

                       (* next M = next N : future A *)
                       refine (Rule.hypothesis i) >> done
                       ],

                    withgoal (fn (_, dir) => chdir (D.bind0 dir) >> idtacM Primary)
                    ])\

          | _ => \(fnc => fail "not an injection expression")\
         /

      val () =
         List.app (fn (const, tac) => H.insert injectionTactics const (fn hyp => tac hyp >> idtacM Primary))
         [
         (Prim.bool, injectionBool),
         (Prim.nat, injectionNat),
         (Prim.sum, injectionSum),
         (Prim.exists, injectionExists),
         (Prim.prod, injectionProd)
         ]

      val () =
         List.app (fn (const, tac) => H.insert injectionTactics const tac)
         [
         (Prim.set, injectionSet),
         (Prim.quotient, injectionQuotient),
         (Prim.future, injectionFuture)
         ]

   end


structure EqualityTactic :> EQUALITY_TACTIC = EqualityTacticInternal
