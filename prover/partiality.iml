
signature PARTIALITY =
   sig

      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority

      val typecheckFixpoint : tactic
      val typecheckFixpointRaw : tactic
      val typecheckFixpointPriority : priority tacticm

      val termination : Hyp.hypothesis -> tactic
      val terminationRaw : Hyp.hypothesis -> tactic
      val terminationPriority : Hyp.hypothesis -> priority tacticm

      val partiality : Hyp.hypothesis -> tactic
      val partialityRaw : Hyp.hypothesis -> tactic
      val partialityPriority : Hyp.hypothesis -> priority tacticm

      val tightenPartial : Hyp.hypothesis -> tactic
      val tightenPartialRaw : Hyp.hypothesis -> tactic
      val tightenPartialPriority : Hyp.hypothesis -> priority tacticm

      val totality : tactic
      val totalityRaw : tactic
      val totalityPriority : priority tacticm

      val proveAdmiss1Raw : tactic
      val proveAdmiss1 : tactic
      val uptypeAdmiss : tactic

      val proveAdmissPriority : priority tacticm
      val proveAdmissRaw : tactic
      val proveAdmiss : tactic

      val establishUptype : Constant.constant -> unit

      val admissTactics : tactic ConstantTable.table
      val uptypeTactics : tactic ConstantTable.table

   end


structure Partiality :> PARTIALITY =
   struct

      structure H = ConstantTable
      structure J = Judgement
      structure RT = RuleTactic
      structure R = Reduction
      structure T = Term
      structure D = Directory

      open Tactic
      open RefineTactic
      open CasePervasive


      exception Partiality of string

      fun signalError msg = raise (Partiality
                                      (String.concat
                                          [
                                          "Error: ",
                                          msg,
                                          ".\n"
                                          ]))

      val () =
         Handler.customHandler
         (fn Partiality msg => (print msg; true)
           | _ => false)


      val admissTactics : tactic H.table = H.table ()      
      val uptypeTactics : tactic H.table = H.table ()      


      val uptypeAdmiss = RuleTactic.uptypeAdmiss


      val unsh = Prune.Pundef (Prune.Pshift 0)
      
      fun proveAdmiss1Loop () =
         goalCaseT
         /| \Prim.uptype\ (const? @ _) =>
            \(fnc const =>
                 (case H.find uptypeTactics const of
                     SOME tac => tac

                   | NONE => 
                        (case Constant.definition const of
                            SOME _ =>
                               refine (Rule.reduce (R.within [1] (R.trans [R.unfold, R.betas])))
                               >>+
                               lift proveAdmiss1Loop

                          | NONE =>
                               fail ("no uptype rule for " ^ Namespace.toString const))))\

          | \Prim.admiss\ (const? @ _) =>
            \(fnc const =>
                 (case H.find admissTactics const of
                     SOME tac => tac

                   | NONE =>
                        (case Constant.definition const of
                            SOME _ =>
                               refine (Rule.reduce (R.within [1] (R.trans [R.unfold, R.betas])))
                               >>+
                               lift proveAdmiss1Loop

                          | NONE =>
                               fail ("no admissibility rule for " ^ Namespace.toString const))))\

          | \Prim.padmiss\ ? (fn . ?) =>
            \(fnc a b =>
                 (case Prune.prune b unsh of
                     SOME bunsh =>
                        refine (Rule.padmissClosed a bunsh)

                   | NONE =>
                        termCaseT b
                        /| \Prim.forall\ ?  (fn . ?) =>
                           \(fnc dom cod =>
                                (case Prune.prune dom unsh of
                                    SOME domunsh =>
                                       RuleTactic.forallPadmissDomainClosed domunsh

                                  | NONE =>
                                       fail "no predicate admissibility rule for this type"))\

                         | \Prim.arrow\ ? ? =>
                           \(fnc dom cod =>
                                (case Prune.prune dom unsh of
                                    SOME domunsh =>
                                       RuleTactic.arrowPadmissDomainClosed domunsh

                                  | NONE =>
                                       termCaseT dom
                                       /| \Prim.halts\ ? =>
                                          \(fnc m =>
                                               RuleTactic.arrowPadmissDomainHalts (T.evar ()))\

                                        | _ =>
                                          \(fnc =>
                                               fail "no predicate admissibility rule for this type")\
                                       /))\

                         | \Prim.prod\ ? ? =>
                           \(fnc b1 b2 =>
                                refine (Rule.prodPadmiss a b1 b2))\

                         | \Prim.eq\ _ _ _ =>
                           \(fnc =>
                                RuleTactic.eqPadmiss)\

                         | const? @ _ =>
                           \(fnc const =>
                                fail ("no predicate admissibility rule for " ^ Namespace.toString const))\

                         | _ =>
                           \(fnc =>
                                fail "improper form for predicate-admissibility goal")\
                        /))\

          | \Prim.uptype\ _ =>
            \(fnc =>
                 fail "no uptype rule for non-constant")\

          | \Prim.admiss\ _ =>
            \(fnc =>
                 fail "no admissibility rule for non-constant")\

          | \Prim.padmiss\ _ _ =>
            \(fnc =>
                 fail "no predicate admissibility rule for non-constant")\

          | _ =>
            \(fnc =>
                 let do goal = withgoal in Show.showGoal goal; idtac end >>
                 fail "not an admissibility goal")\
         /
      
                 
         
      val proveAdmiss1Raw = lift proveAdmiss1Loop
      val proveAdmiss1 = Typecheck.withTypecheck proveAdmiss1Raw


      fun proveAdmissMain assumtac =
         cut $
         first
            [
            assumtac >> done,

            let
               do (jud, _) = withgoal
            in
               if TypecheckInternal.isTypecheckGoal jud then
                  idtacM Secondary
               else
                  termCaseT (J.concl jud)
                  /| \Prim.admiss\ _ =>
                     \(fnc =>
                          first
                             [
                             uptypeAdmiss >> lift (fn () => proveAdmissMain assumtac),
                             proveAdmiss1Raw >> lift (fn () => proveAdmissMain assumtac)
                             ])\

                   | (\Prim.uptype\ _ | \Prim.padmiss\ _ _) =>
                     \(fnc =>
                          proveAdmiss1Raw >> lift (fn () => proveAdmissMain assumtac))\

                   | \Prim.forall\ _ (fn . _) =>
                     \(fnc =>
                          RT.forallIntro
                          >>> [
                              idtacM Secondary,
                              lift (fn () => proveAdmissMain assumtac)
                              ])\

                   | \Prim.arrow\ _ _ =>
                     \(fnc =>
                          RT.arrowIntro
                          >>> [
                              idtacM Secondary,
                              lift (fn () => proveAdmissMain assumtac)
                              ])\

                   | _ =>
                     \(fnc =>
                          idtacM Primary)\
                  /
            end
            ]


      val proveAdmissPriority : priority tacticm = 
         lift (fn () => 
                  refine Rule.normalizeConcl
                  >>+
                  proveAdmissMain Hyp.assumption)

      val proveAdmissRaw = proveAdmissPriority >> idtac

      val proveAdmiss = Typecheck.withTypecheckSnd proveAdmissPriority


      fun establishUptype const =
         (case Datatype.info const of
             NONE =>
                signalError "not a datatype"

           | SOME (_, bundle) =>
                let
                   val (_, _, _, _, _, dts) = bundle

                   (* Do some ugly name manipulation to find the uptype condition lemma. *)
                   val (firstconst, _, _, _, _) = Vector.sub dts 0
                   val firstnamerev = List.rev (Namespace.name firstconst)  (* nonempty by invariant *)
                   val conditionLemmaName =
                      List.rev
                         (Symbol.fromValue (Symbol.toValue (List.hd firstnamerev) ^ "_uptype_condition")
                          :: List.tl firstnamerev)
                   val conditionLemma = Namespace.resolve conditionLemmaName

                   val conditionLemmaTp =
                      (case Report.typeOf conditionLemma of
                          NONE =>
                             signalError "uptype condition lemma not found"

                        | SOME t => t)

                   (* Drop the condition part of the lemma, and add unknown proposition
                      for each quantified variable.  That proposition will either become
                      (uptype 0) or unit, depending on whether it's needed.
                   *)
                    
                   fun makeLemma t =
                      termCase t
                      /| \Prim.forall\ ? (fn ? . ?) =>
                         \(fnc dom binder cod =>
                              T.apply2 Prim.forall dom
                                 (T.Lam (binder, 
                                         T.apply2 Prim.arrow 
                                            (T.evar ())
                                            (makeLemma cod))))\

                       | \Prim.arrow\ _ ? =>
                         \(fnc cod => cod)\
                      /

                   val lemmaTp = makeLemma conditionLemmaTp

                   val jud = J.make Seq.empty lemmaTp

                   val assumtac =
                      goalCaseT
                      /
                      \Prim.uptype\ var? =>
                      \(fnc i =>
                           if i < 1 then
                              fail ""
                           else
                              (* use the unknown proposition that should be positioned after the variable *)
                              refine (Rule.hypothesis (i-1)))\
                      /

                   val tac =
                      Typecheck.withTypecheckSnd
                         (andthenM
                             (IntroTactic.introsPriority >>!
                              Backchain.applyPriority (ETerm.literal (T.Const conditionLemma)) >>!
                              repeat IntroTactic.split >>
                              lift (fn () => proveAdmissMain assumtac))

                             (fn Primary =>
                                    idtacM Primary

                               | Secondary => 
                                    first
                                       [
                                       (* If the proposition is still unknown, set it to unit.
                                          Need to do this before invoking the typechecker.
                                       *)
                                       refine Rule.unitForm >> done,

                                       idtacM Secondary
                                       ]))
                in
                   (case Tactic.execute (jud, Directory.empty) tac of
                       Sum.INL v =>
                          Vector.appi
                             (fns (n : int) (dtconst, _, _, _, _) =>
                                 let
                                    (* makeLemmaN T s

                                       if    s takes T into G
                                       then  tac :: G, T[s] |- U[s o ^]
                                             and
                                             returns (U, tac)

                                       This code is long because I don't want to generate extraneous typing goals.
                                    *)
                                    fun makeLemmaN t s =
                                       termCase t
                                       /| \Prim.forall\ ? (fn ? . ?) =>
                                          \(fnc dom binder cod =>
                                               let
                                                  (* suppose G' |- forall Dom . Cod : type
                                                     G |- s : G'
                                                     so
                                                     G', Dom |- Cod : type
                                                     G, Dom[s] |- 0 . (s o ^) : G', Dom
                                                  *)

                                                  val (cod', tac) = makeLemmaN cod (T.under 1 s)
                                               in
                                                  (T.apply2 Prim.forall dom (T.Lam (binder, cod')),

                                                   (* G, (forall Dom . Cod)[s] |- (forall Dom . Cod')[s o ^] *)
                                                   refine (Rule.forallIntro (T.evar ()) (T.evar ()))
                                                   >>> [
                                                       (* G, (forall Dom . Cod)[s] |- Dom[s o ^] : type *)
                                                       refine (Rule.forallFormInv1 (T.evar ()) (T.evar ()))
                                                       >>+
                                                       (* G, (forall Dom . Cod)[s] |- (forall Dom . _)[s o ^] : type *)
                                                       refine (Rule.inhabitedForm (T.evar ()))
                                                       >>+
                                                       (* G, (forall Dom . Cod)[s] |- (forall Dom . _)[s o ^] *)
                                                       refine (Rule.hypothesis 0),

                                                       (* G, (forall Dom . Cod)[s], Dom[s o ^] |- Cod'[0 . s o ^2] *)
                                                       refine (Rule.assert (T.Sub (cod, T.Idot (0, T.compose s (T.Shift 2)))) (T.evar ()))
                                                       >>> [
                                                           (* G, (forall Dom . Cod)[s], Dom[s o ^] |- Cod[0 . s o ^2]
                                                                                                    = Cod[0 . s o ^3][0 . id]
                                                           *)
                                                           refine (Rule.forallElim
                                                                      (T.Sub (dom, T.compose s (T.Shift 2)))
                                                                      (T.Sub (cod, T.Idot (0, T.compose s (T.Shift 3))))
                                                                      T.zero)
                                                           >>> [
                                                               (* G, (forall Dom . Cod)[s], Dom[s o ^] |- forall Dom[s o ^2] . Cod[0 . s o ^3] *)
                                                               refine (Rule.hypothesis 1),

                                                               (* G, (forall Dom . Cod)[s], Dom[s o ^] |- 0 : Dom[s o ^2] *)
                                                               refine (Rule.hypothesisOf 0)
                                                               ],

                                                           (* G, (forall Dom . Cod)[s], Dom[s o ^], Cod[0 . s o ^2] |- Cod'[1 . s o ^3] *)
                                                           refine (Rule.weaken 2 1)
                                                           >>+
                                                           (* G, Dom[s], Cod[0 . s o ^] |- Cod'[1 . s o ^2] *)
                                                           tac
                                                           ]
                                                       ])
                                               end)\

                                        | \Prim.arrow\ \Prim.unit\ ? =>
                                          \(fnc cod =>
                                               let
                                                  val (cod', tac) = makeLemmaN cod s
                                               in
                                                  (cod',

                                                   (* (G, unit -> Cod)[s] |- Cod'[s o ^] *)
                                                   refine (Rule.assert (T.Sub (cod, T.compose s T.shift1)) (T.evar ()))
                                                   >>> [
                                                       (* G, unit -> Cod[s] |- Cod[s o ^] *)
                                                       refine (Rule.arrowElim (T.Const Prim.unit) (T.evar ()))
                                                       >>> [
                                                           (* G, unit -> Cod[s] |- unit -> Cod[s o ^] *)
                                                           refine (Rule.hypothesis 0),

                                                           (* G, unit -> Cod[s] |- unit *)
                                                           refine Rule.unitIntro
                                                           ],

                                                       (* G, unit -> Cod[s], Cod[s o ^] |- Cod'[s o ^2] *)
                                                       refine (Rule.weaken 1 1)
                                                       >>+
                                                       (* G, Cod[s] |- Cod'[s o ^] *)
                                                       tac
                                                       ])
                                               end)\

                                        | \Prim.arrow\ ? ? =>
                                          \(fnc dom cod =>
                                               let
                                                  (* suppose G' |- Dom -> Cod : type
                                                     G |- s : G'
                                                     so
                                                     G' |- Cod : type
                                                     G, Dom[s] |- s o ^ : G'
                                                  *)

                                                  val (cod', tac) = makeLemmaN cod (T.compose s T.shift1)
                                               in
                                                  (T.apply2 Prim.arrow dom cod',

                                                   (* G, (Dom -> Cod)[s] |- (Dom -> Cod')[s o ^] *)
                                                   refine (Rule.arrowIntro (T.evar ()) (T.evar ()))
                                                   >>> [
                                                       (* G, (Dom -> Cod)[s] |- Dom[s o ^] : type *)
                                                       refine (Rule.arrowFormInv1 (T.evar ()) (T.evar ()))
                                                       >>+
                                                       (* G, (Dom -> Cod)[s] |- (Dom -> _)[s o ^] : type *)
                                                       refine (Rule.inhabitedForm (T.evar ()))
                                                       >>+
                                                       (* G, (Dom -> Cod)[s] |- (Dom -> _)[s o ^] *)
                                                       refine (Rule.hypothesis 0),

                                                       (* G, (Dom -> Cod)[s], Dom[s o ^] |- Cod'[s o ^2] *)
                                                       refine (Rule.assert (T.Sub (cod, T.compose s (T.Shift 2))) (T.evar ()))
                                                       >>> [
                                                           (* G, (Dom -> Cod)[s], Dom[s o ^] |- Cod[s o ^2] *)
                                                           refine (Rule.arrowElim (T.Sub (dom, T.compose s (T.Shift 2))) (T.evar ()))
                                                           >>> [
                                                               (* G, (Dom -> Cod)[s], Dom[s o ^] |- Dom[s o ^2] -> Cod[s o ^2] *)
                                                               refine (Rule.hypothesis 1),

                                                               (* G, (Dom -> Cod)[s], Dom[s o ^] |- Dom[s o ^2] *)
                                                               refine (Rule.hypothesis 0)
                                                               ],

                                                           (* G, (Dom -> Cod)[s], Dom[s o ^], Cod[s o ^2] |- Cod'[s o ^3] *)
                                                           refine (Rule.weaken 2 1)
                                                           >>+
                                                           (* G, Dom[s], Cod[s o ^] |- Cod'[s o ^2] *)
                                                           tac
                                                           ]
                                                       ])
                                               end)\

                                        | \Prim.prod\ _ _ =>
                                          \(fnc =>
                                               let
                                                  val (anetc, tac) =
                                                     Int.natrecUp
                                                        (fns _ (a, tac) =>
                                                            (* tac :: G, A0 & ... & Ak-1 & unit |- A *)
                                                            termCase a
                                                            /
                                                            \Prim.prod\ _ ? =>
                                                            \(fnc c =>
                                                                 (* tac :: G, A0 & ... & Ak-1 & unit |- B & C *)
                                                                 (c,
      
                                                                  (* G, A0 & ... & Ak-1 & unit |- C *)
                                                                  refine (Rule.prodElim2 (T.evar ()) (T.evar ()))
                                                                  >>+
                                                                  (* G, A0 & ... & Ak-1 & unit |- B & C *)
                                                                  tac))\
                                                            /)
                                                        (t, refine (Rule.hypothesis 0))
                                                        n

                                                  val an =
                                                     termCase anetc
                                                     /
                                                     \Prim.prod\ ? _ =>
                                                     \(fnc b => b)\
                                                     /
                                               in
                                                  (an,

                                                   (* G, A0 & ... & Ak-1 & unit |- An *)
                                                   refine (Rule.prodElim1 (T.evar ()) (T.evar ()))
                                                   >>+
                                                   (* G, A0 & ... & Ak-1 & unit |- An & ... & Ak-1 & unit *)
                                                   tac)
                                                end)\
                                       /

                                    val (lemmanTp, tacn) = makeLemmaN lemmaTp T.id

                                    val judn = J.make Seq.empty lemmanTp

                                    val fulltacn =
                                       (* lemmanTp *)
                                       refine (Rule.assert lemmaTp (T.evar ()))
                                       >>> [
                                           (* lemmaTp *)
                                           cast jud v,

                                           (* lemmaTp |- lemmanTp *)
                                           tacn
                                           ]
                                 in
                                    (case Tactic.execute (judn, Directory.empty) fulltacn of
                                        Sum.INL vn =>
                                           let
                                              val lemmanName =
                                                 Symbol.fromValue (Symbol.toValue (Namespace.lastname dtconst) ^ "_uptype")

                                              val (lemman, judn', vn') = NamespaceInternal.reify lemmanName judn vn
                                           in
                                              Database.setType lemman judn' vn';
                                              Constant.abstract lemman;

                                              H.insert uptypeTactics dtconst
                                                 (Backchain.applyRaw (ETerm.literal (T.Const lemman)))
                                           end

                                      | Sum.INR _ =>
                                           signalError "unexpected failure in establishUptype")
                                 end)
                             dts

                     | Sum.INR _ =>
                          signalError "unable to establish the datatype is an uptype")
                end)



      val existsAdmiss =
         first [RT.existsAdmissUptype, RT.existsAdmiss]


      val () =
         List.app
            (fn (const, tac) => H.insert admissTactics const tac)
            [
            (Prim.partial, RT.partialAdmiss),
            (Prim.void, RT.voidAdmiss),
            (Prim.unit, RT.unitAdmiss),
            (Prim.bool, RT.boolAdmiss),
            (Prim.forall, RT.forallAdmiss),
            (Prim.forallfut, RT.forallfutAdmiss),
            (Prim.arrow, RT.arrowAdmiss),
            (Prim.intersect, RT.intersectAdmiss),
            (Prim.intersectfut, RT.intersectfutAdmiss),
            (Prim.exists, existsAdmiss),
            (Prim.prod, RT.prodAdmiss),
            (Prim.dprod, RT.dprodAdmissUptype),
            (Prim.sum, RT.sumAdmiss),
            (Prim.future, RT.futureAdmiss),
            (Prim.set, RT.setAdmiss),
            (Prim.iset, RT.isetAdmiss),
            (Prim.eq, RT.eqAdmiss),
            (Prim.ov, RT.ofAdmiss),
            (Prim.eqtp, RT.eqtpAdmiss),
            (Prim.istp, RT.istpAdmiss),
            (Prim.subtype, RT.subtypeAdmiss),
            (Prim.rec, RT.recAdmiss),
            (Prim.nat, RT.natAdmiss),
            (Prim.integer, RT.integerAdmiss),
            (Prim.symbol, RT.symbolAdmiss),
            ]

      val () =
         List.app
            (fn (const, tac) => H.insert uptypeTactics const tac)
            [
            (Prim.void, RT.voidUptype),
            (Prim.unit, RT.unitUptype),
            (Prim.bool, RT.boolUptype),
            (Prim.forall, RT.forallUptype),
            (Prim.forallfut, RT.forallfutUptype),
            (Prim.arrow, RT.arrowUptype),
            (Prim.intersect, RT.intersectUptype),
            (Prim.intersectfut, RT.intersectfutUptype),
            (Prim.exists, RT.existsUptype),
            (Prim.prod, RT.prodUptype),
            (Prim.dprod, RT.dprodUptype),
            (Prim.sum, RT.sumUptype),
            (Prim.future, RT.futureUptype),
            (Prim.eq, RT.eqUptype),
            (Prim.ov, RT.ofUptype),
            (Prim.eqtp, RT.eqtpUptype),
            (Prim.istp, RT.istpUptype),
            (Prim.subtype, RT.subtypeUptype),
            (Prim.halts, RT.haltsUptype),
            (Prim.set, RT.setUptype),
            (Prim.iset, RT.isetUptype),
            (Prim.mu, RT.muUptype),
            (Prim.rec, RT.recUptype),
            (Prim.nat, RT.natUptype),
            (Prim.integer, RT.integerUptype),
            (Prim.symbol, RT.symbolUptype),
            ]


      fun typecheckFixpointMain () =
         goalCaseT
         /| \Prim.ov\ ? (\Prim.fix\ ?) =>
            \(fnc a f =>
                 (* fix F : A *)
                 refine (Rule.partialElimOf (T.evar ()) (T.evar ()))
                 >>> [
                     (* fix F : partial A *)
                     refine (Rule.fixpointInductionOf (T.evar ()) (T.evar ()))
                     >>> [
                         (* F : partial A -> partial A *)
                         refine (Rule.subsumptionOf (T.apply2 Prim.arrow (T.apply1 Prim.partial a) a) (T.evar ()) (T.evar ()))
                         >>> [
                             refine (Rule.assert (T.apply2 Prim.subtype a (T.apply1 Prim.partial a)) (T.evar ()))
                             >>> [
                                 (* A <: partial A *)
                                 idtacM Secondary,

                                 (* A <: partial A |- (partial A -> A <: partial A -> partial A)[^] *)
                                 refine (Rule.arrowSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                                 >>> [
                                     (* partial A[^] <: partial A[^] *)
                                     refine (Rule.subtypeRefl (T.evar ()))
                                     >>+
                                     (* partial A[^] : type *)
                                     refine (Rule.subtypeIstp2 (T.Sub (a, T.shift1)) (T.evar ()))
                                     >>+
                                     (* A[^] <: partial A[^] *)
                                     refine (Rule.hypothesis 0) >> done,
    
                                     (* A[^] <: partial A[^] *)
                                     refine (Rule.hypothesis 0) >> done
                                     ],
                                 ],

                             (* F : partial A -> A *)
                             idtacM Primary
                             ],

                         (* admiss A *)
                         attemptPri proveAdmissPriority
                         ],

                     (* halts (fix F) *)
                     refine (Rule.reduce (R.within [1] (R.trans [R.user PrimReduction.unroll_fix, R.betas])))
                     >>+
                     (* halts (Fbody [fix F . id]) *)
                     (setFailure "body is not valuable" $ refine (Rule.haltsValue))
                     >> done
                     ])\

          | \Prim.ov\ _ (const? @ _) =>
            \(fnc _ =>
                 refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.betas])))
                 >>+
                 lift typecheckFixpointMain)\

          | \Prim.ov\ ? (var? @ ?) =>
            \(fnc a i spine =>
                 (* i spine : A  =  (0 spine[^] : A[^])[i . id] *)
                 refine (Rule.letUnfold i (T.apply2 Prim.ov (T.Sub (a, T.shift1)) (T.Elim (T.zero, T.ssubst spine T.shift1))))
                 >>+
                 refine (Rule.reduce (R.within [2] R.betas))
                 >>+
                 lift typecheckFixpointMain)\

          | _ =>
            \(fnc =>
                 fail "goal has incorrect form for typecheckFixpoint")\
         /

      val typecheckFixpointPriority = lift typecheckFixpointMain

      val typecheckFixpointRaw = typecheckFixpointPriority >> idtac

      val typecheckFixpoint = Typecheck.withTypecheckSnd typecheckFixpointPriority


      fun terminationPriority hyp =
         let
            do iopt = Hyp.findhypOrConcl hyp
            do (jud, dir) = withgoal
         in
            (case iopt of
                NONE =>
                   goalCaseT
                   /| \Prim.halts\ ? =>
                      \(fnc t =>
                           if Valuability.valuability t > 0 then
                              refine Rule.haltsValue >> done
                           else
                              termCaseT t
                              /| \Prim.seq\ ? (fn . ?) =>
                                 \(fnc m n =>
                                      refine (Rule.seqHalts (T.evar ()) m n)
                                      >>> [
                                          (* M : partial A *)
                                          idtacM Secondary,
                     
                                          (* halts M *)
                                          idtacM Primary,
                     
                                          (* A |- halts N[^] *)
                                          chdir (D.bind0 dir) >>+ idtacM Primary
                                          ])\
          
                               | \Prim.ite\ ? ? ? =>
                                 \(fnc m n p =>
                                      refine (Rule.iteHalts (T.evar ()) m n p)
                                      >>> [
                                          idtacM Secondary,
                                          idtacM Primary,
                                          chdir (D.bind0 dir) >>+ idtacM Primary
                                          ])\

                               | ? @ ? =>
                                 \(fnc h spine =>
                                      (case List.rev spine of
                                          [] =>
                                             fail "no strategy for proving termination of object"
                     
                                        | elim :: restrev =>
                                             let
                                                val spine' = List.rev restrev
                                             in
                                                (case elim of
                                                    T.App n =>
                                                       refine (Rule.appHalts (T.evar ()) (T.Elim (h, spine')) n)
                                                       >>> [
                                                           idtacM Secondary,
                                                           idtacM Primary,
                                                           chdir (D.bind0 dir) >>+ idtacM Primary
                                                           ]
       
                                                  | T.Pi1 =>
                                                       refine (Rule.pi1Halts (T.evar ()) (T.Elim (h, spine')))
                                                       >>> [
                                                           idtacM Secondary,
                                                           idtacM Primary,
                                                           chdir (D.bind0 dir) >>+ idtacM Primary
                                                           ]
       
                                                  | T.Pi2 =>
                                                       refine (Rule.pi2Halts (T.evar ()) (T.Elim (h, spine')))
                                                       >>> [
                                                           idtacM Secondary,
                                                           idtacM Primary,
                                                           chdir (D.bind0 dir) >>+ idtacM Primary
                                                           ]
       
                                                  | T.Prev =>
                                                       refine (Rule.prevHalts (T.evar ()) (T.Elim (h, spine')))
                                                       >>> [
                                                           idtacM Secondary,
                                                           idtacM Primary,
                                                           chdir (D.bind0 dir) >>+ idtacM Primary
                                                           ])
                                             end))\
                                                               
                               | _ =>
                                 \(fnc =>
                                      fail "no strategy for proving termination of object")\
                              /)\
               
                    | _ =>
                      \(fnc =>
                           fail "not a termination goal")\
                   /

              | SOME i =>
                   let
                      val h = J.subHyp (J.hyp jud i) (T.Shift (i+1))
                      val dir' = D.bind0 dir
                   in
                      (case h of
                          J.Tm d =>
                             termCaseT d
                             /| \Prim.halts\ ? =>
                                \(fnc t =>
                                     termCaseT t
                                     /| \Prim.bottom\ =>
                                        \(fnc =>
                                             refine (Rule.voidElim (T.evar ()))
                                             >>+
                                             refine Rule.bottomDiverges
                                             >>+
                                             refine (Rule.hypothesis i) >> done)\

                                      | \Prim.seq\ ? ? =>
                                        \(fnc m n =>
                                             refine (Rule.assert (T.apply1 Prim.halts m) (T.evar ()))
                                             >>> [
                                                 refine (Rule.seqHaltsInv m n)
                                                 >>+
                                                 refine (Rule.hypothesis i) >> done,
          
                                                 chdir dir' >> idtacM Primary
                                                 ])\
          
                                      | \Prim.ite\ ? ? ? =>
                                        \(fnc m n p =>
                                             refine (Rule.assert (T.apply1 Prim.halts m) (T.evar ()))
                                             >>> [
                                                 refine (Rule.iteHaltsInv m n p)
                                                 >>+
                                                 refine (Rule.hypothesis i) >> done,

                                                 chdir dir' >> idtacM Primary
                                                 ])\

                                      | ? @ ? =>
                                        \(fnc h spine =>
                                             (case List.rev spine of
                                                 [] =>
                                                    fail "no consequences of object termination"
                            
                                               | elim :: restrev =>
                                                    let
                                                       val spine' = List.rev restrev
                                                       val m = T.Elim (h, spine')
                                                    in
                                                       (case elim of
                                                           T.App n =>
                                                              refine (Rule.assert (T.apply1 Prim.halts m) (T.evar ()))
                                                              >>> [
                                                                  refine (Rule.appHaltsInv m n)
                                                                  >>+
                                                                  refine (Rule.hypothesis i) >> done,
          
                                                                  chdir dir' >> idtacM Primary
                                                                  ]
          
                                                         | T.Pi1 =>
                                                              refine (Rule.assert (T.apply1 Prim.halts m) (T.evar ()))
                                                              >>> [
                                                                  refine (Rule.pi1HaltsInv m)
                                                                  >>+
                                                                  refine (Rule.hypothesis i) >> done,
          
                                                                  chdir dir' >> idtacM Primary
                                                                  ]
          
                                                         | T.Pi2 =>
                                                              refine (Rule.assert (T.apply1 Prim.halts m) (T.evar ()))
                                                              >>> [
                                                                  refine (Rule.pi2HaltsInv m)
                                                                  >>+
                                                                  refine (Rule.hypothesis i) >> done,
          
                                                                  chdir dir' >> idtacM Primary
                                                                  ]
          
                                                         | T.Prev =>
                                                              refine (Rule.assert (T.apply1 Prim.halts m) (T.evar ()))
                                                              >>> [
                                                                  refine (Rule.prevHaltsInv m)
                                                                  >>+
                                                                  refine (Rule.hypothesis i) >> done,
          
                                                                  chdir dir' >> idtacM Primary
                                                                  ])
                                                    end))\
          
                                      | _ =>
                                        \(fnc =>
                                             fail "no consequences of object termination")\
                                     /)\
          
                              | \Prim.eq\ (\Prim.partial\ ?) ? ? =>
                                \(fnc a m n =>
                                     refine (Rule.assert (T.apply2 Prim.iff (T.apply1 Prim.halts m) (T.apply1 Prim.halts n)) (T.evar ()))
                                     >>> [
                                         refine (Rule.partialElimHalts a m n)
                                         >>+
                                         refine (Rule.hypothesis i) >> done,

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | _ =>
                                \(fnc =>
                                     fail "not a termination hypothesis")\
                             /
          
                        | _ =>
                             fail "hypothesis has improper sort")
                   end)
         end

      fun terminationRaw hyp = terminationPriority hyp >> idtac

      fun termination hyp = Typecheck.withTypecheckSnd $ terminationPriority hyp



      fun partialityPriority hyp =
         let
            do iopt = Hyp.findhypOrConcl hyp
            do (jud, dir) = withgoal
         in
            (case iopt of
                NONE =>
                   goalCaseT
                   /| \Prim.eq\ (\Prim.partial\ ?) ? ? =>
                      \(fnc a m n =>
                           (* M = N : partial A *)
                           refine (Rule.subsumptionEq a (T.apply1 Prim.partial a) m n)
                           >>> [
                               (* A <: partial A *)
                               idtacM Secondary,

                               (* M = N : A *)
                               idtacM Primary
                               ])\

                    | \Prim.eq\ ? ? ? =>
                      \(fnc a m n =>
                           (* M = N : A *)
                           refine (Rule.partialElimEq a m n)
                           >>> [
                               (* M = N : partial A *)
                               idtacM Primary,

                               (* halts M *)
                               idtacM Primary
                               ])\

                    | \Prim.ov\ (\Prim.partial\ ?) ? =>
                      \(fnc a m =>
                           (* M : partial A *)
                           refine (Rule.subsumptionOf a (T.apply1 Prim.partial a) m)
                           >>> [
                               (* A <: partial A *)
                               idtacM Secondary,

                               (* M : A *)
                               idtacM Primary
                               ])\

                    | \Prim.ov\ ? ? =>
                      \(fnc a m =>
                           (* M : A *)
                           refine (Rule.partialElimOf a m)
                           >>> [
                               (* M : partial A *)
                               idtacM Primary,

                               (* halts M *)
                               idtacM Primary
                               ])\

                    | _ =>
                      \(fnc =>
                           fail "not a partiality goal")\
                   /
                  
              | SOME i =>
                   let
                      val h = J.subHyp (J.hyp jud i) (T.Shift (i+1))
                      val dir' = D.bind0 dir
                   in
                      (case h of
                          J.Tm d =>
                             termCaseT d
                             /| \Prim.eq\ (\Prim.partial\ (\Prim.partial\ ?)) ? ? =>
                                \(fnc a m n =>
                                     refine (Rule.assert (T.apply3 Prim.eq (T.apply1 Prim.partial a) m n) (T.evar ()))
                                     >>> [
                                         (* M = N : partial A *)
                                         refine (Rule.subsumptionEq (T.apply1 Prim.partial (T.apply1 Prim.partial a)) (T.apply1 Prim.partial a) m n)
                                         >>> [
                                             (* partial (partial A) <: partial A *)
                                             refine (Rule.partialStrictConverse a)
                                             >>+
                                             (* A : type *)
                                             idtacM Secondary,

                                             (* M = N : partial A *)
                                             refine (Rule.hypothesis i) >> done,
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | \Prim.eq\ (\Prim.partial\ ?) ? ? =>
                                \(fnc a m n =>
                                     refine (Rule.assert (T.apply3 Prim.eq a m n) (T.evar ()))
                                     >>> [
                                         (* M = N : A *)
                                         refine (Rule.partialElimEq a m n)
                                         >>> [
                                             (* M = N : partial A *)
                                             refine (Rule.hypothesis i) >> done,

                                             (* halts M *)
                                             idtacM Primary
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | \Prim.eq\ ? ? ? =>
                                \(fnc a m n =>
                                     refine (Rule.assert (T.apply3 Prim.eq (T.apply1 Prim.partial a) m n) (T.evar ()))
                                     >>> [
                                         (* M = N : partial A *)
                                         refine (Rule.subsumptionEq a (T.apply1 Prim.partial a) m n)
                                         >>> [
                                             (* A <: partial A *)
                                             idtacM Secondary,

                                             (* M = N : A *)
                                             refine (Rule.hypothesis i) >> done
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | \Prim.ov\ (\Prim.partial\ (\Prim.partial\ ?)) ? =>
                                \(fnc a m =>
                                     refine (Rule.assert (T.apply2 Prim.eq (T.apply1 Prim.partial a) m) (T.evar ()))
                                     >>> [
                                         (* M : partial A *)
                                         refine (Rule.subsumptionOf (T.apply1 Prim.partial (T.apply1 Prim.partial a)) (T.apply1 Prim.partial a) m)
                                         >>> [
                                             (* partial (partial A) <: partial A *)
                                             refine (Rule.partialStrictConverse a)
                                             >>+
                                             (* A : type *)
                                             idtacM Secondary,

                                             (* M : partial A *)
                                             refine (Rule.hypothesis i) >> done,
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | \Prim.ov\ (\Prim.partial\ ?) ? =>
                                \(fnc a m =>
                                     refine (Rule.assert (T.apply2 Prim.ov a m) (T.evar ()))
                                     >>> [
                                         (* M : A *)
                                         refine (Rule.partialElimOf a m)
                                         >>> [
                                             (* M : partial A *)
                                             refine (Rule.hypothesis i) >> done,

                                             (* halts M *)
                                             idtacM Primary
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | \Prim.ov\ ? ? =>
                                \(fnc a m =>
                                     refine (Rule.assert (T.apply2 Prim.ov (T.apply1 Prim.partial a) m) (T.evar ()))
                                     >>> [
                                         (* M : partial A *)
                                         refine (Rule.subsumptionOf a (T.apply1 Prim.partial a) m)
                                         >>> [
                                             (* A <: partial A *)
                                             idtacM Secondary,

                                             (* M : A *)
                                             refine (Rule.hypothesis i) >> done
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | \Prim.partial\ ? =>
                                \(fnc a =>
                                     refine (Rule.assert (T.apply2 Prim.ov a (T.Var i)) (T.evar ()))
                                     >>> [
                                         (* i : A *)
                                         refine (Rule.partialElimOf a (T.Var i))
                                         >>> [
                                             (* i : partial A *)
                                             refine (Rule.hypothesisOf i) >> done,

                                             (* halts i *)
                                             idtacM Primary
                                             ],

                                         chdir dir' >> idtacM Primary
                                         ])\

                              | _ =>
                                \(fnc =>
                                     fail "not a partiality hypothesis")\

                             /
          
                        | _ =>
                             fail "hypothesis has improper sort")
                   end)
         end

      fun partialityRaw hyp = partialityPriority hyp >> idtac

      fun partiality hyp = Typecheck.withTypecheckSnd $ partialityPriority hyp



      fun tightenPartialPriority hyp =
         let
            do i = Hyp.findhyp hyp
            do (_, dir) = withgoal
         in
            partialityRaw (Hyp.NUMBER i)
            >>> [
                (* halts i *)
                idtacM Primary,
   
                (* i : A |- C *)
                goalHypnCaseT 0
                /| $tm \Prim.ov\ ? _ =>
                   \(fnc a =>
                        SubtypeTactic.tightenRaw (Hyp.NUMBER (i + 1)) (ETerm.literal a)
                        >>> [
                            idtacM Secondary,
                            refine (Rule.hypothesis 0) >> done,
                            refine (Rule.weaken 0 1) >> chdir dir >> idtacM Primary
                            ])\
                /
                ]
         end

      fun tightenPartialRaw hyp = tightenPartialPriority hyp >> idtac

      fun tightenPartial hyp = Typecheck.withTypecheckSnd $ tightenPartialPriority hyp



      val totalityPriority =
         let
            do () = lift
         in
            setFailure "not a totality goal" $ cut $
               refine (Rule.haltsTotal (T.evar ()) (T.evar ())) >> idtacM Secondary
         end

      val totalityRaw = totalityPriority >> idtac

      val totality = Typecheck.withTypecheckSnd $ totalityPriority
                        
   end
