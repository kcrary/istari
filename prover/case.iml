
(* Performance notes:
   1. There is no tail-call optimization when using Case.
   2. Case tries each option in turn, it does not build a decision tree.

   For these reasons, Case may be inappropriate for performance-critical code.
*)

signature CASE =
   sig

      type constant = Term.constant
      type term = Term.term
      type spine = Term.elim list
      type hyp = Judgement.hyp
      type context = Judgement.context

      type answer = exn
      type 'a tacticm = 'a Tactic.tacticm


      (* matching 'a, adds to 'b, resulting in 'c *)
      type ('a, 'b, 'c) matcher

      val wild : ('a, 'b, 'b) matcher
      val what : ('a, 'b, 'b * 'a) matcher
      val az : ('a, 'b * 'a, 'c) matcher -> ('a, 'b, 'c) matcher  (* "as" *)

      val wrap : ('a, 'b, 'c) matcher -> ('c -> 'd) -> ('a, 'b, 'd) matcher
      val alt : ('a, 'b, 'c) matcher list -> ('a, 'b, 'c) matcher

      type ('a, 'c) rmatcher
      val use : ('a, 'c) rmatcher -> ('a, 'b, 'b * 'c) matcher
      val fix : (('a, 'c) rmatcher -> ('a, unit, 'c) matcher) -> ('a, 'b, 'b * 'c) matcher

      (* backtracks on NONE *)
      val cond : ('a, 'b, 'c option) matcher -> ('a, 'b, 'c) matcher

      (* returns NONE when the function raises Backtrack *)
      exception Backtrack
      val tri : ('a -> 'b) -> ('a -> 'b option)  (* "try" *)

      (* wrapk m f = cond (wrap m (tri f)) *)
      val wrapk : ('a, 'b, 'c) matcher -> ('c -> 'd) -> ('a, 'b, 'd) matcher

      val seq : ('a, 'c, 'd) matcher -> ('b, 'd, 'e) matcher -> ('a * 'b, 'c, 'e) matcher

      val discrim : ('b -> ('a, 'b, 'c) matcher) -> ('a, 'b, 'c) matcher


      (* terms *)

      val constant : constant -> (term, 'a, 'a) matcher
      val variable : int -> (term, 'a, 'a) matcher
      val whatConstant : (term, 'a, 'a * constant) matcher
      val whatVar : (term, 'a, 'a * int) matcher
      val whatEvar : (term, 'a, 'a * (Term.ebind * Term.sub)) matcher

      val elim : (term, 'a, 'b) matcher -> (spine, 'b, 'c) matcher -> (term, 'a, 'c) matcher
      val lam : (term, 'a, 'b) matcher -> (term, 'a, 'b) matcher
      val lamb : (term, 'a * Term.binder, 'b) matcher -> (term, 'a, 'b) matcher
      val pair : (term, 'a, 'b) matcher -> (term, 'b, 'c) matcher -> (term, 'a, 'c) matcher
      val next : (term, 'a, 'b) matcher -> (term, 'a, 'b) matcher
      val triv : (term, 'a, 'a) matcher
      val marker : Symbol.symbol -> (term, 'a, 'a) matcher

      val notvar : (term, 'a, 'a * term) matcher

      val unify : term -> (term, 'a, 'a) matcher

      val whnf : (term, 'a, 'b) matcher -> (term, 'a, 'b) matcher
      val whnfHard : (term, 'a, 'b) matcher -> (term, 'a, 'b) matcher

      val nat : (term, 'a, 'a * int) matcher
      val integer : (term, 'a, 'a * IntInf.int) matcher


      (* spines *)
      
      val null : (spine, 'a, 'a) matcher
      val app : (term, 'a, 'b) matcher -> (spine, 'b, 'c) matcher -> (spine, 'a, 'c) matcher
      val pi1 : (spine, 'a, 'b) matcher -> (spine, 'a, 'b) matcher
      val pi2 : (spine, 'a, 'b) matcher -> (spine, 'a, 'b) matcher
      val prev : (spine, 'a, 'b) matcher -> (spine, 'a, 'b) matcher


      (* hypotheses *)

      val tm : (term, 'a, 'b) matcher -> (hyp, 'a, 'b) matcher
      val tml : (term, 'a, 'b) matcher -> (hyp, 'a, 'b) matcher
      val tmh : (term, 'a, 'b) matcher -> (hyp, 'a, 'b) matcher
      val tp : (hyp, 'a, 'a) matcher
      val tpl : (hyp, 'a, 'a) matcher
      val lett : (term, 'a, 'b) matcher -> (hyp, 'a, 'b) matcher


      (* contexts

         The hypothesis being matched is shifted into the entire context's scope.
      *)

      val hyp : int -> (hyp, 'a, 'b) matcher -> (context, 'a, 'b) matcher
      val anyhyp : (hyp, 'a, int -> 'b) matcher -> (context, 'a, 'b) matcher



      (* Raises NoMatch when matching fails. *)
      exception NoMatch
      val termCase : term -> (term, unit, 'a) matcher -> 'a
      val unitCase : (unit, unit, 'a) matcher -> 'a
      val term2Case : term -> term -> (term * term, unit, 'a) matcher -> 'a
      val term3Case : term -> term -> term -> (term * (term * term), unit, 'a) matcher -> 'a
      val spineCase : spine -> (spine, unit, 'a) matcher -> 'a
      val hypCase : hyp -> (hyp, unit, 'a) matcher -> 'a
      val contextCase : context -> (context, unit, 'a) matcher -> 'a



      (* Backtracks when matching fails.
         Will not try other matches when the resulting tactic or subsequent tactics fail.
      *)

      val termCaseT : term -> (term, unit, 'a tacticm) matcher -> 'a tacticm
      val unitCaseT : (unit, unit, 'a tacticm) matcher -> 'a tacticm
      val term2CaseT : term -> term -> (term * term, unit, 'a tacticm) matcher -> 'a tacticm
      val term3CaseT : term -> term -> term -> (term * term * term, unit, 'a tacticm) matcher -> 'a tacticm
      val spineCaseT : spine -> (spine, unit, 'a tacticm) matcher -> 'a tacticm
      val hypCaseT : hyp -> (hyp, unit, 'a tacticm) matcher -> 'a tacticm
      val contextCaseT : context -> (context, unit, 'a tacticm) matcher -> 'a tacticm
      val goalCaseT : (term, unit, 'a tacticm) matcher -> 'a tacticm
      val goalContextCaseT : (context, unit, 'a tacticm) matcher -> 'a tacticm



      (* Backtracks when matching fails.
         Tries other matches when the resulting tactic or subsequent tactics fail.
      *)

      val termCaseB : term -> (term, unit, 'a tacticm) matcher -> 'a tacticm
      val unitCaseB : (unit, unit, 'a tacticm) matcher -> 'a tacticm
      val term2CaseB : term -> term -> (term * term, unit, 'a tacticm) matcher -> 'a tacticm
      val term3CaseB : term -> term -> term -> (term * term * term, unit, 'a tacticm) matcher -> 'a tacticm
      val spineCaseB : spine -> (spine, unit, 'a tacticm) matcher -> 'a tacticm
      val hypCaseB : hyp -> (hyp, unit, 'a tacticm) matcher -> 'a tacticm
      val contextCaseB : context -> (context, unit, 'a tacticm) matcher -> 'a tacticm
      val goalCaseB : (term, unit, 'a tacticm) matcher -> 'a tacticm
      val goalContextCaseB : (context, unit, 'a tacticm) matcher -> 'a tacticm


      (* Note on rationale:
         One may wonder why termCase, etc. are not just polymorphic instead.
         We want to preserve an invariant on terms (namely, simple form), and
         that precludes having a polymorphic entry point that could be used
         with terms not satifying the invariant.

         The alternatives are to resimplify terms repeatedly in every case,
         which would be expensive, or to create the opportunity for subtle bugs
         by making it possible for term matching to bypass establishing the 
         invariant.
      *)

   end


structure Case :> CASE =
   struct

      structure T = Term
      structure N = Normalize
      structure J = Judgement

      type constant = Term.constant
      type term = Term.term
      type spine = Term.elim list
      type hyp = Judgement.hyp
      type context = Judgement.context

      type answer = exn
      type 'a tacticm = 'a Tactic.tacticm

      type ('a, 'b, 'c) matcher =
         'a                                    (* the discriminand *)
         -> 'b                                 (* the accumulator *)
         -> (unit -> answer)                   (* failure continuation *)
         -> ('c * (unit -> answer) -> answer)  (* success continuation *)
         -> answer

      
      fun wild _ x fk sk = sk (x, fk)


      fun what m x fk sk = sk ((x, m), fk)


      fun az f m x fk sk = f m (x, m) fk sk
      

      fun wrap f g m x fk sk =
         let
            do (y, fk') = f m x fk
         in
            sk (g y, fk')
         end


      fun alt l m x fk sk =
         (case l of
             [] => fk ()

           | f :: rest =>
                f m x (fn () => alt rest m x fk sk) sk)

         
      type ('a, 'b) rmatcher =
         'a
         -> (unit -> answer)
         -> ('b * (unit -> answer) -> answer)
         -> answer

      fun use f m x fk sk =
         let
            do (y, fk') = f m fk
         in
            sk ((x, y), fk')
         end

      (* fixr as an rmatcher
         Just using fix would cause polymorphic recursion, plus this is simpler anyway.
      *)
      fun fixr f m fk sk = f (fixr f) m () fk sk

      fun fix f m x fk sk =
         let
            do (y, fk') = f (fixr f) m () fk
         in
            sk ((x, y), fk')
         end

         
      fun cond f m x fk sk =
         let
            do (yopt, fk') = f m x fk
         in
            (case yopt of
                SOME y => sk (y, fk')
               
              | NONE => fk' ())
         end
         

      exception Backtrack

      fun tri f x =
         (try SOME (f x)
          with Backtrack => NONE)


      fun wrapk f g = cond (wrap f (tri g))


      fun seq f g (m, n) x fk sk =
         let
            do (y, fk') = f m x fk
         in
            g n y fk sk
         end


      fun discrim f m x fk sk = f x m x fk sk


      fun constant const m x fk sk =
         (case m of
             T.Elim (T.Const const', []) =>
                if Constant.eq (const, const') then
                   sk (x, fk)
                else
                   fk ()

           | _ => fk ())


      fun variable i m x fk sk =
         (case m of
             T.Elim (T.Var j, []) =>
                if i = j then
                   sk (x, fk)
                else
                   fk ()

           | _ => fk ())


      fun elim f g m x fk sk =
         (case m of
             T.Elim (h, spine) =>
                let
                   do (y, fk') = f (N.simplify h) x fk
                in
                   g spine y fk' sk
                end

           | _ => fk ())

      
      fun whatConstant m x fk sk =
         (case m of
             T.Elim (T.Const const, []) =>
                sk ((x, const), fk)

           | _ => fk ())


      fun whatVar m x fk sk =
         (case m of
             T.Elim (T.Var i, []) =>
                sk ((x, i), fk)

           | _ => fk ())


      fun whatEvar m x fk sk =
         (case m of
             T.Elim (T.Sub (T.Evar e, s), []) =>
                sk ((x, (e, s)), fk)

           | _ => fk ())


      fun lam f m x fk sk =
         (case m of
             T.Lam (_, n) =>
                f (N.simplify n) x fk sk

           | _ => fk ())


      fun lamb f m x fk sk =
         (case m of
             T.Lam (binder, n) =>
                f (N.simplify n) (x, binder) fk sk

           | _ => fk ())


      fun pair f g m x fk sk =
         (case m of
             T.Pair (m1, m2) =>
                let
                   val m1' = N.simplify m1
                   val m2' = N.simplify m2

                   do (x, fk') = f m1' x fk
                in
                   g m2' x fk' sk
                end

           | _ => fk ())


      fun next f m x fk sk =
         (case m of
             T.Next m1 =>
                f (N.simplify m1) x fk sk

           | _ => fk ())


      fun triv m x fk sk =
         (case m of
             T.Triv => sk (x, fk)

           | _ => fk ())


      fun marker sym m x fk sk =
         (case m of
             T.Marker sym' =>
                if Symbol.eq (sym, sym') then
                   sk (x, fk)
                else
                   fk ()

           | _ => fk ())

         
      fun notvar m x fk sk =
         (case m of
             T.Var _ =>
                fk ()

           | _ => sk ((x, m), fk))
         

      fun unify n m x fk sk =
         if Unify.unify1 n m then
            sk (x, fk)
         else
            fk ()


      fun whnf f m x fk sk =
         f (N.whnf m) x fk sk


      fun whnfHard f m x fk sk =
         f (N.whnfHard m) x fk sk


      fun natLoop n m fk sk =
         (case m of
             T.Elim (T.Const const, spine) =>
                if Constant.eq (const, Prim.zero) then
                   (case spine of
                       [] =>
                          sk n

                     | _ =>
                          fk ())
                else if Constant.eq (const, Prim.succ) then
                   (case spine of
                       [T.App m'] =>
                          natLoop (n+1) (N.simplify m') fk sk

                     | _ =>
                          fk ())

                else
                   fk ()

           | _ => fk ())

      fun nat m x fk sk = 
         let
            do n = natLoop 0 m fk
         in
            sk ((x, n), fk)
         end
         

      fun integer m x fk sk =
         (case m of
             T.Native (T.Integer y) => sk ((x, y), fk)

           | _ => fk ())


      fun null spine x fk sk =
         (case spine of
             [] => sk (x, fk)

           | _ :: _ => fk ())


      fun app f g spine x fk sk =
         (case spine of
             T.App m :: rest =>
                let
                   do (y, fk') = f (N.simplify m) x fk
                in
                   g rest y fk' sk
                end

           | _ => fk ())


      fun pi1 f spine x fk sk =
         (case spine of
             T.Pi1 :: rest =>
                f rest x fk sk

           | _ => fk ())


      fun pi2 f spine x fk sk =
         (case spine of
             T.Pi2 :: rest =>
                f rest x fk sk

           | _ => fk ())


      fun prev f spine x fk sk =
         (case spine of
             T.Prev :: rest =>
                f rest x fk sk

           | _ => fk ())


      fun tm f hyp x fk sk =
         (case hyp of
             J.Tm a =>
                f (N.simplify a) x fk sk

           | _ =>
                fk ())


      fun tml f hyp x fk sk =
         (case hyp of
             J.Tml a =>
                f (N.simplify a) x fk sk

           | _ =>
                fk ())


      fun tmh f hyp x fk sk =
         (case hyp of
             J.Tmh a =>
                f (N.simplify a) x fk sk

           | _ =>
                fk ())


      fun tp hyp x fk sk =
         (case hyp of
             J.Tp => sk (x, fk)

           | _ => fk ())


      fun tpl hyp x fk sk =
         (case hyp of
             J.Tpl => sk (x, fk)

           | _ => fk ())


      fun lett f hyp x fk sk =
         (case hyp of
             J.Let m =>
                f (N.simplify m) x fk sk

           | _ =>
                fk ())



      fun hyp i f ctx x fk sk =
         (case Seq.nthOpt ctx i of
             NONE =>
                fk ()

           | SOME h =>
                f (J.subHyp h (T.Shift (i+1))) x fk sk)


      fun anyhypLoop f i l x fk sk =
         (case Seq.expose l of
             Seq.Nil =>
                fk ()

           | Seq.Cons (h, rest) =>
                f
                   (J.subHyp h (T.Shift (i+1)))
                   x
                   (fn () => anyhypLoop f (i+1) rest x fk sk)
                   (fn (g, fk') => sk (g i, fk')))

      fun anyhyp f ctx x fk sk = anyhypLoop f 0 ctx x fk sk


      exception NoMatch
      
      fun ('a, 'b) caseX (m : 'a) (f : ('a, unit, 'b) matcher) : 'b =
         let
            extension Answer of 'b
         in
            (case 
                f m () (fn () => raise NoMatch) (fn (y, _) => Answer y)
             of
                Answer y => y

              | _ => raise (Fail "impossible"))
         end

         
      fun termCase m f = caseX (N.simplify m) f
      fun term2Case m1 m2 f = caseX (N.simplify m1, N.simplify m2) f
      fun term3Case m1 m2 m3 f = caseX (N.simplify m1, (N.simplify m2, N.simplify m3)) f

      fun unitCase f = caseX () f

      val spineCase = caseX
      val hypCase = caseX
      val contextCase = caseX


      fun caseT err x f goal fk sk =
         f x ()
            (fn () => fk err)
            (fn (tac, _) => tac goal fk sk)


      fun termCaseT m f goal fk sk =
         caseT "no match in termCase" (N.simplify m) f goal fk sk

      fun term2CaseT m1 m2 f goal fk sk =
         caseT "no match in term2Case" (N.simplify m1, N.simplify m2) f goal fk sk

      fun term3CaseT m1 m2 m3 f goal fk sk =
         caseT "no match in term3Case" (N.simplify m1, N.simplify m2, N.simplify m3) f goal fk sk

      fun unitCaseT f goal fk sk =
         caseT "no match in unitCase" () f goal fk sk

      fun spineCaseT m f goal fk sk = caseT "no match in spineCase" m f goal fk sk
      fun hypCaseT m f goal fk sk = caseT "no match in hypCase" m f goal fk sk
      fun contextCaseT m f goal fk sk = caseT "no match in contextCase" m f goal fk sk


      fun goalCaseT f (goal as (jud, _)) fk sk =
         caseT "no match in goalCase" (N.simplify (J.concl jud)) f goal fk sk


      fun goalContextCaseT f (goal as (jud, _)) fk sk =
         caseT "no match in goalContextCase" (J.context jud) f goal fk sk
             

      fun caseB err x f goal fk sk =
         f x ()
            (fn () => fk err)
            (fn (tac, fk') => tac goal (fn _ => fk' ()) sk)


      fun termCaseB m goal fk sk =
         caseB "no match in termCaseB" (N.simplify m) goal fk sk

      fun term2CaseB m1 m2 f goal fk sk =
         caseB "no match in term2CaseB" (N.simplify m1, N.simplify m2) f goal fk sk

      fun term3CaseB m1 m2 m3 f goal fk sk =
         caseB "no match in term3CaseB" (N.simplify m1, N.simplify m2, N.simplify m3) f goal fk sk

      fun unitCaseB f goal fk sk =
         caseB "no match in unitCaseB" () f goal fk sk

      fun spineCaseB m f goal fk sk = caseB "no match in spineCaseB" m f goal fk sk
      fun hypCaseB m f goal fk sk = caseB "no match in hypCaseB" m f goal fk sk
      fun contextCaseB m f goal fk sk = caseB "no match in contextCaseB" m f goal fk sk


      fun goalCaseB f (goal as (jud, _)) fk sk =
         caseB "no match in goalCaseB" (N.simplify (J.concl jud)) f goal fk sk


      fun goalContextCaseB f (goal as (jud, _)) fk sk =
         caseB "no match in goalContextCaseB" (J.context jud) f goal fk sk


      fun parseMatch x = x

   end


structure CasePervasive =
   struct

      val termCase = Case.termCase
      val unitCase = Case.unitCase
      val term2Case = Case.term2Case
      val term3Case = Case.term3Case
      val spineCase = Case.spineCase
      val hypCase = Case.hypCase
      val contextCase = Case.contextCase
      val termCaseT = Case.termCaseT
      val unitCaseT = Case.unitCaseT
      val term2CaseT = Case.term2CaseT
      val term3CaseT = Case.term3CaseT
      val spineCaseT = Case.spineCaseT
      val hypCaseT = Case.hypCaseT
      val contextCaseT = Case.contextCaseT
      val goalCaseT = Case.goalCaseT
      val goalContextCaseT = Case.goalContextCaseT
      val termCaseB = Case.termCaseB
      val unitCaseB = Case.unitCaseB
      val term2CaseB = Case.term2CaseB
      val term3CaseB = Case.term3CaseB
      val spineCaseB = Case.spineCaseB
      val hypCaseB = Case.hypCaseB
      val contextCaseB = Case.contextCaseB
      val goalCaseB = Case.goalCaseB
      val goalContextCaseB = Case.goalContextCaseB

      fun parseMatch x = x

   end



structure ParseCase =
   struct

      open Case

      fun id x = x

      val empty = []
      fun sing x = [x]
      fun duo x y = [x, y]
      fun cons h t = h :: t

      fun constpath const spine = elim (constant const) spine
      fun varpath i spine = elim (variable i) spine
         
      fun shortConstant name = Namespace.resolve [Symbol.fromValue name]
      fun longConstant name = Namespace.resolve (map Symbol.fromValue name)

      fun altsing x = alt [x]

   end


grammardef Case

   open ParseCase

   rule Match(4)      ::= "_" => wild
   rule Match(4)      ::= "?" => what
   rule Match(4)      ::= "(" Match(0) ")" => id

   rule Match(3)      ::= "$lit" EMBED => id
   rule Match(3)      ::= "$as" Match(3) => az
   rule Match(3)      ::= "$az" Match(3) => az
   rule Match(3)      ::= "$use" EMBED => use

   rule Match(2)      ::= Match(3) "=>" EMBED => wrap
   rule Match(2)      ::= Match(3) "=!>" EMBED => wrapk

   rule Match(1)      ::= Match(2) ";" Match(1) => seq

   rule Match(0)      ::= AltMatches => alt
   rule Match(0)      ::= "|" AltMatches => alt
   rule Match(0)      ::= "|" Match(1) => altsing
   rule AltMatches    ::= Match(1) "|" Match(1) => duo
   rule AltMatches    ::= Match(1) "|" AltMatches => cons


   (* terms *)
   rule Match(4)      ::= "(" ")" => triv
   rule Match(4)      ::= EMBED => constant
   rule Match(4)      ::= MatchConstant => constant
   rule Match(4)      ::= "$var" EMBED => variable
   rule Match(4)      ::= "const?" => whatConstant
   rule Match(4)      ::= "var?" => whatVar
   rule Match(4)      ::= "evar?" => whatEvar
   rule Match(4)      ::= "nat?" => nat
   rule Match(4)      ::= "integer?" => integer
   rule Match(4)      ::= "notvar?" => notvar

   rule Match(4)      ::= "(" Matches ")" => id
   rule Matches       ::= Match(0) "," Match(0) => pair
   rule Matches       ::= Match(0) "," Matches => pair

   rule Match(3)      ::= Match(4) "@" Match(3) => elim
   rule Match(3)      ::= EMBED NonemptySpine => constpath
   rule Match(3)      ::= MatchConstant NonemptySpine => constpath
   rule Match(3)      ::= "$var" EMBED NonemptySpine => varpath

   rule Match(3)      ::= "next" Match(3) => next
   rule Match(3)      ::= "$marker" EMBED => marker
   rule Match(3)      ::= "$unify" EMBED => unify
   rule Match(3)      ::= "$whnf" Match(3) => whnf
   rule Match(3)      ::= "$whnfHard" Match(3) => whnfHard
   rule Match(3)      ::= "fn" "." Match(3) => lam
   rule Match(3)      ::= "fn" "?" "." Match(3) => lamb

   (* general spines *)
   rule Match(3)      ::= "$nil" => null
   rule Match(3)      ::= "$ap" Match(4) Match(3) => app
   rule Match(3)      ::= "#1" Match(3) => pi1
   rule Match(3)      ::= "#2" Match(3) => pi2
   rule Match(3)      ::= "#prev" Match(3) => prev

   (* hyps *)
   rule Match(3)      ::= "$tm" Match(3) => tm
   rule Match(3)      ::= "$tml" Match(3) => tml
   rule Match(3)      ::= "$tmh" Match(3) => tmh
   rule Match(3)      ::= "$tp" => tp
   rule Match(3)      ::= "$tpl" => tpl
   rule Match(3)      ::= "$let" Match(3) => lett

   (* contexts *)
   rule Match(3)      ::= "$hyp" NUMBER Match(3) => hyp
   rule Match(3)      ::= "$hyp" EMBED Match(3) => hyp
   rule Match(3)      ::= "$anyhyp" Match(3) => anyhyp

   (* special spines *)
   rule Spine         ::= => null
   rule Spine         ::= Match(4) Spine => app
   rule Spine         ::= "#1" Spine => pi1
   rule Spine         ::= "#2" Spine => pi2
   rule Spine         ::= "#prev" Spine => prev
   rule NonemptySpine ::= Match(4) Spine => app
   rule NonemptySpine ::= "#1" Spine => pi1
   rule NonemptySpine ::= "#2" Spine => pi2
   rule NonemptySpine ::= "#prev" Spine => prev

   rule MatchConstant ::= LONGID => longConstant

   reserved "x" "as" "az" "next" "fn" "var" "tm" "tml" "tmh" "tp" "tpl" "ap" : MatchConstant


   start termCase _ Match
   start unitCase Match
   start term2Case _ _ Match
   start term3Case _ _ _ Match
   start spineCase _ Match
   start hypCase _ Match
   start contextCase _ Match
   start termCaseT _ Match
   start unitCaseT Match
   start term2CaseT _ _ Match
   start term3CaseT _ _ _ Match
   start spineCaseT _ Match
   start hypCaseT _ Match
   start contextCaseT _ Match
   start goalCaseT Match
   start goalContextCaseT Match
   start termCaseB _ Match
   start unitCaseB Match
   start term2CaseB _ _ Match
   start term3CaseB _ _ _ Match
   start spineCaseB _ Match
   start hypCaseB _ Match
   start contextCaseB _ Match
   start goalCaseB Match
   start goalContextCaseB Match

   start parseMatch Match

end


grammardef CasePervasive

   open ParseCase

   (* Don't want to use this rule while building the prover. *)
   rule MatchConstant ::= IDENT => shortConstant

end


grammaron Case
