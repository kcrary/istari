
signature INFER =
   sig

      type term = Term.term
      type elim = Term.elim
      type tactic = Tactic.tactic
      type answer = unit


      (* Reported when the type doesn't match the elim.  Carries (1) the term that
         caused the error, (2) the type the next elim saw and didn't expect, 
         (3) an error message.
      *)
      exception Mismatch of term * term option * string

      (* Reported when the term (or one of the terms) is not a path.  Carries an
         error message.
      *)
      exception NotPath of string

      (* Reported by compat when terms are incompatible paths. *)
      exception Clash

      (* Reported when a prefix of the path has an evar type.  Carries (1) the
         term that caused the error, (2) the type (an evar) the next elim saw,
         (3) a continuation to try again.  (The continuation is only usable
         when returned by the CPS variants.)
      *)
      exception Ambiguous of term * term * (unit -> answer)



      (* inferVar G i

         returns (A, tac)
         where  tac proves G |- i : A
         or raises Mismatch if i cannot be typed
      *)
      val inferVar : Judgement.context -> int -> term * tactic


      (* inferConstant const

         returns (A, tac)
         where  tac proves G |- const : A
         or raises Mismatch/NotPath if const cannot be typed
      *)
      val inferConstant : Constant.constant -> term * tactic


      (* infer G M prove

         calls prove to generate tactics for subgoals, and
         returns (A, tac)
         where
         tac proves G |- M : A

         or raises Mismatch/NotPath/Ambiguous

         Prove takes the judgement to prove, and any additional bindings.
      *)
      val infer :
         Judgement.context
         -> term
         -> (Judgement.judgement -> Term.binder list -> tactic)
         -> term * tactic


      (* inferFrom G M A spine tac prove

         if    tac proves G |- M : A
         then  calls prove to generate tactics for subgoals, and
               returns (B, tac')
               where
               tac' proves G |- M spine : B
      
         or raises Mismatch/NotPath/Ambiguous

         Prove takes the judgement to prove, and any additional bindings.
      *)
      val inferFrom :
         Judgement.context
         -> term -> term -> elim list
         -> tactic
         -> (Judgement.judgement -> Term.binder list -> tactic)
         -> term * tactic


      (* inferPartial G M prove

         calls prove to generate tactics for subgoals, and
         return (A, tac, M', spine)
         where
         M = M' spine
         tac proves G |- M' : A
         if spine is nonempty, it starts with a marker

         or raises Mismatch/NotPath/Ambiguous
      *)
      val inferPartial :
         Judgement.context
         -> term
         -> (Judgement.judgement -> Term.binder list -> tactic)
         -> term * tactic * term * elim list


      (* compat G M N prove

         calls prove to generate tactics for subgoals, and
         returns (A, tac)
         tac proves G |- M = N : A

         or raises Mismatch/NotPath/Ambiguous/Clash
      *)
      val compat :
         Judgement.context
         -> term
         -> term
         -> (Judgement.judgement -> Term.binder list -> tactic)
         -> term * tactic


      (* inferCps G M prove fk sk

         calls prove to generate tactics for subgoals, and
         continues with sk (A, tac)
         where
         tac proves G |- M : A

         or continues with fk Mismatch/NotPath/Ambiguous

         Prove takes the judgement to prove, and any additional bindings.
      *)
      val inferCps :
         Judgement.context
         -> term
         -> (Judgement.judgement -> Term.binder list -> tactic)
         -> (exn -> answer)
         -> (term * tactic -> answer)
         -> answer


      (* compatCps G M N prove fk sk

         calls prove to generate tactics for subgoals, and
         continues with sk (A, tac)
         tac proves G |- M = N : A

         or continues with fk Mismatch/NotPath/Ambiguous/Clash
      *)
      val compatCps :
         Judgement.context
         -> term
         -> term
         -> (Judgement.judgement -> Term.binder list -> tactic)
         -> (exn -> answer)
         -> (term * tactic -> answer)
         -> answer

   end


structure Infer :> INFER =
   struct

      structure T = Term
      structure N = Normalize
      structure J = Judgement
      structure S = Seq
      structure D = Directory
      structure R = Reduction

      type term = Term.term
      type elim = Term.elim

      open Tactic
      open CasePervasive

      type answer = unit  (* must be after Tactic is opened *)

      exception Mismatch of term * term option * string
      exception NotPath of string
      exception Clash
      exception Ambiguous of term * term * (unit -> answer)



      fun binddir binder =
         let
            do (_, dir) = withgoal
         in
            chdir (D.bindVary dir binder)
         end


      fun inferVarCps ctx i fk sk =
         (case Seq.nthOpt ctx i of
             SOME (J.Tm a) =>
                sk $
                (T.Sub (a, T.Shift (i+1)),
                 refine (Rule.hypothesisOf i))

           | SOME (J.Tmh a) =>
                sk $
                (T.Sub (a, T.Shift (i+1)),
                 refine (Rule.hypothesisOf i))

           | SOME (J.Let _) =>
                let
                   fun loop j seq =
                      if j < i then
                         (case Seq.expose seq of
                             Seq.Nil =>
                                (* This shouldn't happen unless someone is mucking around. *)
                                NONE

                           | Seq.Cons (J.Tm c, seq') =>
                                (case N.simplify c of
                                    T.Elim (T.Const const, [T.App a, T.App b]) =>
                                       if Constant.eq (const, Prim.ov) then
                                          (case N.simplify b of
                                              T.Elim (T.Var i', []) =>
                                                 if i = i' + j + 1 then
                                                    SOME (j, a)
                                                 else
                                                    loop (j+1) seq'

                                            | _ =>
                                                 loop (j+1) seq')
                                       else
                                          loop (j+1) seq'

                                  | _ =>
                                       loop (j+1) seq')

                           | Seq.Cons (_, seq') =>
                                loop (j+1) seq')
                      else
                         NONE
                in
                   (case loop 0 ctx of
                       NONE =>
                          fk (Mismatch (T.Var i, NONE,
                                        "head variable is let-bound and unsupported by a typing hypothesis"))

                     | SOME (j, a) =>
                          sk $
                          (T.Sub (a, T.Shift (j+1)),
                           refine (Rule.hypothesis j)))
                end

           | NONE =>
                fk (Mismatch (T.Var i, NONE, "head variable is unbound"))

           | SOME _ =>
                fk (Mismatch (T.Var i, NONE, "head variable has improper sort")))



      fun inferConstantCps const fk sk =
         (case Database.findType const of
             NONE =>
                fk (NotPath "head constant has unknown type")

           | SOME (dj, v) =>
                (* v validates dj *)
                termCase (J.concl dj)
                /| \Prim.ov\ ? \const\ =>
                   \(fnc a =>
                        sk $
                        (a,
                         cast dj v >> done))\

                 | _ =>
                   \(fnc =>
                        fk (Mismatch (T.Const const, NONE, "bad type entry in database")))\
                /)


      fun inferVar ctx i =
         inferVarCps ctx i
            (fn exn => raise exn)
            (fn x => x)


      fun inferConstant const =
         inferConstantCps const 
            (fn exn => raise exn)
            (fn x => x)



      (* inferSpine G M A spine tac invis prove

         if    tac proves G |- M : A
         then  calls prove to generate tactics for subgoals, and
               returns (B, tac', M', spine')
               where
               M spine = M' spine', and M' is the largest such
               tac' proves G |- M' : B

         Eliminates intersect/guard/foralltp at the end of the spine only if invis=true.
      *)
      fun inferSpine ctx m a spine tac invis prove =
         if invis orelse not (List.null spine) then
            termCase (N.whnfHard a)
            /| \Prim.intersect\ ? (fn . ?) =>
               \(fnc dom cod =>
                    let
                       val e = T.evar ()
                       
                       val etac = prove (J.make ctx (T.apply2 Prim.ov dom e)) []
 
                       val tac' =
                          (* G |- M : Cod[E . id] *)
                          refine (Rule.intersectElimOf dom cod m e)
                          >>> [
                              (* G |- M : intersect Dom . Cod *)
                              tac,
    
                              (* G |- E : Dom *)
                              etac
                              ]
                    in
                       inferSpine ctx m
                          (T.Sub (cod, T.Dot (e, T.id)))
                          spine tac' invis prove
                    end)\

             | \Prim.iforall\ ? ? (fn ? . ?) =>
               \(fnc lev dom binder cod =>
                    let
                       val e = T.evar ()

                       val tac1 =
                          prove (J.make (S.cons (J.Tm dom) ctx) (T.apply1 Prim.istp cod)) [binder]

                       val tac2 =
                          prove (J.make ctx (T.apply2 Prim.ov dom e)) []
                    
                       val tac' =
                          (* G |- M : Cod[E . id] *)
                          refine (Rule.iforallElimOf cod lev dom m e)
                          >>> [
                              (* G, K |- Cod : type *)
                              binddir binder >> tac1,

                              (* G |- M : iforall Lev Dom (fn . Cod) *)
                              tac,

                              (* G |- E : Dom *)
                              tac2
                              ]
                    in
                       inferSpine ctx m
                          (T.Sub (cod, T.Dot (e, T.id)))
                          spine tac' invis prove
                    end)\

             | \Prim.guard\ ? ? =>
               \(fnc dom cod =>
                    let
                       val etac = prove (J.make ctx dom) []
 
                       val tac' =
                          (* G |- M : Cod *)
                          refine (Rule.guardElimOf dom cod m)
                          >>> [
                              (* G |- M : guard Dom Cod *)
                              tac,
    
                              (* G |- Dom *)
                              etac
                              ]
                    in
                       inferSpine ctx m cod
                          spine tac' invis prove
                    end)\

             | \Prim.foralltp\ (fn ? . ?) =>
               \(fnc binder cod =>
                    let
                       val e = T.evar ()
 
                       val tac1 =
                          prove (J.make (S.cons J.Tp ctx) (T.apply1 Prim.istp cod)) [binder]

                       val tac2 =
                          prove (J.make ctx (T.apply1 Prim.istp e)) []
 
                       val tac' =
                          (* G |- M : Cod[E . id] *)
                          refine (Rule.foralltpElimOf cod e m)
                          >>> [
                              (* G, type |- Cod : type *)
                              binddir binder >> tac1,
 
                              (* G |- M : foralltp . Cod *)
                              tac,
 
                              (* G |- E : type *)
                              tac2
                              ]
                    in
                       inferSpine ctx m
                          (T.Sub (cod, T.Dot (e, T.id)))
                          spine tac' invis prove
                    end)\

             | \Prim.set\ ? (fn . ?) =>
               \(fnc b c =>
                    (case spine of
                        nil =>
                           (* only eliminate set when there are more elims to come *)
                           (a, tac, m, [])

                      | _ :: _ =>
                           let
                              val tac' =
                                 (* G |- M : B *)
                                 refine (Rule.setWeakenOf b c m)
                                 >>+
                                 (* G |- M : { B | C } *)
                                 tac
                           in
                              inferSpine ctx m b spine tac' invis prove
                           end))\

             | ? =>
               \(fnc a' =>
                    inferSpineElim ctx m a spine tac invis prove)\
            /
         else
            inferSpineElim ctx m a spine tac invis prove
            


      (* inferSpineElim G M A spine tac invis prove

         As inferSpine except A is not an intersect/guard/foralltp.
      *)
      and inferSpineElim ctx m a spine tac invis prove =
         (case spine of
             [] =>
                (a, tac, m, [])

           | T.App (T.Marker _) :: _ =>
                (* Stop quickly here. *)
                (a, tac, m, spine)

           | T.App p :: rest =>
                termCase (N.whnfHard a)
                /| \Prim.arrow\ ? ? =>
                   \(fnc dom cod =>
                        let
                           val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
 
                           val tac' =
                              (* G |- M P : Cod *)
                              refine (Rule.arrowElimOf dom cod m p)
                              >>> [
                                  (* G |- M : Dom -> Cod *)
                                  tac,
                                  
                                  (* G |- P : Dom *)
                                  ptac
                                  ]
                        in
                           inferSpine ctx (T.app m p)
                              cod rest tac' invis prove
                        end)\

                 | \Prim.forall\ ? (fn . ?) =>
                   \(fnc dom cod =>
                        let
                           val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
 
                           val tac' =
                              (* G |- M P : Cod[P . id] *)
                              refine (Rule.forallElimOf dom cod m p)
                              >>> [
                                  (* G |- M : forall Dom . Cod *)
                                  tac,
                                  
                                  (* G |- P : Dom *)
                                  ptac
                                  ]
                        in
                           inferSpine ctx (T.app m p)
                              (T.Sub (cod, T.Dot (p, T.id)))
                              rest tac' invis prove
                        end)\

                 | \Prim.tarrow\ ? ? =>
                   \(fnc dom cod =>
                        let
                           val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
 
                           val tac' =
                              (* G |- M P : Cod *)
                              refine (Rule.tarrowElimOf dom cod m p)
                              >>> [
                                  (* G |- M : Dom -t> Cod *)
                                  tac,
                                  
                                  (* G |- P : Dom *)
                                  ptac
                                  ]
                        in
                           inferSpine ctx (T.app m p)
                              cod rest tac' invis prove
                        end)\

                 | \Prim.karrow\ ? ? =>
                   \(fnc dom cod =>
                        let
                           val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
 
                           val tac' =
                              (* G |- M P : Cod *)
                              refine (Rule.karrowElimOf dom cod m p)
                              >>> [
                                  (* G |- M : Dom -k> Cod *)
                                  tac,
                                  
                                  (* G |- P : Dom *)
                                  ptac
                                  ]
                        in
                           inferSpine ctx (T.app m p)
                              cod rest tac' invis prove
                        end)\

                 | ? =>
                   \(fnc a' =>
                        inferSpineRetry ctx m a' spine tac invis prove)\
                /

           | T.Pi1 :: rest =>
                termCase (N.whnfHard a)
                /| \Prim.prod\ ? ? =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #1 : A1 *)
                              refine (Rule.prodElim1Of a1 a2 m)
                              >>
                              (* G |- M : A1 & A2 *)
                              tac
                        in
                           inferSpine ctx (T.pi1 m) a1 rest tac' invis prove
                        end)\

                 | \Prim.exists\ ? (fn . ?) =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #1 : A1 *)
                              refine (Rule.existsElim1Of a1 a2 m)
                              >>
                              (* G |- M : exists A1 . A2 *)
                              tac
                        in
                           inferSpine ctx (T.pi1 m) a1 rest tac' invis prove
                        end)\

                 | ? =>
                   \(fnc a' =>
                        inferSpineRetry ctx m a' spine tac invis prove)\
                /

           | T.Pi2 :: rest =>
                termCase (N.whnfHard a)
                /| \Prim.prod\ ? ? =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #2 : A2 *)
                              refine (Rule.prodElim2Of a1 a2 m)
                              >>
                              (* G |- M : A1 & A2 *)
                              tac
                        in
                           inferSpine ctx (T.pi2 m) a2 rest tac' invis prove
                        end)\

                 | \Prim.exists\ ? (fn . ?) =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #2 : A2[M #1 . id] *)
                              refine (Rule.existsElim2Of a1 a2 m)
                              >>
                              (* G |- M : exists A1 . A2 *)
                              tac
                        in
                           inferSpine ctx (T.pi2 m)
                              (T.Sub (a2, T.Dot (T.pi1 m, T.id)))
                              rest tac' invis prove
                        end)\

                 | ? =>
                   \(fnc a' =>
                        inferSpineRetry ctx m a' spine tac invis prove)\
                /

           | T.Prev :: rest =>
                (* Cannot typecheck a prev in isolation. *)
                (a, tac, m, spine))



      (* inferSpineRetry G M A spine tac invis prove

         As inferSpine except:
         - A is not an intersect/guard/foralltp
         - A does not match the first elim in spine
         - A in whnf

         Tries to unfold A and proceed.
      *)
      and inferSpineRetry ctx m a spine tac invis prove =
         termCase a
         /| const? @ ? =>
            \(fnc const aspine =>
                 (case Constant.definition const of
                     NONE =>
                        (a, tac, m, spine)

                   | SOME n =>
                        let
                           val tac' =
                              (* G |- M : N @ aspine *)
                              refine (Rule.unreduce
                                         (T.apply2 Prim.ov a m)
                                         (R.within [1] R.unfold))
                              >>+
                              (* G |- M : A *)
                              tac
                        in
                           inferSpine ctx m (T.Elim (n, aspine)) spine tac' invis prove
                        end))\

          | _ =>
            \(fnc =>
                 (a, tac, m, spine))\
         /



      (* calls ak for ambiguous inference *)
      fun 'a detectInferError m a spine (fk : exn -> 'a) (ak : unit -> 'a) (sk : unit -> 'a) : 'a =
         (case spine of
             [] => sk ()

           | elim :: _ =>
                (case Normalize.simplify a of
                    a as (T.Elim (T.Sub _, _)) =>
                       ak ()

                  | _ =>
                       fk (Mismatch
                              (T.Elim (m, [elim]), SOME a,
                               (case elim of
                                   T.App (T.Marker _) => "marker encountered"

                                 | T.App _ => "ill-typed application"

                                 | T.Pi1 => "ill-typed projection"

                                 | T.Pi2 => "ill-typed projection"

                                 | T.Prev => "isolated previous")))))



      (* inferMain G M invis prove fk ak sk

         calls prove to generate tactics for subgoals, and
         continues with sk (A, tac, M', spine)
         where
         M = M' spine, and M' is the largest such
         tac proves G |- M' : A

         or continues with ak (M', A, resume) or fk error

         Eliminates intersect/guard/foralltp at the end of the spine only if invis=true.

         Answer type is polymorphic (not answer).
      *)
      fun 'a inferMain ctx m invis prove (fk : exn -> 'a) (ak : term * term * (unit -> 'a) -> 'a) (sk : term * tactic * term * elim list -> 'a) : 'a =
         termCase m
         /| var? @ ? =>
            \(fnc i spine =>
                 let
                    do (a, tac) = inferVarCps ctx i fk
                 in
                    sk (inferSpine ctx (T.Var i) a spine tac invis prove)
                 end)\

          | const? @ ? =>
            \(fnc const spine =>
                 (* special cases for typechecking directives *)
                 if Constant.eq (const, Prim.ann) then
                    (case spine of
                        T.App a :: T.App m' :: rest =>
                           let
                              val ntac = prove (J.make ctx (T.apply2 Prim.ov a m')) []
 
                              val tac =
                                 (* G |- ann A M' : A *)
                                 refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                 >>
                                 (* G |- M' : A *)
                                 ntac
                           in
                              sk (inferSpine ctx (T.apply2 Prim.ann a m') a rest tac invis prove)
                           end
 
                      | _ =>
                           fk (Mismatch (m, NONE, "ill-formed annotation")))
 
                 else if Constant.eq (const, Prim.fnann) then
                    (case spine of
                        T.App a :: T.App m' :: rest =>
                           let
                              val b = T.apply2 Prim.forall a (T.Lam (NONE, T.evar ()))

                              val ntac = prove (J.make ctx (T.apply2 Prim.ov b m')) []
 
                              val tac =
                                 (* G |- fnann A M' : B *)
                                 refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                 >>
                                 (* G |- M' : B *)
                                 ntac
                           in
                              sk (inferSpine ctx (T.apply2 Prim.fnann a m') b rest tac invis prove)
                           end
 
                      | _ =>
                           fk (Mismatch (m, NONE, "ill-formed annotated function")))

                 else if Constant.eq (const, Prim.ap) then
                    (case spine of
                        T.App m' :: T.App p :: rest =>
                           let
                              fun kloop (a, mtac, m'', remainder) =
                                 let
                                    fun resume () = 
                                       kloop (inferSpine ctx m'' a remainder mtac false prove)
                                    
                                    do () =
                                       detectInferError m'' a remainder fk
                                          (fn () => ak (m'', a, resume))

                                    (* remainder = [] so M' = M''
                                       mtac proves G |- M' : A
                                    *)
                                 in
                                    termCase (N.whnfHard a)
                                    /| \Prim.intersect\ ? (fn . ?) =>
                                       \(fnc dom cod =>
                                            let
                                               val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
        
                                               val tac' =
                                                  (* G |- ap M' P : Cod[P . id] *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' : Cod[P . id] *)
                                                  refine (Rule.intersectElimOf dom cod m' p)
                                                  >>> [
                                                      (* G |- M' : intersect Dom . Cod *)
                                                      mtac,
                            
                                                      (* G |- P : Dom *)
                                                      ptac,
                                                      ]
                                            in
                                               sk $
                                               inferSpine ctx
                                                  (T.apply2 Prim.ap m' p)
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest tac' invis prove
                                            end)\
      
                                     | \Prim.iforall\ ? ? (fn ? . ?) =>
                                       \(fnc lev dom binder cod =>
                                            let
                                               val tac1 =
                                                  prove (J.make (S.cons (J.Tm dom) ctx) (T.apply1 Prim.istp cod)) [binder]
                        
                                               val tac2 =
                                                  prove (J.make ctx (T.apply2 Prim.ov dom p)) []
      
                                               val tac' =
                                                  (* G |- ap M' P : Cod[P . id] *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' : Cod[P . id] *)
                                                  refine (Rule.iforallElimOf cod lev dom m' p)
                                                  >>> [
                                                      (* G, K |- Cod : type *)
                                                      binddir binder >> tac1,
                        
                                                      (* G |- M' : iforall Lev Dom (fn . Cod) *)
                                                      mtac,
                        
                                                      (* G |- P : Dom *)
                                                      tac2
                                                      ]
                                            in
                                               sk $
                                               inferSpine ctx
                                                  (T.apply2 Prim.ap m' p)
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest tac' invis prove
                                            end)\
      
                                     | \Prim.guard\ ? ? =>
                                       \(fnc dom cod =>
                                            let
                                               val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
        
                                               val tac' =
                                                  (* G |- ap M' P : Cod *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' : Cod *)
                                                  refine (Rule.guardElimOf dom cod m')
                                                  >>> [
                                                      (* G |- M' : guard Dom Cod *)
                                                      mtac,
                            
                                                      (* G |- Dom *)
                                                      refine (Rule.inhabitant (T.evar ()) p)
                                                      >>
                                                      (* G |- P : Dom *)
                                                      ptac,
                                                      ]
                                            in
                                               sk $
                                               inferSpine ctx m' cod
                                                  rest tac' invis prove
                                            end)\
      
                                     | \Prim.foralltp\ (fn ? . ?) =>
                                       \(fnc binder cod =>
                                            let
                                               val tac1 = prove (J.make (S.cons J.Tp ctx) (T.apply1 Prim.istp cod)) [binder]
                                               val tac2 = prove (J.make ctx (T.apply1 Prim.istp p)) []
        
                                               val tac' =
                                                  (* G |- ap M' P : Cod[P . id] *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' : Cod[P . id] *)
                                                  refine (Rule.foralltpElimOf cod p m')
                                                  >>> [
                                                      (* G, type |- Cod : type *)
                                                      binddir binder >> tac1,
                         
                                                      (* G |- M' : foralltp . Cod *)
                                                      mtac,
                         
                                                      (* G |- P : type *)
                                                      tac2
                                                      ]
                                            in
                                               sk $
                                               inferSpine ctx
                                                  (T.apply2 Prim.ap m' p)
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest tac' invis prove
                                            end)\
      
                                     | _ =>
                                       \(fnc =>
                                            fk (Mismatch (m, SOME a, "ill-typed visibilized application")))\
                                    /
                                 end
                           in
                              inferMain ctx m' false prove fk ak kloop
                           end
 
                      | _ =>
                           fk (Mismatch (m, NONE, "ill-formed visibilized application")))
 
                 else if Constant.eq (const, Prim.paramapp) then
                    (case spine of
                        T.App m' :: T.App p :: rest =>
                           let
                              fun kloop (a, mtac, m'', remainder) =
                                 let
                                    fun resume () = 
                                       kloop (inferSpine ctx m'' a remainder mtac false prove)
                                    
                                    do () =
                                       detectInferError m'' a remainder fk
                                          (fn () => ak (m'', a, resume))

                                    (* remainder = [] so M' = M''
                                       mtac proves G |- M' : A
                                    *)
                                 in
                                    termCase (N.whnfHard a)
                                    /| \Prim.parametric\ ? (fn . ?) =>
                                       \(fnc dom cod =>
                                            let
                                               val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
                     
                                               val tac' =
                                                  (* G |- paramapp M' P : Cod[P . id] *)
                                                  refine (Rule.parametricElimOf dom cod m' p)
                                                  >>> [
                                                      (* G |- M' : parametric Dom . Cod *)
                                                      mtac,
                                                      
                                                      (* G |- P : Dom *)
                                                      ptac
                                                      ]
                                            in
                                               sk $
                                               inferSpine ctx 
                                                  (T.apply2 Prim.paramapp m' p)
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest tac' invis prove
                                            end)\

                                     | _ =>
                                       \(fnc =>
                                            fk (Mismatch (m, SOME a, "ill-typed parametric application")))\
                                    /
                                 end
                           in
                              inferMain ctx m' false prove fk ak kloop
                           end

                      | _ =>
                           fk (Mismatch (m, NONE, "ill-formed parametric application")))

                 (* the normal case *)
                 else
                    let
                       do (a, atac) = inferConstantCps const fk
                    in
                       sk (inferSpine ctx (T.Const const) a spine atac invis prove)
                    end)\

          | _ =>
            \(fnc =>
                 fk (NotPath "not a path"))\
         /


      fun nullcont () = raise (Fail "not resumable")


      fun infer ctx m prove =
         let
            fun fk err = raise err

            do (a, tac, m', remainder) =
               inferMain ctx m true prove fk
                  (fn (m', a, _) => raise (Ambiguous (m', a, nullcont)))

            do () =
               detectInferError m' a remainder fk
                  (fn () => raise (Ambiguous (m', a, nullcont)))
         in
            (a, tac)
         end


      fun inferFrom ctx m a spine tac prove =
         let
            val (b, tac', n, remainder) = inferSpine ctx m a spine tac true prove

            do () =
               detectInferError n b remainder
                  (fn err => raise err)
                  (fn () => raise (Ambiguous (n, b, nullcont)))
         in
            (b, tac')
         end


      fun inferPartial ctx m prove =
         let
            fun fk err = raise err

            do (a, tac, m', remainder) =
               inferMain ctx m true prove fk 
                  (fn (m', a, _) => raise (Ambiguous (m', a, nullcont)))

         in
            (case remainder of
                [] => (a, tac, m, [])

              | T.App (T.Marker _) :: _ => (a, tac, m', remainder)

              | _ =>
                   detectInferError m' a remainder fk
                      (fn () => raise (Ambiguous (m', a, nullcont)))
                      (fn () => raise (Fail "unreachable")))
         end


      fun inferCps ctx m prove fk sk =
         let
            fun kloop (a, tac, m', remainder) =
               let
                  fun resume () = 
                     kloop (inferSpine ctx m' a remainder tac true prove)

                  do () =
                     detectInferError m' a remainder fk 
                        (fn () => fk (Ambiguous (m', a, resume)))
               in
                  sk (a, tac)
               end
         in
            inferMain ctx m true prove fk
               (fn (m', a, resume) => fk (Ambiguous (m', a, resume)))
               kloop
         end


      (* compatSpine G M N A spine1 spine2 tac invis

         if    tac proves G |- M = N : A
         then  calls prove to generate tactics for subgoals, and
               returns (B, tac', M', N', spine1', spine2')
               where
               M spine1 = M' spine1', N spine2 = N' spine2', and M' and N' are the largest such
               tac' proves G |- M' = N' : B

         Eliminates intersect/foralltp/guard at the end of spine1 only if invis=true.

         Similar code to inferSpine.
      *)
      fun compatSpine ctx m n a spine1 spine2 tac invis prove =
         if invis orelse not (List.null spine1) then
            termCase (N.whnfHard a)
            /| \Prim.intersect\ ? (fn . ?) =>
               \(fnc dom cod =>
                    let
                       val e = T.evar ()
                       
                       val etac = prove (J.make ctx (T.apply2 Prim.ov dom e)) []
 
                       val tac' =
                          (* G |- M = N : Cod[E . id] *)
                          refine (Rule.intersectElimEq dom cod m n e)
                          >>> [
                              (* G |- M = N : intersect Dom . Cod *)
                              tac,
    
                              (* G |- E : Dom *)
                              etac
                              ]
                       in
                          compatSpine ctx m n
                             (T.Sub (cod, T.Dot (e, T.id)))
                             spine1 spine2 tac' invis prove
                       end)\

             | \Prim.iforall\ ? ? (fn ? . ?) =>
               \(fnc lev dom binder cod =>
                    let
                       val e = T.evar ()

                       val tac1 =
                          prove (J.make (S.cons (J.Tm dom) ctx) (T.apply1 Prim.istp cod)) [binder]

                       val tac2 =
                          prove (J.make ctx (T.apply2 Prim.ov dom e)) []
                    
                       val tac' =
                          (* G |- M : Cod[E . id] *)
                          refine (Rule.iforallElimEq cod lev dom m n e)
                          >>> [
                              (* G, K |- Cod : type *)
                              binddir binder >> tac1,

                              (* G |- M = N : iforall Lev Dom (fn . Cod) *)
                              tac,

                              (* G |- E : Dom *)
                              tac2
                              ]
                    in
                       compatSpine ctx m n
                          (T.Sub (cod, T.Dot (e, T.id)))
                          spine1 spine2 tac' invis prove
                    end)\

             | \Prim.guard\ ? ? =>
               \(fnc dom cod =>
                    let
                       val etac = prove (J.make ctx dom) []
 
                       val tac' =
                          (* G |- M = N : Cod *)
                          refine (Rule.guardElimEq dom cod m n)
                          >>> [
                              (* G |- M = N : guard Dom Cod *)
                              tac,
    
                              (* G |- Dom *)
                              etac
                              ]
                    in
                       compatSpine ctx m n cod
                          spine1 spine2 tac' invis prove
                    end)\

             | \Prim.foralltp\ (fn ? . ?) =>
               \(fnc binder cod =>
                    let
                       val e = T.evar ()
 
                       val tac1 = prove (J.make (S.cons J.Tp ctx) (T.apply1 Prim.istp cod)) [binder]
                       val tac2 = prove (J.make ctx (T.apply1 Prim.istp e)) []
 
                       val tac' =
                          (* G |- M = N : Cod[E . id] *)
                          refine (Rule.foralltpElimEq cod e m n)
                          >>> [
                              (* G, type |- Cod : type *)
                              binddir binder >> tac1,
 
                              (* G |- M = N : foralltp . Cod *)
                              tac,
 
                              (* G |- E : type *)
                              tac2
                              ]
                    in
                       compatSpine ctx m n
                          (T.Sub (cod, T.Dot (e, T.id)))
                          spine1 spine2 tac' invis prove
                    end)\

             | \Prim.set\ ? (fn . ?) =>
               \(fnc b c =>
                    (case spine1 of
                        nil =>
                           (* only eliminate set when there are more elims to come *)
                           (a, tac, m, n, spine1, spine2)

                      | _ :: _ =>
                           let
                              val tac' =
                                 (* G |- M = N : B *)
                                 refine (Rule.setWeakenEq b c m n)
                                 >>+
                                 (* G |- M = N : { B | C } *)
                                 tac
                           in
                              compatSpine ctx m n b spine1 spine2 tac' invis prove
                           end))\

             | ? =>
               \(fnc a' =>
                    compatSpineElim ctx m n a' spine1 spine2 tac invis prove)\
            /
         else
            compatSpineElim ctx m n (N.whnfHard a) spine1 spine2 tac invis prove



      (* compatSpineElim G M N A spine1 spine2 tac invis prove

         As compatSpine except A is hard whnf and not an intersect/guard/foralltp.

         Similar code to inferSpineElim.
      *)
      and compatSpineElim ctx m n a spine1 spine2 tac invis prove =
         (case (spine1, spine2) of
             ([], _) =>
                (a, tac, m, n, spine1, spine2)
                
           | (_, []) =>
                (a, tac, m, n, spine1, spine2)

           | (T.App (T.Marker _) :: _, _) => 
                (a, tac, m, n, spine1, spine2)

           | (_, T.App (T.Marker _) :: _) => 
                (a, tac, m, n, spine1, spine2)

           | (T.App p :: rest1, T.App q :: rest2) =>
                termCase a
                /| \Prim.arrow\ ? ? =>
                   \(fnc dom cod =>
                        let
                           val pqtac = prove (J.make ctx (T.apply3 Prim.eq dom p q)) []
 
                           val tac' =
                              (* G |- M P = N Q : Cod *)
                              refine (Rule.arrowElimEq dom cod m n p q)
                              >>> [
                                  (* G |- M = N : Dom -> Cod *)
                                  tac,
                                  
                                  (* G |- P = Q : Dom *)
                                  pqtac
                                  ]
                        in
                           compatSpine ctx (T.app m p) (T.app n q)
                              cod rest1 rest2 tac' invis prove
                        end)\

                 | \Prim.forall\ ? (fn . ?) =>
                   \(fnc dom cod =>
                        let
                           val pqtac = prove (J.make ctx (T.apply3 Prim.eq dom p q)) []
 
                           val tac' =
                              (* G |- M P = N Q : Cod[P . id] *)
                              refine (Rule.forallElimEq dom cod m n p q)
                              >>> [
                                  (* G |- M = N : forall Dom . Cod *)
                                  tac,
                                  
                                  (* G |- P = Q : Dom *)
                                  pqtac
                                  ]
                        in
                           compatSpine ctx (T.app m p) (T.app n q)
                              (T.Sub (cod, T.Dot (p, T.id)))
                              rest1 rest2 tac' invis prove
                        end)\

                 | \Prim.tarrow\ ? ? =>
                   \(fnc dom cod =>
                        let
                           val pqtac = prove (J.make ctx (T.apply3 Prim.eq dom p q)) []
 
                           val tac' =
                              (* G |- M P = N Q : Cod *)
                              refine (Rule.tarrowElimEq dom cod m n p q)
                              >>> [
                                  (* G |- M = N : Dom -t> Cod *)
                                  tac,
                                  
                                  (* G |- P = Q : Dom *)
                                  pqtac
                                  ]
                        in
                           compatSpine ctx (T.app m p) (T.app n q)
                              cod rest1 rest2 tac' invis prove
                        end)\

                 | \Prim.karrow\ ? ? =>
                   \(fnc dom cod =>
                        let
                           val pqtac = prove (J.make ctx (T.apply3 Prim.eq dom p q)) []
 
                           val tac' =
                              (* G |- M P = N Q : Cod *)
                              refine (Rule.karrowElimEq dom cod m n p q)
                              >>> [
                                  (* G |- M = N : Dom -k> Cod *)
                                  tac,
                                  
                                  (* G |- P = Q : Dom *)
                                  pqtac
                                  ]
                        in
                           compatSpine ctx (T.app m p) (T.app n q)
                              cod rest1 rest2 tac' invis prove
                        end)\

                 | _ =>
                   \(fnc =>
                        (a, tac, m, n, spine1, spine2))\
                /

           | (T.Pi1 :: rest1, T.Pi1 :: rest2) =>
                termCase a
                /| \Prim.prod\ ? ? =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #1 = N #1 : A1 *)
                              refine (Rule.prodElim1Eq a1 a2 m n)
                              >>
                              (* G |- M = N : A1 & A2 *)
                              tac
                        in
                           compatSpine ctx (T.pi1 m) (T.pi1 n) a1 rest1 rest2 tac' invis prove
                        end)\

                 | \Prim.exists\ ? (fn . ?) =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #1 = N #1 : A1 *)
                              refine (Rule.existsElim1Eq a1 a2 m n)
                              >>
                              (* G |- M = N : exists A1 . A2 *)
                              tac
                        in
                           compatSpine ctx (T.pi1 m) (T.pi1 n) a1 rest1 rest2 tac' invis prove
                        end)\

                 | _ =>
                   \(fnc =>
                        (a, tac, m, n, spine1, spine2))\
                /

           | (T.Pi2 :: rest1, T.Pi2 :: rest2) =>
                termCase a
                /| \Prim.prod\ ? ? =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #2 = N #2 : A2 *)
                              refine (Rule.prodElim2Eq a1 a2 m n)
                              >>
                              (* G |- M = N : A1 & A2 *)
                              tac
                        in
                           compatSpine ctx (T.pi2 m) (T.pi2 n) a2 rest1 rest2 tac' invis prove
                        end)\

                 | \Prim.exists\ ? (fn . ?) =>
                   \(fnc a1 a2 =>
                        let
                           val tac' =
                              (* G |- M #2 = N #2 : A2[M #1 . id] *)
                              refine (Rule.existsElim2Eq a1 a2 m n)
                              >>
                              (* G |- M = N : exists A1 . A2 *)
                              tac
                        in
                           compatSpine ctx (T.pi2 m) (T.pi2 n)
                              (T.Sub (a2, T.Dot (T.pi1 m, T.id)))
                              rest1 rest2 tac' invis prove
                        end)\

                 | _ =>
                   \(fnc =>
                        (a, tac, m, n, spine1, spine2))\
                /

           | _ =>
                (* prev or clash *)
                (a, tac, m, n, spine1, spine2))



      (* calls ak for ambiguous inference *)
      fun 'a detectCompatError m a spine1 spine2 (fk : exn -> 'a) (ak : unit -> 'a) (sk : unit -> 'a) : 'a =
         (case (spine1, spine2) of
             ([], []) => sk ()

           | ([], _) => fk Clash

           | (_, []) => fk Clash

           | (elim1 :: _, elim2 :: _) =>
                (case Normalize.simplify a of
                    a as (T.Elim (T.Sub _, _)) =>
                       ak ()

                  | _ =>
                       fk (case (elim1, elim2) of
                              (T.App _, T.App _) =>
                                 Mismatch (T.Elim (m, [elim1]), SOME a, "ill-typed application")
          
                            | (T.Pi1, T.Pi1) =>
                                 Mismatch (T.Elim (m, [elim1]), SOME a, "ill-typed projection")
          
                            | (T.Pi2, T.Pi2) =>
                                 Mismatch (T.Elim (m, [elim1]), SOME a, "ill-typed projection")
          
                            | (T.Prev, T.Prev) =>
                                 Mismatch (T.Elim (m, [elim1]), SOME a, "isolated previous")
          
                            | _ => Clash)))



      (* compatMain G M N invis prove fk sk

         calls prove to generate tactics for subgoals, and
         continues with sk (A, tac, M', N', spine1, spine2)
         where
         M = M' spine1, N = N' spine2, and M' and N' are the largest such
         tac proves G |- M' = N' : A

         or continues with ak (M', A, resume) or fk error

         Eliminates intersect/guard/foralltp at the end of the spine only if invis=true.

         Polymorphic answer type (not answer).
      *)
      fun 'a compatMain ctx m n invis prove (fk : exn -> 'a) (ak : term * term * (unit -> 'a) -> 'a) (sk : term * tactic * term * term * elim list * elim list -> 'a) : 'a =
         termCase m
         /| var? @ ? =>
            \(fnc i spine1 =>
                 termCase n
                 /| var? @ ? =>
                    \(fnc j spine2 =>
                         if i = j then
                            let
                               do (a, tac) = inferVarCps ctx i fk
  
                               val tac' =
                                  (* G |- i = i : A *)
                                  refine (Rule.eqRefl (T.evar ()) (T.evar ()))
                                  >>
                                  (* G |- i : A *)
                                  tac
                            in
                               sk (compatSpine ctx (T.Var i) (T.Var i) a spine1 spine2 tac' invis prove)
                            end
                         else
                            fk Clash)\

                  | const? @ _ =>
                    \(fnc _ =>
                         fk Clash)\

                  | _ =>
                    \(fnc =>
                         fk (NotPath "second term is not a path"))\
                 /)\

          | const? @ ? =>
            \(fnc const spine1 =>
                 (* special cases for typechecking directives *)
                 if Constant.eq (const, Prim.ann) then
                    fk (NotPath "first term is annotated")
 
                 else if Constant.eq (const, Prim.fnann) then
                    fk (NotPath "first term is annotated function")
 
                 else if Constant.eq (const, Prim.ap) then
                    (case spine1 of
                        T.App m' :: T.App p :: rest1 =>
                           let
                              fun kloop (a, mntac, m'', n', rest, rest2) : 'a =
                                 let
                                    do () =
                                       (case rest of
                                           [] => (fn k => k ())
       
                                         | _ =>
                                              let
                                                 fun resume () =
                                                    kloop (compatSpine ctx m'' n' a rest rest2 mntac false prove)
                                              in
                                                 detectCompatError m'' a rest1 rest2 fk
                                                    (fn () => ak (m'', a, resume))
                                              end)
       
                                    (* rest = []  so  M'' = M'
                                       N = N' rest2
                                       mntac proves G |- M' = N' : A
                                    *)
                                 in
                                    termCase (N.whnfHard a)
                                    /| \Prim.intersect\ ? (fn . ?) =>
                                       \(fnc dom cod =>
                                            let
                                               val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
        
                                               val tac' =
                                                  (* G |- ap M' P = N' : Cod[P . id] *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' = N' : Cod[P . id] *)
                                                  refine (Rule.intersectElimEq dom cod m' n' p)
                                                  >>> [
                                                      (* G |- M' = N' : intersect Dom . Cod *)
                                                      mntac,
                            
                                                      (* G |- P : Dom *)
                                                      ptac,
                                                      ]
                                            in
                                               sk $
                                               compatSpine ctx
                                                  (T.apply2 Prim.ap m' p) n'
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest1 rest2 tac' invis prove
                                            end)\
      
                                     | \Prim.iforall\ ? ? (fn ? . ?) =>
                                       \(fnc lev dom binder cod =>
                                            let
                                               val tac1 =
                                                  prove (J.make (S.cons (J.Tm dom) ctx) (T.apply1 Prim.istp cod)) [binder]
                        
                                               val tac2 =
                                                  prove (J.make ctx (T.apply2 Prim.ov dom p)) []
      
                                               val tac' =
                                                  (* G |- ap M' P = N' : Cod[P . id] *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' = N' : Cod[P . id] *)
                                                  refine (Rule.iforallElimEq cod lev dom m' n' p)
                                                  >>> [
                                                      (* G, K |- Cod : type *)
                                                      binddir binder >> tac1,
                        
                                                      (* G |- M' = N' : iforall Lev Dom (fn . Cod) *)
                                                      mntac,
                        
                                                      (* G |- P : Dom *)
                                                      tac2
                                                      ]
                                            in
                                               sk $
                                               compatSpine ctx
                                                  (T.apply2 Prim.ap m' p) n'
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest1 rest2 tac' invis prove
                                            end)\
      
                                     | \Prim.guard\ ? ? =>
                                       \(fnc dom cod =>
                                            let
                                               val ptac = prove (J.make ctx (T.apply2 Prim.ov dom p)) []
        
                                               val tac' =
                                                  (* G |- ap M' P = N' : Cod *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' = N' : Cod *)
                                                  refine (Rule.guardElimEq dom cod m' n')
                                                  >>> [
                                                      (* G |- M' = N' : guard Dom Cod *)
                                                      mntac,
                            
                                                      (* G |- Dom *)
                                                      refine (Rule.inhabitant (T.evar ()) p)
                                                      >>
                                                      (* G |- P : Dom *)
                                                      ptac,
                                                      ]
                                            in
                                               sk $
                                               compatSpine ctx m' n' cod
                                                  rest1 rest2 tac' invis prove
                                            end)\
      
                                     | \Prim.foralltp\ (fn ? . ?) =>
                                       \(fnc binder cod =>
                                            let
                                               val tac1 = prove (J.make (S.cons J.Tp ctx) (T.apply1 Prim.istp cod)) [binder]
                                               val tac2 = prove (J.make ctx (T.apply1 Prim.istp p)) []
        
                                               val tac' =
                                                  (* G |- ap M' P = N' : Cod[P . id] *)
                                                  refine (Rule.reduce (R.within [2] (R.trans [R.unfold, R.beta 2])))
                                                  >>
                                                  (* G |- M' = N' : Cod[P . id] *)
                                                  refine (Rule.foralltpElimEq cod p m' n')
                                                  >>> [
                                                      (* G, type |- Cod : type *)
                                                      binddir binder >> tac1,
                         
                                                      (* G |- M' = N : foralltp . Cod *)
                                                      mntac,
                         
                                                      (* G |- P : type *)
                                                      tac2
                                                      ]
                                            in
                                               sk $
                                               compatSpine ctx
                                                  (T.apply2 Prim.ap m' p) n'
                                                  (T.Sub (cod, T.Dot (p, T.id)))
                                                  rest1 rest2 tac' invis prove
                                            end)\
      
                                     | _ =>
                                       \(fnc =>
                                            fk (Mismatch (m, SOME a, "ill-typed visibilized application")))\
                                    /
                                 end
                           in
                              compatMain ctx m' n false prove fk ak kloop
                           end
 
                      | _ =>
                           fk (Mismatch (m, NONE, "ill-formed visibilized application")))
 
                 else if Constant.eq (const, Prim.paramapp) then
                    (case spine1 of
                        T.App m' :: T.App p :: rest1 =>
                           termCase n
                           /| \Prim.paramapp\ @ ? =>
                              \(fnc spine2 =>
                                   (case spine2 of
                                       T.App n' :: T.App q :: rest2 =>
                                          let
                                             fun kloop (a, mntac, m'', n'', rest1', rest2') : 'a =
                                                (case (rest1', rest2') of
                                                    ([], _ :: _) => fk Clash

                                                  | (_ :: _, []) => fk Clash

                                                  | (_ :: _, _ :: _) =>
                                                       let
                                                          fun resume () =
                                                             kloop (compatSpine ctx m'' n'' a rest1' rest2' mntac false prove)
                                                       in
                                                          detectCompatError m'' a rest1' rest2' fk
                                                             (fn () => ak (m'', a, resume))
                                                             (fn () => raise (Fail "unreachable"))
                                                       end

                                                  | ([], []) =>
                                                       (* rest1' = rest2' = []  so  M'' = M' and N'' = N'
                                                          mntac proves G |- M' = N' : A
                                                       *)
                                                       termCase (N.whnfHard a)
                                                       /| \Prim.parametric\ ? (fn . ?) =>
                                                          \(fnc dom cod =>
                                                               let
                                                                  (* Requiring that P = Q as if this were a regular application,
                                                                     but we don't have to do that.
                                                                  *)
                                                                  val pqtac = prove (J.make ctx (T.apply3 Prim.eq dom p q)) []
                                        
                                                                  val tac' =
                                                                     (* G |- paramapp M' P = paramapp N' Q : Cod[P . id] *)
                                                                     refine (Rule.parametricElimEq dom cod m' n' p q)
                                                                     >>> [
                                                                         (* G |- M' = N' : parametric Dom . Cod *)
                                                                         mntac,
                                                                         
                                                                         (* G |- P = Q : Dom *)
                                                                         pqtac
                                                                         ]
                                                               in
                                                                  sk $
                                                                  compatSpine ctx 
                                                                     (T.apply2 Prim.paramapp m' p)
                                                                     (T.apply2 Prim.paramapp n' q)
                                                                     (T.Sub (cod, T.Dot (p, T.id)))
                                                                     rest1 rest2 tac' invis prove
                                                               end)\
                   
                                                        | _ =>
                                                          \(fnc =>
                                                               fk (Mismatch (m, SOME a, "ill-typed parametric application")))\
                                                       /)
                                          in
                                             compatMain ctx m' n' false prove fk ak kloop
                                          end
        
                                     | _ =>
                                          fk (Mismatch (n, NONE, "ill-formed parametric application"))))\

                            | _ =>
                              \(fnc =>
                                   fk Clash)\
                           /

                      | _ =>
                           fk (Mismatch (m, NONE, "ill-formed parametric application")))

                 (* the normal case *)
                 else
                    termCase n
                    /| const? @ ? =>
                       \(fnc const' spine2 =>
                            if Constant.eq (const', Prim.ann) then
                               fk (NotPath "second term is annotated")
  
                            else if Constant.eq (const', Prim.fnann) then
                               fk (NotPath "second term is annotated function")
  
                            else if Constant.eq (const', Prim.ap) then
                               fk (NotPath "second term is visibilized application")
  
                            else if Constant.eq (const, const') then
                               let
                                  do (a, tac) = inferConstantCps const fk
  
                                  val tac' =
                                     (* G |- const = const : A *)
                                     refine (Rule.eqRefl (T.evar ()) (T.evar ()))
                                     >>
                                     (* G |- const : A *)
                                     tac
                               in
                                  sk (compatSpine ctx (T.Const const) (T.Const const) a spine1 spine2 tac' invis prove)
                               end
  
                            else
                               fk Clash)\

                     | var? @ _ =>
                       \(fnc _ =>
                            fk Clash)\

                     | _ =>
                       \(fnc =>
                            fk (NotPath "second term is not a path"))\
                    /)\

          | _ =>
            \(fnc =>
                 fk (NotPath "first term is not a path"))\
         /
         

      fun compat ctx m n prove =
         let
            fun fk err = raise err

            do (a, tac, m', n', remain1, remain2) =
               compatMain ctx m n true prove fk
                  (fn (m', a, _) => raise (Ambiguous (m', a, nullcont)))
            
            do () =
               detectCompatError m' a remain1 remain2 fk
                  (fn () => raise (Ambiguous (m', a, nullcont)))
         in
            (a, tac)
         end


      fun compatCps ctx m n prove fk sk =
         let
            fun kloop (a, tac, m', n', remain1, remain2) =
               let
                  fun resume () =
                     kloop (compatSpine ctx m' n' a remain1 remain2 tac true prove)

                  do () =
                     detectCompatError m' a remain1 remain2 fk
                        (fn () => fk (Ambiguous (m', a, resume)))
               in
                  sk (a, tac)
               end
         in
            compatMain ctx m n true prove fk
               (fn (m', a, resume) => fk (Ambiguous (m', a, resume)))
               kloop
         end

   end
