
signature DATATYPE =
   sig

      type symbol = Symbol.symbol
      type eterm = ETerm.eterm
      type constant = Constant.constant

      type typedef =
         (symbol * eterm) list               (* invisible pervasive arguments *)
         *
         (symbol * eterm) list               (* visible pervasive arguments *)
         *
         eterm                               (* universe *)
         *
         (* each mutually recursive data type *)
            (
            symbol                           (* name *)
            *
            (symbol option * eterm) list     (* type arguments (datatypes not in scope) 
                                                SOME indicates the argument arose from a forall
                                             *)
            * 
            (* each constructor *)
               (
               symbol                        (* name *)
               *
               eterm                         (* type (datatypes in scope) *)
               ) list
            ) list

      exception Datatype of string

      val typedefRaw : typedef -> unit
      val typedef : typedef -> unit

      (* When set to true, does not validate datatype elaboration.  Requires unsafe mode. *)
      val rapid : bool ref


      (* List of constructors for each datatype. *)
      val constructors : constant -> constant list option

      type bundle =
         int                          (* number of invisible pervasive arguments *)
         *
         int                          (* number of visible pervasive arguments *)
         *
         int                          (* number of mutually recursive datatypes *)
         *
         int                          (* total number of contructors *)
         *
            (* each mutually recursive data type *)
            (
            constant                  (* the datatype *)
            *
            constant                  (* its iterator *)
            *
            int                       (* number of index arguments *)
            *
            int                       (* number of constructors *)
            *
            (* each constructor *)
               (
               constant               (* the constructor *)
               *
               int                    (* constructor's number of arguments *)
               *
               int option list        (* which of the constructor's arguments are internal, and if so, for what datatype # *)
               *
               Reduction.reduction2   (* the reduction for the iterator applied to the constructor *)
               ) Vector.vector
            ) Vector.vector

      (* returns (1) which datatype this is out of the bundle, (2) the bundle *)
      val info : constant -> (int * bundle) option

   end


signature DATATYPE_INTERNAL =
   sig

      include DATATYPE

      val write : (Word8.word -> unit) -> unit
      val read : (unit -> Word8.word) -> unit

      (* called on each new datatype (info will be populated before it is called) *)
      val install : (constant -> unit) ref

   end


structure DatatypeInternal :> DATATYPE_INTERNAL =
   struct

      structure AR = AutoReduce
      structure C = Case
      structure CR = CheckpointedRef
      structure D = Directory
      structure DE = DestructInternal
      structure ET = ETerm
      structure IP = IntroPattern
      structure J = Judgement
      structure N = Normalize
      structure P = Pickle
      structure PP = Pickling
      structure PR = PrimReduction
      structure R = ReductionInternal
      structure RR = RegistryInternal
      structure S = Seq
      structure T = Term
      structure U = Unify
      structure X = XTerm

      type symbol = Symbol.symbol
      type term = Term.term
      type eterm = ET.eterm
      type constant = Constant.constant

      open Tactic
      open CasePervasive



      exception Datatype of string

      fun signalError msg = raise (Datatype
                                      (String.concat
                                          [
                                          "Error: ",
                                          msg,
                                          ".\n"
                                          ]))

      val () =
         Handler.customHandler
         (fn Datatype msg => (print msg; true)
           | _ => false)



      structure ID = RedBlackDict (structure Key = IntOrdered)
      structure CD = RedBlackDict (structure Key = Constant.Ordered)




      datatype 't conarg =
         External of T.binder option * 't  (* SOME indicates the argument arose from a forall *)
       | Internal of int * 't list  (* indices *)


      (* Orignal representation: uses eterms with user names. *)
      type typedef =
         (symbol * eterm) list
         * (symbol * eterm) list
         * eterm
         * (symbol
            * (symbol option * eterm) list
            * (symbol * eterm) list) list

      (* Resolved representation: organized, and uses terms in place of eterms.
         In the inner list, each element is (sym, conargs, indices).

         Note: all index arguments and internal arguments bind, even those arising from an arrow.
         Invisible and pervasive arguments also always bind.  Internal arguments never bind.
      *)
      type rtypedef =
         (symbol * term) list
         * (symbol * term) list
         * term
         * (symbol
            * (symbol option * term) list
            * (symbol * term conarg list * term list) list) list

      type mxterm = X.mxterm
      type mxtype = X.mxtype

      (* Internal representation: as resolved, but with mxterms. *)
      type itypedef =
         (symbol * mxtype) list
         * (symbol * mxtype) list
         * mxterm
         * (symbol
            * (symbol option * mxterm) list
            * (symbol 
               * (mxterm conarg) list 
               * mxterm list) list) list





      (* natrecl i f x = f 0 (f 1 (... (f (i-1) x) ...)) *)
      fun natrecl i f x =
         if i = 0 then
            x
         else
            natrecl (i-1) f (f (i-1) x)
      
      (* natrecr i f x = f (i-1) (f (i-2) (... (f 0 x) ...)) *)
      fun natrecr i f x = natrecl i (fns j y => f (i-1-j) y) x

      (* natmapl i f = [f 0, ..., f (i-1)] *)
      fun natmapl i f = natrecl i (fns j l => f j :: l) []

      (* natmapr i f = [f (i-1), ..., f 0] *)
      fun natmapr i f = natrecr i (fns j l => f j :: l) []

      fun maprev f l = List.foldl (fns x l' => f x :: l') [] l


      (* precondition: l1 and l2 have equal lengths *)
      fun foldl2 f x l1 l2 =
         (case (l1, l2) of
             ([], []) => x

           | (x1 :: rest1, x2 :: rest2) =>
                foldl2 f (f x1 x2 x) rest1 rest2

           | _ => raise (Fail "precondition"))


      (* precondition: l1, l2, and l3 have equal lengths *)
      fun foldl3 f x l1 l2 l3 =
         (case (l1, l2, l3) of
             ([], [], []) => x

           | (x1 :: rest1, x2 :: rest2, x3 :: rest3) =>
                foldl3 f (f x1 x2 x3 x) rest1 rest2 rest3

           | _ => raise (Fail "precondition"))


      (* precondition: l1 and l2 have equal lengths *)
      fun foldr2 f x l1 l2 =
         (case (l1, l2) of
             ([], []) => x

           | (x1 :: rest1, x2 :: rest2) =>
                f x1 x2 (foldr2 f x rest1 rest2)

           | _ => raise (Fail "precondition"))


      (* precondition: l1 and l2 have equal lengths *)
      fun map2 f l1 l2 =
         let
            val l =
               foldl2
                  (fns x1 x2 l => f x1 x2 :: l)
                  []
                  l1 l2
         in
            List.rev l
         end


      (* precondition: l1, l2, and l3 have equal lengths *)
      fun map3 f l1 l2 l3 =
         let
            val l =
               foldl3
                  (fns x1 x2 x3 l => f x1 x2 x3 :: l)
                  []
                  l1 l2 l3
         in
            List.rev l
         end


      (* precondition: l1 and l2 have equal lengths *)
      fun map2i f l1 l2 =
         let
            val (_, l) =
               foldl2
                  (fns x1 x2 (i, l) => (i+1, f i x1 x2 :: l))
                  (0, [])
                  l1 l2
         in
            List.rev l
         end


      fun bifoldLoop f g z h l =
         (case l of
             [] => (z, h (g z))

           | x :: rest =>
                let
                   val (z', k) = f x z
                in
                   bifoldLoop f g z' (fn y => h (k y)) rest
                end)

      fun bifold f g z l = bifoldLoop f g z (fn y => y) l

      fun bifold2Loop f g z h l1 l2 =
         (case (l1, l2) of
             ([], []) => (z, h (g z))

           | (x1 :: rest1, x2 :: rest2) =>
                let
                   val (z', k) = f x1 x2 z
                in
                   bifold2Loop f g z' (fn y => h (k y)) rest1 rest2
                end

           | _ => raise (Fail "precondition"))

      (* precondition: l1 and l2 have equal lengths *)         
      fun bifold2 f g z l1 l2 = bifold2Loop f g z (fn y => y) l1 l2



      fun natTerm i =
         if i = 0 then
            T.Const Prim.zero
         else
            T.apply1 Prim.succ (natTerm (i-1))



      (* Turns the external syntax for datatypes into internal, resolving names. *)
      fun resolve ((invis, pers, univ, dts) : typedef) : rtypedef =
         try
            let
               val (revinvis', invisdir) =
                  List.foldl
                     (fns (sym, em) (l, dir) =>
                         ((sym, ET.withidir dir em) :: l,
                          D.ibind dir sym))
                     ([], D.iempty)
                     invis
   
               (* Invisible variables are available to each other, visible pervasive variables,
                  and the universe, but nothing else.
               *)
   
               val (revpers', visdir, fulldir) =
                  List.foldl
                     (fns (sym, em) (l, dir, fulldir) =>
                         ((sym, ET.withidir fulldir em) :: l,
                          D.ibind dir sym,
                          D.ibind fulldir sym))
                     ([], D.iempty, invisdir)
                     pers
   
               val univ' = ET.withidir fulldir univ
   
               val (bodydir, num, arities) =
                  List.foldl
                     (fns (sym, args, _) (dir, i, arities) => 
                         (D.ibind dir sym,
                          i+1,
                          ID.insert arities i (sym, List.length args)))
                     (visdir, 0, ID.empty)
                     dts
   
               (* There are num datatypes, with bodydir directing the ith datatype to
                  deBruijn index num-1-i.
               *)
               
               fun recmatcher sym depth p =
                  C.wrapk
                     (C.elim C.whatVar C.what)
                     (fnc i spine =>
                         if i - depth < 0 orelse i - depth >= num then
                            raise C.Backtrack
                         else
                            let
                               val j = num - (i - depth) - 1
   
                               val args =
                                  List.map
                                     (fn T.App c =>
                                         (case Prune.prune c p of
                                             SOME c' => c'
   
                                           | NONE =>
                                                signalError ("misplaced recursive reference in " ^ Symbol.toValue sym))
   
                                       | _ => signalError (String.concat
                                                              [
                                                              "recursive reference in ",
                                                              Symbol.toValue sym,
                                                              " contains a type error"
                                                              ]))
                                     spine

                               val (dtname, arity) = ID.lookup arities j
                            in
                               if arity = List.length args then
                                  (j, args)
                               else
                                  signalError (String.concat [
                                                             "recursive reference to ",
                                                             Symbol.toValue dtname,
                                                             " in ",
                                                             Symbol.toValue sym,
                                                             " has the wrong arity"
                                                             ])
                            end)
   
               (* in datatype i, under depth binders (syntactically), and under substitution s (to adjust to the typing context) *)
               fun cleanup sym i m depth s acc =
                  let
                     val p =
                        natrecl depth
                           (fns j p => Prune.Pidot (j, p))
                           (natrecl num
                               (fns _ p => Prune.Pundef p)
                               (Prune.Pshift depth))
   
                     (* p = 0 .. depth-1 . UNDEF_1 .. UNDEF_num . ^depth *)
                  in
                     termCase m
                     /| \Prim.forall\ ? (fn ? . ?) =>
                        \(fnc a binder b =>
                             (case Prune.prune a p of
                                 SOME a' =>
                                    cleanup sym i b (depth+1) (T.under 1 s) (External (SOME binder, T.Sub (a', s)) :: acc)
    
                               | NONE =>
                                    signalError ("misplaced recursive reference in " ^ Symbol.toValue sym)))\

                      | \Prim.arrow\ ? ? =>
                        \(fnc a b =>
                             termCase a
                             /| $lit \recmatcher sym depth p\ =>
                                \(fn (j, args) =>
                                     cleanup sym i b depth s (Internal (j, map (fn t => T.Sub (t, s)) args) :: acc))\
                                   
                              | _ =>
                                \(fnc =>
                                     (case Prune.prune a p of
                                         SOME a' => cleanup sym i b depth (T.compose s T.shift1) (External (NONE, T.Sub (a', s)) :: acc)
     
                                       | NONE =>
                                            signalError ("misplaced recursive reference in " ^ Symbol.toValue sym)))\
                             /)\

                      | $lit \recmatcher sym depth p\ =>
                        \(fn (j, args) =>
                             if i = j then
                                (sym, List.rev acc, map (fn t => T.Sub (t, s)) args)
                             else
                                signalError (String.concat
                                                [
                                                "right-hand-side of ",
                                                Symbol.toValue sym,
                                                " is the wrong datatype"
                                                ]))\

                      | _ =>
                        \(fnc =>
                             signalError "illegal constructor type")\
                     /
                  end
   
               val dts' =
                  List.mapi
                     (fns i (dtsym, args, dcons) =>
                         let
                            val (revargs', dir) =
                               List.foldl
                                  (fns (symopt, em) (l, dir) =>
                                      (case symopt of
                                          SOME sym =>
                                             ((symopt, ET.withidir dir em) :: l,
                                              D.ibind dir sym)
   
                                        | NONE =>
                                             ((NONE, ET.withidir dir em) :: l, 
                                              D.ibind0 dir)))
                                  (* NB: visdir not bodydir. The datatypes aren't in scope here. *)
                                  ([], visdir)
                                  args
   
                            val dcons' =
                               List.map
                                  (fns (dconsym, em) =>
                                      cleanup dconsym i (ET.withidir bodydir em) 0 T.id [])
                                  dcons
                         in
                            (dtsym, List.rev revargs', dcons')
                         end)
                     dts
            in
               (List.rev revinvis', List.rev revpers', univ', dts')
            end
         with
            D.Unbound sym =>
               signalError ("unbound identifier " ^ Symbol.toValue sym)



      type origin = string
      type 'a res = (origin * goal) list * (validation list -> 'a * validation list)

      fun 'a unitres (goal, f : validation -> 'a) : 'a res =
         ([goal],
          (fn [] =>
                 raise Refine.ValidationFailure

            | v :: vrest =>
                 (f v, vrest)))

      val nilres : 'a list res = ([], (fn vs => ([], vs)))

      fun 'a consres ((goal, f1) : (origin * goal) * (validation -> 'a)) ((goals, f2) : 'a list res) : 'a list res =
         (goal :: goals,
          (fn [] =>
                 raise Refine.ValidationFailure

            | v :: vrest =>
                 let
                    val x = f1 v

                    val (l, leftover) = f2 vrest
                 in
                    (x :: l, leftover)
                 end))

      fun 'c joinres2 (g : 'a -> 'b -> 'c) ((goals1, f1) : 'a res) ((goals2, f2) : 'b res) : 'c res =
         (goals1 @ goals2,
          (fn vs =>
              let
                 val (x1, vs) = f1 vs
                 val (x2, vs) = f2 vs
              in
                 (g x1 x2, vs)
              end))

      fun 'd joinres3 (g : 'a -> 'b -> 'c -> 'd) ((goals1, f1) : 'a res) ((goals2, f2) : 'b res) ((goals3, f3) : 'c res) : 'd res =
         (goals1 @ goals2 @ goals3,
          (fn vs =>
              let
                 val (x1, vs) = f1 vs
                 val (x2, vs) = f2 vs
                 val (x3, vs) = f3 vs
              in
                 (g x1 x2 x3, vs)
              end))

      fun 'e joinres4 (g : 'a -> 'b -> 'c -> 'd -> 'e) ((goals1, f1) : 'a res) ((goals2, f2) : 'b res) ((goals3, f3) : 'c res) ((goals4, f4) : 'd res) : 'e res =
         (goals1 @ goals2 @ goals3 @ goals4,
          (fn vs =>
              let
                 val (x1, vs) = f1 vs
                 val (x2, vs) = f2 vs
                 val (x3, vs) = f3 vs
                 val (x4, vs) = f4 vs
              in
                 (g x1 x2 x3 x4, vs)
              end))

      fun 'b mapres (g : 'a -> 'b res) (l : 'a list) : 'b list res =
         List.foldr
            (fns x res =>
                joinres2 (fns y ys => y :: ys) (g x) res)
            nilres
            l

      fun 'c mapres2 (g : 'a -> 'b -> 'c res) (l1 : 'a list) (l2 : 'b list) : 'c list res =
         foldr2
            (fns x y res =>
                joinres2 (fns z zs => z :: zs) (g x y) res)
            nilres
            l1 l2

      fun growres label dir ctx a g goals =
         let
            val jud = J.make ctx a
         in
            consres
               ((label, (jud, dir)), (fn v => g jud v))
               goals
         end



      (* Reprocess:
         1. generates typechecking goals, and
         2. defines a function that builds a itypedef from validations for those goals.

         In the itypedef, each term comes with a tactic that proves it is well-formed 
         (using the validations from the typechecking goals).
      *)
      fun reprocess ((invis, pers, univ, dts) : rtypedef) : (origin * goal) list * (validation list -> itypedef) =
         let
            val ((invisdir, invisctx), invisres) =
               bifold
                  (fns (sym, a) (dir, ctx) =>
                      ((D.bind dir sym,
                        S.cons (J.Tm a) ctx),

                       growres ("pervasive argument " ^ Symbol.toValue sym) dir ctx
                          (T.apply1 Prim.istp a)
                          (fns jud v => (sym, (a, jud, v)))))
                  (fn _ => nilres)
                  (D.empty, S.empty)
                  invis

            
            val ((fulldir, fullctx), persres) =
               bifold
                  (fns (sym, a) (dir, ctx) =>
                      ((D.bind dir sym,
                        S.cons (J.Tm a) ctx),

                       growres ("pervasive argument " ^ Symbol.toValue sym) dir ctx
                          (T.apply1 Prim.istp a)
                          (fns jud v => (sym, (a, jud, v)))))
                  (fn _ => nilres)
                  (invisdir, invisctx)
                  pers

            val univjud = J.make fullctx (T.apply2 Prim.ov (T.Const Prim.level) univ)

            val univtacres =
               unitres
               (("universe", (univjud, fulldir)), (fn v => (univjud, v)))


            val dtsres =
               mapres
                  (fn (dtsym, tyargs, dcons) =>
                      let
                         val dtorigin = "datatype " ^ Symbol.toValue dtsym

                         val (_, tyargres) =
                            bifold
                               (fns (symopt, a) (dir, ctx, depth) =>
                                   let
                                      val t = T.apply1 Prim.univ (T.Sub (univ, T.Shift depth))
                                   in
                                      ((D.bindh dir symopt,
                                        S.cons (J.Tm a) ctx,
                                        depth+1),
                                       
                                       growres dtorigin dir ctx
                                          (T.apply2 Prim.ov t a)
                                          (fns jud v => (symopt, (a, t, jud, v))))
                                   end)
                               (fn _ => nilres)
                               (fulldir, fullctx, 0)
                               tyargs
                               
                         val dconsres =
                            mapres
                               (fns (dconsym, conargs, indices) =>
                                   let
                                      val origin = "constructor " ^ Symbol.toValue dconsym

                                      val ((dir, ctx, depth), conargsres) =
                                         bifold
                                            (fns arg (dir, ctx, depth) =>
                                                (case arg of
                                                    External (binderopt, a) =>
                                                       let
                                                          val t = T.apply1 Prim.univ (T.Sub (univ, T.Shift depth))
                                                       in
                                                          ((D.bindh dir (Option.join binderopt),
                                                            S.cons (J.Tm a) ctx,
                                                            depth+1),
   
                                                           growres origin dir ctx
                                                              (T.apply2 Prim.ov t a)
                                                              (fns jud v => External (binderopt, (a, t, jud, v))))
                                                       end

                                                  | Internal (i, iindices) =>
                                                       let
                                                          val (_, tyargsi, _) = List.nth dts i

                                                          val (_, iindicesres) =
                                                             bifold2
                                                                (fns index (symopt, tyarg) st =>
                                                                    (* st puts tyargs in the same context as the indices *)
                                                                    let
                                                                       val t = T.Sub (tyarg, st)
                                                                    in
                                                                       (T.Dot (index, st),
   
                                                                        growres origin dir ctx
                                                                           (T.apply2 Prim.ov t index)
                                                                           (fns jud v => (index, t, jud, v)))
                                                                    end)
                                                                (fn _ => nilres)
                                                                (T.Shift depth)
                                                                iindices tyargsi
                                                       in
                                                          ((dir, ctx, depth),

                                                           joinres2
                                                              (fns iindices' rest => Internal (i, iindices') :: rest)
                                                              iindicesres)
                                                       end))
                                            (fn _ => nilres)
                                            (fulldir, fullctx, 0)
                                            conargs

                                      val (_, indicesres) =
                                         bifold2
                                            (fns index (symopt, tyarg) st =>
                                                let
                                                   val t = T.Sub (tyarg, st)
                                                in
                                                   (T.Dot (index, st),
   
                                                    growres origin dir ctx
                                                       (T.apply2 Prim.ov t index)
                                                       (fns jud v => (index, t, jud, v)))
                                                end)
                                            (fn _ => nilres)
                                            (T.Shift depth)
                                            indices tyargs
                                   in
                                      joinres2
                                         (fns conargs' indices' => (dconsym, conargs', indices'))
                                         conargsres indicesres
                                   end)
                               dcons
                      in
                         joinres2
                            (fns tyargs' dcons' => (dtsym, tyargs', dcons'))
                            tyargres dconsres
                      end)
                  dts
                  
            val (goals, f) =
               joinres4
                  (fns invis' pers' (univjud, univv) dts' => 
                      (invis', pers', (univ, T.Const Prim.level, univjud, univv), dts'):itypedef)
                  invisres persres univtacres dtsres
         in
            (goals, (fn vs => 
                        (case f vs of 
                            (x, []) => x

                          | _ => raise Refine.ValidationFailure)))
         end



      (* Flattens the recursive bundle, producing (for each constructor):

         (i, j, name, args, |args|, indices)

         where the constructor:
            belongs to datatype #i
            is #j over all
            has the given name, arguments, and indices
      *)
      fun flattenDts dts =
         let
            val (l, _, _) =
               List.foldl
                  (fns (_, _, dcons) (l, i, j) =>
                      let
                         val (l', j') =
                            List.foldl
                               (fns (name, args, indices) (l, j) => 
                                   ((i, j, name, args, List.length args, indices) :: l,
                                    j+1))
                               (l, j)
                               dcons
                      in
                         (l', i+1, j')
                      end)
                  ([], 0, 0)
                  dts
         in
            List.rev l
         end



      extension Answer of (Message.label * goal) list * Tactic.validator

      val rapid = ref false

      (* When using rapid datatype elaboration, we could save even more time by not building
         the tactics in the first place, but this is much cleaner and should be good enough.
      *)

      fun execute ctx a tac =
         let
            val jud = J.make ctx a

            val tac' =
               if !rapid then
                  if Unsafe.allowed () then
                     refine Rule.trustme
                  else
                     signalError "rapid datatype elaboration requires unsafe mode"
               else
                  tac
         in
            (case Tactic.execute (jud, D.empty) tac' of
                Sum.INL v =>
                   (jud, v)

              | Sum.INR msg => raise (Fail ("datatype internal proof failure: " ^ msg)))
         end


      fun compact ctx m =
         if !rapid then
            m
         else
            X.compact ctx m
         

      fun tcompact ctx m =
         if !rapid then
            m
         else
            X.tcompact ctx m
         

      (* check a proof, and turn it into a tactic *)
      fun compactProof ctx a tac =
         let
            val (jud, v) = execute ctx a tac
         in
            cast jud v
         end




      (* Load stuff from the libraries

         We put all this stuff into suspensions, since the libraries aren't loaded yet
         when this code is run.

         A subtle point is what happens if the libraries get loaded, the suspensions are
         forced, and the loading of the libraries gets rewound.  The suspensions won't
         be forced again until the libraries are reloaded, at we are guaranteed that the
         the same constants will be used when the libraries are reloaded, so the next time
         the suspensions are forced, everything will be fine.
      *)

      fun loadSymbol module str =
         Susp.delay (fn () => Namespace.resolve [module, Symbol.fromValue str])

      val accSym = Symbol.fromValue "Acc"
      val datatypeSym = Symbol.fromValue "Datatype"
      val natSym = Symbol.fromValue "Nat"

      val constAcc = loadSymbol accSym "Acc"
      val constLeq = loadSymbol natSym "leq"
      val constLeq_0_min = loadSymbol natSym "leq_0_min"
      val constLeq_succ_succ = loadSymbol natSym "leq_succ_succ"
      val constList = loadSymbol datatypeSym "list"
      val constNil = loadSymbol datatypeSym "nil"
      val constCons = loadSymbol datatypeSym "cons"
      val constListRec = loadSymbol datatypeSym "list_rec"
      val constRep = loadSymbol datatypeSym "rep"
      val constDt = loadSymbol datatypeSym "dt"
      val constCon = loadSymbol datatypeSym "con"
      val constUnroll = loadSymbol datatypeSym "unroll_datatype"
      val constSubtermDt = loadSymbol datatypeSym "subterm"
      val constSubtermTrans = loadSymbol datatypeSym "subterm_trans"
      val constSubtermWellFounded = loadSymbol datatypeSym "subterm_well_founded"
      val constStrip = loadSymbol datatypeSym "strip"
      val constSubtermCon = loadSymbol datatypeSym "subterm_con"
      val constIter = loadSymbol datatypeSym "dt_iter"

      val eqzbTac = Susp.delay (fn () => snd (Infer.inferConstant Prim.eqzb))



      (* Xterm definitions *)

      fun xvar i ctx = X.var i (List.nth ctx i)

      fun xconstant const = X.constant (Susp.force const)

      fun xlist lv a =
         X.apps (xconstant constList) [lv, a]

      fun xnil lv a =
         X.apps (xconstant constNil) [lv, a]

      fun xcons lv a h t =
         X.apps (xconstant constCons) [lv, a, h, t]

      fun xcon lv a dcons n tac x y =
         X.apps
            (X.appGuard
                (X.apps (xconstant constCon) [lv, a, dcons, n])
                tac)
            [x, y]

      fun xsubtermcon lv a dcons n tac x y =
         X.apps
            (X.appGuard
                (X.apps (xconstant constSubtermCon) [lv, a, dcons, n])
                tac)
            [x, y]


      fun xleqProof m n =
         if m = 0 then
            X.app (X.constant (Susp.force constLeq_0_min)) (X.nat n)
         else
            X.apps
               (X.constant (Susp.force constLeq_succ_succ))
               [
               X.nat (m-1),
               X.nat (n-1),
               xleqProof (m-1) (n-1)
               ]
               
      fun proveLeq m n =
         let
            val (x, _, xtac) = xleqProof m n
         in
            refine (Rule.inhabitant (T.evar ()) x)
            >> xtac
         end
         

      fun xadjust depth (depth', m) = X.weaken m (depth - depth')



      (* Defining constants *)

      fun define sym ((def, deft, deftac):X.xterm) t =
         let
            val const = Namespace.declare sym (SOME (N.simplifyAll def))

(* for debugging
            val () =
               if Unify.unify1 deft t then
                  ()
               else
                  (
                  X.elements := [deft, t];
                  raise (Fail "definition mismatch")
                  )
*)

            val () = Constant.setOpacity const Constant.SOFT  (* for now *)

            val (jud, v) =
               execute Seq.empty (T.apply2 Prim.ov t (T.Const const)) deftac

            val typingName = Symbol.toValue sym ^ "_type"

            val (typingConst, typingJud, typingV) =
               NamespaceInternal.reify (Symbol.fromValue typingName) jud v
         in
            Database.setType typingConst typingJud typingV;
            Define.recordTyping typingName;
            const
         end

      fun close const = Constant.abstract const


      
      (* Miscellaneous facilities *)

      val xsym = Symbol.fromValue "x"
      val ysym = Symbol.fromValue "y"
      val zsym = Symbol.fromValue "z"
      val cPsym = Symbol.fromValue "P"


      fun unshift m = T.Sub (m, T.Dot (T.Const Prim.orphan, T.id))

      (* for unpackConstr *)
      datatype entry = Item of (int * term) | Subst of T.sub


      val list_rec_cons = Susp.delay (fn () => RR.read (List.map Symbol.fromValue ["Datatype", "list_rec_cons"]) RR.reduction2)
      val con_unroll = Susp.delay (fn () => Option.valOf $ Database.findUnroll $ Namespace.resolve $ List.map Symbol.fromValue ["Datatype", "con"])
      val dt_iter_unroll = Susp.delay (fn () => Option.valOf $ Database.findUnroll $ Namespace.resolve $ List.map Symbol.fromValue ["Datatype", "dt_iter"])

      val reductions =
         Susp.delay
            (fn () =>
                [
                (Prim.nat_case, [R.user2 PR.nat_case_succ, R.user2 PR.nat_case_zero]),
                (Prim.sum_case, [R.user2 PR.sum_case_inr, R.user2 PR.sum_case_inl]),
                (Susp.force constListRec, [R.user2 (Susp.force list_rec_cons)]),
                (Susp.force constCon, [R.trans [Susp.force con_unroll, R.user2 PR.nat_case_succ], 
                                       R.trans [Susp.force con_unroll, R.user2 PR.nat_case_zero]])
                ])


         
      (* I/O and record-keeping *)

      (* datatype information in a pickleable form *)

      datatype type_environment =
         TENV of
         {
         const : constant,                  (* the type constant *)
         red : R.reduction,                 (* unfolds the constant *)
         args : (T.binder * mxterm) list,   (* the index arguments *)
         numargs : int,                     (* the number of index arguments *)
         adisj : mxterm,                    (* the disjunct of "a" corresponding to this datatype *)
         iterator : constant,               (* the iterator constant *)
         strip : constant,                  (* the strip constant *)
         }

      datatype con_environment =
         CENV of
         {
         const : constant,                  (* the constructor constant *)
         red : R.reduction,                 (* unfolds the constant *)
         tpnum : int,                       (* belongs to this datatype # *)
         connum : int,                      (* is constructor # *)
         args : mxterm conarg list,         (* the constructor's arguments *)
         numargs : int,                     (* the constructor's number of arguments *)
         indices : mxterm list,             (* the constructor's indices *)
         iteratorReduction : R.reduction2   (* the iterator reduction for this constructor *)
         }

      datatype environment =
         ENV of
         {
         invis : (symbol * mxtype) list,                         (* invisible pervasives *)
         invisnum : int,                                         (* number of invisible pervasives *)
         pers : (symbol * mxtype) list,                          (* visible pervasives *)
         persnum : int,                                          (* number of visible pervasives *)
         univ : mxterm,                                          (* the universe *)
         a : mxterm,                                             (* the "a" when the datatype is written as "dt a dcons" *)
         dcons : mxterm,                                         (* the "dcons" when the datatype is written as "dt a dcons" *)
         tplist : type_environment list,                         (* for each datatype, in order *)
         conlist : con_environment list,                         (* for each constructor, in order *)
         skeleton : constant,                                    (* the skeleton constant *)
         subterm : constant,                                     (* the subterm constant *)
         subtermWf : constant,                                   (* the subterm-well-founded constant *)
         discriminators : constant Vector.vector,                (* the discriminators *)
         extractorTypes : constant Vector.vector,                (* the extractor types *)
         extractors : constant Vector.vector,                    (* the extractors *)
         discriminatorReductions : R.reduction2 Vector.vector,   (* the discriminator's reductions *)
         extractorTypeReductions : R.reduction2 Vector.vector,   (* the extractor type's reductions *)
         extractorReductions : R.reduction2 Vector.vector,       (* the extractor type's reductions *)
         totalConstructors : int,                                (* the total number of constructors *)
         }

      val theDatatypes : environment list CR.cref = CR.new []

      val pumx : mxterm P.pu =
         P.wrap
            (fn (m, a, jud, v) => (m, a, (jud, v)))
            (fn (m, a, (jud, v)) => (m, a, jud, v))
            (P.tuple3 PP.puTerm PP.puTerm Refine.pu)

      val pumxt : mxtype P.pu =
         P.wrap
            (fn (m, jud, v) => (m, (jud, v)))
            (fn (m, (jud, v)) => (m, jud, v))
            (P.tuple2 PP.puTerm Refine.pu)

      val puConarg : mxterm conarg P.pu =
         P.alt
            (fn External _ => 0 | Internal _ => 1)
            [
            P.wrap
               (fn External (binder, m) => (binder, m)
                 | _ => raise (Fail "impossible"))
               External
               (P.pair (P.option (P.option PP.puSymbol)) pumx),

            P.wrap
               (fn Internal (sym, l) => (sym, l)
                 | _ => raise (Fail "impossible"))
               Internal
               (P.pair P.int (P.list pumx))
            ]

      val puTenv : type_environment P.pu =
         P.wrap
            (fn TENV {const, red, args, numargs, adisj, iterator, strip} =>
                (const, red, args, numargs, adisj, iterator, strip))
            (fn (const, red, args, numargs, adisj, iterator, strip) =>
                TENV {const=const, red=red, args=args, numargs=numargs, adisj=adisj, iterator=iterator, strip=strip})
            (P.tuple7
                PP.puConstant
                R.puReduction
                (P.list (P.pair (P.option PP.puSymbol) pumx))
                P.int
                pumx
                PP.puConstant
                PP.puConstant)

      val puCenv : con_environment P.pu =
         P.wrap
            (fn CENV {const, red, tpnum, connum, args, numargs, indices, iteratorReduction} =>
                (const, red, tpnum, connum, args, numargs, indices, iteratorReduction))
            (fn (const, red, tpnum, connum, args, numargs, indices, iteratorReduction) =>
                CENV {const=const, red=red, tpnum=tpnum, connum=connum, args=args, numargs=numargs, indices=indices, iteratorReduction=iteratorReduction})
            (P.tuple8
                PP.puConstant
                R.puReduction
                P.int
                P.int
                (P.list puConarg)
                P.int
                (P.list pumx)
                R.puReduction2)
               
      val puEnv : environment P.pu =
         P.wrap
            (fn ENV {invis, invisnum, pers, persnum, univ, a, dcons, tplist, conlist, skeleton, subterm, subtermWf, discriminators, extractorTypes, extractors, discriminatorReductions, extractorTypeReductions, extractorReductions, totalConstructors} =>
                (invis, invisnum, pers, persnum, univ, a, dcons, tplist, conlist, (skeleton, subterm, subtermWf, discriminators, extractorTypes, extractors, discriminatorReductions, extractorTypeReductions, extractorReductions, totalConstructors)))
            (fn (invis, invisnum, pers, persnum, univ, a, dcons, tplist, conlist, (skeleton, subterm, subtermWf, discriminators, extractorTypes, extractors, discriminatorReductions, extractorTypeReductions, extractorReductions, totalConstructors)) =>
                ENV {invis=invis, invisnum=invisnum, pers=pers, persnum=persnum, univ=univ, a=a, dcons=dcons, tplist=tplist, conlist=conlist, skeleton=skeleton, subterm=subterm, subtermWf=subtermWf, discriminators=discriminators, extractorTypes=extractorTypes, extractors=extractors, discriminatorReductions=discriminatorReductions, extractorTypeReductions=extractorTypeReductions, extractorReductions=extractorReductions, totalConstructors=totalConstructors})
            (P.tuple10
                (P.list (P.pair PP.puSymbol pumxt))
                P.int
                (P.list (P.pair PP.puSymbol pumxt))
                P.int
                pumx
                pumx
                pumx
                (P.list puTenv)
                (P.list puCenv)
                (P.tuple10
                    PP.puConstant
                    PP.puConstant
                    PP.puConstant
                    (P.vector PP.puConstant)
                    (P.vector PP.puConstant)
                    (P.vector PP.puConstant)
                    (P.vector R.puReduction2)
                    (P.vector R.puReduction2)
                    (P.vector R.puReduction2)
                    P.int))



      (* The destruction function.
         We manually closure-convert it so we can pickle its environment.

         (Note that we can't just use the iterator for destruct.  We want to destruct datatype
         hypotheses in-place, which the iterator cannot do.)
      *)


      fun destructor (ENV {invis, pers, univ=univ_mobile, a=a_mobile, dcons=dcons_mobile, tplist, conlist}) =
         let
            val a = X.use a_mobile
            val dcons = X.use dcons_mobile
            val univ = X.use univ_mobile

            val typeInfo = Vector.fromList tplist
            val conInfo = Vector.fromList conlist
            
            val (_, typeConstantsInvert) =
               List.foldl
                  (fns (TENV {const}) (i, d) =>
                      (i+1, CD.insert d const i))
                  (0, CD.empty)
                  tplist


            exception TypeError

            (* X.dot is not very efficient.  We should build functions with
               univ, a, and dcons so we don't have to do this work repeatedly.
            *)

            fun collectInvis l s =
               (case l of
                   [] =>
                      s

                 | (_, c) :: l' =>
                      let
                         val c = X.tuse c
                      in
                         collectInvis l'
                            (X.dot (X.hole (T.evar ()) (T.Sub (X.typ c, fst s))) c s)
                      end)
                         

            fun collectPers l spine s persactrev =
               (case (l, spine) of
                   ([], _) => 
                      (s, List.rev persactrev, spine)

                 | ((_, c) :: l', T.App m :: spine') =>
                      let
                         val c = X.tuse c
                      in
                         collectPers l' spine'
                            (X.dot (X.hole m (T.Sub (X.typ c, fst s))) c s)
                            (m :: persactrev)
                      end

                 | _ => raise TypeError)


            fun collectArgs l spine s constituents =
               (case (l, spine) of
                   ([], []) =>
                      List.rev constituents

                 | ((_, c) :: l', T.App m :: spine') =>
                      let
                         val c = X.use c
                         val m' = X.hole m (T.Sub (X.term c, fst s))
                      in
                         collectArgs l' spine' (X.dot m' (X.forget c) s) (m' :: constituents)
                      end

                 | _ => raise TypeError)




            (* splitArgs cur hyp s persact pat set conargs

               context looks like:
               G, ..cur processed arguments.., <external>, <internal>, ..hyp..

               G, ..processed arguments.. |- s : ..procesed external arguments..
               G |- persact_i : pers_i[persact_i-1 ... persact_0 . id]
               conargs still to examine

               end with context looking like:
               G, ..processed arguments.., ..hyp..
            *)
            fun splitArgs cur hyp s persact conargs =
               (case conargs of
                   [] =>
                      refine (Rule.unitLeft hyp (T.evar ()))
                      >>
                      refine (Rule.unitLeft hyp (T.evar ()))

                 | External _ :: rest =>
                      refine (Rule.existsLeft (hyp+1) (T.evar ()) (T.evar ()) (T.evar ()))
                      >>
                      splitArgs (cur+1) hyp (T.under 1 s) persact rest

                 | Internal (i, indices) :: rest =>
                      refine (Rule.prodLeft hyp (T.evar ()) (T.evar ()) (T.evar ()))
                      >>
                      refine (Rule.exchange (hyp+1) 1 1)
                      >>
                      let
                         val TENV {const, red} = Vector.sub typeInfo i
                      in
                         refine (Rule.unreduceHyp (hyp+2)
                                    (T.Elim 
                                        (T.Const const,
                                         List.map
                                            (fn m => T.App (T.Sub (m, T.Shift cur)))
                                            persact
                                         @
                                         List.map 
                                            (fn (m, _, _, _) => T.App (T.Sub (m, s)))
                                            indices))
                                    red)
                      end
                      >>
                      splitArgs (cur+1) hyp (T.compose s T.shift1) persact rest)


            fun destArgs hyp pats num set =
               if num = 0 then
                  idtacM (S.empty, DE.Principal (pats, set))
               else
                  let
                     do (vars1, (pats', set1)) =
                        DE.andthenp S.empty $ destArgs (hyp+1) pats (num-1) set

                     val (pat, pats'') = 
                        (case pats' of
                            [] => (IP.Ident NONE, [])
         
                          | pat :: pats'' => (pat, pats''))

                     do (vars2, set2) =
                        DE.andthenp vars1 $ DE.dest hyp pat set1
                  in
                     idtacM (S.append vars1 vars2, DE.Principal (pats'', set2))
                  end


            fun normalizeHyps max i goal fk sk =
               if i >= max then
                  idtac goal fk sk
               else
                  (refine (Rule.normalizeHyp i)
                   >>+
                   normalizeHyps max (i+1)) goal fk sk


            fun destOne hyp persact origjud pat (CENV {tpnum=i, connum=j, args, numargs, indices}) set =
               (case pat of
                   IP.And pats =>
                      let
                         val v = D.freshSet set

                         do (jud, _) = withgoal
                      in
                         (* G, exists (set C . D) . E ... |- ... *)
                         refine (Rule.existsLeft hyp (T.evar ()) (T.evar ()) (T.evar ()))
                         >>
                         (* G, set C . D, E ... |- ... *)
                         refine (Rule.isetLeft (hyp+1) (T.evar ()) (T.evar ()) (T.evar ()))
                         >>+
                         (* G, C, hide D, E[^] ... |- ... *)
                         refine (Rule.assert (T.evar ()) (T.evar ()))
                         >>> [
                             (* G, C, hide D, E[^] ... |- D[^hyp+2] *)
                             refine (Rule.inhabitant (T.evar ()) T.Triv)
                             >>
                             (* G, C, D, E[^] ... |- () : D[^hyp+2] *)
                             refine (Rule.eqIntro (T.evar ()) (T.evar ()) (T.evar ()))
                             >>
                             (* G, C, D, E[^] ... |- D[^hyp+2] *)
                             refine (Rule.hypothesis (hyp+1)) >> done,

                             (* G, C, hide D, E[^] ... D[^hyp+2] |- ... *)
                             refine (Rule.weaken (hyp+2) 1)
                             >>
                             (* G, C, E ... D[^hyp+1] |- ... *)
                             cut
                                (repeat
                                    (
                                    refine (Rule.whnfHypAt 0 [2])
                                    >>+
                                    refine (Rule.whnfHypAt 0 [3])
                                    >>+
                                    EqualityTacticInternal.injectionSum 0
                                    >>
                                    refine (Rule.weaken 1 1)
                                    ))
                             >>
                             (* G, C, E ... <equality> |- ... *)
                             cut
                                (repeatCount
                                    (
                                    refine (Rule.whnfHypAt 0 [2])
                                    >>+
                                    refine (Rule.whnfHypAt 0 [3])
                                    >>+
                                    EqualityTacticInternal.injectionExists 0
                                    >>
                                    refine (Rule.weaken 2 1)
                                    ))
                             >>= 
                             (* eqs is the number of times the above code ran, which is
                                the number of equalities generated.
                             *)
                             (fn eqs =>
                                 (* G, C, E ... <equalities>, () = () : unit |- ... *)
                                 refine (Rule.weaken 0 1)
                                 >>
                                 (* G, C, E ... <equalities> |- ... *)
                                 splitArgs 0 (hyp+eqs) T.id persact args
                                 >>
                                 normalizeHyps eqs 0
                                 >>+
                                 (* G, <arguments>, ..., <equalities> |- ... *)
                                 refine (Rule.exchange 0 eqs hyp)
                                 >>
                                 (* G, <arguments>, <equalities>, ... |- ... *)
                                 let
                                    val CENV {const=conConst, red} = Vector.sub conInfo j
                                 in
                                    DE.refold origjud hyp (numargs+eqs)
                                       (T.Elim
                                           (T.Const conConst,
                                            List.map
                                               (fn m => T.App (T.Sub (m, T.Shift (numargs+eqs))))
                                               persact
                                            @
                                            natrecr numargs
                                               (fns k l => T.App (T.Var (k+eqs)) :: l)
                                               []))
                                       red
                                 end
                                 >>
                                 (* G, <arguments>, <equalities>, ... |- ... *)
                                 let
                                    do (vars, (pats', set')) =
                                       DE.andthenp S.empty $ destArgs hyp pats (numargs+eqs) set
                                 in
                                    (case pats' of
                                        [] =>
                                           idtacM (vars, DE.Principal set')

                                      | _ =>
                                           fail "too many patterns supplied for arm")
                                 end)
                             ]
                      end

                 | _ => fail "datatype pattern expected")


            fun destAll hyp persact origjud pats tpnum cons set =
               (case cons of
                   [] =>
                      (case pats of
                          [] =>
                             refine (Rule.voidElim (T.evar ()))
                             >>
                             refine (Rule.hypothesis hyp) >> done

                        | _ =>
                             fail "datatype pattern has superfluous arms")

                 | (con as CENV {tpnum=tpnum'}) :: rest =>
                      let
                         val (pat, pats') =
                            if tpnum = tpnum' then
                               (case pats of
                                   pat :: pats' => (pat, pats')

                                 | [] => (IP.And [], []))
                            else
                               (IP.And [], pats)

                         do (jud, _) = withgoal

                         val (a, b) =
                            hypCase (J.hyp jud hyp)
                            / $tm $whnfHard \Prim.sum\ ? ? =>
                              \(fnc a b => (a, b))\
                            /
                      in
                         refine (Rule.sumLeft hyp (T.evar ()) (T.evar ()) (T.evar ()))
                         >>> [
                             destOne hyp persact origjud pat con set,
   
                             destAll hyp persact origjud pats' tpnum rest set
                             ]
                      end)


            fun destDatatype hyp pat set =
               (case pat of
                   IP.Or pats =>
                      let
                         do (jud, _) = withgoal
                      in
                         hypCaseT (J.hyp jud hyp)
                         / $tm const? @ ? =>
                           \(fnc const spine =>
                                (try
                                    let
                                       val i = CD.lookup typeConstantsInvert const
                                       val TENV {red, args, adisj} = Vector.sub typeInfo i
                                       val sinvis = collectInvis invis X.id
                                       val (s, persact, spine') = collectPers pers spine sinvis []
                                       val a_s = X.sub a s
                                    in
                                       (* G, const @ spine, G' |- C *)
                                       refine (Rule.reduceHyp hyp red)
                                       >>
                                       (* G, rolled, G' |- C *)
                                       refine (Rule.subsumptionLeft hyp (T.evar ()) (T.evar ()) (T.evar ()))
                                       >>> [
                                           (* G, blah |- rolled[^] <:> unrolled[^] *)
                                           refine (Rule.weaken 0 1)
                                           >>
                                           (* G |- rolled <:> unrolled *)
                                           X.inhabitant
                                              (X.apps (X.constant (Susp.force constUnroll))
                                                  [
                                                  X.sub univ s,
                                                  a_s,
                                                  X.sub dcons s,
           
                                                  X.inN i
                                                     (X.tupleEx
                                                         (collectArgs args spine' s [])
                                                         (X.forget (X.sub (X.use adisj) s)))
                                                     (X.forget a_s)
                                                  ])
                                           >> idtacM (Seq.empty, DE.Tertiary),
                        
                                           (* G, unrolled, G' |- C *)
                                           destAll hyp persact jud pats i conlist set
                                           ]
                                    end
                                 with
                                    TypeError => fail "type error in datatype hypothesis"))\
       
                         /
                      end

                 | _ => fail "datatype pattern expected")
         in
            destDatatype
         end



      (* A more convenient induction tactic for datatypes without mutual induction. *)

      val sym_s = Symbol.fromValue "s"

      fun inductor 
         (ENV {invisnum=ninvis, persnum=nvis, skeleton=skeletonConst, subterm=subtermConst, subtermWf=subtermWfConst, tplist})
         const nind stripConst
         =
         let
            do (jud, dir) = withgoal
         in
            hypCaseT (J.subHyp (J.hyp jud 0) T.shift1)
            / $tm $az $whnfHard \const\ @ ? =>
              \(fnc indtp spine =>
                   let
                      val indvar = D.name dir 0

                      val eindtp = ET.absolute dir indtp
                      val concl = ET.absolute dir (J.concl jud)

                      do (visSpine, indVars, indTypes) =
                         tryf
                         (fn () =>
                             let
                                val (visSpine, indSpine) =
                                   (case List.splitOpt spine nvis of
                                       NONE =>
                                          raise (Tryf "type error in hypothesis for induction")

                                     | SOME spines => spines)

                                val visSpine' =
                                   List.map
                                      (fn elim =>
                                          (case elim of
                                              T.App m =>
                                                 ET.absolute dir m

                                            | _ =>
                                                 raise (Tryf "type error in hypothesis for induction")))
                                      visSpine

                                val (nind', indVars, indTypes) =
                                   List.foldr
                                      (fns elim (n, indVars, indTypes) =>
                                          (case elim of
                                              T.App m =>
                                                 (case N.simplify m of
                                                     T.Elim (T.Var v, []) =>
                                                        let
                                                           val var = D.name dir v
                                                           val tp = 
                                                              (case J.hyp jud v of
                                                                  J.Tm a =>
                                                                     ET.absolute dir (T.Sub (a, T.Shift (v+1)))
                              
                                                                | _ =>
                                                                     raise (Tryf "index argument has the wrong sort"))
                                                        in
                                                           (n+1, var :: indVars, tp :: indTypes)
                                                        end
     
                                                   | _ => 
                                                        raise (Tryf "index arguments must be variables"))
   
                                            | _ => 
                                                 raise (Tryf "type error in hypothesis for induction")))
                                      (0, [], [])
                                      indSpine
                             in
                                if nind' = nind then
                                   (visSpine', indVars, indTypes)
                                else
                                   raise (Tryf "type error in hypothesis for induction")
                             end)

                      val invisSpine =
                         natrecl ninvis (fns _ l => ET.evar :: l) []

                      val pervSpine = invisSpine @ visSpine

                      val skelTp = ET.applyn skeletonConst visSpine

                      val set = D.set dir
                      val (ih, set) = D.freshAndBindSet set
                      val (skel, set) = D.varyAndBindSet set (SOME sym_s)
                      val (skelEq, set) = D.freshAndBindSet set
                      val (h, set) = D.freshAndBindSet set  (* used for wf hypothesis, and for internal IH *)

                      val (indVars'_rev, set) =
                         List.foldl
                            (fns var (l, set) =>
                                let
                                   val (var', set') = D.varyAndBindSet set (SOME var)
                                in
                                   (var' :: l, set')
                                end)
                            ([], set)
                            indVars

                      val indVars' = List.rev indVars'_rev
                      val (indvar', set) = D.varyAndBindSet set (SOME indvar)
                      val (alt, set) = D.freshAndBindSet set
                      val (subterm, set) = D.freshAndBindSet set

                      val espine = visSpine @ List.map ET.var indVars
                      val espine' = visSpine @ List.map ET.var indVars'

                      val newIH =
                         ET.subst (ET.app (ET.applyn stripConst espine) (ET.var indvar)) alt $
                         foldr2
                            (fns sym a b => 
                                ET.apply2 Prim.forall a (ET.lam (SOME sym) b))
                            (ET.apply2 Prim.forall eindtp 
                                (ET.lam (SOME indvar)
                                    (ET.apply2 Prim.arrow
                                        (ET.appn
                                            (ET.applyn subtermConst visSpine)
                                            [ET.app (ET.applyn stripConst espine) (ET.var indvar),
                                             ET.var alt])
                                        concl)))
                            indVars
                            indTypes
                   in
                      Generalize.setEqPriority
                         skel
                         (ET.literal (T.app (T.Elim (T.Const stripConst, spine)) T.zero))  (* nothing has moved yet *)
                         skelTp
                         (SOME skelEq)
                      >>!
                      Hyp.revert [Hyp.NAME indvar, Hyp.NAME skelEq]
                      >>
                      Hyp.revert (List.map Hyp.NAME indVars)
                      >>
                      Backchain.soPriority
                         (ET.app (ET.applyn subtermWfConst pervSpine) (ET.var skel))
                         (IP.Ident (SOME h))
                      >>!
                      InductionInternal.accInduction
                      >>!
                      Hyp.rename (Hyp.NUMBER 0) h
                      >>
                      IntroTactic.introPriority (List.map (fn name => IP.Ident (SOME name)) indVars)
                      >>!
                      IntroTactic.introPriority [IP.Ident (SOME indvar), IP.Ident (SOME skelEq)]
                      >>!
                      Destruct.assertRaw newIH (IP.Ident (SOME ih))
                      >>> [
                          IntroTactic.introPriority (List.map (fn var => IP.Ident (SOME var)) indVars')
                          >>!
                          IntroTactic.introPriority [IP.Ident (SOME indvar'), IP.Ident (SOME subterm)]
                          >>!
                          Backchain.witnessPriority 
                             (ET.appn (ET.var h) $
                              ET.app (ET.applyn stripConst espine') (ET.var indvar')
                              :: ET.hole
                              :: List.map ET.var indVars'
                              @ [ET.var indvar', ET.hole])
                          >>>! [
                               Hyp.clear [Hyp.NAME h]
                               >> 
                               Hyp.movePos [Hyp.NAME skel, Hyp.NAME skelEq] 0
                               >> 
                               EqualityTactic.substitutionPriority (Hyp.NAME skel) ET.evar
                               >>>! [
                                    Hyp.hyp (Hyp.NAME skelEq) >> done,

                                    Hyp.hyp (Hyp.NAME subterm) >> done
                                    ],

                               EqualityTactic.reflexivityPriority
                               ],
                          
                          Hyp.clear [Hyp.NAME skel, Hyp.NAME h, Hyp.NAME skelEq]
                          >>
                          idtacM Primary
                          ]
                   end)\
            /
         end



      (* For building other functions from iterators *)

      fun mimicType i n ctx a items f =
         if i = n then
            f i ctx a items
         else
            termCase (X.typ a)
            /| \Prim.intersect\ _ (fn ? . _) =>
               \(fnc binder =>
                    let
                       val dom = X.intersectInv1 a
                       val ctx' = Seq.cons (J.Tm (X.typ dom)) ctx
                       val cod = tcompact ctx' (X.intersectInv2 a)

                       val items' =
                          List.map
                             (fn m => X.app (X.weaken m 1) (X.var 0 dom))
                             items
                    
                       val ms = mimicType (i+1) n ctx' cod items' f
                    in
                       List.map
                          (X.lamInt binder dom)
                          ms
                    end)\

             | \Prim.forall\ _ (fn ? . _) =>
               \(fnc binder =>
                    let
                       val dom = X.forallInv1 a
                       val ctx' = Seq.cons (J.Tm (X.typ dom)) ctx
                       val cod = tcompact ctx' (X.forallInv2 a)

                       val items' =
                          List.map
                             (fn m => X.app (X.weaken m 1) (X.var 0 dom))
                             items
                    
                       val ms = mimicType (i+1) n ctx' cod items' f
                    in
                       List.map
                          (X.lamAll binder dom)
                          ms
                    end)\

             | \Prim.arrow\ _ _ =>
               \(fnc =>
                    let
                       val dom = X.arrowInv1 a
                       val ctx' = Seq.cons (J.Tm (X.typ dom)) ctx
                       val cod = tcompact ctx' (X.arrowInv2 a)

                       val items' =
                          List.map
                             (fn m => X.app (X.weaken m 1) (X.var 0 dom))
                             items
                    
                       val ms = mimicType (i+1) n ctx' cod items' f
                    in
                       List.map
                          (X.lam NONE dom)
                          ms
                    end)\

             | _ =>
               \(fnc =>
                    f i ctx a items)\
            /

      fun mimicType1 ctx a f =
         List.hd $
         mimicType 0 ~1 ctx a [] (fns n _ _ _ => [f n])




      (* Merging iterators into the joint iterator.

         n: the number of arguments the merged iterator should take
         consts: the iterators being merged
      *)
      fun merge n consts =
         let
            val mergees = List.map X.constant consts
         in
            (case mergees of
                [] => raise (Invalid "empty list")

              | m :: _ =>
                   let
                      val a = tcompact Seq.empty (X.inhabitedForm m)
                   in
                      List.hd $
                      mimicType 0 n Seq.empty a mergees
                         (fns n' _ _ mergees' =>
                             if n' = n then
                                [X.tuple mergees']
                             else
                                raise (Fail "unexpected type in merge"))
                   end)
         end




      (* Injection *)

      fun injector
         (ENV {tplist, conlist, discriminators, extractorTypes, extractors, discriminatorReductions, extractorTypeReductions, extractorReductions})
         =
         let
            (* maps type constants to their type # *)
            val (_, typeInvert) =
               List.foldl
                  (fns (TENV {const}) (i, d) =>
                      (i+1, CD.insert d const i))
                  (0, CD.empty)
                  tplist

            (* maps constructor constants to their constructor # *)
            val (_, constructorInvert) =
               List.foldl
                  (fns (CENV {const}) (i, d) =>
                      (i+1, CD.insert d const i))
                  (0, CD.empty)
                  conlist


            (* h : M = N : A 
               where A = const spine
                     M = mconst ...
                     N = nconst ...
            *)
            fun injectNo h a const spine m mconst n nconst =
               let
                  do (jud, _) = withgoal

                  val pos = CD.lookup typeInvert const

                  do mpos =
                     tryf
                     (fn () =>
                         (case CD.find constructorInvert mconst of
                             NONE =>
                                raise (Tryf (String.concat [Namespace.toString mconst, " is not a constructor for ", Namespace.toString const]))
    
                           | SOME i => i))

                  do npos =
                     tryf
                     (fn () =>
                         (case CD.find constructorInvert nconst of
                            NONE =>
                               raise (Tryf (String.concat [Namespace.toString nconst, " is not a constructor for ", Namespace.toString const]))
   
                          | SOME i => i))

                  val d = T.Elim (T.Const (Vector.sub discriminators pos), spine)

                  val (_, dtac) = Infer.infer (J.context jud) d (fns _ _ => idtac)

                  val mlit = T.Native (T.Integer (IntInf.fromInt mpos))
                  val eqzb_literal1 = T.apply1 Prim.eqzb mlit

                  val dm = T.Elim (d, [T.App m])
                  val dn = T.Elim (d, [T.App n])
               in
                  (* C *)
                  refine (Rule.boolContradiction (T.evar ()))
                  >>+
                  (* true = false : bool *)
                  refine (Rule.unreduce
                             (T.apply3 Prim.eq
                                 (T.Const Prim.bool)
                                 (T.apply2 Prim.eqzb mlit dm)
                                 (T.apply2 Prim.eqzb mlit dn))
                             (R.compat
                                 [
                                 R.refl,
                                 R.trans [R.within [2] (R.user2 (Vector.sub discriminatorReductions mpos)), R.native],
                                 R.trans [R.within [2] (R.user2 (Vector.sub discriminatorReductions npos)), R.native]
                                 ]))
                  >>+
                  (* (eqzb mpos (D M)) = (eqzb mpos (D N)) : bool *)
                  refine (Rule.arrowElimEq
                             (T.Const Prim.integer)
                             (T.evar ())
                             eqzb_literal1
                             eqzb_literal1
                             dm
                             dn)
                  >>> [
                      (* eqzb mpos = eqzb mpos : integer -> bool *)
                      refine (Rule.eqRefl (T.evar ()) (T.evar ()))
                      >>+
                      (* eqzb mpos : integer -> bool *)
                      refine (Rule.arrowElimOf
                                 (T.Const Prim.integer)
                                 (T.evar ())
                                 (T.Const Prim.eqzb)
                                 mlit)
                      >>> [
                          (* eqzb : integer -> integer -> bool *)
                          Susp.force eqzbTac >> done,

                          (* mpos : integer *)
                          refine (Rule.integerIntroOf) >> done
                          ],

                      (* D M = D N : integer *)
                      refine (Rule.arrowElimEq
                                 a
                                 (T.evar ())
                                 d
                                 d
                                 m
                                 n)
                      >>> [
                          (* D = D : A -> integer *)
                          refine (Rule.eqRefl (T.evar ()) (T.evar ()))
                          >>+
                          (* D : A -> integer *)
                          dtac >> idtacM Secondary,
                          
                          (* M = N : A *)
                          refine (Rule.hypothesis h) >> done
                          ]
                      ]
               end


            (* h : M = N : A 
               where A = const spine
                     M = mconst ...
                     N = mconst ...
            *)
            fun injectYes h a const spine m mconst n =
               let
                  do (jud, dir) = withgoal

                  val pos = CD.lookup typeInvert const

                  do mpos =
                     tryf
                     (fn () =>
                         (case CD.find constructorInvert mconst of
                             NONE =>
                                raise (Tryf (String.concat [Namespace.toString mconst, " is not a constructor for ", Namespace.toString const]))
    
                           | SOME i => i))

                  val e = T.Elim (T.Const (Vector.sub extractors pos), spine)
                  val et = T.Elim (T.Const (Vector.sub extractorTypes pos), spine)

                  val (_, etac) = Infer.infer (J.context jud) e (fns _ _ => idtac)
               in
                  (* C *)
                  refine (Rule.assert'
                             (T.apply3 Prim.eq (T.app et m) (T.app e m) (T.app e n))
                             (T.evar ()))
                  >>> [
                      (* E M = E N : ET M *)
                      refine (Rule.eqTrivialize (T.evar ()) (T.evar ()) (T.evar ()))
                      >>+
                      (* E M = E N : ET M *)
                      refine (Rule.forallElimEq
                                 a
                                 (T.app (T.Sub (et, T.shift1)) T.zero)
                                 e
                                 e
                                 m
                                 n)
                      >>> [
                          (* E = E : forall A . ET[^] 0 *)
                          refine (Rule.eqRefl (T.evar ()) (T.evar ()))
                          >>+
                          (* E : forall A . ET[^] 0 *)
                          etac >> idtacM Secondary,

                          (* M = N : A *)
                          refine (Rule.hypothesis h) >> done
                          ],

                      (* E M = E N : ET M |- C[^] *)
                      refine (Rule.reduceHyp 0
                                 (R.compat
                                     [
                                     R.user2 (Vector.sub extractorTypeReductions mpos),
                                     R.user2 (Vector.sub extractorReductions mpos),
                                     R.user2 (Vector.sub extractorReductions mpos)
                                     ]))
                      >>+
                      (* package = package' : package-type |- C[^] *)
                      cut
                         (repeatCount
                             (
                             first [EqualityTacticInternal.injectionExists 0, EqualityTacticInternal.injectionProd 0]
                             >>
                             refine (Rule.weaken 2 1)
                             ))
                      >>=
                      (fn eqs =>
                          refine (Rule.weaken 0 1)
                          >>
                          chdir (D.bind0s dir eqs)
                          >>
                          idtacM Primary)
                      ]
               end


            fun inject h =
               goalHypCaseT h
               / $tm \Prim.eq\ ($as (const? @ ?)) ($as (const? @ _)) ($as (const? @ _)) =>
                 \(fnc a const spine m mconst n nconst =>
                      if Constant.eq (mconst, nconst) then
                         injectYes h a const spine m mconst n
                      else
                         injectNo h a const spine m mconst n nconst)\
               /
         in
            inject
         end



      val theConstructors : constant list ConstantTable.table = ConstantTable.table ()
      fun constructors const = ConstantTable.find theConstructors const

      type bundle =
         int                          (* number of invisible pervasive arguments *)
         *
         int                          (* number of visible pervasive arguments *)
         *
         int                          (* number of mutually recursive datatypes *)
         *
         int                          (* total number of contructors *)
         *
            (* each mutually recursive data type *)
            (
            constant                  (* the datatype *)
            *
            constant                  (* its iterator *)
            *
            int                       (* number of index arguments *)
            *
            int                       (* number of constructors *)
            *
            (* each constructor *)
               (
               constant               (* the constructor *)
               *
               int                    (* constructor's number of arguments *)
               *
               int option list        (* which of the constructor's arguments are internal, and if so, for what datatype # *)
               *
               Reduction.reduction2   (* the reduction for the iterator applied to the constructor *)
               ) Vector.vector
            ) Vector.vector

      val theInfo : (int * bundle) ConstantTable.table = ConstantTable.table ()
      fun info const = ConstantTable.find theInfo const

      val install : (constant -> unit) ref = ref (fn _ => ())



      fun populate (env as ENV {invisnum=numberOfInvisibleArgs, persnum=numberOfVisibleArgs, tplist, conlist, discriminators, totalConstructors}) =
         let
            val destructor' = destructor env
            val injector' = injector env
            val insert = ConstantTable.insert

            val () =
               List.app
                  (fn (TENV {const, iterator, numargs=numberOfIndexArgs, strip}) =>
                      (
                      insert DE.destructTactics const destructor';
   
                      insert InductionInternal.inductionTactics const (inductor env const numberOfIndexArgs strip);
   
                      insert InductionInternal.iterators const (iterator, numberOfVisibleArgs, numberOfIndexArgs);
   
                      insert EqualityTacticInternal.injectionTactics const injector'
                      ))
                  tplist


            (* populate constructors and info tables, and the unparsing table *)

            val tab = Array.array (List.length tplist) (0, [], [])

            (* correlate the constructors by datataype, since (annoyingly) they are not *)
            val () =
               List.app
                  (fn (CENV {const, tpnum, numargs, args, iteratorReduction}) =>
                      let
                         val (n, lshort, lfull) = Array.sub tab tpnum

                         val args' =
                            List.map
                               (fn External _ => NONE
                                 | Internal (i, _) => SOME i)
                               args

                         val info = (const, numargs, args', iteratorReduction)
                      in
                         Array.update tab tpnum 
                            (n+1,
                             const :: lshort,
                             info :: lfull)
                      end)
                  conlist

            val numberOfDatatypes = Vector.length discriminators  (* a convenient way to get the count *)

            val bundle =
               (numberOfInvisibleArgs,
                numberOfVisibleArgs,
                numberOfDatatypes,
                totalConstructors,
                Vector.fromList
                   (List.mapi
                       (fns i (TENV {const=tpconst, iterator, numargs=numberOfIndexArgs}) =>
                           let
                              val (numberOfConstructors, _, l) = Array.sub tab i
                           in
                              (tpconst,
                               iterator,
                               numberOfIndexArgs,
                               numberOfConstructors,
                               Vector.fromList (List.rev l))
                           end)
                       tplist))

            val () =
               List.appi 
                  (fns i (TENV {const=tpconst}) =>
                      let
                         val (_, l, _) = Array.sub tab i
                      in
                         ConstantTable.insert theConstructors tpconst l;
                         ConstantTable.insert theInfo tpconst (i, bundle);
                         !install tpconst
                      end)
                  tplist
         in
            ()
         end



      (* Does the main work of building the datatypes. *)
      fun makeDatatype (typedef as (invis, pers, univ_mobile, dts) : itypedef) =
         let
            val mut = List.length dts

            val () =
               if mut = 0 then
                  signalError "empty datatype specification"
               else
                  ()

            val allcons = flattenDts dts

            val (ctxPers, xctxPers) =
               List.foldl
                  (fns (_, (c as (cterm, _, _))) (ctx, xctx) => 
                      (Seq.cons (J.Tm cterm) ctx,
                       X.tuse c :: xctx))
                  (Seq.empty, [])
                  (invis @ pers)


            val univ = X.use univ_mobile



            (* 1. Build the schema.

               The schema (i, A, [  (Bj, [Mjk | k], Nj)  | j])
      
               represents:
               tp : A -> U i
               with
               con_j : forall (x : Bj) .  ... dt (Mjk x) -> ... dt (Nj x)
      
               that is:
               depmu (tp : A -> Ui) . lam (y : A) .
                  ...
                  % (exists (x : Bj) .
                        y = Nj x : A
                        & (... & tp (Mjk x) & ...))
                  % ...

               (In datatype.ist, the word "schema" is used for just the constructors
               portion of this.)
            *)
            
            val indextpsList =
               List.map
                  (fn (_, args, _) =>
                      let
                         val (_, b) =
                            (* We are working in G_depth = G, C1, ..., Cdepth
                             
                               If the argument type is C, then ctac proves G_depth |- C : Ui[^depth],
                            *)
                            bifold
                               (fns (symopt, c) depth =>
                                   (depth+1,

                                    (fn t => X.existsUniv symopt (X.use c) t)))
                               (fn depth => X.unitUniv (X.weaken univ depth))
                               0
                               args
                      in
                         X.mobilize ctxPers b
                      end)
                  dts  

            val a_mobile : X.mxterm =
               X.mobilize ctxPers $ 
               List.foldr 
                  (fns c d => X.sumUniv (X.use c) d)
                  (X.voidUniv univ) indextpsList

            val a : X.xterm = X.use a_mobile

            val indextps : X.mxterm Vector.vector = Vector.fromList indextpsList



            (* procIndices j s indices

               If    indices live in G', and are the indices for datatype #j
                     G, B |- s : G'
               then  returns G, B |- A[^]
            *)
            fun procIndices j s indices =
               let
                  val c = X.use (Vector.sub indextps j)

                  (* G |- C : Ui *)

                  val n =
                     X.tupleEx (map (fn p => X.sub (X.use p) s) indices) (X.tweaken (X.forget c) 1)

                  (* G, B |- N : C[^]  where  N = (P1[s], .. (Pk[s], ())) *)

               in 
                  X.inN j n (X.tweaken (X.forget a) 1)
               end


            val dconsl : (X.xterm * X.xterm list * X.xterm) list =
               List.map
                  (fn (j, _, _, conargs, _, indices) =>
                      let
                         val (_, b) =
                            bifold
                               (fns conarg depth =>
                                   (case conarg of
                                       External (_, c) =>
                                          (depth+1,

                                           (fn b =>
                                               X.existsUniv NONE (X.use c) b))

                                     | Internal _ =>
                                          (depth,
                                           (fn b => b))))
                               (fn depth => X.unitUniv (X.weaken univ depth))
                               0
                               conargs

                         val ((_, s), ms) =
                            (* We are working in Gi = G, C1, ..., Ci.
                               We have processed i external args already.
                               B is the full type; T is the remainder of B.

                               G_depth |- T : type.
                               G, B |- s : Gi, T
                               (so G, B |- ^ o s : Gi)

                               Computing [.. Mk .. | k]
                               where     G |- Mk : B -> A
                            *)
                            bifold
                               (fns conarg (t, s) =>
                                   (case conarg of
                                       External _ =>
                                          ((X.existsInv2 t, X.compose (X.existsLeft t) s),
                                           (fn ms => ms))

                                     | Internal (j', indices') =>
                                          ((t, s),

                                           (fn ms =>
                                               let
                                                  val m = 
                                                     X.lam NONE (X.forget b)
                                                        (procIndices j' (X.compose (X.shift 1) s) indices')
                                               in
                                                  m :: ms
                                               end))))
                               (fn _ => [])
                               (X.forget b, X.id)
                               conargs

                         val n = X.lam NONE (X.forget b) (procIndices j (X.compose (X.shift 1) s) indices)
                      in
                         (b, ms, n)
                      end)
                  allcons

            val dconsarr = Vector.fromList dconsl




            (* 2. Rebuild the schema in library terms. *)

            val za = X.arrowUniv (X.var 0 (X.univ univ)) (X.weaken a 1)
            val elementrhs = X.cumulativeSucc (X.prodUniv (xlist (X.weaken univ 1) za) za)
            val element = X.existsUniv NONE (X.univUniv univ) elementrhs
            val suniv = X.lsucc univ

            val dcons_mobile =
               X.mobilize ctxPers $
               List.foldr
                  (fns (b, ms, n) t =>
                      let
                         val ba = X.arrowUniv b a

                         val ms' =
                            List.foldr
                               (fns m u => xcons univ ba m u)
                               (xnil univ ba)
                               ms
                      in
                         xcons suniv element
                            (X.pairEx
                                b
                                (X.pair ms' n)
                                (X.forget elementrhs))
                            t
                      end)
                  (xnil suniv element)
                  dconsl

            val dcons = X.use dcons_mobile
            



            (* 3. Useful definitions *)

            fun wrap m =
               List.foldr
                  (fns (sym, d) n => X.lamInt (SOME sym) (X.tuse d) n)
                  (List.foldr
                      (fns (sym, d) n => X.lamAll (SOME sym) (X.tuse d) n)
                      m
                      pers)
                  invis

            fun wraptp m =
               List.foldr
                  (fns (sym, (d, _, _)) n => T.apply2 Prim.intersect d (T.Lam (SOME sym, n)))
                  (List.foldr
                      (fns (sym, (d, _, _)) n => T.apply2 Prim.forall d (T.Lam (SOME sym, n)))
                      m
                      pers)
                  invis

            (* same as wrap/wraptp, but intersections replaced by forall *)

            fun wrapLemma m =
               List.foldr
                  (fns (sym, d) n => X.lamAll (SOME sym) (X.tuse d) n)
                  (List.foldr
                      (fns (sym, d) n => X.lamAll (SOME sym) (X.tuse d) n)
                      m
                      pers)
                  invis

            fun wraptpLemma m =
               List.foldr
                  (fns (sym, (d, _, _)) n => T.apply2 Prim.forall d (T.Lam (SOME sym, n)))
                  (List.foldr
                      (fns (sym, (d, _, _)) n => T.apply2 Prim.forall d (T.Lam (SOME sym, n)))
                      m
                      pers)
                  invis

            (* to fill in pervasive arguments, when in the scope of pervasive arguments *)
            val (_, topargs) =
               List.foldr
                  (fns (_, c) (i, l) => (i+1, X.var i (X.tuse c) :: l))
                  (0, [])
                  (invis @ pers)

            val numberOfInvisibleArgs = List.length invis
            val numberOfVisibleArgs = List.length pers
            val numberOfPervasiveArgs = numberOfInvisibleArgs + numberOfVisibleArgs

            val topvisargsSpine =
               natrecr numberOfVisibleArgs
                  (fns i l => T.App (T.Var i) :: l)
                  []




            (* 4. Define the subterm ordering and associated stuff *)

            val firstName = Symbol.toValue $ n1of3 $ List.hd dts

            (* blah_skel *)
            val skeletonConst =
               define
                  (Symbol.fromValue (firstName ^ "_skel"))
                  (wrap (X.apps (xconstant constRep) [univ, a, dcons]))
                  (wraptp (T.apply1 Prim.univ (X.term univ)))

            val skel = tcompact ctxPers $ X.forget $ X.apps (xconstant constRep) [univ, a, dcons]

            val skeltp = 
               T.Elim (T.Const skeletonConst, topvisargsSpine)

            val subterm =
               compact ctxPers $
               X.apps (xconstant constSubtermDt)
                  [
                  univ,
                  a,
                  dcons
                  ]

            (* blah_subterm *)
            val subtermConst =
               define
                  (Symbol.fromValue (firstName ^ "_subterm"))
                  (wrap subterm)
                  (wraptp (T.apply2 Prim.arrow skeltp
                              (T.apply2 Prim.arrow skeltp
                                  (T.apply1 Prim.univ (X.term univ)))))

            fun setImplicits const n =
               if n = 0 then
                  ()
               else
                  Database.setImplicits const n

            val () = 
               setImplicits subtermConst numberOfVisibleArgs

            val subtermtp =
               T.Elim (T.Const subtermConst, topvisargsSpine)

            (* blah_subterm_trans *)
            val subtermTransConst =
               let
                  val a1 = skel
                  val a2 = X.tweaken skel 1
                  val a3 = X.tweaken skel 2

                  val a4 =
                     X.forget $
                     X.apps (X.weaken subterm 3)
                        [
                        X.var 2 a1,
                        X.var 1 a2
                        ]

                  val a5 =
                     X.forget $
                     X.apps (X.weaken subterm 4)
                        [
                        X.var 2 a2,
                        X.var 1 a3
                        ]
               in
                  define
                     (Symbol.fromValue (firstName ^ "_subterm_trans"))
                     (wrapLemma
                         (X.lamAll NONE a1
                             (X.lamAll NONE a2
                                 (X.lamAll NONE a3
                                     (X.lam NONE a4
                                         (X.lam NONE a5
                                             (X.apps (xconstant constSubtermTrans)
                                                 [
                                                 X.weaken univ 5,
                                                 X.weaken a 5,
                                                 X.weaken dcons 5,
                                                 X.var 4 a1,
                                                 X.var 3 a2,
                                                 X.var 2 a3,
                                                 X.var 1 a4,
                                                 X.var 0 a5
                                                 ])))))))
                     (wraptpLemma
                         (T.apply2 Prim.forall skeltp
                             (T.Lam (SOME xsym,
                                     T.apply2 Prim.forall (T.Sub (skeltp, T.shift1))
                                        (T.Lam (SOME ysym,
                                                T.apply2 Prim.forall (T.Sub (skeltp, T.Shift 2))
                                                   (T.Lam (SOME zsym,
                                                           T.apply2 Prim.arrow
                                                              (T.Elim (T.Sub (subtermtp, T.Shift 3),
                                                                       [T.App (T.Var 2), T.App (T.Var 1)]))
                                                              (T.apply2 Prim.arrow
                                                                  (T.Elim (T.Sub (subtermtp, T.Shift 3),
                                                                           [T.App (T.Var 1), T.App (T.Var 0)]))
                                                                  (T.Elim (T.Sub (subtermtp, T.Shift 3),
                                                                           [T.App (T.Var 2), T.App (T.Var 0)])))))))))))
               end


            (* blah_subterm_well_founded *)
            val subtermWellFoundedConst =
               define
                  (Symbol.fromValue (firstName ^ "_subterm_well_founded"))
                  (wrapLemma
                      (X.lamAll NONE skel
                          (X.apps (xconstant constSubtermWellFounded)
                              [
                              X.weaken univ 1,
                              X.weaken a 1,
                              X.weaken dcons 1,
                              X.var 0 skel
                              ])))
                  (wraptpLemma
                      (T.apply2 Prim.forall skeltp
                          (T.Lam (SOME xsym,
                                  T.apply3 (Susp.force constAcc)
                                     (T.Sub (skeltp, T.shift1))
                                     (T.Sub (subtermtp, T.shift1))
                                     T.zero))))




            (* 5. Define the types. *)

            val typeInfoList =
               List.mapi
                  (fns j (dtsym, args, constructors) =>
                      let
                         val d = X.use (Vector.sub indextps j)

                         val numberOfIndexArgs = List.length args
                         val numberOfTotalArgs = numberOfVisibleArgs + numberOfIndexArgs

                         fun makeType depth args' constituents =
                            (case args' of
                                [] =>
                                   let
                                      val ind =
                                         X.inN j
                                            (X.tupleEx 
                                                (maprev (xadjust depth) constituents)
                                                (X.tweaken (X.forget d) depth))
                                            (X.tweaken (X.forget a) depth)

                                      val dt =
                                         X.apps (xconstant constDt)
                                            [
                                            X.weaken univ depth,
                                            X.weaken a depth,
                                            X.weaken dcons depth,
                                            ind
                                            ]
                                   in
                                      (ind, 

                                       dt,
   
                                       T.apply1 Prim.univ (T.Sub (X.term univ, T.Shift depth)),
   
                                       X.lam NONE (X.forget dt)
                                          (X.apps (xconstant constStrip)
                                              [
                                              X.weaken univ (depth+1),
                                              X.weaken a (depth+1),
                                              X.weaken dcons (depth+1),
                                              X.weaken ind 1,
                                              X.var 0 (X.forget dt)
                                              ]),

                                       (fn const =>
                                           T.apply2 Prim.arrow
                                              (T.Elim (T.Const const,
                                                       natrecr
                                                          (numberOfVisibleArgs + depth)
                                                          (fns i l => T.App (T.Var i) :: l)
                                                          []))
                                              (T.Elim (T.Const skeletonConst,
                                                       natrecr
                                                          numberOfVisibleArgs
                                                          (fns i l => T.App (T.Var (i + depth)) :: l)
                                                          []))))
                                   end
                                       
   
                              | (symopt, c) :: restArgs =>
                                   let
                                      val c = X.use c

                                      val constituents' =
                                         (depth+1, X.var 0 (X.forget c)) :: constituents

                                      val (ind, body, body_t, strip, strip_t) = makeType (depth+1) restArgs constituents'
                                   in
                                      (case symopt of
                                          NONE =>
                                             (ind,

                                              X.lam NONE (X.forget c) body,

                                              T.apply2 Prim.arrow (X.term c) (unshift body_t),

                                              X.lamAll NONE (X.forget c) strip,

                                              (fn const =>
                                                  T.apply2 Prim.forall (X.term c) (T.Lam (NONE, strip_t const))))

                                        | SOME _ =>
                                             (ind,

                                              X.lamAll symopt (X.forget c) body,
                                              
                                              T.apply2 Prim.forall (X.term c) (T.Lam (symopt, body_t)),

                                              X.lamAll NONE (X.forget c) strip,

                                              (fn const =>
                                                  T.apply2 Prim.forall (X.term c) (T.Lam (symopt, strip_t const)))))
                                   end)

                         val (ind, dt_def, dt_t, strip_def, strip_t) = makeType 0 args []

                         val const = define dtsym (wrap dt_def) (wraptp dt_t)

                         val red =
                            R.trans [R.unfold, R.beta numberOfTotalArgs]

                         val red' =
                            (* This one will still work after const is made opaque. *)
                            R.user1 $
                            R.new1 const numberOfTotalArgs
                               (R.reduce red (T.Elim (T.Const const,
                                                      natrecr numberOfTotalArgs (fns i l => T.App (T.Var i) :: l) [])))
                               red
                               R.refl

                         val stripConst =
                            define
                               (Symbol.fromValue (Symbol.toValue dtsym ^ "_strip"))
                               (wrap strip_def) 
                               (wraptp (strip_t const))
                      in
                         if numberOfTotalArgs = 0 then
                            ()
                         else
                            setImplicits stripConst numberOfTotalArgs;

                         print "Datatype ";
                         print (Symbol.toValue dtsym);
                         print " defined.\n";

                         (const, red', stripConst, ind, args, numberOfIndexArgs)
                      end)
                  dts
               

            (* typeInfo maps to (const, red, stripConst, ind, args, numberOfIndexArgs)

               const: the datatype's constant
               red: a reduciton to unroll the datatype
               stripConst: the datatype's strip function's constant
               ind: the index term (in a context containing only pervasive arguments and the datatype's arguments)
               args: the index arguments
               numberOfIndexArgs: the number of index arguments
            *)

            val typeInfo = Vector.fromList typeInfoList
            val numberOfTypes = Vector.length typeInfo




            (* 6. Define the constructors. *)

            val numberOfConstructors = List.length allcons

            val conInfoList =
               List.map
                  (fn (i, j, consym, conargs, _, indices) =>
                      let
                         val (tpconst, _, stripconst, _, _, _) = Vector.sub typeInfo i
                         val (b, _, _) = Vector.sub dconsarr j

                         fun makeCon depth s conargs xconstituents iconstituents strips =
                            (* G, G1 |- s : G, G2

                               where |G1| = depth = number of internal or external arguments in scope
                                 and |G2| = number of external arguments in scope

                               conargs are in G, G2

                               iconstituents and strips include an argument depth', and their terms
                               are in a context G, G1' where |G1'| = depth' and G1' is a prefix of G1.

                               returns the constructor and its type in G, G1
                               and returns the subterm lemma and its type in G, G1
                            *)
                            (case conargs of
                                [] =>
                                   let
                                      val xtuple = 
                                         (X.tupleEx
                                             (maprev (xadjust depth) xconstituents)
                                             (X.tweaken (X.forget b) depth))

                                      val iconstituents' = map (xadjust depth) iconstituents

                                      val conspine = 
                                         natrecr numberOfVisibleArgs
                                            (fns i l => T.App (T.Var (i+depth)) :: l)
                                            (List.map 
                                                (fn (m, _, _, _) => T.App (T.Sub (m, fst s)))
                                                indices)
                                   in
                                      (xcon
                                          (X.weaken univ depth)
                                          (X.weaken a depth)
                                          (X.weaken dcons depth)
                                          (X.nat j)
                                          (proveLeq (j+1) numberOfConstructors)
                                          xtuple
                                          (* relying on a nontrivial equality here *)
                                          (List.foldl X.pair X.triv iconstituents'),
   
                                       T.Elim (T.Const tpconst, conspine),
   
                                       xsubtermcon
                                          (X.weaken univ depth)
                                          (X.weaken a depth)
                                          (X.weaken dcons depth)
                                          (X.nat j)
                                          (proveLeq (j+1) numberOfConstructors)
                                          xtuple
                                          (* relying on a nontrivial equality here *)
                                          (List.foldl X.pair X.triv iconstituents'),
   
                                       (fn const =>
                                           let
                                              val sp =
                                                 natrecr
                                                    numberOfVisibleArgs
                                                    (fns i l => T.App (T.Var (i + depth)) :: l)
                                                    []
       
                                              val fullskel =
                                                 T.App $
                                                 T.Elim (T.Const stripconst,
                                                         conspine
                                                         @ [T.App (T.Elim (T.Const const,
                                                                           natrecr
                                                                              (numberOfVisibleArgs + depth)
                                                                              (fns i l => T.App (T.Var i) :: l)
                                                                              []))])
                                           in
                                              foldl2
                                                 (fns (v, _, _) (stripconst', depth', indices') t =>
                                                     T.apply2 Prim.prod
                                                        (T.Elim (T.Const subtermConst,
                                                                 sp @ [
                                                                      T.App (T.Elim (T.Const stripconst',
                                                                                     sp
                                                                                     @ List.map
                                                                                          (fn (m, _, _) => 
                                                                                              T.App (T.Sub (m, T.Shift (depth-depth'))))
                                                                                          indices'
                                                                                     @ [T.App v])),

                                                                      fullskel
                                                                      ]))
                                                        t)
                                                 (T.Const Prim.unit)
                                                 iconstituents'
                                                 strips
                                           end))
                                   end
 
                              | External (binderopt, c) :: rest =>
                                   let
                                      val csh = X.tsub (X.forget (X.use c)) s

                                      val (body, bodytp, subtermbody, subtermbodytp) =
                                         makeCon
                                            (depth+1)
                                            (X.underEasy 1 s)
                                            rest
                                            ((depth+1, X.var 0 csh) :: xconstituents)
                                            iconstituents
                                            strips
                                   in
                                      (case binderopt of
                                          NONE =>
                                             (X.lam NONE csh body,

                                              T.apply2 Prim.arrow (X.typ csh) (unshift bodytp),

                                              X.lamAll NONE csh subtermbody,

                                              (fn const =>
                                                  T.apply2 Prim.forall (X.typ csh) (T.Lam (NONE, subtermbodytp const))))

                                        | SOME binder =>
                                             (X.lamAll binder csh body,

                                              T.apply2 Prim.forall (X.typ csh) (T.Lam (binder, bodytp)),

                                              X.lamAll binder csh subtermbody,

                                              (fn const =>
                                                  T.apply2 Prim.forall (X.typ csh) (T.Lam (binder, subtermbodytp const)))))
                                   end

                              | Internal (k, indices) :: rest =>
                                   let
                                      val (kconst, _, kstripconst, _, _, _) = Vector.sub typeInfo k

                                      val indices' = List.map (fn m => X.sub (X.use m) s) indices

                                      val c as (cterm, _) = 
                                         X.forget $
                                         X.apps
                                            (X.weaken (X.constant kconst) depth)
                                            (List.map (fn m => X.weaken m depth) topargs @ indices')

                                      val (body, bodytp, subtermbody, subtermbodytp) =
                                         makeCon
                                            (depth+1)
                                            (X.compose s (X.shift 1))
                                            rest
                                            xconstituents
                                            ((depth+1, X.var 0 c) :: iconstituents)
                                            ((kstripconst, depth, indices') :: strips)
                                   in
                                      (X.lam NONE c body,

                                       T.apply2 Prim.arrow cterm (unshift bodytp),

                                       X.lamAll NONE c subtermbody,
                                       
                                       (fn const =>
                                           T.apply2 Prim.forall cterm (T.Lam (NONE, subtermbodytp const))))
                                   end)

                         val (pre_def, pre_t, subtermcon_def, subtermcon_t) = makeCon 0 X.id conargs [] [] []

                         val const = define consym (wrap pre_def) (wraptp pre_t)

                         val numberOfTotalArgs = numberOfVisibleArgs + List.length conargs

                         val red =
                            R.trans [R.unfold, R.beta numberOfTotalArgs]

                         val red' =
                            (* This one will still work after const is made opaque. *)
                            R.user1 $
                            R.new1 const numberOfTotalArgs
                               (R.reduce red (T.Elim (T.Const const,
                                                      natrecr numberOfTotalArgs (fns i l => T.App (T.Var i) :: l) [])))
                               red
                               R.refl

                         val subtermConConst =
                            define
                               (Symbol.fromValue (Symbol.toValue consym ^ "_subterm"))
                               (wrapLemma subtermcon_def)
                               (wraptpLemma (subtermcon_t const))
                      in
                         print "Constructor ";
                         print (Symbol.toValue consym);
                         print " defined.\n";

                         (const, red', subtermConConst)
                      end)
                  allcons

            val conInfo = Vector.fromList conInfoList




            (* 7. Define the iterators *)


            (* Builds something under index arguments.

               arrows: use arrows if possible
               ctx: the context (including pervasives)
               depth: the size of the context (after pervasives)
               numberOfArgs: the number of index arguments seen so far
               s: a substitution from the context containing only pervasives and index arguments
               args: the index arguments still to be processed
               f: takes ctx, depth, numberOfArgs, and s; returns an xterm and a type
            *)
            fun underIndexArguments arrows ctx depth numberOfArgs s args f =
               (case args of
                   [] =>
                      f ctx depth numberOfArgs s

                 | (binder, arg) :: rest =>
                      let
                         val arg' = X.tsub (X.forget (X.use arg)) s

                         val (def, t) =
                            underIndexArguments arrows
                               (arg' :: ctx)
                               (depth+1) (numberOfArgs+1)
                               (X.underEasy 1 s)
                               rest f
                      in
                         if arrows andalso not (Option.isSome binder) then
                            (X.lam NONE arg' def,
                             T.apply2 Prim.arrow (X.typ arg') (unshift t))
                         else
                            (X.lamAll binder arg' def,
                             T.apply2 Prim.forall (X.typ arg') (T.Lam (binder, t)))
                      end)


            (* as above, but the xterm returned is a type, not a term *)
            fun typeUnderIndexArguments arrows ctx depth numberOfArgs s args f =
               (case args of
                   [] =>
                      f ctx depth numberOfArgs s

                 | (binder, arg) :: rest =>
                      let
                         val arg' = X.tsub (X.forget (X.use arg)) s

                         val (def, t) =
                            typeUnderIndexArguments arrows
                               (arg' :: ctx)
                               (depth+1) (numberOfArgs+1)
                               (X.underEasy 1 s)
                               rest f
                      in
                         if arrows andalso not (Option.isSome binder) then
                            (X.arrowDep arg' def,
                             T.apply2 Prim.arrow (X.typ arg') (unshift t))
                         else
                            (X.forall binder arg' def,
                             T.apply2 Prim.forall (X.typ arg') (T.Lam (binder, t)))
                      end)
               

            (* Produces the type of an arm

               i: the datatype this is a constructor for
               j: the constructor this is
               ctx: the context (including pervasives)
               depth: the depth where it's going (after pervasives)
               predindex: the index of the last predicate
               indices: the constructor's indices (in a context containing pervasives and external args)
               s: a substitution from a context containing only pervasives and external args
               constituents: the constructor arguments (but not the recursive results), innermost first
               conarg: the constructor arguments yet to be processed
            *)
            fun makeArmType i j ctx depth predindex indices s constituents conargs =
               (case conargs of
                   [] =>
                      let
                         val (conConst, _, _) = Vector.sub conInfo j

                         val k = predindex + numberOfTypes - 1 - i
                      in
                         (X.forget
                             (X.apps (xvar k ctx)
                                 (List.map (fn m => X.sub (X.use m) s) indices
                                  @ [X.apps (X.constant conConst)
                                        (natrecr numberOfPervasiveArgs (fns h l => xvar (h+depth) ctx :: l)
                                            (maprev (xadjust depth) constituents))])),
                          T.Elim (T.Var k, 
                                  List.map (fn (m, _, _, _) => T.App (T.Sub (m, fst s))) indices
                                  @ [T.App $
                                     T.Elim (T.Const conConst,
                                             natrecr numberOfVisibleArgs (fns h l => T.App (T.Var (h+depth)) :: l)
                                                (maprev 
                                                    (fn (depth', (m, _, _)) => 
                                                        T.App (T.Sub (m, T.Shift (depth-depth'))))
                                                    constituents))]))
                      end

                 | External (binderopt, c) :: rest =>
                      let
                         val binder = Option.join binderopt

                         val c' = X.tsub (X.forget (X.use c)) s

                         val (def, t) =
                            makeArmType i j
                               (c' :: ctx)
                               (depth+1) (predindex+1) indices 
                               (X.under [c'] s)
                               ((depth+1, X.var 0 c') :: constituents)
                               rest
                      in
                         (X.forall binder c' def,
                          T.apply2 Prim.forall (X.typ c') (T.Lam (binder, t)))
                      end

                 | Internal (this_i, these_indices) :: rest =>
                      let
                         val (this_const, _, _, _, _, _) = Vector.sub typeInfo this_i

                         val indices' = List.map (fn m => X.sub (X.use m) s) these_indices

                         val dom_def =
                            X.forget $
                            X.apps (X.constant this_const)
                               (natrecr numberOfPervasiveArgs (fns h l => xvar (h+depth) ctx :: l)
                                   indices')

                         val dom_t =
                            T.Elim (T.Const this_const,
                                    natrecr numberOfVisibleArgs (fns h l => T.App (T.Var (h+depth)) :: l)
                                       (List.map (fn (m, _, _) => T.App m) indices'))

                         val k = predindex + numberOfTypes - this_i
                         
                         val s' = X.compose s (X.shift 1)

                         val rec_def =
                            X.forget $
                            X.apps (xvar k (dom_def :: ctx))
                               (List.map (fn m => X.sub (X.use m) s') these_indices
                                @ [X.var 0 dom_def])

                         val rec_t =
                            T.Elim (T.Var k,
                                    List.map (fn (m, _, _, _) => T.App (T.Sub (m, fst s'))) these_indices
                                    @ [T.App (T.Var 0)])

                         val (def, t) =
                            makeArmType i j
                               (rec_def :: dom_def :: ctx)
                               (depth+2) (predindex+2) indices
                               (X.compose s (X.shift 2))
                               ((depth+2, X.var 1 dom_def) :: constituents)
                               rest
                      in
                         (X.forall NONE dom_def (X.arrowDep rec_def def),
                          T.apply2 Prim.forall dom_t
                             (T.Lam (NONE, T.apply2 Prim.arrow rec_t (unshift t))))
                      end)



            (* Builds something under an unpacked constructor.

               The context looks like:
               G, <external args>, <tuple of remaining external args>,
                  <internal args>, <tuple of remaining internal args>,
                  <recursive results>, <tuple of remaining internal results>

               The ending context looks like
               G, <external args>, <internal args>, <recursive results>

               extnum: number of external args (so far)
               extern: the type of the tuple of remaining external args
               intnum: number of internal args (so far)
               intern: the type of the tuple of remaining internal args
               (the number of recursive results so far is the same as intnum)
               rc: the type of the tuple of remaining recursive results
               constituents: the terms to be passed to f, in reverse order, as a list of entries
                  each item is a variable index and that variable's type (shiften into the full context)
                  each substitution in the list is applied to the subsequent elements
                  (which are actually earlier arguments since the list is reversed)
               result: the result type, in the current context
               args: the constructor arguments yet to be processed
               f: takes the number of added hypotheses (i.e., extnum + 2*intnum)
                  and a list of xterm arguments to the case (in the order the case expects them),
                  and returns an xterm
            *)
            fun unpackConstr extnum extern intnum intern rc constituents result args f =
               (case args of
                   [] =>
                      (* context is G, ..extnum.., unit, ..intnum.., unit, ..intnum.., unit *)
                      let
                         val s1 = T.under (2*intnum + 2) (T.Dot (T.Triv, T.id))
                         val s2 = T.under (intnum + 1) (T.Dot (T.Triv, T.id))
                         val s3 = T.Dot (T.Triv, T.id)

                         val s12 = T.compose s1 s2
                         val s123 = T.compose s12 s3

                         val (_, constituents') =
                            List.foldl
                               (fns entry (s, l) =>
                                   (case entry of
                                       Item (i, c) =>
                                          (case T.substVar i s of
                                              T.Idx i' =>
                                                 (s, X.vart i' (T.Sub (c, s)) :: l)

                                            | T.Term _ =>
                                                 (* By construction, we never substitute for these variables, only shift them. *)
                                                 raise (Fail "impossible"))

                                     | Subst s' =>
                                          (T.compose s' s, l)))
                               (s123, [])
                               constituents
                         
                         val def = f (extnum + 2*intnum) constituents'
                      in
                         X.splitUnit (2*intnum + 2)
                            (X.splitUnit (intnum+1)
                                (X.splitUnit 0
                                    def
                                    (T.Sub (result, s12)))
                                (T.Sub (result, s1)))
                            result
                      end

                 | External _ :: rest =>
                      (* context is G, ..extnum.., extern, ..intnum.., intern, ..intnum.., rc *)
                      termCase extern
                      / \Prim.exists\ ? (fn . ?) =>
                        \(fnc c1 c2 =>
                             let
                                val i = 2 * intnum + 2

                                val split = T.Dot (T.Pair (T.Var 1, T.Var 0), T.Shift 2)

                                val s = T.under i split

                                val def =
                                   unpackConstr (extnum+1) c2 intnum
                                      (T.Sub (intern, T.under intnum split))
                                      (T.Sub (rc, T.under (2*intnum + 1) split))
                                      (Item (i+1, T.Sub (c1, T.Shift (i+2))) :: Subst s :: constituents)
                                      (T.Sub (result, s))
                                      rest f
                             in
                                X.splitExists i def result
                             end)\
                      /

                 | Internal _ :: rest =>
                      (* context is G, ..extnum.., extern, ..intnum.., intern, ..intnum.., rc *)
                      term2Case intern rc
                      / \Prim.prod\ ? ? ; \Prim.prod\ ? ? =>
                        \(fnc c1 c2 d1 d2 =>
                             let
                                val split = T.Dot (T.Pair (T.Var 1, T.Var 0), T.Shift 2)
                                val s1 = T.under (intnum+1) split
                                val s2 = split

                                val s12 = T.compose s1 s2

                                val intnum_split = T.under intnum split

                                val def =
                                   unpackConstr extnum extern (intnum+1)
                                      (T.Sub (c2, T.shift1))
                                      (T.Sub (d2, T.compose intnum_split T.shift1))
                                      (Item (1, T.Sub (d1, T.compose intnum_split (T.Shift 2)))
                                       :: Item (intnum+3, T.Sub (c1, T.Shift (intnum+4)))
                                       :: Subst s12 :: constituents)
                                      (T.Sub (result, s12))
                                      rest f
                             in
                                X.splitProd (intnum+1)
                                   (X.splitProd 0 def (T.Sub (result, s1)))
                                   result
                             end)\
                      /)



            (* Produces the iterator's core (after predicate arguments).

               ctx: the context (including pervasives)
               depth: the depth where it's going (after pervasives)
               predindex: the index of the last predicate
               predicate: the master predicate (residing after the predicates)
               cases: the cases supplied to the iterator, innermost first
               cont: a continuation to apply to the result
               cons: the constructors still to be processed
            *)
            fun makeIterCore ctx depth predindex predicate cases cont cons =
               (case cons of
                   [] =>
                      let
                         val cases' = X.tuple (maprev (xadjust depth) cases)
                      in
                         List.mapi
                            (fns k (name, args, _) =>
                                let
                                   val (def, t) =
                                      underIndexArguments false ctx depth 0 (X.shift depth) args
                                      (fns _ depth' numberOfArgs s =>
                                          let
                                             val (const, _, _, argtuple, _, _) = Vector.sub typeInfo k
                                          in
                                             (X.apps (xconstant constIter)
                                                 [
                                                 X.weaken univ depth',
                                                 X.weaken a depth',
                                                 X.weaken dcons depth',
                                                 X.weaken predicate (predindex + numberOfArgs),
                                                 X.weaken cases' numberOfArgs,
                                                 X.sub argtuple s
                                                 ],
                    
                                              T.apply2 Prim.forall
                                                 (T.Elim (T.Const const,
                                                          natrecr numberOfVisibleArgs (fns i l => T.App (T.Var (i + depth')) :: l)
                                                             (natmapr numberOfArgs (fn i => T.App (T.Var i)))))
                                                 (T.Lam (NONE,
                                                         T.Elim (T.Var (predindex + numberOfArgs + numberOfTypes - k),
                                                                 natrecr numberOfArgs (fns i l => T.App (T.Var (i + 1)) :: l)
                                                                    [T.App T.zero]))))
                                          end)
                                in
                                   cont (name, def, t)
                                end)
                            dts
                      end
               
                 | (i, j, _, conargs, _, indices) :: rest =>
                      let
                         val (arm_def, arm_t) =
                            makeArmType i j ctx depth predindex indices (X.shift depth) [] conargs

                         val (b, ms, n) = Vector.sub dconsarr j

                         (* This appears after the case is added to the context, so depth+1. *)

                         val b' = X.tweaken (X.forget b) (depth+1)

                         val dom =
                            List.foldr
                               (fns m l =>
                                   X.prod
                                      (X.forget $
                                       X.apps (xconstant constDt)
                                          [
                                          X.weaken univ (depth+2),
                                          X.weaken a (depth+2),
                                          X.weaken dcons (depth+2),
                                          X.app 
                                             (X.weaken m (depth+2))
                                             (X.var 0 b')
                                          ])
                                      l)
                               X.unit
                               ms

                         val (_, rc) =
                            bifold
                               (fns m z =>
                                   (X.pi2 z,

                                    (fn rc =>
                                        X.prod
                                           (X.forget $
                                            X.apps (X.weaken predicate (predindex+3))
                                               [
                                               X.app
                                                  (X.weaken m (depth+3))
                                                  (X.var 1 b'),
                                               X.pi1 z
                                               ])
                                           rc)))
                               (fn _ => X.unit)
                               (X.var 0 dom)
                               ms

                         (* resides in the context ..., arm_def, b', dom, rc *)
                         val result =
                            T.app2 (T.Sub (X.term predicate, T.Shift (predindex+4)))
                               (T.app
                                   (T.Sub (X.term n, T.Shift (depth+4)))
                                   (T.Var 2))
                               (T.Elim 
                                   (T.Const (Susp.force constCon),
                                    [
                                    T.App (T.Sub (X.term a, T.Shift (depth+4))),
                                    T.App (T.Sub (X.term dcons, T.Shift (depth+4))),
                                    T.App (natTerm j),
                                    T.App (T.Var 2),
                                    T.App (T.Var 1)
                                    ]))

                         val thiscase =
                            X.lamAll NONE b'
                               (X.lamAll NONE dom
                                   (X.lam NONE rc
                                       (unpackConstr 0 (X.typ b') 0 (X.typ dom) (X.typ rc) [] result conargs
                                           (fns num armargs =>
                                               (* context is ..., arm_def, ..num.. *)
                                               X.apps (X.var num arm_def) armargs))))

                         fun cont' (name, iter_def, iter_t) =
                            cont
                               (name,
                                X.lam NONE arm_def iter_def,
                                T.apply2 Prim.arrow arm_t (unshift iter_t))
                      in
                         makeIterCore (arm_def :: ctx) (depth+1) (predindex+1) 
                            predicate
                            ((depth+1, thiscase) :: cases)
                            cont'
                            rest
                      end)


            (* Produces an arm of the master predicate, corresponding to one of the predicates, using that predicate in scope.

               The context is: G, <pervasives>, <predicates>, <index arguments>, <tuple of the (remaining) index arguments>

               k: which arm of the master predicate we're computing
               ctx: the context, except for the final element
               depth: the depth where this is all going, except the final element
                      (that is, the length of everything between <pervasives> and <tuple of ...>)
               (the number of predicates is numberOfTypes)
               numberOfArgs: number of index args seen so far
               result: the type of the thing, in the full context containing the final element
               args: the index arguments still to be processed
            *)
            fun makeIterPredBody k ctx depth numberOfArgs result args =
               (case args of
                   [] =>
                      (* inside the splitUnit, the context is ctx *)
                      X.splitUnit 0
                         (X.apps (xvar (numberOfArgs - 1 + numberOfTypes - k) ctx)
                             (natmapr numberOfArgs (fn i => xvar i ctx)))
                         result
                      
                 | (_, arg) :: rest =>
                      let
                         val s = X.underShift numberOfArgs numberOfTypes

                         (* G, <pervasives>, <predicates>, <index arguments> |- s : G, <pervasives>, <index arguments> *)

                         val arg' = X.tsub (X.forget (X.use arg)) s

                         val pred =
                            makeIterPredBody k 
                               (arg' :: ctx)
                               (depth+1) (numberOfArgs+1) 
                               (T.Sub (result, T.Dot (T.Pair (T.Var 1, T.Var 0), T.Shift 2)))
                               rest
                      in
                         X.splitExists 0 pred result
                      end)


            (* Produces the iterator (after pervasive arguments).
               Adds predicate arguments and hands off to makeIterCore.

               ctx: the context (including pervasives)
               depth: the depth where this is all going (after pervasives)
               (equivalently: the number of datatypes whose predicates are processed already)
               cont: a continuation to apply to the result
               dts': the datatypes still to be processed
            *)
            fun makeIter ctx depth cont dts' =
               (case dts' of
                   [] =>
                      let
                         val a' = X.tweaken (X.forget a) depth

                         val xresult as (result, _) =
                            X.arrow
                               (X.forget
                                   (X.apps (xconstant constDt)
                                       [
                                       X.weaken univ (depth+1),
                                       X.weaken a (depth+1),
                                       X.weaken dcons (depth+1),
                                       X.var 0 a'
                                       ]))
                               (X.univ (X.weaken univ (depth+1)))
                               
                         val (_, _, armsrev) =
                            List.foldl
                               (fns (_, args, _) (k, result', armsrev) =>
                                   (k+1,
                                    T.Sub (result', T.Dot (T.apply1 Prim.inr (T.Var 0), T.shift1)),
                                    
                                    X.weakenUnder
                                       (makeIterPredBody k ctx depth 0
                                           (T.Sub (result', T.Dot (T.apply1 Prim.inl (T.Var 0), T.shift1)))
                                           args)
                                       1 1
                                    :: armsrev))
                               (0, result, [])
                               dts

                         val fullpredicate =
                            compact
                               (List.foldr
                                   (fns (c, _) g => Seq.cons (J.Tm c) g)
                                   Seq.empty
                                   ctx)
                               (X.lamAll NONE a' (X.multicase (X.var 0 a') (List.rev armsrev) (X.tweakenUnder xresult 1 1)))
                      in
                         makeIterCore ctx depth 0 fullpredicate [] cont allcons
                      end

                 | (_, args, _) :: rest =>
                      let
                         val (pred_def, pred_t) =
                            typeUnderIndexArguments false ctx depth 0 (X.shift depth) args
                            (fns ctx' depth' numberOfArgs _ =>
                                let
                                   val (const, _, _, _, _, _) = Vector.sub typeInfo depth
                                   
                                   val xspine =
                                      natrecr numberOfPervasiveArgs
                                         (fns i l => xvar (i + depth') ctx' :: l)
                                         (natmapr numberOfArgs (fn i => xvar i ctx'))

                                   val spine = 
                                      natrecr numberOfVisibleArgs
                                         (fns i l => T.App (T.Var (i + depth')) :: l)
                                         (natmapr numberOfArgs (fn i => T.App (T.Var i)))
                                in
                                   (X.arrow
                                       (X.forget (X.apps (X.constant const) xspine))
                                       (X.univ (X.weaken univ depth')),
          
                                    T.apply2 Prim.arrow
                                       (T.Elim (T.Const const, spine))
                                       (T.apply1 Prim.univ (T.Sub (X.term univ, T.Shift depth'))))
                                end)
                                
                         fun cont' (name, iter_def, iter_t) =
                            cont
                               (name,
                                X.lamAll (SOME cPsym) pred_def iter_def,
                                T.apply2 Prim.forall pred_t (T.Lam (SOME cPsym, iter_t)))
                      in
                         makeIter (pred_def :: ctx) (depth+1) cont' rest
                      end)


            val iters = makeIter xctxPers 0 (fn x => x) dts

            val iterInfoList =
               List.map
                  (fn (dtname, iter_def, iter_t) =>
                      let
                         val name = Symbol.toValue dtname ^ "_iter"

                         val const =
                            define
                               (Symbol.fromValue name)
                               (wrap iter_def)
                               (wraptp iter_t)
                      in
                         print "Iterator ";
                         print name;
                         print " defined.\n";

                         (const, name)
                      end)
                  iters

            val iterInfo = Vector.fromList iterInfoList




            (* 8. Compute the iterator reductions *)

            val reductions' =
               List.foldl
                  (fns (const, _) d => (const, [R.unfold]) :: d)
                  (Susp.force reductions)
                  iterInfoList

            val iterReductionList =
               List.map
                  (fn (i, j, name, conargs, numberOfConargs, _) =>
                      let
                         val (iterConst, constName) = Vector.sub iterInfo i
                         val (_, _, _, _, _, numberOfIndexArgs) = Vector.sub typeInfo i
                         val (conConst, _, _) = Vector.sub conInfo j

                         val iterParams = numberOfVisibleArgs + numberOfTypes + numberOfConstructors + numberOfIndexArgs
                         val conParams = numberOfVisibleArgs + numberOfConargs

                         val dp = (conConst, [R.unfold]) :: reductions'
                         val dl = [(Susp.force constIter, Susp.force dt_iter_unroll)]
                         
                         val (_, _, caseargs) =
                            List.foldl
                               (fns conarg (pos, s, caseargs) =>
                                   (case conarg of
                                       External _ =>
                                          (pos-1, 
                                           T.Idot (pos, s),
                                           T.App (T.Var pos) :: caseargs)

                                     | Internal (i', indices) =>
                                          let
                                             val (iterConst', _) = Vector.sub iterInfo i'
                                             val (_, _, _, _, _, numberOfIndexArgs') = Vector.sub typeInfo i'

                                             val iterParamsBeforeIndex = numberOfVisibleArgs + numberOfTypes + numberOfConstructors

                                             val recarg =
                                                T.Elim (T.Const iterConst',
                                                        natrecr iterParamsBeforeIndex 
                                                           (fns i l => T.App (T.Var (i + numberOfIndexArgs + conParams)) :: l)
                                                           (List.map (fn (index, _, _, _) => T.App (T.Sub (index, s))) indices
                                                            @ [T.App (T.Var pos)]))
                                          in
                                             (pos-1, s, T.App recarg :: T.App (T.Var pos) :: caseargs)
                                          end))
                               (numberOfConargs - 1, T.id, [])
                               conargs

                         val after =
                            T.Elim (T.Var (numberOfConstructors - 1 - j + numberOfIndexArgs + conParams),
                                    List.rev caseargs)

                         val r = AR.new2 false dp dl iterConst iterParams 0 conConst conParams after
                      in
                         Define.register r;
                         
                         RR.write
                            (Symbol.fromValue (String.concat [constName, "_", Symbol.toValue name]))
                            RR.reduction2
                            r;

                         r
                      end)
                  allcons

            val iterReductions = Vector.fromList iterReductionList




            (* 9. Create merged iterator *)

            val merged as (_, merged_t, _) =
               merge
                  (numberOfPervasiveArgs + mut + numberOfConstructors)
                  (List.map
                      (fn (const, _) => const)
                      iterInfoList)

            val jointIter = define (Symbol.fromValue (firstName ^ "_iter_joint")) merged merged_t
            val () = Constant.setOpacity jointIter Constant.HARD



            
            (* 10. Create the discriminator and extractor *)

            (* The discriminators (for 'no' instances of injection) *)
      
            (* numdts : number of datatypes remaining
               iters : the iterators (as applied to the predicates for datatype already processed)
               ctx : the context insidee the pervasive arguments
            *)
            fun discrimBody numdts iters ctx =
               if numdts = 0 then
                  let
                     val (_, revargs) =
                        natrecr numberOfConstructors
                           (fns i (a, acc) =>
                               let
                                  val dom = X.arrowInv1 a
      
                                  val arg =
                                     mimicType1 ctx dom (fn _ => X.integerLiteral (IntInf.fromInt i))
      
                                  val cod = tcompact ctx (X.tsub (X.arrowInv2 a) (X.dotid arg))
                               in
                                  (cod, arg :: acc)
                               end)
                           (tcompact ctx (X.inhabitedForm (List.hd iters)), [])
      
                     val args = List.rev revargs
                  in
                     List.map
                        (fn iter => X.apps iter args)
                        iters
                  end
               else
                  let
                     val dom = tcompact ctx (X.forallInv1 (X.inhabitedForm (List.hd iters)))
                     
                     val m = mimicType1 ctx dom (fn n => X.weaken (X.integerUniv univ) n)
      
                     val iters' =
                        List.map
                           (fn iter => X.app iter m)
                           iters
                  in
                     discrimBody (numdts-1) iters' ctx
                  end

            val discriminatorList =
               let
                  val iters = List.map (fn (iter, _) => X.constant iter) iterInfoList
                  val a = tcompact Seq.empty (X.inhabitedForm (List.hd iters))
      
                  val discrims =
                     mimicType 0 numberOfPervasiveArgs Seq.empty a iters
                     (fns n ctx _ iters' =>
                         if n = numberOfPervasiveArgs then
                            let
                               val bodies = discrimBody mut iters' ctx
                            in
                               (* Wish we could just use bodies, but we need to turn that last forall into an arrow. *)
                               map2
                                  (fns body (_, _, _, _, _, numberOfIndexArgs) =>
                                      let
                                         val body = compact ctx body
                                         val b = tcompact ctx (X.inhabitedForm body)
                                      in
                                         List.hd $
                                         mimicType 0 numberOfIndexArgs ctx b [body]
                                         (fns _ _ c l =>
                                             let
                                                val dom = X.forallInv1 c
                                             in
                                                [X.lam NONE dom 
                                                    (X.app (X.weaken (List.hd l) 1) (X.var 0 dom))]
                                             end)
                                      end)
                                  bodies typeInfoList
                            end
                         else
                            raise (Fail "unexpected type in makeDiscrims"))
               in
                  map2
                     (fns (dtname, _, _) (discrim as (_, t, _)) =>
                         let
                            val name = Symbol.fromValue (Symbol.toValue dtname ^ "_discrim")
                         in
                            define name discrim (Normalize.normalize t)
                         end)
                     dts discrims
               end

            val discriminators = Vector.fromList discriminatorList

            val discriminatorReductionList =
               map
                  (fn (i, j, name, _, numberOfArgs, _) =>
                      let
                         val (_, _, _, _, _, numberOfIndexArgs) = Vector.sub typeInfo i
                         val (iterConst, constName) = Vector.sub iterInfo i
                         val discrimConst = Vector.sub discriminators i
                         val (conConst, _, _) = Vector.sub conInfo j
                         val iterRed = Vector.sub iterReductions j

                         val r =
                            R.new2
                               discrimConst
                               (numberOfVisibleArgs + numberOfIndexArgs) 0
                               conConst
                               (numberOfVisibleArgs + numberOfArgs)
                               (T.Native (T.Integer (IntInf.fromInt j)))
                               (R.trans [R.unfold, R.betas, R.user2 iterRed, R.betas])
                               R.refl
                      in
                         RR.write
                            (Symbol.fromValue (String.concat [constName, "_discrim_", Symbol.toValue name]))
                            RR.reduction2
                            r;

                         r
                      end)
                  allcons

            val discriminatorReductions = Vector.fromList discriminatorReductionList


            (* The extractors (for 'yes' instances of injection) *)

            val (extractorTypeList, extractorList, extractorTypeReductionList, extractorReductionList) =
               let
                  val (pervl, wrap) =
                     List.foldl
                        (fns (sym, dom) (pervl, wrap) =>
                            let
                               val dom = X.tuse dom
                            in
                               (dom :: pervl,
                                (fn m => wrap (X.lamInt (SOME sym) dom m)))
                            end)
                        ([], (fn m => m))
                        invis
                        
                  val (pervl, wrap) =
                     List.foldl
                        (fns (sym, dom) (pervl, wrap) =>
                            let
                               val dom = X.tuse dom
                            in
                               (dom :: pervl,
                                (fn m => wrap (X.lamAll (SOME sym) dom m)))
                            end)
                        (pervl, wrap)
                        pers
      
                  val ctx = S.mapFromList (fn a => J.Tm (X.typ a)) pervl
      
                  val pervargs =
                     List.rev $
                     List.mapi
                        (fns i a => X.var i a)
                        pervl
      
                  (* the datatypes, inside the pervasive arguments *)
                  val tpsIn =
                     Vector.tabulate mut
                        (fn i => 
                            let
                               val (const, _, _, _, _, _) = Vector.sub typeInfo i
                            in
                               X.apps (X.constant const) pervargs
                            end)
      
                  val univ = X.use univ_mobile
      
                  val (_, _, extractorTypeListRev, extractorListRev, extractorTypeReductionListRev, extractorReductionListRev) =
                     List.foldl
                        (fns (dtname, _, cons) (dtsSoFar, consSoFar, extractorTypeListRev, extractorListRev, extractorTypeReductionListRev, extractorReductionListRev) =>
                            (* accumulator:
                               datatypes processed so far
                               constructor processed so far
                               extractor type constants (reversed)
                               extractor constants (reversed)
                               extractor type reductions (reversed)
                               extractor reductions (reversed)
                            *)
                            (case cons of
                                [] =>
                                   (* If this datatype has no constructors, no need for extractor, so put out a bogus constant. *)
                                   (dtsSoFar + 1, 
                                    consSoFar, 
                                    Prim.bogus :: extractorTypeListRev,
                                    Prim.bogus :: extractorListRev,
                                    extractorTypeReductionListRev,
                                    extractorReductionListRev)
                                   
                              | _ =>
                                   let
                                      val (_, _, _, _, _, numberOfIndexArgs) = Vector.sub typeInfo dtsSoFar
                                      val (iterconst, _) = Vector.sub iterInfo dtsSoFar
                                      val discrimconst = Vector.sub discriminators dtsSoFar

                                      val numberOfConstructorsHere = List.length cons
      
                                      (* numberOfConstructorsHere > 0 *)
             
                                      (* for each constructor:
                                         - the tuple of the constructor's arguments (in the iterator-arm context, containing not
                                           only the arguments, but also the recursive variables provided by the iterator, even
                                           though those recursive variables are ignored)

                                         - and the type of the tuple (pervasive context)

                                         (We have to go back to the original datatype information here.  We can't work from the
                                         iterator's type in this case (as we could with the discriminator) because we need to be
                                         able to show that the extractor's arms' types belong to the right universe.)
                                      *)
                                      val arms =
                                         List.map
                                            (fn (_, args, _) =>
                                                let
                                                   (* the type in the ambient context *)
                                                   val ((numext, numint), t) =
                                                      bifold
                                                         (fns arg (numext, numint) =>
                                                             (case arg of
                                                                 External (binder, u) =>
                                                                    ((numext+1, numint),
                                                                     (fn t =>
                                                                         X.existsUniv (Option.join binder) (X.use u) t))
                   
                                                               | Internal (j, indices) =>
                                                                    ((numext, numint+1),
                                                                     (fn t =>
                                                                         X.prodUniv
                                                                            (X.apps
                                                                                (X.weaken (Vector.sub tpsIn j) numext)
                                                                                (List.map X.use indices))
                                                                            t))))
                                                         (fn (numext, _) => X.unitUniv (X.weaken univ numext))
                                                         (0, 0)
                                                         args
                   
                                                   val tot = numext + 2 * numint
                   
                                                   val (_, elems) =
                                                      bifold
                                                         (* G2 |- s : G1
                                                            where G1 is the context within the constructor (internal args bind 0)
                                                                  G2 is the context within the iterator (internal args bind 2)
                   
                                                            depth = |G2|
                                                         *)
                                                         (fns arg (depth, s) =>
                                                             (case arg of
                                                                 External (_, u) =>
                                                                    ((depth+1, X.underEasy 1 s),
                                                                     (fn elems =>
                                                                         X.var (tot - depth - 1) (X.tsub (X.forget (X.use u)) s) :: elems))
                   
                                                               | Internal (j, indices) =>
                                                                    ((depth+2, X.compose s (X.shift 2)),
                                                                     (fn elems =>
                                                                         X.var 
                                                                            (tot - depth - 1)
                                                                            (X.forget
                                                                                (X.apps
                                                                                    (X.weaken (Vector.sub tpsIn j) depth)
                                                                                    (List.map (fn m => X.sub (X.use m) s) indices)))
                                                                         :: elems))))
                                                         (fn _ => [])
                                                         (0, X.id)
                                                         args
                   
                                                   val t = compact ctx t
                                                in
                                                   (X.tupleEx elems (X.forget (X.weaken t tot)), t)
                                                end)
                                            cons
             
                                      (* Build the extractor's type.

                                         We can't use the iterator to determine the extraction type directly,
                                         because we would be using the iterator at too high a universe.
                                         Instead, use the discriminator to get a number, and then branch on
                                         the number.
                                      *)
      
                                      (* Build a decision tree for number i to j (exclusive)
                                         |l| >= j - i >= 1
                                         depth is the size of the context beyond the pervasives
                                         returns (tree, l') where l' is the rest of l
                                      *)
                                      fun decisionTree depth i j l =
                                         if i + 1 = j then
                                            (case l of
                                                [] =>
                                                   raise (Fail "precondition")
                                
                                              | (_, h) :: t =>
                                                   (X.weaken h depth, t))
                                         else
                                            let
                                               val k = i + (j - i) div 2
                                
                                               val (left, l') = decisionTree depth i k l
                                               val (right, l'') = decisionTree depth k j l'
                                            in
                                               (X.ifthenelse
                                                   (X.apps (X.constant Prim.leqzb)
                                                       [X.var 0 X.integer, X.integerLiteral (IntInf.fromInt (k - 1))])
                                                   left right,
                                                l'')
                                            end
      
                                      fun decisionTreeReduction x i j acc =
                                         if i + 1 = j then
                                            List.rev acc
                                         else
                                            let
                                               val k = i + (j - i) div 2
                                            in
                                               if x < k then
                                                  decisionTreeReduction x i k
                                                     (R.user2 PrimReduction.ite_tru :: R.compat [R.native] :: acc)
                                               else
                                                  decisionTreeReduction x k j
                                                     (R.user2 PrimReduction.ite_fals :: R.compat [R.native] :: acc)
                                            end

                                      val discrimPerv = compact ctx (X.apps (X.constant discrimconst) pervargs)
      
                                      val exttp =
                                         List.hd $
                                         mimicType 0 ~1 ctx (X.tcompact ctx (X.inhabitedForm discrimPerv)) 
                                            [discrimPerv]
                                            (fns n _ _ l =>
                                                let
                                                   val d = List.hd l
         
                                                   val (body, _) =
                                                      decisionTree 
                                                         (n + 1)
                                                         consSoFar
                                                         (consSoFar + numberOfConstructorsHere)
                                                         arms
                                                in
                                                   [X.lett NONE d body]
                                                end)
      
                                      val exttpFull as (_, exttpType, _) = wrap exttp
      
                                      val exttpName = Symbol.fromValue (Symbol.toValue dtname ^ "_Extract")
             
                                      val exttpConst = define exttpName exttpFull exttpType

                                      val exttpReds =
                                         map2i
                                            (fns i (name, args, _) (_, t) =>
                                                let
                                                   val pos = consSoFar + i
                                                   val (conConst, _, _) = Vector.sub conInfo pos
                                                   val numberOfArgs = List.length args

                                                   val pre =
                                                      R.trans
                                                         ([
                                                          R.unfold,
                                                          R.betas,
                                                          R.compat [R.user2 (Vector.sub discriminatorReductions pos)],
                                                          R.user1 PrimReduction.reduce_lett,
                                                          R.beta 1
                                                          ]
                                                          @
                                                          decisionTreeReduction 
                                                             pos consSoFar (consSoFar + numberOfConstructorsHere) [])

                                                   val res = 
                                                      (* t lives in the context with the pervasives only *)
                                                      T.Sub (X.term t, T.Shift (numberOfIndexArgs + numberOfVisibleArgs + numberOfArgs))

                                                   val r =
                                                      R.new2
                                                         exttpConst
                                                         (numberOfVisibleArgs + numberOfIndexArgs) 0
                                                         conConst
                                                         (numberOfVisibleArgs + numberOfArgs)
                                                         res
                                                         pre
                                                         R.refl
                                                in
                                                   r
                                                end)
                                            cons arms

                                      (* build the extractor itself *)
      
                                      val iterPerv = compact ctx (X.apps (X.constant iterconst) pervargs)
      
                                      val ext1 =
                                         natrecl dtsSoFar
                                            (fns _ m =>
                                                X.appWithGoal (compact ctx m)
                                                (fn a =>
                                                    mimicType1 ctx a (fn n => X.weaken (X.unitUniv univ) n)))
                                            iterPerv
             
                                      val ext2 = X.app ext1 (X.apps (X.constant exttpConst) pervargs)
             
                                      val ext3 =
                                         natrecl (mut - dtsSoFar - 1)
                                            (fns _ m =>
                                                X.appWithGoal (compact ctx m)
                                                (fn a =>
                                                    mimicType1 ctx a (fn n => X.weaken (X.unitUniv univ) n)))
                                            ext2
             
                                      val ext4 =
                                         natrecl consSoFar
                                            (fns _ m =>
                                                X.appWithGoal (compact ctx m)
                                                (fn a =>
                                                    mimicType1 ctx a (fn n => X.triv)))
                                            ext3
             
                                      val ext5 =
                                         foldl2
                                            (fns (arm, _) r m =>
                                                X.appWithGoal 
                                                   (compact ctx m)
                                                   (fn a =>
                                                       List.hd $
                                                       mimicType 0 ~1 ctx a []
                                                       (fns _ _ b _ => [X.unreduce b (R.user2 r) arm])))
                                            ext4
                                            arms exttpReds

                                      val ext6 =
                                         natrecl (numberOfConstructors - consSoFar - numberOfConstructorsHere)
                                            (fns _ m =>
                                                X.appWithGoal (compact ctx m)
                                                (fn a =>
                                                    mimicType1 ctx a (fn _ => X.triv)))
                                            ext5
             
                                      val extFull as (_, extType, _) = wrap ext6
             
                                      val extName = Symbol.fromValue (Symbol.toValue dtname ^ "_extract")
             
                                      val extConst = define extName extFull extType

                                      val extReds =
                                         List.mapi
                                            (fns i (name, args, _) =>
                                                let
                                                   val pos = consSoFar + i
                                                   val (conConst, _, _) = Vector.sub conInfo pos
                                                   val numberOfArgs = List.length args
                                                   val iterRed = Vector.sub iterReductions pos

                                                   val pre =
                                                      R.trans [R.unfold, R.betas, R.user2 iterRed, R.betas]

                                                   val arm =
                                                      natrecr numberOfArgs
                                                         (fns j m => T.Pair (T.Var j, m))
                                                         T.Triv

                                                   val r =
                                                      R.new2
                                                         extConst
                                                         (numberOfVisibleArgs + numberOfIndexArgs) 0
                                                         conConst
                                                         (numberOfVisibleArgs + numberOfArgs)
                                                         arm
                                                         pre
                                                         R.refl
                                                in
                                                   r
                                                end)
                                            cons
                                   in
                                      (dtsSoFar + 1,
                                       consSoFar + numberOfConstructorsHere, 
                                       exttpConst :: extractorTypeListRev,
                                       extConst :: extractorListRev,
                                       List.revAppend exttpReds extractorTypeReductionListRev,
                                       List.revAppend extReds extractorReductionListRev)
                                   end))
                        (0, 0, [], [], [], [])
                        dts
               in
                  (List.rev extractorTypeListRev, 
                   List.rev extractorListRev, 
                   List.rev extractorTypeReductionListRev,
                   List.rev extractorReductionListRev)
               end

            val extractorTypes = Vector.fromList extractorTypeList
            val extractors = Vector.fromList extractorList
            val extractorTypeReductions = Vector.fromList extractorTypeReductionList
            val extractorReductions = Vector.fromList extractorReductionList




            (* 11. Populate the tables *)

            val tplist =
               map3
                  (fns (const, red, stripConst, _, args, numberOfIndexArgs) afield (iterator, _) => 
                      TENV {const=const, red=red, args=args, numargs=numberOfIndexArgs, adisj=afield, iterator=iterator, strip=stripConst})
                  typeInfoList indextpsList iterInfoList

            val conlist =
               map3
                  (fns (const, red, _) (i, j, _, args, numargs, indices) iteratorReduction =>
                      CENV {const=const, red=red, tpnum=i, connum=j, args=args, numargs=numargs, indices=indices, iteratorReduction=iteratorReduction})
                  conInfoList allcons iterReductionList

            val env =
               ENV
               {
               invis = invis,
               invisnum = numberOfInvisibleArgs,
               pers = pers,
               persnum = numberOfVisibleArgs,
               univ = univ_mobile,
               a = a_mobile,
               dcons = dcons_mobile,
               tplist = tplist,
               conlist = conlist,
               skeleton = skeletonConst,
               subterm = subtermConst,
               subtermWf = subtermWellFoundedConst,
               discriminators = discriminators,
               extractorTypes = extractorTypes,
               extractors = extractors,
               discriminatorReductions = discriminatorReductions,
               extractorTypeReductions = extractorTypeReductions,
               extractorReductions = extractorReductions,
               totalConstructors = numberOfConstructors,
               }
         in
            populate env;

            CR.assign theDatatypes (env :: CR.deref theDatatypes);



            (* 12. Make all the contants opaque. *)

            close skeletonConst;
            close subtermConst;
            close subtermTransConst;
            close subtermWellFoundedConst;

            List.app 
               (fn (const, _, stripConst, _, _, _) =>
                   (
                   close const;
                   close stripConst
                   )) 
               typeInfoList;

            List.app 
               (fn (const, _, subtermConConst) => 
                   (
                   close const;
                   close subtermConConst
                   ))
               conInfoList;

            List.app (fn (const, _) => close const) iterInfoList;

            Vector.app (fn const => close const) discriminators;
            Vector.app (fn const => close const) extractorTypes;
            Vector.app (fn const => close const) extractors
                   
         end



      fun checkLibrariesLoaded () =
         List.app
            (fn (module, elem) =>
                (case Namespace.resolveOpt (map Symbol.fromValue [module, elem]) of
                    SOME _ => ()
       
                  | NONE =>
                       signalError (module ^ " library not loaded")))
            (* doesn't really matter which element from the module we pick *)
            [
            ("Acc", "Acc"),
            ("Nat", "leq"),
            ("Datatype", "dt"),
            ("Integer", "leqzb")
            ]


      fun typedefRaw typedef = 
         let
            val () = ProverInternal.checkpoint ()

            val () = checkLibrariesLoaded ()
         
            val (goals, f) = reprocess (resolve typedef)

            do vs = ProverInternal.setGoals (List.map (fn (origin, goal) => (Message.fromString origin, goal)) goals)
         in
            makeDatatype (f vs)
         end


      fun typedef typedef = 
         let
            val () = ProverInternal.checkpoint ()

            val () = checkLibrariesLoaded ()

            val (goals, f) = reprocess (resolve typedef)

            val (goals', g) = TypecheckInternal.multigoalTypecheck goals
         in
            (case goals' of
                [] =>
                   makeDatatype (f (g []))

              | _ =>
                   let
                      do vs = ProverInternal.setGoals goals'
                   in
                      makeDatatype (f (g vs))
                   end)
         end


      fun write outf =
         P.pickle 
            outf
            (P.list puEnv)
            (CR.deref theDatatypes)


      fun read inf =
         (case
             P.unpickle inf (P.option puEnv)
          of
             NONE => ()

           | SOME env => 
                (
                populate env;
                read inf
                ))

   end


structure Datatype :> DATATYPE = DatatypeInternal


structure ParseDatatype =
   struct

      fun id x = x
      val none = NONE
      val some = SOME
      val null = []
      fun sing x = [x]
      fun cons x y = x :: y
      fun append x y = x @ y

      fun abindingAnnot xl a = map (fn x => (x, a)) xl

      fun datatypeArgsIntersectForall args args' a = (args, args', a)
      fun datatypeArgsIntersect args a = (args, [], a)
      fun datatypeArgsForall args a = ([], args, a)
      fun datatypeArgsNone m = ([], [], m)

      fun paramForall args rest =
         map (fn (x, a) => (SOME x, a)) args @ rest

      fun paramArrow a rest =
         (NONE, a) :: rest

      fun dcon name a = (name, a)

      fun dt name args dcons = (name, args, dcons)

      fun datatypeDef (invis, args, univ) dts = (invis, args, univ, dts)

   end


(*

An example of the syntax:

typedef
   intersect (i : level) .
   forall (a : U i) .
   U i
of
   tree : nat -> type =
   | Empty : tree 0
   | Node : forall (n : nat) . a -> forest n -> tree (succ n)

   and
   forest : nat -> type =
   | Nil : forest 0
   | Cons : forall (m n : nat) . tree m -> forest n -> forest (m + n)

*)


grammardef Datatype

   open ParseDatatype

   rule ABinding      ::= "(" Idents ":" Term ")" => abindingAnnot

   rule ABindings     ::= => null
   rule ABindings     ::= ABinding ABindings => append

   rule DatatypeArgs  ::= "intersect" ABindings "." "forall" ABindings "." "U" Level(1) => datatypeArgsIntersectForall
   rule DatatypeArgs  ::= "intersect" ABindings "." "U" Level(1) => datatypeArgsIntersect
   rule DatatypeArgs  ::= "forall" ABindings "." "U" Level(1) => datatypeArgsForall
   rule DatatypeArgs  ::= "U" Level(1) => datatypeArgsNone

   rule DtType        ::= "type" => null
   rule DtType        ::= "forall" ABindings "." DtType => paramForall
   rule DtType        ::= Term(1) "->" DtType => paramArrow

   rule Constructor   ::= "|" Ident ":" Term => dcon

   rule Constructors  ::= => null
   rule Constructors  ::= Constructor Constructors => cons

   rule Datatype      ::= Ident ":" DtType "=" Constructors => dt

   rule Datatypes     ::= Datatype => sing
   rule Datatypes     ::= Datatype "and" Datatypes => cons

   rule Datatype      ::= "datatype" DatatypeArgs "of" Datatypes => datatypeDef

end


grammaron Datatype
