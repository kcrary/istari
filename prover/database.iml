
signature DATABASE =
   sig

      type constant = Constant.constant

      (* Every type entry in the database should have the form
         const |-> (J, v) 
         where  J is |- A, v validates J, and A has the form const : B.

         This is not checked, but an entry will not work if it doesn't.
      *)

      val findType : constant -> (Judgement.djudgement * Refine.validation) option
      val enterType : constant -> Judgement.djudgement -> Refine.validation -> unit

      val findArity : constant -> int
      val setArity : constant -> int -> unit

      val findImplicits : constant -> int
      val setImplicits : constant -> int -> unit

      val findUnroll : constant -> Reduction.reduction option
      val setUnroll : constant -> Reduction.reduction -> unit

   end


signature DATABASE_INTERNAL =
   sig

      include DATABASE


      exception Database

      val appLocal : (constant * (Judgement.djudgement * Refine.validation) option * int * int * Reduction.reduction option -> unit) -> unit

      (* doesn't set the dirty bit, so it won't be exported *)
      val import : constant * (Judgement.djudgement * Refine.validation) option * int * int * Reduction.reduction option -> unit

      (* like enterType, but doesn't set the dirty bit *)
      val primType : constant -> Judgement.djudgement -> Refine.validation -> unit

   end


structure DatabaseInternal :> DATABASE_INTERNAL =
   struct

      structure H = ConstantTable
      structure T = Term
      structure J = Judgement

      type constant = Constant.constant


      (* database entry: (type, arity, implicits, unroller, imported?) *)

      (* the value and a dirty bit
         (The dirty bit is not set for primitives and imported entries.)
      *)
      type 'a entry = 'a * bool  

      val theDatabase : ((Judgement.djudgement * Refine.validation) option entry * int entry * int entry * Reduction.reduction option entry) H.table = H.table ()

      fun findType const =
         Option.mapPartial
            (fn ((t, _), _, _, _) => t)
            (H.find theDatabase const)

      fun enterType const j v =
         (
         H.operate theDatabase const
            (fn () => 
                ((SOME (j, v), true), (0, false), (0, false), (NONE, false)))
            (fn (_, arity, implicits, unroll,) => 
                ((SOME (j, v), true), arity, implicits, unroll));
         ()
         )

      fun primType const j v =
         (
         H.operate theDatabase const
            (fn () => 
                ((SOME (j, v), false), (0, false), (0, false), (NONE, false)))
            (fn (_, arity, implicits, unroll) =>
                ((SOME (j, v), false), arity, implicits, unroll));
         ()
         )


      fun findArity const =
         (case H.find theDatabase const of
             SOME (_, (arity, _), _, _) => arity

           | NONE => 0)

      fun setArity const arity =
         (
         H.operate theDatabase const
            (fn () => 
                ((NONE, false), (arity, true), (0, false), (NONE, false)))
            (fn (t, _, implicits, unroll) =>
                (t, (arity, true), implicits, unroll));
         ()
         )

      fun primArity const arity =
         (
         H.operate theDatabase const
            (fn () => 
                ((NONE, false), (arity, false), (0, false), (NONE, false)))
            (fn (t, _, implicits, unroll) =>
                (t, (arity, false), implicits, unroll));
         ()
         )


      fun findImplicits const =
         (case H.find theDatabase const of
             SOME (_, _, (implicits, _), _) => implicits

           | NONE => 0)

      fun setImplicits const implicits =
         (
         H.operate theDatabase const
            (fn () =>
                ((NONE, false), (0, false), (implicits, true), (NONE, false)))
            (fn (t, arity, _, unroll) =>
                (t, arity, (implicits, true), unroll));
         ()
         )


      fun findUnroll const =
         (case H.find theDatabase const of
             SOME (_, _, _, (unroll, _)) => unroll

           | NONE => NONE)

      fun setUnroll const r =
         (
         H.operate theDatabase const
            (fn () => 
                ((NONE, false), (0, false), (0, false), (SOME r, true)))
            (fn (t, arity, implicits, _) =>
                (t, arity, implicits, (SOME r, true)));
         ()
         )

      fun primUnroll const r =
         (
         H.operate theDatabase const
            (fn () =>
                ((NONE, false), (0, false), (0, false), (SOME r, false)))
            (fn (t, arity, implicits, _) =>
                (t, arity, implicits, (SOME r, false)));
         ()
         )


      val () =
         List.app
            (fn (const, arity) => primArity const arity)
            Prim.arities

      val () =
         List.app
            (fn r => primUnroll (ReductionInternal.trigger r) (Reduction.user1 r))
            [
            Prim.unroll_fix,
            Prim.unroll_pause,
            Prim.unroll_wind
            ]


      fun appLocal f =
         H.app
            (fn (const, ((t, td), (arity, arityd), (implicits, implicitsd), (unroll, unrolld))) =>
                if td orelse arityd orelse implicitsd orelse unrolld then
                   f (const,
                      if td then t else NONE,
                      if arityd then arity else 0,
                      if implicitsd then implicits else 0,
                      if unrolld then unroll else NONE)
                else
                   ())
            theDatabase


      exception Database
      exception Merge

      fun mergeOpt opt opt' =
         (case (opt, opt') of
             (NONE, _) => opt'

           | (_, NONE) => opt

           | (SOME _, SOME _) => raise Merge)

      fun mergeInt i i' =
         if i = 0 then
            i'
         else if i' = 0 then
            i
         else if i = i' then
            i
         else
            raise Merge

      fun merge ((t, td), (arity, arityd), (implicits, implicitsd), (unroll, unrolld)) (t', arity', implicits', unroll') =
         (if td then (mergeOpt t t', true) else (t', false),
          if arityd then (mergeInt arity arity', true) else (arity', false),
          if implicitsd then (mergeInt implicits implicits', true) else (implicits', false),
          if unrolld then (mergeOpt unroll unroll', true) else (unroll', false))

      fun import (const, t, arity, implicits, unroll) =
         (
         H.operate theDatabase const
            (fn () => 
                ((t, false), (arity, false), (implicits, false), (unroll, false)))
            (fn entry => 
                (try
                    merge entry (t, arity, implicits, unroll)
                 with
                    Merge =>
                       raise (Message.Error (Database,
                                             String.concat
                                                ["Error: constant ",
                                                 Namespace.toString const,
                                                 " conflicts with an existing database entry.\n"]))));
         ()
         )

   end


structure Database :> DATABASE = DatabaseInternal
