
signature DATABASE =
   sig

      type constant = Constant.constant

      (* Every type entry in the database should have the form
         const |-> (J, v) 
         where  J is |- A, v validates J, and A has the form const : B.

         This is not checked, but an entry will not work if it doesn't.
      *)

      val findType : constant -> (Judgement.judgement * Refine.validation) option
      val enterType : constant -> Judgement.judgement -> Refine.validation -> unit

      val findImplicits : constant -> int
      val setImplicits : constant -> int -> unit

      val findUnroll : constant -> Reduction.reduction option
      val setUnroll : constant -> Reduction.reduction -> unit

   end


signature DATABASE_INTERNAL =
   sig

      include DATABASE


      exception Database of string

      val appLocal : (constant * (Judgement.judgement * Refine.validation) option * int * Reduction.reduction option -> unit) -> unit

      (* doesn't set the dirty bit, so it won't be exported *)
      val import : constant * (Judgement.judgement * Refine.validation) option * int * Reduction.reduction option -> unit

      (* like enterType, but doesn't set the dirty bit *)
      val primType : constant -> Judgement.judgement -> Refine.validation -> unit

   end


structure DatabaseInternal :> DATABASE_INTERNAL =
   struct

      structure H = ConstantTable
      structure T = Term
      structure J = Judgement

      type constant = Constant.constant


      (* database entry: (type, implicits, unroller) *)

      (* the value and a dirty bit
         (The dirty bit is not set for primitives and imported entries.)
      *)
      type 'a entry = 'a * bool  

      val theDatabase : ((Judgement.judgement * Refine.validation) option entry * int entry * Reduction.reduction option entry) H.table = H.table ()

      fun findType const =
         Option.mapPartial
            (fn ((t, _), _, _) => t)
            (H.find theDatabase const)

      fun enterType const j v =
         (
         H.operate theDatabase const
            (fn () => 
                ((SOME (j, v), true), (0, false), (NONE, false)))
            (fn (_, implicits, unroll,) => 
                ((SOME (j, v), true), implicits, unroll));
         ()
         )

      fun primType const j v =
         (
         H.operate theDatabase const
            (fn () => 
                ((SOME (j, v), false), (0, false), (NONE, false)))
            (fn (_, implicits, unroll) =>
                ((SOME (j, v), false), implicits, unroll));
         ()
         )


      fun findImplicits const =
         (case H.find theDatabase const of
             SOME (_, (implicits, _), _) => implicits

           | NONE => 0)

      fun setImplicits const implicits =
         (
         H.operate theDatabase const
            (fn () =>
                ((NONE, false), (implicits, true), (NONE, false)))
            (fn (t, _, unroll) =>
                (t, (implicits, true), unroll));
         ()
         )


      fun findUnroll const =
         (case H.find theDatabase const of
             SOME (_, _, (unroll, _)) => unroll

           | NONE => NONE)

      fun setUnroll const r =
         (
         H.operate theDatabase const
            (fn () => 
                ((NONE, false), (0, false), (SOME r, true)))
            (fn (t, implicits, _) =>
                (t, implicits, (SOME r, true)));
         ()
         )

      fun primUnroll const r =
         (
         H.operate theDatabase const
            (fn () =>
                ((NONE, false), (0, false), (SOME r, false)))
            (fn (t, implicits, _) =>
                (t, implicits, (SOME r, false)));
         ()
         )


      val () =
         List.app
            (fn r => primUnroll (ReductionInternal.trigger r) (Reduction.user1 r))
            [
            Prim.unroll_fix,
            Prim.unroll_pause,
            Prim.unroll_wind
            ]


      fun appLocal f =
         H.app
            (fn (const, ((t, td), (implicits, implicitsd), (unroll, unrolld))) =>
                if td orelse implicitsd orelse unrolld then
                   f (const,
                      if td then t else NONE,
                      if implicitsd then implicits else 0,
                      if unrolld then unroll else NONE)
                else
                   ())
            theDatabase


      exception Database of string

      val () =
         Handler.customHandler
         (fn Database str => (print str; true)
           | _ => false)
      

      exception Merge

      fun mergeOpt opt opt' =
         (case (opt, opt') of
             (NONE, _) => opt'

           | (_, NONE) => opt

           | (SOME _, SOME _) => raise Merge)

      fun mergeInt i i' =
         if i = 0 then
            i'
         else if i' = 0 then
            i
         else if i = i' then
            i
         else
            raise Merge

      fun merge ((t, td), (implicits, implicitsd), (unroll, unrolld)) (t', implicits', unroll') =
         (if td then (mergeOpt t t', true) else (t', false),
          if implicitsd then (mergeInt implicits implicits', true) else (implicits', false),
          if unrolld then (mergeOpt unroll unroll', true) else (unroll', false))

      fun import (const, t, implicits, unroll) =
         (
         H.operate theDatabase const
            (fn () => 
                ((t, false), (implicits, false), (unroll, false)))
            (fn entry => 
                (try
                    merge entry (t, implicits, unroll)
                 with
                    Merge =>
                       raise (Database
                                 (String.concat
                                     ["Error: constant ",
                                      Namespace.toString const,
                                      " conflicts with an existing database entry.\n"]))));
         ()
         )

   end


structure Database :> DATABASE = DatabaseInternal
