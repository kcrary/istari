
(* Pi *)

rule forallForm
forall {x : A} B : type
>>
|- A : type ;
x : A |- B : type ;


rule forallEq
forall {x : A} B = forall {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;


rule forallFormUniv
forall {x : A} B : Ui
>>
|- A : Ui ;
x : A |- B : Ui ;


rule forallEqUniv
forall {x : A} B = forall {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;


rule forallSub
forall {x : A} B <: forall {x : A'} B'
>>
|- A' <: A ;
x : A' |- B <: B' ;
x : A |- B : type ;


rule forallIntroOf
(fn x . M) : forall {x : A} B
>>
|- A : type ;
x : A |- M : B ;


rule forallIntroEq
(fn x . M) = (fn x . N) : forall {x : A} B
>>
|- A : type ;
x : A |- M = N : B ;


rule forallIntro
forall {x : A} B ext (fn x . M)
>>
|- A : type ;
x : A |- B ext M ;


rule forallElimOf
M P : B [P / x]
>>
|- M : forall {x : A} B ;
|- P : A ; 


rule forallElimEq
M P = N Q : B [P / x]
>>
|- M = N : forall {x : A} B ;
|- P = Q : A ;


rule forallElim
B [P / x] ext M P
>>
|- forall {x : A} B ext M ;
|- P : A ;


rule forallEta
M = (fn x . M $x) : forall {x : A} B
>>
|- M : forall {x : A} B ;


rule forallExt
M = N : forall {x : A} B
>>
|- M : forall {x : A} B ;
|- N : forall {x : A} B ;
x : A |- M $x = N $x : B ;


rule forallOfExt
M : forall {x : A} B
>>
|- A : type ;
|- M : forall {x : A'} B' ;
x : A |- M $x : B ;


rule forallFormInv1
A : type
>>
|- forall {x : A} B : type ;


rule forallFormInv2
B [M / x] : type
>>
|- forall {x : A} B : type ;
|- M : A ;



(* Arrow *)

rule arrowForm
arrow A B : type
>>
|- A : type ;
x : A |- B : type ;


rule arrowEq
arrow A B = arrow A' B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;


rule arrowFormUniv
arrow A B : Ui
>>
|- A : Ui ;
x : A |- B : Ui ;


rule arrowEqUniv
arrow A B = arrow A' B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;


rule arrowForallEq
arrow A B = forall {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;


rule arrowForallEqUniv
arrow A B = forall {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;


rule arrowSub
arrow A B <: arrow A' B'
>>
|- A' <: A ;
|- B <: B' ;


rule arrowForallSub
arrow A B <: forall {x : A'} B'
>>
|- A' <: A ;
x : A' |- B <: B' ;
|- B : type ;


rule forallArrowSub
forall {x : A} B <: arrow A' B'
>>
|- A' <: A ;
x : A' |- B <: B' ;
x : A |- B : type ;


rule arrowIntroOf
(fn x . M) : arrow A B
>>
|- A : type ;
x : A |- M : B ;


rule arrowIntroEq
(fn x . M) = (fn x . N) : arrow A B
>>
|- A : type ;
x : A |- M = N : B ;


rule arrowIntro
arrow A B ext (fn x . M)
>>
|- A : type ;
x : A |- B ext M ;


rule arrowElimOf
M P : B
>>
|- M : arrow A B ;
|- P : A ;


rule arrowElimEq
M P = N Q : B
>>
|- M = N : arrow A B ;
|- P = Q : A ;


rule arrowElim
B ext M P
>>
|- arrow A B ext M ;
|- A ext P ;


rule arrowEta
M = (fn x . M $x) : arrow A B
>>
|- M : arrow A B ;


rule arrowExt
M = N : arrow A B
>>
|- M : arrow A B ;
|- N : arrow A B ;
x : A |- M $x = N $x : B ;


rule arrowOfExt
M : arrow A B
>>
|- A : type ;
|- M : forall {x : A'} B' ;
x : A |- M $x : B ;


rule arrowFormInv1
A : type
>>
|- arrow A B : type ;


rule arrowFormInv2
B : type
>>
|- arrow A B : type ;
|- M : A;



(* TArrow *)

rule tarrowKind
tarrow A K : Ki
>>
|- A : Ui ;
|- K : Ki ;


rule tarrowKindEq
tarrow A K = tarrow A' K' : Ki
>>
|- A = A' : Ui ;
|- K = K' : Ki ;


rule tarrowForm
tarrow A B : type
>>
|- A : type ;
|- B : type ;


rule tarrowEq
tarrow A B = tarrow A' B' : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule tarrowFormUniv
tarrow A B : Ui
>>
|- A : Ui ;
|- B : Ui ;


rule tarrowEqUniv
tarrow A B = tarrow A' B' : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule tarrowArrowEq
tarrow A B = arrow A' B' : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule tarrowArrowEqUniv
tarrow A B = arrow A' B' : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule tarrowForallEq
tarrow A B = forall {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;
|- B : type ;


rule tarrowForallEqUniv
tarrow A B = forall {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;
|- B : Ui ;


rule tarrowIntroOf
(fn x . M) : tarrow A B
>>
|- A : type ;
|- B : type ;
x : A |- M : B ;


rule tarrowIntroEq
(fn x . M) = (fn x . N) : tarrow A B
>>
|- A : type ;
|- B : type ;
x : A |- M = N : B ;


rule tarrowIntro
tarrow A B ext (fn x . M)
>>
|- A : type ;
|- B : type ;
x : A |- B ext M ;


rule tarrowElimOf
M P : B
>>
|- M : tarrow A B ;
|- P : A ;


rule tarrowElimEq
M P = N Q : B
>>
|- M = N : tarrow A B ;
|- P = Q : A ;


rule tarrowElim
B ext M P
>>
|- tarrow A B ext M ;
|- A ext P ;


rule tarrowEta
M = (fn x . M $x) : tarrow A B
>>
|- M : tarrow A B ;


rule tarrowExt
M = N : tarrow A B
>>
|- B : type ;
|- M : tarrow A B ;
|- N : tarrow A B ;
x : A |- M $x = N $x : B ;



(* KArrow *)

rule karrowKind
karrow K L : Ki
>>
|- K : Ki ;
|- L : Ki ;


rule karrowKindEq
karrow K L = karrow K' L' : Ki
>>
|- K = K' : Ki ;
|- L = L' : Ki ;


rule karrowForm
karrow A B : type
>>
|- A : type ;
|- B : type ;


rule karrowEq
karrow A B = karrow A' B' : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule karrowFormUniv
karrow A B : Ui
>>
|- A : Ui ;
|- B : Ui ;


rule karrowEqUniv
karrow A B = karrow A' B' : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule karrowArrowEq
karrow A B = arrow A' B' : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule karrowArrowEqUniv
karrow A B = arrow A' B' : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule karrowForallEq
karrow A B = forall {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;
|- B : type ;


rule karrowForallEqUniv
karrow A B = forall {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;
|- B : Ui ;


rule karrowIntroOf
(fn x . M) : karrow A B
>>
|- A : type ;
|- B : type ;
x : A |- M : B ;


rule karrowIntroEq
(fn x . M) = (fn x . N) : karrow A B
>>
|- A : type ;
|- B : type ;
x : A |- M = N : B ;


rule karrowIntro
karrow A B ext (fn x . M)
>>
|- A : type ;
|- B : type ;
x : A |- B ext M ;


rule karrowElimOf
M P : B
>>
|- M : karrow A B ;
|- P : A ;


rule karrowElimEq
M P = N Q : B
>>
|- M = N : karrow A B ;
|- P = Q : A ;


rule karrowElim
B ext M P
>>
|- karrow A B ext M ;
|- A ext P ;


rule karrowEta
M = (fn x . M $x) : karrow A B
>>
|- M : karrow A B ;


rule karrowExt
M = N : karrow A B
>>
|- B : type ;
|- M : karrow A B ;
|- N : karrow A B ;
x : A |- M $x = N $x : B ;



(* Intersect *)

rule intersectForm
intersect {x : A} B : type
>>
|- A : type ;
x : A |- B : type ;


rule intersectEq
intersect {x : A} B = intersect {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;


rule intersectFormUniv
intersect {x : A} B : Ui
>>
|- A : Ui ;
x : A |- B : Ui ;


rule intersectEqUniv
intersect {x : A} B = intersect {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;


rule intersectIntroOf
M : intersect {x : A} B
>>
|- A : type ;
x : A |- M : B ;


rule intersectIntroEq
M = N : intersect {x : A} B
>>
|- A : type ;
x : A |- M = N : B ;


rule intersectIntro
intersect {x : A} B ext M [() / x]
>>
|- A : type ;
x : hide A |- B ext M ;


rule intersectElimOf
M : B [P / x]
>>
|- M : intersect {x : A} B ;
|- P : A ; 


rule intersectElimEq
M = N : B [P / x]
>>
|- M = N : intersect {x : A} B ;
|- P : A ; 


rule intersectElim
B [P / x] ext M
>>
|- intersect {x : A} B ext M ;
|- P : A ;


rule intersectFormInv1
A : type
>>
|- intersect {x : A} B : type ;


rule intersectFormInv2
B [M / x] : type
>>
|- intersect {x : A} B : type ;
|- M : A ;



(* Guard *)

rule guardForm
guard A B : type
>>
|- A : type ;
x : A |- B : type ;


rule guardEq
guard A B = guard A' B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;


rule guardFormUniv
guard A B : Ui
>>
|- A : Ui ;
x : A |- B : Ui ;


rule guardEqUniv
guard A B = guard A' B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;


rule guardIntroOf
M : guard A B
>>
|- A : type ;
x : A |- M : B ;


rule guardIntroEq
M = N : guard A B
>>
|- A : type ;
x : A |- M = N : B ;


rule guardIntro
guard A B ext M [() / x]
>>
|- A : type ;
x : hide A |- B ext M ;


rule guardElimOf
M : B
>>
|- M : guard A B ;
|- A ;


rule guardElimEq
M = N : B
>>
|- M = N : guard A B ;
|- A ;


rule guardElim
B ext M
>>
|- guard A B ext M ;
|- A ;


rule guardSatEq
B = guard A B : type
>>
|- B : type ;
|- A ;



(* Sigma *)

rule existsForm
exists {x : A} B : type
>>
|- A : type ;
x : A |- B : type ;


rule existsEq
exists {x : A} B = exists {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B = B' : type ;


rule existsFormUniv
exists {x : A} B : Ui
>>
|- A : Ui ;
x : A |- B : Ui ;


rule existsEqUniv
exists {x : A} B = exists {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B = B' : Ui ;


rule existsSub
exists {x : A} B <: exists {x : A'} B'
>>
|- A <: A' ;
x : A |- B <: B' ;
x : A' |- B' : type ;


rule existsIntroOf
(M, N) : exists {x : A} B
>>
x : A |- B : type ;
|- M : A ;
|- N : B[M / x] ;


rule existsIntroEq
(M, N) = (M', N') : exists {x : A} B
>>
x : A |- B : type ;
|- M = M' : A ;
|- N = N' : B[M / x] ;


rule existsIntro
exists {x : A} B ext (M, N)
>>
x : A |- B : type ;
|- M : A ;
|- B[M / x] ext N ;


rule existsElim1Of
M #1 : A
>>
|- M : exists {x : A} B ;


rule existsElim1Eq
M #1 = N #1 : A
>>
|- M = N : exists {x : A} B ;


rule existsElim2Of
M #2 : B [M #1 / x]
>>
|- M : exists {x : A} B ;


rule existsElim2Eq
M #2 = N #2 : B [M #1 / x]
>>
|- M = N : exists {x : A} B ;


rule existsEta 
M = (M #1, M #2) : exists {x : A} B
>>
|- M : exists {x : A} B ;


rule existsExt
M = N : exists {x : A} B
>>
|- M : exists {x : A} B ;
|- N : exists {x : A} B ;
|- M #1 = N #1 : A ;
|- M #2 = N #2 : B[M #1 / x] ;


lrule existsLeft
x : (exists {y : A} B) ... |- C ext M[$x #1 / y, $x #2 / z]
>>
y : A, z : B ...[($y, $z) / x] |- C[($y, $z) / x] ext M ;


rule existsFormInv1
A : type
>>
|- exists {x : A} B : type ;


rule existsFormInv2
B [M / x] : type
>>
|- exists {x : A} B : type ;
|- M : A ;


rule existsFormInv2Eq
B [M / x] = B [N / x] : type
>>
|- exists {x : A} B : type ;
|- M = N : A ;



(* Product *)

rule prodKind
prod K L : Ki
>>
|- K : Ki ;
|- L : Ki ;


rule prodKindEq
prod K L = prod K' L' : Ki
>>
|- K = K' : Ki ;
|- L = L' : Ki ;


rule prodForm
prod A B : type
>>
|- A : type ;
|- B : type ;


rule prodEq
prod A B = prod A' B' : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule prodFormUniv
prod A B : Ui
>>
|- A : Ui ;
|- B : Ui ;


rule prodEqUniv
prod A B = prod A' B' : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule prodExistsEq
prod A B = exists {x : A} B : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule prodExistsEqUniv
prod A B = exists {x : A} B : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule prodSub
prod A B <: prod A' B'
>>
|- A <: A' ;
|- B <: B' ;


rule prodExistsSub
prod A B <: exists {x : A'} B'
>>
|- A <: A' ;
x : A |- B <: B' ;
|- B : type ;
x : A' |- B' : type ;


rule existsProdSub
exists {x : A} B <: prod A' B'
>>
|- A <: A' ;
x : A |- B <: B' ;
|- B' : type ;


rule prodIntroOf
(M, N) : prod A B
>>
|- M : A ;
|- N : B ;


rule prodIntroEq
(M, N) = (M', N') : prod A B
>>
|- M = M' : A ;
|- N = N' : B ;


rule prodIntro
prod A B ext (M, N)
>>
|- A ext M ;
|- B ext N ;


rule prodElim1Of
M #1 : A
>>
|- M : prod A B ;


rule prodElim1Eq
M #1 = N #1 : A
>>
|- M = N : prod A B ;


rule prodElim1
A ext M #1
>>
|- prod A B ext M ;


rule prodElim2Of
M #2 : B
>>
|- M : prod A B ;


rule prodElim2Eq
M #2 = N #2 : B
>>
|- M = N : prod A B ;


rule prodElim2
B ext M #2
>>
|- prod A B ext M ;


rule prodEta 
M = (M #1, M #2) : prod A B
>>
|- M : prod A B ;


rule prodExt
M = N : prod A B
>>
|- M : prod A B ;
|- N : prod A B ;
|- M #1 = N #1 : A ;
|- M #2 = N #2 : B ;


lrule prodLeft
x : (prod A B) ... |- C ext M[$x #1 / y, $x #2 / z]
>>
y : A, z : B ...[($y, $z) / x] |- C[($y, $z) / x] ext M ;


rule prodFormInv1
A : type
>>
|- prod A B : type ;


rule prodFormInv2
B : type
>>
|- prod A B : type ;
|- A ;



(* Sum *)

rule sumForm
sum A B : type
>>
|- A : type ;
|- B : type ;


rule sumEq
sum A B = sum A' B' : type
>>
|- A = A' : type ;
|- B = B' : type ;


rule sumFormUniv
sum A B : Ui
>>
|- A : Ui ;
|- B : Ui ;


rule sumEqUniv
sum A B = sum A' B' : Ui
>>
|- A = A' : Ui ;
|- B = B' : Ui ;


rule sumSub
sum A B <: sum A' B'
>>
|- A <: A' ;
|- B <: B' ;


rule sumIntro1Of
inl M : sum A B
>>
|- B : type ;
|- M : A ;


rule sumIntro1Eq
inl M = inl N : sum A B
>>
|- B : type ;
|- M = N : A ;


rule sumIntro1
sum A B ext inl M
>>
|- B : type ;
|- A ext M ;


rule sumIntro2Of
inr M : sum A B
>>
|- A : type ;
|- M : B ;


rule sumIntro2Eq
inr M = inr N : sum A B
>>
|- A : type ;
|- M = N : B ;


rule sumIntro2
sum A B ext inr M
>>
|- A : type ;
|- B ext M ;


rule sumElimOf
sum_case M (fn x . P) (fn x . R) : C [M / y]
>>
|- M : sum A B ;
x : A |- P : C [inl $x / y] ;
x : B |- R : C [inr $x / y] ;


rule sumElimOfNondep
sum_case M (fn x . P) (fn x . R) : C
>>
|- M : sum A B ;
x : A |- P : C ;
x : B |- R : C ;


rule sumElimEq
sum_case M (fn x . P) (fn x . R) = sum_case N (fn x . Q) (fn x . S) : C [M / y]
>>
|- M = N : sum A B ;
x : A |- P = Q : C [inl $x / y] ;
x : B |- R = S : C [inr $x / y] ;


rule sumElim
C [M / y] ext sum_case M (fn x . P) (fn x . R)
>>
|- M : sum A B ;
x : A |- C [inl $x / y] ext P ;
x : B |- C [inr $x / y] ext R ;


rule sumElimNondep
C ext sum_case M (fn x . P) (fn x . R)
>>
|- sum A B ext M ;
x : A |- C ext P ;
x : B |- C ext R ;


rule sumElimIstype
sum_case M (fn x . C) (fn x . E) : type
>>
|- M : sum A B ;
x : A |- C : type ;
x : B |- E : type ;


rule sumElimEqtype
sum_case M (fn x . C) (fn x . E) = sum_case N (fn x . D) (fn x . F) : type
>>
|- M = N : sum A B ;
x : A |- C = D : type ;
x : B |- E = F : type ;


(* Hardcoded
lrule sumLeft
x : (sum A B) ... |- C ext sum_case $x (fn y . M) (fn y . N)
>>
y : A ...[inl $y / x] |- C [inl $y / x] ext M ;
y : B ...[inr $y / x] |- C [inr $y / x] ext N ;
*)


rule sum_caseType
sum_case : 
   intersect {i : level} 
      (intersect {a : (univ $i)}
          (intersect {b : (univ $i)} 
              (intersect {c : (univ $i)} 
                  (arrow (sum $a $b)
                      (arrow (arrow $a $c)
                          (arrow (arrow $b $c) $c))))))
>>


rule sumFormInv1
A : type
>>
|- sum A B : type ;


rule sumFormInv2
B : type
>>
|- sum A B : type ;



(* Future *)

rule futureKind
future K : Ki
>>
|- I : level ;
promote |- K : Ki ;


rule futureKindEq
future K = future L : Ki
>>
|- I : level ;
promote |- K = L : Ki ;


rule futureForm
future A : type
>>
promote |- A : type ;


rule futureEq
future A = future B : type
>>
promote |- A = B : type ;


rule futureFormUniv
future A : Ui
>>
|- I : level ;
promote |- A : Ui ;


rule futureEqUniv
future A = future B : Ui
>>
|- I : level ;
promote |- A = B : Ui ;


rule futureSub
future A <: future B
>>
promote |- A <: B ;


rule futureIntroOf
next M : future A
>>
promote |- M : A ;


rule futureIntroEq
next M = next N : future A
>>
promote |- M = N : A ;


rule futureIntro
future A ext next M
>>
promote |- A ext M ;


rule futureElimOf
P [M #prev / x] : B [M #prev / x]
>>
promote |- A : type ;
|- M : future A ;
x : demote A |- P : B ;


rule futureElimOfLetnext
letnext M (fn x . P) : B [M #prev / x]
>>
promote |- A : type ;
|- M : future A ;
x : demote A |- P : B ;


rule futureElimOfLetnextNondep
letnext M (fn x . P) : B
>>
promote |- A : type ;
|- M : future A ;
x : demote A |- P : B ;


rule futureElimEq
P [M #prev / x] = Q [N #prev / x] : B [M #prev / x]
>>
promote |- A : type ;
|- M = N : future A ;
x : demote A |- P = Q : B ;


rule futureElimIstype
B [M #prev / x] : type
>>
promote |- A : type ;
|- M : future A ;
x : demote A |- B : type ;


rule futureElimIstypeLetnext
letnext M (fn x . B) : type
>>
promote |- A : type ;
|- M : future A ;
x : demote A |- B : type ;


rule futureElimEqtype
B [M #prev / x] = C [N #prev / x] : type
>>
promote |- A : type ;
|- M = N : future A ;
x : demote A |- B = C : type ;


rule futureEta
M = next (M #prev) : future A
>>
|- M : future A ;


rule futureExt
M = N : future A
>>
|- M : future A ;
|- N : future A ;
promote |- M #prev = N #prev : A ;


lrule futureLeft
x : (future A) ... |- B ext M [$x #prev / y]
>>
promote |- A : type ;
y : demote A ...[next $y / x] |- B[next $y / x] ext M ;



(* Recursive types *)

rule recKind
rec (fn x . K) : Ki
>>
|- I : level ;
x : demote Ki |- K : Ki ;


rule recKindEq
rec (fn x . K) = rec (fn x . L) : Ki
>>
|- I : level ;
x : demote Ki |- K = L : Ki ;


rule recForm
rec (fn x . A) : type
>>
x : demote type |- A : type ;


rule recEq
rec (fn x . A) = rec (fn x . B) : type
>>
x : demote type |- A = B : type ;


rule recFormUniv
rec (fn x . A) : Ui
>>
|- I : level ;
x : demote Ui |- A : Ui ;


rule recEqUniv
rec (fn x . A) = rec (fn x . B) : Ui
>>
|- I : level ;
x : demote Ui |- A = B : Ui ;


rule recUnroll
rec (fn x . A) = A [rec (fn x . A) / x] : type
>>
x : demote type |- A : type ;


rule recUnrollUniv
rec (fn x . A) = A [rec (fn x . A) / x] : Ui
>>
|- I : level ;
x : demote Ui |- A : Ui ;


rule recBisimilar
B = rec (fn x . A) : type
>>
x : demote type |- A : type ;
|- B = A[B / x] : type ;



(* Inductive types *)

rule muForm
mu (fn t . A) : type
>>
t : type |- A : type ;
|- positive (fn t . A) ;


rule muEq
mu (fn t . A) = mu (fn t . B) : type
>>
t : type |- A = B : type ;
|- positive (fn t . A) ;
|- positive (fn t . B) ;


rule muFormUniv
mu (fn t . A) : Ui
>>
|- I : level ;
t : Ui |- A : Ui ;
|- positive (fn t . A) ;


rule muEqUniv
mu (fn t . A) = mu (fn t . B) : Ui
>>
|- I : level ;
t : Ui |- A = B : Ui ;
|- positive (fn t . A) ;
|- positive (fn t . B) ;


rule muUnroll
eeqtp (mu (fn t . A)) (A [mu (fn t . A) / t]) ext ((), ())
>>
t : type |- A : type ;
|- positive (fn t . A) ;


rule muUnrollUniv
eeqtp (mu (fn t . A)) (A [mu (fn t . A) / t]) ext ((), ())
>>
|- I : level ;
t : Ui |- A : Ui ;
|- positive (fn t . A) ;


rule muInd
B [M / w] ext (fix (fn z x . N [() / y , () / t']) M)
>>
t : type |- A : type ;
|- positive (fn t . A) ;

t' : hide type,
x : A [$t' / t],
y : ($t' <: mu (fn t'' . A [$t'' / t])),
z : (forall { w : $t' } B)
|- B [$x / w] ext N ;

|- M : mu (fn t . A) ;


rule muIndUniv
B [M / w] ext (fix (fn z x . N [() / y , () / t'] #1) M)
>>
|- I : level ;
t : Ui |- A : Ui ;
|- positive (fn t . A) ;
t' : hide Ui,
x : A [$t' / t],
y : ($t' <: mu (fn t'' . A [$t'' / t])),
z : (forall { w : $t' } B)
|- prod (B [$x / w]) (B [$x / w] : Ui) ext N ;
|- M : mu (fn t . A) ;



(* Void *)

rule voidForm
void : type
>>


rule voidEq
void = void : type
>>


rule voidFormUniv
void : Ui
>>
|- I : level ;


rule voidEqUniv
void = void : Ui
>>
|- I : level ;


rule voidElim
A
>>
|- void ;


rule voidSub
void <: A
>>
|- A : type ;


rule abortType
abort : intersect {i : level} (intersect {a : (univ $i)} (arrow void $a))
>>



(* Unit *)

rule unitKind
unit : Ki
>> 
|- I : level ;


rule unitKindEq
unit = unit : Ki
>> 
|- I : level ;


rule unitForm
unit : type
>>


rule unitEq
unit = unit : type
>>


rule unitFormUniv
unit : Ui
>> 
|- I : level ;


rule unitEqUniv
unit = unit : Ui
>> 
|- I : level ;


rule unitIntroOf
() : unit
>>


rule unitIntro
unit ext ()
>>


rule unitExt
M = N : unit
>>
|- M : unit ;
|- N : unit ;


lrule unitLeft
x : unit ... |- B ext M
>>
...[() / x] |- B [() / x] ext M ;



(* Bool *)

rule boolForm
bool : type
>>


rule boolEq
bool = bool : type
>>


rule boolFormUniv
bool : Ui
>>
|- I : level ;


rule boolEqUniv
bool = bool : Ui
>>
|- I : level ;


rule boolIntro1Of
true : bool
>>


rule boolIntro2Of
false : bool
>>


rule boolElimOf
ite M P R : A [M / x]
>>
|- M : bool ;
|- P : A [true / x] ;
|- R : A [false / x] ;


rule boolElimEq
ite M P R = ite N Q S : A [M / x]
>>
|- M = N : bool ;
|- P = Q : A [true / x] ;
|- R = S : A [false / x] ;


rule boolElim
A [M / x] ext ite M P R
>>
|- M : bool ;
|- A [true / x] ext P ;
|- A [false / x] ext R ;


rule boolElimIstype
ite M A C : type
>>
|- M : bool ;
|- A : type ;
|- C : type ;


rule boolElimEqtype
ite M A C = ite N B D : type
>>
|- M = N : bool ;
|- A = B : type ;
|- C = D : type ;


lrule boolLeft
x : bool ... |- A ext ite $x M N
>>
...[true / x] |- A[true / x] ext M ;
...[false / x] |- A[false / x] ext N ;


rule iteType
ite : intersect {i : level} (intersect {a : (univ $i)} (arrow bool (arrow $a (arrow $a $a))))
>>



(* Nat *)

rule natForm
nat : type
>>


rule natEq
nat = nat : type
>>


rule natFormUniv
nat : Ui
>>
|- I : level ;


rule natEqUniv
nat = nat : Ui
>>
|- I : level ;


rule natElimEq
nat_case M P (fn x . R) = nat_case N Q (fn x . S) : A [M / y]
>>
|- M = N : nat ;
|- P = Q : A [zero / y] ;
x : nat |- R = S : A [succ $x / y] ;


rule natElimEqtype
nat_case M A (fn x . C) = nat_case N B (fn x . D) : type
>>
|- M = N : nat ;
|- A = B : type ;
x : nat |- C = D : type ;


rule zeroType
zero : nat
>>


rule succType
succ : arrow nat nat
>>



(* Universes *)

rule univKind
univ J : Ki
>>
|- J = I : level ;


rule univKindEq
univ J  = univ K : Ki
>>
|- J = K : level ;
|- J = I : level ;


rule univForm
Ui : type
>>
|- I : level ;


rule univEq
univ I = univ J : type
>>
|- I = J : level ;


rule univFormUniv
univ J : Ui
>>
|- lleq (lsucc J) I ;


rule univFormUnivSucc
univ I : univ (lsucc I)
>>
|- I : level ;


rule univEqUniv
univ J = univ K : Ui
>>
|- J = K : level ;
|- lleq (lsucc J) I ;


rule univCumulativeOf
A : univ J
>>
|- A : univ I ;
|- lleq I J ;


rule univCumulativeEq
A = B : univ J
>>
|- A = B : univ I ;
|- lleq I J ;


rule univCumulativeSuccOf
A : univ (lsucc I)
>>
|- A : univ I ;


rule univSub
univ I <: univ J
>>
|- lleq I J ;


rule univForgetOf
A : type
>>
|- A : Ui ;


rule univForgetEq
A = B : type
>>
|- A = B : Ui ;


rule univIntroEqtype
A = B : Ui
>>
|- A = B : type ;
|- A : Ui ;
|- B : Ui ;


rule univFormInv
I : level
>>
|- Ui : type ;



(* Kind universes *)

rule kindForm
Ki : type
>>
|- I : level ;


rule kindEq
kind I = kind J : type
>>
|- I = J : level ;


rule kindFormUniv
Ki : univ K
>>
|- lleq (lsucc (lsucc I)) K ;


rule kindEqUniv
kind I = kind J : univ K
>>
|- I = J : level ;
|- lleq (lsucc (lsucc I)) K ;


rule kindForgetOf
A : univ (lsucc I)
>>
|- A : Ki ;


rule kindForgetEq
A = B : univ (lsucc I)
>>
|- A = B : Ki ;


rule kindUnivSub
kind I <: univ J
>>
|- lleq (lsucc I) J ;



(* Levels *)

rule levelForm
level : type
>>


rule levelEq
level = level : type
>>


rule levelFormUniv
level : Ui
>>
|- I : level ;


rule levelEqUniv
level = level : Ui
>>
|- I : level ;


rule lleqForm
lleq I J : type
>>
|- I : level ;
|- J : level ;


rule lleqEq
lleq I J = lleq I' J' : type
>>
|- I = I' : level ;
|- J = J' : level ;


rule lleqFormUniv
lleq I J : univ K
>>
|- I : level ;
|- J : level ;
|- K : level ;


rule lleqEqUniv
lleq I J = lleq I' J' : univ K
>>
|- I = I' : level ;
|- J = J' : level ;
|- K : level ;


rule lzeroLevel
lzero : level
>>


rule lsuccLevel
lsucc M : level
>>
|- M : level ;


rule lsuccEq
lsucc M = lsucc N : level
>>
|- M = N : level ;


rule lmaxLevel
lmax M N : level
>>
|- M : level ;
|- N : level ;


rule lmaxEq
lmax M N = lmax M' N' : level
>>
|- M = M' : level ;
|- N = N' : level ;


rule lleqRefl
lleq M M
>>
|- M : level ;


rule lleqTrans
lleq M P
>>
|- lleq M N ;
|- lleq N P ;


rule lleqZero
lleq lzero M
>>
|- M : level;


rule lleqSucc
lleq (lsucc M) (lsucc N)
>>
|- lleq M N ;


rule lleqIncrease
lleq M (lsucc N)
>>
|- lleq M N ;


rule lleqMaxL
lleq (lmax M N) P
>>
|- lleq M P ;
|- lleq N P ;


rule lleqMaxR1
lleq M (lmax N P)
>>
|- lleq M N ;
|- P : level ;


rule lleqMaxR2
lleq M (lmax N P)
>>
|- lleq M P ;
|- N : level ;


rule lleqResp
lleq M N
>>
|- M' = M : level ;
|- N' = N : level ;
|- lleq M' N' ;


rule lsuccMaxDistTrans
M = lsucc (lmax N P) : level
>>
|- M = lmax (lsucc N) (lsucc P) : level ;


rule lzeroType
lzero : level
>>


rule lsuccType
lsucc : arrow level level
>>


rule lmaxType
lmax : arrow level (arrow level level)
>>



(* Equality *)

rule eqForm
(M = P : A) : type
>>
|- M : A ;
|- P : A ;


rule eqEq
(M = P : A) = (N = Q : B) : type
>>
|- A = B : type ;
|- M = N : A ;
|- P = Q : A ;


rule eqFormUniv
(M = P : A) : Ui
>>
|- A : Ui ;
|- M : A ;
|- P : A ;


rule eqEqUniv
(M = P : A) = (N = Q : B) : Ui
>>
|- A = B : Ui ;
|- M = N : A ;
|- P = Q : A ;


rule eqIntro
() : (M = N : A)
>>
|- M = N : A ;


rule eqElim
M = N : A
>>
|- P : (M = N : A) ;


rule eqExt
P = Q : (M = N : A)
>>
|- P : (M = N : A) ;
|- Q : (M = N : A) ;


lrule eqLeft
x : (P = Q : A) ... |- B ext M
>>
...[() / x] |- B [() / x] ext M ;


rule eqRefl
M = M : A
>>
|- M : A ;


rule eqSymm
M = N : A
>>
|- N = M : A ;


rule eqTrans
M = P : A
>>
|- M = N : A ;
|- N = P : A ;


rule eqFormInv1
A : type
>>
|- (M = N : A) : type ;


rule eqFormInv2
M : A
>>
|- (M = N : A) : type ;


rule eqFormInv3
N : A
>>
|- (M = N : A) : type ;



(* Of *)

rule ofForm
(M : A) : type
>>
|- M : A ;


rule ofEq
(M : A) = (N : B) : type
>>
|- A = B : type ;
|- M = N : A ;


rule ofFormUniv
(M : A) : Ui
>>
|- A : Ui ;
|- M : A ;


rule ofEqUniv
(M : A) = (N : B) : Ui
>>
|- A = B : Ui ;
|- M = N : A ;


rule ofIntro
() : (M : A)
>>
|- M : A ;


rule ofElim
M : A
>>
|- P : (M : A) ;


rule ofTrivialize
M : A ext ()
>>
|- M : A ;


rule ofExt
P = Q : (M : A)
>>
|- P : (M : A) ;
|- Q : (M : A) ;


lrule ofLeft
x : (P : A) ... |- B ext M
>>
...[() / x] |- B [() / x] ext M ;


rule ofEquand1
M : A
>>
|- M = N : A ;


rule ofEquand2
N : A
>>
|- M = N : A ;



(* Type equality *)

rule eqtpForm
(A = B : type) : type
>>
|- A : type ;
|- B : type ;


rule eqtpEq
(A = C : type) = (B = D : type) : type
>>
|- A = B : type ;
|- C = D : type ;


rule eqtpFormUniv
(A = B : type) : Ui
>>
|- A : Ui ;
|- B : Ui ;


rule eqtpEqUniv
(A = C : type) = (B = D : type) : Ui
>>
|- A = B : Ui ;
|- C = D : Ui ;


rule eqtpIntro
() : (A = B : type)
>>
|- A = B : type ;


rule eqtpElim
A = B : type
>>
|- P : (A = B : type) ;


rule eqtpExt
P = Q : (A = B : type)
>>
|- P : (A = B : type) ;
|- Q : (A = B : type) ;


lrule eqtpLeft
x : (A = B : type) ... |- C ext M
>>
...[() / x] |- C [() / x] ext M ;


rule eqtpFunct
B[M / x] = B[N / x] : type
>>
x : A |- B : type ;
|- M = N : A ;


rule equivalenceOf
M : B
>>
|- A = B : type ;
|- M : A ;


rule equivalenceEq
M = N : B
>>
|- A = B : type ;
|- M = N : A ;


rule equivalence
B ext M
>>
|- A = B : type ;
|- A ext M ;


lrule equivalenceLeft
x : A ... |- C ext M
>>
y : (A : type) |- A = B : type ;
x : B ... |- C ext M ;


rule eqtpRefl
A = A : type
>>
|- A : type ;


rule eqtpSymm
A = B : type
>>
|- B = A : type ;


rule eqtpTrans
A = C : type
>>
|- A = B : type ;
|- B = C : type ;



(* Type formation *)

rule istpForm
(A : type) : type
>>
|- A : type ;


rule istpEq
(A : type) = (B : type) : type
>>
|- A = B : type ;


rule istpFormUniv
(A : type) : Ui
>>
|- A : Ui ;


rule istpEqUniv
(A : type) = (B : type) : Ui
>>
|- A = B : Ui ;


rule istpIntro
() : (A : type)
>>
|- A : type ;


rule istpElim
A : type
>>
|- P : (A : type) ;


rule istpExt
P = Q : (A : type)
>>
|- P : (A : type) ;
|- Q : (A : type) ;


lrule istpLeft
x : (A : type) ... |- B ext M
>>
...[() / x] |- B [() / x] ext M ;


rule inhabitedForm
A : type
>>
|- A ;



(* Subtyping *)

rule subtypeForm
(A <: B) : type
>>
|- A : type ;
|- B : type ;


rule subtypeEq
(A <: C) = (B <: D) : type
>>
|- A = B : type ;
|- C = D : type ;


rule subtypeFormUniv
(A <: B) : Ui
>>
|- A : Ui ;
|- B : Ui ;


rule subtypeEqUniv
(A <: C) = (B <: D) : Ui
>>
|- A = B : Ui ;
|- C = D : Ui ;


rule subtypeIntro
A <: B
>>
|- A : type ;
|- B : type ;
x : A |- $x : B ;


rule subtypeExt
P = Q : (A <: B)
>>
|- P : (A <: B) ;
|- Q : (A <: B) ;


lrule subtypeLeft
x : (A <: B) ... |- C ext M
>>
...[() / x] |- C [() / x] ext M ;


rule subsumptionOf
M : B
>>
|- A <: B ;
|- M : A ;


rule subsumptionEq
M = N : B
>>
|- A <: B ;
|- M = N : A ;


rule subsumption
B ext M
>>
|- A <: B ;
|- A ext M ;


lrule subsumptionLeft
x : A ... |- C ext M
>>
y : (A : type) |- eeqtp A B ;
x : B ... |- C ext M ;


rule subtypeRefl
A <: A
>>
|- A : type ;


rule subtypeReflEqtype
A <: B
>>
|- A = B : type ;


rule subtypeTrans
A <: C
>>
|- A <: B ;
|- B <: C ;


rule subtypeIstp1
A : type
>>
|- A <: B ;


rule subtypeIstp2
B : type
>>
|- A <: B ;



(* Subsets *)

rule setForm
set {x : A} B : type
>>
|- A : type ;
x : A |- B : type ;


rule setEq
set {x : A} B = set {x : A'} B' : type
>>
|- A = A' : type ;
x : A |- B : type ;
x : A |- B' : type ;
x : A, y : B |- B' ;
x : A, y : B' |- B ;


rule setFormUniv
set {x : A} B : Ui
>>
|- A : Ui ;
x : A |- B : Ui ;


rule setEqUniv
set {x : A} B = set {x : A'} B' : Ui
>>
|- A = A' : Ui ;
x : A |- B : Ui ;
x : A |- B' : Ui ;
x : A, y : B |- B' ;
x : A, y : B' |- B ;


rule setWeakenOf
M : A
>>
|- M : set {x : A} B ;


rule setWeakenEq
M = N : A
>>
|- M = N : set {x : A} B ;


rule setWeaken
A ext M
>>
|- set {x : A} B ext M ;


rule setIntroOf
M : set {x : A} B
>>
x : A |- B : type ;
|- M : A ;
|- B [M/x] ;


rule setIntroEq
M = N : set {x : A} B
>>
x : A |- B : type ;
|- M = N : A ;
|- B [M/x] ;


rule setIntro
set {x : A} B ext M
>>
x : A |- B : type ;
|- M : A ;
|- B [M/x] ;


rule setIntroOfSquash
M : set {x : A} B
>>
x : A |- B : type ;
|- M : A ;
|- squash (B [M/x]) ;


rule squashIntroOfSquash
() : squash A
>>
|- A : type ;
|- squash A ;


rule setElim
C ext N [() / y]
>>
x : A |- B : type ;
|- M : set {x : A} B ;
y : hide (B [M / x]) |- C ext N  ;


lrule setLeft
x : (set {x : A} B) ... |- C ext M [() / y]
>>
x : A |- B : type ;
x : A, y : hide B ... |- C ext M ;


rule setSquash
set {x : A} B = set {x : A} (squash B) : type
>>
|- set {x : A} B : type ;


rule setFormInv
A : type
>>
|- set {x : A} B : type ;


rule setSubElim
set {x : A} B <: A'
>>
|- A <: A' ;
x : A |- B : type ;



(* Squash *)

rule squashForm
squash A : type
>>
|- A : type ;


rule squashEq
squash A = squash B : type
>>
|- A : type ;
|- B : type ;
x : A |- B ;
x : B |- A ;


rule squashFormUniv
squash A : Ui
>>
|- A : Ui ;


rule squashEqUniv
squash A = squash B : Ui
>>
|- A : Ui ;
|- B : Ui ;
x : A |- B ;
x : B |- A ;


rule squashIntroOf
() : squash A
>>
|- A ;


rule squashIntro
squash A
>>
|- A ;


rule squashElim
C ext N [() / x]
>>
|- M : squash A ;
|- A : type ;
x : hide A |- C ext N ;


rule squashExt
M = N : squash A
>>
|- M : squash A ;
|- N : squash A ;
|- A : type ;


lrule squashLeft
x : (squash A) ... |- C ext M [() / y]
>>
|- A : type ;
y : hide A ...[() / x] |- C [() / x] ext M ;



(* Quotients *)

rule quotientForm
quotient A (fn x y . B) : type
>>
|- A : type ;
x : A, y : A |- B : type ;
x' : A, y' : A, w : B [$x' / x, $y' / y] |- B [$y' / x, $x' / y] ;
x' : A, y' : A, z' : A, w : B [$x' / x, $y' / y], w' : B [$y' / x, $z' / y] |- B [$x' / x, $z' / y] ;


rule quotientEq
quotient A (fn x y . B) = quotient A' (fn x y . B') : type
>>
|- A = A' : type ;
x : A, y : A |- B : type ;
x : A, y : A |- B' : type ;
x : A, y : A, w : B |- B' ;
x : A, y : A, w : B' |- B ;
x' : A, y' : A, w : B [$x' / x, $y' / y] |- B [$y' / x, $x' / y] ;
x' : A, y' : A, z' : A, w : B [$x' / x, $y' / y], w' : B [$y' / x, $z' / y] |- B [$x' / x, $z' / y] ;


rule quotientFormUniv
quotient A (fn x y . B) : Ui
>>
|- A : Ui ;
x : A, y : A |- B : Ui ;
x' : A, y' : A, w : B [$x' / x, $y' / y] |- B [$y' / x, $x' / y] ;
x' : A, y' : A, z' : A, w : B [$x' / x, $y' / y], w' : B [$y' / x, $z' / y] |- B [$x' / x, $z' / y] ;


rule quotientEqUniv
quotient A (fn x y . B) = quotient A' (fn x y . B') : Ui
>>
|- A = A' : Ui ;
x : A, y : A |- B : Ui ;
x : A, y : A |- B' : Ui ;
x : A, y : A, w : B |- B' ;
x : A, y : A, w : B' |- B ;
x' : A, y' : A, w : B [$x' / x, $y' / y] |- B [$y' / x, $x' / y] ;
x' : A, y' : A, z' : A, w : B [$x' / x, $y' / y], w' : B [$y' / x, $z' / y] |- B [$x' / x, $z' / y] ;


rule quotientIntroOf
M : quotient A (fn x y . B)
>>
|- quotient A (fn x y . B) : type ;
|- M : A ;
|- B [M / x, M / y] ;


rule quotientIntroEq
M = N : quotient A (fn x y . B)
>>
|- quotient A (fn x y . B) : type ;
|- M : A ;
|- N : A ;
|- B [M / x, N / y] ;


rule quotientElimOf
P [M / z] : C [M / z]
>>
|- M : quotient A (fn x y . B) ;
x : A, y : A |- B : type ;
z : (quotient A (fn x y . B)) |- C : type ;
x : A, y : A, w : B |- P [$x / z] = P [$y / z] : C [$x / z];


rule quotientElimEq
P [M / z] = Q [N / z] : C [M / z]
>>
|- M = N : quotient A (fn x y . B) ;
x : A, y : A |- B : type ;
z : (quotient A (fn x y . B)) |- C : type ;
x : A, y : A, w : B |- P [$x / z] = Q [$y / z] : C [$x / z];


rule quotientElimIstype
C [M / z] : type
>>
|- M : quotient A (fn x y . B) ;
x : A, y : A |- B : type ;
x : A, y : A, w : B |- C [$x / z] = C [$y / z] : type ;


rule quotientElimEqtype
C [M / z] = D [N / z]: type
>>
|- M = N : quotient A (fn x y . B) ;
x : A, y : A |- B : type ;
x : A, y : A, w : B |- C [$x / z] = D [$y / z] : type ;


rule quotientDescent
C ext P [() / z]
>>
x : A, y : A |- B : type ;
|- C : type ;
|- M : A ;
|- N : A ;
|- M = N : quotient A (fn x y . B) ;
z : hide B [M / x, N / y] |- C ext P ;


lrule quotientLeft
z : (quotient A (fn x y . B)) ... |- C ext M [() / z']
>>
z : (quotient A (fn x y . B)) ... |- C : type ;
z' : hide A ...[$z' / z] |- C [$z' / z] ext M ;


lrule quotientLeftRefl
z : (quotient A (fn x y . B)) ... |- C ext M [() / v, () / w]
>>
x : A, y : A |- B : type ;
z : (quotient A (fn x y . B)) ... |- C : type ;
(* need v and w in alphabetical order because the rule generator isn't very smart *)
v : hide A, w : hide B [$v /x, $v / y] ...[$v / z] |- C [$v / z] ext M ;


lrule quotientLeftIstype
z : (quotient A (fn x y . B)) ... |- C : type
>>
x : A, y : A |- B : type ;
x : A, y : A, w : B ...[$x / z] |- C[$x / z] = C[$y / z] : type ;


lrule quotientLeftEqtype
z : (quotient A (fn x y . B)) ... |- C = D : type
>>
x : A, y : A |- B : type ;
x : A, y : A, w : B ...[$x / z] |- C[$x / z] = D[$y / z] : type ;


lrule quotientLeftOf
z : (quotient A (fn x y . B)) ... |- M : C
>>
x : A, y : A |- B : type ;
x : A, y : A, w : B ...[$x / z] |- M[$x / z] = M[$y / z] : C ;


lrule quotientLeftEq
z : (quotient A (fn x y . B)) ... |- M = N : C
>>
x : A, y : A |- B : type ;
x : A, y : A, w : B ...[$x / z] |- M[$x / z] = N[$y / z] : C ;


lrule quotientLeftOfDep
z : (quotient A (fn x y . B)) ... |- M : C
>>
x : A, y : A |- B : type ;
x : A, y : A, w : B ...[$x / z] |- C[$x / z] = C[$y / z] : type ;
x : A, y : A, w : B ...[$x / z] |- M[$x / z] = M[$y / z] : C[$x / z] ;


lrule quotientLeftEqDep
z : (quotient A (fn x y . B)) ... |- M = N : C
>>
x : A, y : A |- B : type ;
x : A, y : A, w : B ...[$x / z] |- C[$x / z] = C[$y / z] : type ;
x : A, y : A, w : B ...[$x / z] |- M[$x / z] = N[$y / z] : C[$x / z] ;


rule quotientFormInv
A : type
>>
|- quotient A (fn x y . B) : type ;



(* Impredicative universal *)

rule iforallForm
iforall I K (fn x . A) : type
>>
|- K : Ki ;
x : K |- A : type ;


rule iforallEq
iforall I K (fn x . A) = iforall I L (fn x . B) : type
>>
|- K = L : Ki ;
x : K |- A = B : type ;


rule iforallFormUniv
iforall I K (fn x . A) : univ J
>>
|- K : Ki ;
|- lleq I J ;
x : K |- A : univ J ;


rule iforallEqUniv
iforall I K (fn x . A) = iforall I L (fn x . B) : univ J
>>
|- K = L : Ki ;
|- lleq I J ;
x : K |- A = B : univ J ;


rule iforallIntroOf
M : iforall I K (fn x . A)
>>
|- K : Ki ;
x : K |- M : A ;


rule iforallIntroEq
M = N : iforall I K (fn x . A)
>>
|- K : Ki ;
x : K |- M = N : A ;


rule iforallIntro
iforall I K (fn x . A) ext M [() / x]
>>
|- K : Ki ;
x : hide K |- A ext M ;


rule iforallElimOf
M : A [P / x]
>>
x : K |- A : type ;
|- M : iforall I K (fn x . A) ;
|- P : K ;


rule iforallElimEq
M = N : A [P / x]
>>
x : K |- A : type ;
|- M = N : iforall I K (fn x . A) ;
|- P : K ;


rule iforallElim
A [P / x] ext M
>>
x : K |- A : type ;
|- iforall I K (fn x . A) ext M ;
|- P : K ;



(* Impredicative polymorphism *)

rule foralltpForm
foralltp (fn t . A) : type
>>
t : type |- A : type ;


rule foralltpEq
foralltp (fn t . A) = foralltp (fn t . B) : type
>>
t : type |- A = B : type ;


rule foralltpIntroOf
M : foralltp (fn t . A)
>>
t : type |- M : A ;


rule foralltpIntroEq
M = N : foralltp (fn t . A)
>>
t : type |- M = N : A ;


rule foralltpIntro
foralltp (fn t . A) ext M [() / t]
>>
t : hide type |- A ext M ;


rule foralltpElimOf
M : A [B / t]
>>
t : type |- A : type ;
|- M : foralltp (fn t . A) ;
|- B : type ;


rule foralltpElimEq
M = N : A [B / t]
>>
t : type |- A : type ;
|- M = N : foralltp (fn t . A) ;
|- B : type ;


rule foralltpElim
A [B / t] ext M
>>
t : type |- A : type ;
|- foralltp (fn t . A) ext M ;
|- B : type ;



(* Impredicative existential *)

rule iexistsForm
iexists I K (fn x . A) : type
>>
|- K : Ki ;
x : K |- A : type ;


rule iexistsEq
iexists I K (fn x . A) = iexists I L (fn x . B) : type
>>
|- K = L : Ki ;
x : K |- A = B : type ;


rule iexistsFormUniv
iexists I K (fn x . A) : univ J
>>
|- K : Ki ;
|- lleq I J ;
x : K |- A : univ J ;


rule iexistsEqUniv
iexists I K (fn x . A) = iexists I L (fn x . B) : univ J
>>
|- K = L : Ki ;
|- lleq I J ;
x : K |- A = B : univ J ;


rule iexistsIntroOf
M : iexists I K (fn x . A)
>>
|- K : Ki ;
x : K |- A : type ;
|- B : K ;
|- M : A [B / x] ;


rule iexistsIntroEq
M = N : iexists I K (fn x . A)
>>
|- K : Ki ;
x : K |- A : type ;
|- B : K ;
|- M = N : A [B / x] ;


rule iexistsIntro
iexists I K (fn x . A) ext M
>>
|- K : Ki ;
x : K |- A : type ;
|- B : K ;
|- A [B / x] ext M ;


rule iexistsElimOf
P [M / y] : B
>>
|- K : type ;
x : K |- A : type ;
x : K, y : A |- P : B ;
|- M : iexists I K (fn x . A) ;


rule iexistsElimEq
P [M / y] = Q [N / y] : B
>>
|- K : type ;
x : K |- A : type ;
x : K, y : A |- P = Q : B ;
|- M = N : iexists I K (fn x . A) ;


rule iexistsElim
B ext P [() / x, M / y]
>>
|- K : type ;
x : K |- A : type ;
x : hide K, y : A |- B ext P ;
|- M : iexists I K (fn x . A) ;


rule iexistsElimIstype
B [M/y] : type
>>
|- K : type ;
x : K |- A : type ;
x : K, y : A |- B : type ;
|- M : iexists I K (fn x . A) ;


rule iexistsElimEqtype
B [M/y] = C [N/y] : type
>>
|- K : type ;
x : K |- A : type ;
x : K, y : A |- B = C : type ;
|- M = N : iexists I K (fn x . A) ;



(* Miscellaneous *)

lrule substitution
x : A ... |- B ext N
>>
x : A ... |- B : type ;
x : A ... |- $x = M : A ;
...[M / x] |- B [M/x] ext N ;


lrule substitutionSimple
x : A ... |- B ext N
>>
x : A ... |- $x = M : A ;
...[M / x] |- B ext N ;


rule generalize
B [M / x] ext N [M / x]
>>
|- M : A ;
x : A |- B ext N ;


rule assert
B ext let M (fn x . N)
>>
|- A ext M ;
x : A |- B ext N ;


(* For when the assertion is used at most once, or the assertion's extract is small. *)
rule assert'
B ext N [M / x]
>>
|- A ext M ;
x : A |- B ext N ;


rule inhabitant
A ext M
>>
|- M : A ;


rule letForm
let M (fn x . N) : B
>>
|- M : A ;
x : A |- N : B ;


rule eeqtpSymm
eeqtp A B ext ((), ())
>>
|- eeqtp B A ;


rule weakenEqtpEeqtp
eeqtp A B ext ((), ())
>>
|- A = B : type ;


rule accInd
B [M / w] ext fix (fn g x . P [(fn y r . $g $y) / z]) M
>>
|- A : Ui ;
|- R : arrow A (arrow A Ui) ;
x : A, z : (forall {y : A} (arrow (R $y $x) B[$y / w])) |- B [$x / w] ext P ;
|- M : A ;
|- N : acc A R M ;



(* Integers *)

axiom integerForm
integer : type
>>


axiom integerEq
integer = integer : type
>>


axiom integerFormUniv
integer : Ui
>>
|- I : level ;


axiom integerEqUniv
integer = integer : Ui
>>
|- I : level ;


axiom integerToDefType
integer_to_def : arrow integer integer_def
>>


axiom integerFromDefType
integer_from_def : arrow integer_def integer
>>


axiom integerIsomorphism1
(fn x . integer_from_def (integer_to_def $x)) = (fn x . $x) : arrow integer integer
>>


axiom integerIsomorphism2
(fn x . integer_to_def (integer_from_def $x)) = (fn x . $x) : arrow integer_def integer_def
>>


axiom pluszSpec
plusz = (fn x y . integer_from_def (plusz_def (integer_to_def $x) (integer_to_def $y))) : arrow integer (arrow integer integer)
>>


axiom negzSpec
negz = (fn x . integer_from_def (negz_def (integer_to_def $x))) : arrow integer integer
>>


axiom eqzbSpec
eqzb = (fn x y . eqzb_def (integer_to_def $x) (integer_to_def $y)) : arrow integer (arrow integer bool)
>>


axiom leqzbSpec
leqzb = (fn x y . leqzb_def (integer_to_def $x) (integer_to_def $y)) : arrow integer (arrow integer bool)
>>


axiom timeszSpec
timesz = (fn x y . integer_from_def (timesz_def (integer_to_def $x) (integer_to_def $y))) : arrow integer (arrow integer integer)
>>
