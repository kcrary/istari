
signature PRIM =
   sig

      type constant
      type ureduction1
      type ureduction2

      val bool : constant
      val bogus : constant
      val eq : constant
      val eqtp : constant
      val exists : constant
      val fals : constant     (* false *)
      val forall : constant
      val foralltp : constant
      val future : constant
      val iexists : constant
      val iforall : constant
      val inl : constant
      val inr : constant
      val intersect : constant
      val ite : constant
      val guard : constant
      val karrow : constant
      val kind : constant
      val level : constant
      val lleq : constant
      val lmax : constant
      val lsucc : constant
      val lzero : constant
      val magic : constant
      val mu : constant
      val negative : constant
      val positive : constant
      val prod : constant
      val quotient : constant
      val rec : constant
      val set : constant
      val subtype : constant
      val sum : constant
      val sumcase : constant
      val tarrow : constant
      val tru : constant      (* true *)
      val unit : constant
      val univ : constant
      val void : constant
      val wind : constant
      val wtype : constant

      val abort : constant
      val acc : constant      (* Acc *)
      val ann : constant
      val ap : constant
      val arrow : constant
      val eeqtp : constant
      val fix : constant
      val istp : constant
      val lett : constant     (* let *)
      val letnext : constant
      val manual : constant
      val nat : constant
      val natcase : constant
      val ov : constant       (* of *)
      val pause : constant
      val squash : constant
      val succ : constant
      val zero : constant

      val unroll_fix : ureduction1
      val unroll_pause : ureduction1
      val unroll_wind : ureduction1

      val ite_tru : ureduction2
      val ite_fals : ureduction2
      val sumcase_inl : ureduction2
      val sumcase_inr : ureduction2
      val natcase_zero : ureduction2
      val natcase_succ : ureduction2



      (* For internal use *)

      val primitives : (Symbol.symbol * constant) list
      val redices : ureduction2 list

   end


functor PrimFun (structure Term : TERM
                 structure Constant : CONSTANT_INTERNAL
                                      where type term = Term.term
                                      where type constant = Term.constant
                 structure Pickling : PICKLING_PRIV
                                      where type constant = Term.constant
                 structure Reduction : REDUCTION_PRIV
                                       where type constant = Term.constant
                                       where type term = Term.term
                                       where type elim = Term.elim)
   :> 
   PRIM
   where type constant = Constant.constant
   where type ureduction1 = Reduction.ureduction1
   where type ureduction2 = Reduction.ureduction2
   =
   struct

      type constant = Constant.constant
      type ureduction1 = Reduction.ureduction1
      type ureduction2 = Reduction.ureduction2

      structure T = Term
      structure R = Reduction

      val numPrimitives = ref 0
      val thePrimitives : (Symbol.symbol * constant) list ref = ref []

      fun declare str def =
         let
            val i = !numPrimitives
            val sym = Symbol.fromValue str
            val const = Constant.declare def [sym]
         in
            numPrimitives := 1 + !numPrimitives;
            thePrimitives := (sym, const) :: !thePrimitives;
            Pickling.primitive const i;
            const
         end

      fun newconst str = declare str NONE

      fun defconst str m = declare str (SOME m)


      val bool = newconst "bool"
      val bogus = newconst "bogus"
      val eq = newconst "eq"
      val eqtp = newconst "eqtp"
      val exists = newconst "exists"
      val fals = newconst "false"
      val forall = newconst "forall"
      val foralltp = newconst "foralltp"
      val future = newconst "future"
      val iexists = newconst "iexists"
      val iforall = newconst "iforall"
      val inl = newconst "inl"
      val inr = newconst "inr"
      val intersect = newconst "intersect"
      val ite = newconst "ite"
      val guard = newconst "guard"
      val karrow = newconst "karrow"
      val kind = newconst "kind"
      val level = newconst "level"
      val lleq = newconst "lleq"
      val lmax = newconst "lmax"
      val lsucc = newconst "lsucc"
      val lzero = newconst "lzero"
      val magic = newconst "magic"
      val mu = newconst "mu"
      val negative = newconst "negative"
      val prod = newconst "prod"
      val quotient = newconst "quotient"
      val rec = newconst "rec"
      val positive = newconst "positive"
      val set = newconst "set"
      val subtype = newconst "subtype"
      val sum = newconst "sum"
      val sumcase = newconst "sumcase"
      val tarrow = newconst "tarrow"
      val tru = newconst "true"
      val unit = newconst "unit"
      val univ = newconst "univ"
      val void = newconst "void"
      val wind = newconst "wind"
      val wtype = newconst "wtype"

      val abort =
         defconst "abort"
         (T.Lam (NONE, T.zero))

      val ann =
         defconst "ann"
         (T.Lam (NONE, T.Lam (NONE, T.zero)))

      val ap =
         defconst "ap"
         (T.Lam (NONE, T.Lam (NONE, T.Var 1)))

      val arrow = 
         defconst "arrow"
         (T.Lam (NONE, T.Lam (NONE, T.apply2 forall (T.Var 1) (T.Lam (NONE, T.Var 1)))))

      val eeqtp =
         defconst "eeqtp"
         (T.Lam (NONE, T.Lam (NONE, T.apply2 prod (T.apply2 subtype (T.Var 1) (T.Var 0)) (T.apply2 subtype (T.Var 0) (T.Var 1)))))

      val istp =
         defconst "istp"
         (T.Lam (NONE, T.apply2 eqtp T.zero T.zero))

      (* hardcoded reduction in Normalize depends on this definition *)
      val letnext =
         defconst "letnext"
         (T.Lam (NONE, T.Lam (NONE, T.app T.zero (T.prev (T.Var 1)))))

      val lett =
         defconst "let"
         (T.Lam (NONE, T.Lam (NONE, T.app T.zero (T.Var 1))))

      val manual =
         defconst "manual"
         (T.Lam (NONE, T.zero))

      val nat =
         defconst "nat"
         (T.apply1 mu (T.Lam (NONE, T.apply2 sum (T.Const unit) (T.Var 0))))

      val natcase =
         defconst "natcase"
         (T.Lam (NONE, 
                 T.Lam (NONE, 
                        T.Lam (NONE,
                               T.apply3 sumcase
                                  (T.Var 2)
                                  (T.Lam (NONE, T.Var 2))
                                  (T.Lam (NONE, T.app (T.Var 1) (T.Var 0)))))))

      val ov =
         defconst "of"
         (T.Lam (NONE, T.Lam (NONE, T.apply3 eq (T.Var 1) T.zero T.zero)))

      val pause =
         defconst "pause"
         (T.Lam (NONE, T.zero))

      val squash = 
         defconst "squash"
         (T.Lam (NONE, T.apply2 set (T.Const unit) (T.Lam (NONE, T.Var 1))))

      val succ = 
         defconst "succ"
         (T.Lam (NONE, T.apply1 inr T.zero))

      val zero =
         defconst "zero"
         (T.apply1 inl T.Triv)

      (* Uses pause.  This isn't strictly necessary, but it's protection in case the user
         accidentally unfolds fix.
      *)
      val fix =
         defconst "fix"
         (T.apply2 pause
             (T.Lam (NONE,
                     T.Lam (SOME (Symbol.fromValue "f"),
                            T.app
                               (T.Var 0)
                               (T.apply3 pause (T.Var 1) (T.Var 1) (T.Var 0)))))
             (T.Lam (NONE,
                     T.Lam (SOME (Symbol.fromValue "f"),
                            T.app
                               (T.Var 0)
                               (T.apply3 pause (T.Var 1) (T.Var 1) (T.Var 0))))))

      fun lamb str m = T.Lam (SOME (Symbol.fromValue str), m)

      fun lamsb l m = List.foldr lamb m l

      val acc =
         defconst "Acc"
         (* fn A R x .
               exists (a : mu t . exists (y : A) . forall (z : A) . R z y -> t) .
                  fix
                     (fn wf b y .
                         exists (_ : y = b #1 : A) .
                            forall (z : A) (r : R z y) .
                               wf (b #2 z r) z)
                     a x
         *)
         (lamsb ["A", "R", "x"]
             (T.apply2 exists
                 (T.apply1 mu
                     (lamb "t"
                         (T.apply2 exists
                             (T.Var 3)
                             (lamsb ["y"]
                                 (T.apply2 forall
                                     (T.Var 4)
                                     (lamsb ["z"]
                                         (T.apply2 arrow
                                             (T.app2 (T.Var 4) (T.Var 0) (T.Var 1))
                                             (T.Var 2))))))))
                 (lamb "a"
                     (T.apply3 fix
                         (lamsb ["W", "b", "y"]
                             (T.apply2 exists
                                 (T.apply3 eq (T.Var 6) (T.Var 0) (T.pi1 (T.Var 1)))
                                 (lamb "v"
                                     (T.apply2 forall
                                         (T.Var 7)
                                         (lamb "z"
                                             (T.apply2 forall
                                                 (T.app2 (T.Var 7) (T.Var 0) (T.Var 2))
                                                 (lamb "r"
                                                     (T.app2
                                                         (T.Var 5)
                                                         (T.app2 (T.pi2 (T.Var 4)) (T.Var 1) (T.Var 0))
                                                         (T.Var 1)))))))))
                         (T.Var 0)
                         (T.Var 1)))))
                                     


      val primitives = !thePrimitives
      val () = thePrimitives := []


      val theRedices : ureduction2 list ref = ref []

      fun redex r =
         let
            val red = R.backdoor2 r
         in
            theRedices := red :: !theRedices;
            red
         end


      val unroll_pause =
         R.new1 pause 1 T.zero (R.trans [R.unfold, R.beta 1]) R.refl

      val unroll_fix =
         R.new1 fix 1
            (T.app T.zero (T.apply1 fix T.zero))
            (R.trans
                [
                R.unfold,
                R.user1 unroll_pause,
                R.beta 2,
                ])
            (R.within [1] R.unfold)

      val unroll_wind =
         (* wind F M --> F (M #1) (M #2) (\z. wind F (M #2 z)) *)
         R.backdoor1
         (wind, 2,
          T.app3
             (T.Var 1)
             (T.pi1 T.zero)
             (T.pi2 T.zero)
             (T.Lam (NONE,
                     T.apply2 wind
                        (T.Var 2)
                        (T.Elim (T.Var 1, [T.Pi2, T.App T.zero])))))

      val ite_tru =
         (* ite true M1 M0 --> M1 *)
         redex (ite, 0, 2, tru, 0, T.Var 1)
   
      val ite_fals =
         (* ite fals M1 M0 --> M0 *)
         redex (ite, 0, 2, fals, 0, T.Var 0)
   
      val sumcase_inl =
         (* sumcase (inl M2) M1 M0 --> M1 M2 *)
         redex (sumcase, 0, 2, inl, 1, T.Elim (T.Var 1, [T.App (T.Var 2)]))
   
      val sumcase_inr =
         (* sumcase (inr M2) M1 M0 --> M0 M2 *)
         redex (sumcase, 0, 2, inr, 1, T.Elim (T.Var 0, [T.App (T.Var 2)]))
   
      val natcase_zero =
         (* natcase zero M1 M0 --> M1 *)
         R.new2 natcase 0 2 zero 0 
            (T.Var 1) 
            (R.trans
                [
                R.unfold,
                R.beta 3,
                R.within [1] R.unfold,
                R.user2 sumcase_inl,
                R.beta 1
                ])
            R.refl

      val natcase_succ =
         (* natcase (succ M2) M1 M0 --> M0 M2 *)
         R.new2 natcase 0 2 succ 1
            (T.app (T.Var 0) (T.Var 2))
            (R.trans
                [
                R.unfold,
                R.beta 3,
                R.within [1] (R.trans [R.unfold, R.beta 1]),
                R.user2 sumcase_inr,
                R.beta 1
                ])
            R.refl

      val () = theRedices := natcase_zero :: natcase_succ :: !theRedices
   

      val redices = !theRedices
      val () = theRedices := []

      val () =
         List.app (fn const => Constant.setOpacity const Constant.FIRM)
         [ann, ap, lett, manual]

   end
