
signature PRIM =
   sig

      type constant

      (* primitive *)
      val bool : constant
      val bogus : constant
      val eq : constant
      val eqtp : constant
      val exists : constant
      val fals : constant     (* false *)
      val forall : constant
      val foralltp : constant
      val future : constant
      val iexists : constant
      val iforall : constant
      val inl : constant
      val inr : constant
      val intersect : constant
      val ite : constant
      val guard : constant
      val integer : constant
      val karrow : constant
      val kind : constant
      val level : constant
      val lleq : constant
      val lmax : constant
      val lsucc : constant
      val lzero : constant
      val magic : constant
      val mu : constant
      val negative : constant
      val positive : constant
      val prod : constant
      val quotient : constant
      val rec : constant
      val set : constant
      val subtype : constant
      val sum : constant
      val sum_case : constant
      val tarrow : constant
      val tru : constant      (* true *)
      val unit : constant
      val univ : constant
      val void : constant

      (* primitive, invisible until placed into library *)
      val eqzb : constant
      val leqzb : constant
      val negz : constant
      val plusz : constant
      val timesz : constant

      (* defined *)
      val abort : constant
      val acc : constant      (* Acc *)
      val ann : constant
      val ap : constant
      val arrow : constant
      val eeqtp : constant
      val fix : constant
      val fnann : constant    (* annotated fn *)
      val istp : constant
      val lett : constant     (* let *)
      val letnext : constant
      val manual : constant
      val nat : constant
      val nat_case : constant
      val ov : constant       (* of *)
      val pause : constant
      val squash : constant
      val succ : constant
      val zero : constant

      (* defined, invisible until placed into library *)
      val eqb : constant
      val eqzb_def : constant
      val integer_def : constant
      val integer_from_def : constant
      val integer_to_def : constant
      val integer_to_nat : constant
      val leqb : constant
      val leqzb_def : constant
      val nat_to_integer : constant
      val negz_def : constant
      val plus : constant
      val plusz_def : constant
      val times : constant
      val timesz_def : constant

   end


signature PRIM_INTERNAL =
   sig

      include PRIM

      val primitives : (Symbol.symbol * constant) list

   end


functor PrimFun (structure Term : TERM
                 structure Constant : CONSTANT_INTERNAL
                                      where type term = Term.term
                                      where type constant = Term.constant
                 structure Pickling : PICKLING_PRIV
                                      where type constant = Term.constant)
   :> 
   PRIM_INTERNAL
   where type constant = Constant.constant
   =
   struct

      type constant = Constant.constant

      structure T = Term

      val numPrimitives = ref 0
      val thePrimitives : (Symbol.symbol * constant) list ref = ref []

      (* visible: whether to place the constant into primitives
         and hence into the namespace.
      *)
      fun declare visible str def =
         let
            val i = !numPrimitives
            val sym = Symbol.fromValue str
            val const = Constant.declare def [sym]
         in
            numPrimitives := 1 + i;

            if visible then
               thePrimitives := (sym, const) :: !thePrimitives
            else
               ();

            Pickling.primitive const i;
            const
         end

      fun newconst str = declare true str NONE
      fun newconstInvis str = declare false str NONE
      fun defconst str m = declare true str (SOME m)
      fun defconstInvis str m = declare false str (SOME m)


      val bool = newconst "bool"
      val bogus = newconst "bogus"
      val eq = newconst "eq"
      val eqtp = newconst "eqtp"
      val exists = newconst "exists"
      val fals = newconst "false"
      val forall = newconst "forall"
      val foralltp = newconst "foralltp"
      val future = newconst "future"
      val iexists = newconst "iexists"
      val iforall = newconst "iforall"
      val inl = newconst "inl"
      val inr = newconst "inr"
      val intersect = newconst "intersect"
      val ite = newconst "ite"
      val guard = newconst "guard"
      val integer = newconst "integer"
      val karrow = newconst "karrow"
      val kind = newconst "kind"
      val level = newconst "level"
      val lleq = newconst "lleq"
      val lmax = newconst "lmax"
      val lsucc = newconst "lsucc"
      val lzero = newconst "lzero"
      val magic = newconst "magic"
      val mu = newconst "mu"
      val negative = newconst "negative"
      val positive = newconst "positive"
      val prod = newconst "prod"
      val quotient = newconst "quotient"
      val rec = newconst "rec"
      val set = newconst "set"
      val subtype = newconst "subtype"
      val sum = newconst "sum"
      val sum_case = newconst "sum_case"
      val tarrow = newconst "tarrow"
      val tru = newconst "true"
      val unit = newconst "unit"
      val univ = newconst "univ"
      val void = newconst "void"

      val eqzb = newconstInvis "eqzb"
      val leqzb = newconstInvis "leqzb"
      val negz = newconstInvis "negz"
      val plusz = newconstInvis "plusz"
      val timesz = newconstInvis "timesz"

      val abort =
         defconst "abort"
         (T.Lam (NONE, T.zero))

      val ann =
         defconst "ann"
         (T.Lam (NONE, T.Lam (NONE, T.zero)))

      val ap =
         defconst "ap"
         (T.Lam (NONE, T.Lam (NONE, T.Var 1)))

      val arrow = 
         defconst "arrow"
         (T.Lam (NONE, T.Lam (NONE, T.apply2 forall (T.Var 1) (T.Lam (NONE, T.Var 1)))))

      val eeqtp =
         defconst "eeqtp"
         (T.Lam (NONE, T.Lam (NONE, T.apply2 prod (T.apply2 subtype (T.Var 1) (T.Var 0)) (T.apply2 subtype (T.Var 0) (T.Var 1)))))

      (* hardcoded reduction in Normalize depends on this definition *)
      val fnann =
         defconst "fnann"
         (T.Lam (NONE, T.Lam (NONE, T.zero)))

      val istp =
         defconst "istp"
         (T.Lam (NONE, T.apply2 eqtp T.zero T.zero))

      (* hardcoded reduction in Normalize depends on this definition *)
      val letnext =
         defconst "letnext"
         (T.Lam (NONE, T.Lam (NONE, T.app T.zero (T.prev (T.Var 1)))))

      val lett =
         defconst "let"
         (T.Lam (NONE, T.Lam (NONE, T.app T.zero (T.Var 1))))

      val manual =
         defconst "manual"
         (T.Lam (NONE, T.zero))

      val nat =
         defconst "nat"
         (T.apply1 mu (T.Lam (NONE, T.apply2 sum (T.Const unit) (T.Var 0))))

      val nat_case =
         defconst "nat_case"
         (T.Lam (NONE, 
                 T.Lam (NONE, 
                        T.Lam (NONE,
                               T.apply3 sum_case
                                  (T.Var 2)
                                  (T.Lam (NONE, T.Var 2))
                                  (T.Lam (NONE, T.app (T.Var 1) (T.Var 0)))))))

      val ov =
         defconst "of"
         (T.Lam (NONE, T.Lam (NONE, T.apply3 eq (T.Var 1) T.zero T.zero)))

      val pause =
         defconst "pause"
         (T.Lam (NONE, T.zero))

      val squash = 
         defconst "squash"
         (T.Lam (NONE, T.apply2 set (T.Const unit) (T.Lam (NONE, T.Var 1))))

      val succ = 
         defconst "succ"
         (T.Lam (NONE, T.apply1 inr T.zero))

      val zero =
         defconst "zero"
         (T.apply1 inl T.Triv)

      (* Uses pause.  This isn't strictly necessary, but it's protection in case the user
         accidentally unfolds fix.
      *)
      val fix =
         defconst "fix"
         (T.apply2 pause
             (T.Lam (NONE,
                     T.Lam (SOME (Symbol.fromValue "f"),
                            T.app
                               (T.Var 0)
                               (T.apply3 pause (T.Var 1) (T.Var 1) (T.Var 0)))))
             (T.Lam (NONE,
                     T.Lam (SOME (Symbol.fromValue "f"),
                            T.app
                               (T.Var 0)
                               (T.apply3 pause (T.Var 1) (T.Var 1) (T.Var 0))))))

      fun lamb str m = T.Lam (SOME (Symbol.fromValue str), m)

      fun lamsb l m = List.foldr lamb m l

      val acc =
         defconst "Acc"
         (* fn A R x .
               exists (a : mu t . exists (y : A) . forall (z : A) . R z y -> t) .
                  fix
                     (fn wf b y .
                         exists (_ : y = b #1 : A) .
                            forall (z : A) (r : R z y) .
                               wf (b #2 z r) z)
                     a x
         *)
         (lamsb ["A", "R", "x"]
             (T.apply2 exists
                 (T.apply1 mu
                     (lamb "t"
                         (T.apply2 exists
                             (T.Var 3)
                             (lamsb ["y"]
                                 (T.apply2 forall
                                     (T.Var 4)
                                     (lamsb ["z"]
                                         (T.apply2 arrow
                                             (T.app2 (T.Var 4) (T.Var 0) (T.Var 1))
                                             (T.Var 2))))))))
                 (lamb "a"
                     (T.apply3 fix
                         (lamsb ["W", "b", "y"]
                             (T.apply2 exists
                                 (T.apply3 eq (T.Var 6) (T.Var 0) (T.pi1 (T.Var 1)))
                                 (lamb "v"
                                     (T.apply2 forall
                                         (T.Var 7)
                                         (lamb "z"
                                             (T.apply2 forall
                                                 (T.app2 (T.Var 7) (T.Var 0) (T.Var 2))
                                                 (lamb "r"
                                                     (T.app2
                                                         (T.Var 5)
                                                         (T.app2 (T.pi2 (T.Var 4)) (T.Var 1) (T.Var 0))
                                                         (T.Var 1)))))))))
                         (T.Var 0)
                         (T.Var 1)))))
                                     


      val integer_to_nat =
         defconstInvis "integer_to_nat"
         (T.apply1 fix
             (T.Lam (NONE, 
                     T.Lam (SOME (Symbol.fromValue "a"),
                            T.apply3 ite
                               (T.apply2 leqzb (T.Var 0) (T.Native (T.Integer 0I)))
                               (T.Const zero)
                               (T.apply1 succ 
                                   (T.app (T.Var 1) 
                                       (T.apply2 plusz (T.Native (T.Integer ~1I)) (T.Var 0))))))))

      val nat_to_integer =
         defconstInvis "nat_to_integer"
         (T.apply1 fix
             (T.Lam (NONE,
                     T.Lam (SOME (Symbol.fromValue "n"),
                            T.apply3 nat_case
                               (T.Var 0)
                               (T.Native (T.Integer 0I))
                               (T.Lam (SOME (Symbol.fromValue "n'"),
                                       T.apply2 plusz
                                          (T.Native (T.Integer 1I))
                                          (T.app (T.Var 2) (T.Var 0))))))))

      val plus =
         defconstInvis "plus"
         (T.apply1 fix
             (T.Lam (NONE,
                     T.Lam (NONE,
                            T.Lam (NONE,
                                   T.apply3 nat_case
                                   (T.Var 1)
                                   (T.Var 0)
                                   (T.Lam (NONE,
                                           T.apply1 succ
                                              (T.app2 (T.Var 3) (T.Var 0) (T.Var 1)))))))))

      val times =
         defconstInvis "times"
         (T.apply1 fix
             (T.Lam (NONE,
                     T.Lam (NONE,
                            T.Lam (NONE,
                                   T.apply3 nat_case
                                   (T.Var 1)
                                   (T.Const zero)
                                   (T.Lam (NONE,
                                           T.apply2 plus 
                                              (T.Var 1)
                                              (T.app2 (T.Var 3) (T.Var 0) (T.Var 1)))))))))

      val eqb =
         defconstInvis "eqb"
         (T.apply1 fix
             (T.Lam (NONE,
                     T.Lam (NONE,
                            T.Lam (NONE,
                                   T.apply3 nat_case 
                                      (T.Var 1)
                                      (T.apply3 nat_case
                                          (T.Var 0)
                                          (T.Const tru)
                                          (T.Lam (NONE, T.Const fals)))
                                      (T.Lam (NONE,
                                              T.apply3 nat_case
                                                 (T.Var 1)
                                                 (T.Const fals)
                                                 (T.Lam (NONE,
                                                         T.app2 (T.Var 4) (T.Var 1) (T.Var 0))))))))))

      val eqzb_def =
         defconstInvis "eqzb_def"
         (T.Lam (NONE,
                 T.Lam (NONE,
                        T.apply2 eqb
                           (T.apply2 plus (T.Elim (T.Var 1, [T.Pi1])) (T.Elim (T.Var 0, [T.Pi2])))
                           (T.apply2 plus (T.Elim (T.Var 1, [T.Pi2])) (T.Elim (T.Var 0, [T.Pi1]))))))
         
      val integer_def =
         defconstInvis "integer_def"
         (T.apply2 quotient
              (T.apply2 prod (T.Const nat) (T.Const nat))
              (T.Lam (NONE,
                      T.Lam (NONE,
                             T.apply3 eq
                                (T.Const nat)
                                (T.apply2 plus (T.Elim (T.Var 1, [T.Pi1])) (T.Elim (T.Var 0, [T.Pi2])))
                                (T.apply2 plus (T.Elim (T.Var 1, [T.Pi2])) (T.Elim (T.Var 0, [T.Pi1])))))))
 
      val integer_from_def =
         defconstInvis "integer_from_def"
         (T.Lam (NONE,
                 T.apply2 plusz
                     (T.apply1 nat_to_integer (T.pi1 (T.Var 0)))
                     (T.apply1 negz (T.apply1 nat_to_integer (T.pi2 (T.Var 0))))))

      val integer_to_def =
         defconstInvis "integer_to_def"
         (T.Lam (NONE,
                 T.apply3 ite
                     (T.apply2 leqzb (T.Native (T.Integer 0I)) (T.Var 0))
                     (T.Pair (T.apply1 integer_to_nat (T.Var 0), T.Const zero))
                     (T.Pair (T.Const zero, T.apply1 integer_to_nat (T.apply1 negz (T.Var 0))))))

      val leqb =
         defconstInvis "leqb"
         (T.apply1 fix
             (T.Lam (NONE,
                     T.Lam (NONE,
                            T.Lam (NONE,
                                   T.apply3 nat_case 
                                      (T.Var 1)
                                      (T.Const tru)
                                      (T.Lam (NONE,
                                              T.apply3 nat_case
                                                 (T.Var 1)
                                                 (T.Const fals)
                                                 (T.Lam (NONE,
                                                         T.app2 (T.Var 4) (T.Var 1) (T.Var 0))))))))))

      val leqzb_def =
         defconstInvis "leqzb_def"
         (T.Lam (NONE,
                 T.Lam (NONE,
                        T.apply2 leqb
                           (T.apply2 plus (T.Elim (T.Var 1, [T.Pi1])) (T.Elim (T.Var 0, [T.Pi2])))
                           (T.apply2 plus (T.Elim (T.Var 1, [T.Pi2])) (T.Elim (T.Var 0, [T.Pi1]))))))
         
      val negz_def =
         defconstInvis "negz_def"
         (T.Lam (NONE,
                 T.Pair (T.pi2 (T.Var 0), T.pi1 (T.Var 0))))

      val plusz_def =
         defconstInvis "plusz_def"
         (T.Lam (NONE,
                 T.Lam (NONE,
                        T.Pair (T.apply2 plus (T.pi1 (T.Var 1)) (T.pi1 (T.Var 0)),
                                T.apply2 plus (T.pi2 (T.Var 1)) (T.pi2 (T.Var 0))))))


      val timesz_def =
         defconstInvis "timesz_def"
         (T.Lam (NONE,
                 T.Lam (NONE,
                        T.Pair (T.apply2 plus
                                   (T.apply2 times (T.pi1 (T.Var 1)) (T.pi1 (T.Var 0)))
                                   (T.apply2 times (T.pi2 (T.Var 1)) (T.pi2 (T.Var 0))),
                                T.apply2 plus
                                   (T.apply2 times (T.pi1 (T.Var 1)) (T.pi2 (T.Var 0)))
                                   (T.apply2 times (T.pi2 (T.Var 1)) (T.pi1 (T.Var 0)))))))




      val primitives = !thePrimitives
      val () = thePrimitives := []

      val () =
         List.app (fn const => Constant.setOpacity const Constant.FIRM)
         [ann, ap, fnann, lett, manual]

   end
