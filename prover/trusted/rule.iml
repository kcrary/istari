
signature RULE =
   sig

      include THE_RULES


      val hypothesis : int -> rule
      val hypothesisOf : int -> rule
      val hypothesisEq : int -> rule
      val hypothesisOfTp : int -> rule
      val hypothesisEqTp : int -> rule


      val identity : string -> rule


      (* weaken i j, if |G2| = j, and |G3| = i,
         turns G1, G2, G3 into G1, G3
      *)
      val weaken : int -> int -> rule

      (* exchange i j k, if |G2| = k and |G3| = j, and |G4| = i,
         turns G1, G2, G3, G4 into G1, G3', G2', G4'
      *)
      val exchange : int -> int -> int -> rule


      (* if    C reduces to D by red
         then  reduce red            turns C into D
               unreduce C red        turns D into C
               reduceAt i A C red    turns A[under_i (C . id)] into A[under_i (D . id)]
               unreduceAt i A C red  turns A[under_i (D . id)] into A[under_i (C . id)]

               reduceHyp j red             turns Hj = Tm* C into Tm* D
               unreduceHhyp j C red        turns Hj = Tm* D into Tm* C
               reduceHypAt j i H C red     turns Hj = H[under_i (C . id)] into H[under_i (D . id)]
               unreduceHypAt j i H C red   turns Hj = H[under_i (D . id)] into H[under_i (C . id)]
          
         In (un)reduceHypAt the hypothesis need not be Tm* (in which case it has no effect).
      *)
      val reduce : Reduction.reduction -> rule
      val unreduce : term -> Reduction.reduction -> rule
      val reduceHyp : int -> Reduction.reduction -> rule
      val unreduceHyp : int -> term -> Reduction.reduction -> rule
      val reduceAt : int -> term -> term -> Reduction.reduction -> rule
      val unreduceAt : int -> term -> term -> Reduction.reduction -> rule
      val reduceHypAt : int -> int -> Judgement.hyp -> term -> Reduction.reduction -> rule
      val unreduceHypAt : int -> int -> Judgement.hyp -> term -> Reduction.reduction -> rule


      (* the path is interpreted as in Simplify.applySubterm *)
      val whnfHypAt : int -> int list -> rule
      val whnfConclAt : int list -> rule

      val whnfHyp : int -> rule
      val whnfConcl : rule
      val whnfHardHyp : int -> rule
      val whnfHardConcl : rule
      val normalizeHyp : int -> rule
      val normalizeConcl : rule


      val checkPositive : rule
      val checkNegative : rule


      (* G |- C
         >>
         G, = M |- C[^]
      *)
      val letIntro : term -> rule

      (* G1, = M, G2 |- J
         >>
         G1, G2[M . id] |- J[under_i (M . id)]
      *)
      val letSubst : int -> rule

      (* if    i unfolds to M
         then  letFold i C         turns C[M . id] into C[i . id]
               letUnfold i C       turns C[i . id] into C[M . id]
               letFoldHyp i j H    turns Hj = H[M . id] into H[i . id]
               letUnfoldHyp i j H  turns Hj = H[i . id] into H[M . id]
      *)
      val letFold : int -> term -> rule
      val letUnfold : int -> term -> rule
      val letFoldHyp : int -> int -> Judgement.hyp -> rule
      val letUnfoldHyp : int -> int -> Judgement.hyp -> rule


      (* sumLeft i A B C
         case analyzes i:(sum A B) with right-hand-side C

         G1, (A % B), G2 |- C ext sum_case i 
                                    (fn y . M[1 .. i . 0 . ^i+1])
                                    (fn y . N[1 .. i . 0 . ^i+1])
         >>
         G1, A, G2[inl 0 . ^] |- C[under_i(inl 0 . ^)] ext M
         G1, B, G2[inr 0 . ^] |- C[under_i(inr 0 . ^)] ext N
      *)
      val sumLeft : int -> term -> term -> term -> rule


      (* insert i

         G1, G2 |- C ext M[under_i(() . id)]  
         >>
         G1, unit, G2[^] |- C[under_i(^)] ext M
         (where |G2| = i)
      *)
      val insert : int -> rule


      (* forallLeft M

         G, (forall A . B) |- C[^] ext N[0 M[^] . ^]
         >>
         G |- M : A
         G, B[M . id] |- C[^] ext N
      *)
      val forallLeft : term -> rule


      (* arrowLeft

         G, (A -> B) |- C[^] ext N[0 M[^] . ^]
         >>
         G |- A ext M
         G, B |- C[^] ext N
      *)
      val arrowLeft : rule


      (* haltsValue
         
         G |- halts M
         >>
         M is valuable
      *)
      val haltsValue : rule


      (* sequalCompatPath path M N P

         G |- sequal C{N} C{P}
         >>
         G |- sequal N P

         where M = C{M'} and C is determined by path.
         Paths are interpreted as in Simplify.applySubterm.
      *)
      val sequalCompatPath : int list -> term -> term -> term -> rule


      (* <x> : integer *)
      val integerIntroOf : rule

      (* <x> = <x> : integer *)
      val integerIntroEq : rule

      (* <x> : symbol *)
      val symbolIntroOf : rule

      (* <x> = <x> : symbol *)
      val symbolIntroEq : rule



      exception Failure         (* usually raised when a rule does not apply *)
      exception HiddenVariable  (* raised when a rule does not apply due to hidden variables *)
      exception ExtractFailure  (* raised when extract function doesn't see what it expects *)

      val apply : rule -> Judgement.judgement -> Judgement.judgement list * (term list -> term)
      val name : rule -> string
      val info : rule -> string * term list

      val trustme : rule

   end


structure Rule :> RULE =
   struct

      structure T = Term
      structure J = Judgement
      structure N = Normalize
      structure S = Seq
      structure P = Prune
      structure U = Unify

      exception Failure
      exception HiddenVariable
      exception ExtractFailure
      
      fun unifyHyps hyps g =
         (case (hyps, S.expose g) of
             (nil, _) => g

           | (_ :: _, S.Nil) => raise Failure

           | (h1 :: rest, S.Cons (h2, g')) =>
                (
                J.unifyHyp h1 h2;
                unifyHyps rest g'
                ))
         
      exception ContextToPsubEasy

      fun contextToPsubMain easy i g =
         (case S.expose g of
             S.Nil =>
                if easy then
                   raise ContextToPsubEasy
                else
                   P.Pshift i

           | S.Cons (J.Tmh _, g') =>
                P.Pundef (contextToPsubMain false (i+1) g')

           | S.Cons (J.Tmlh _, g') =>
                P.Pundef (contextToPsubMain false (i+1) g')

           | S.Cons (J.Tph, g') =>
                P.Pundef (contextToPsubMain false (i+1) g')

           | S.Cons (_, g') =>
                P.Pidot (i, contextToPsubMain easy (i+1) g'))

      fun contextToPsub g =
         try
            contextToPsubMain true 0 g
         with
            ContextToPsubEasy => P.Pshift 0

      fun checkHidden ctx ms =
         (case ms of
             [] => ()

           | _ =>
                let
                   val p = contextToPsub ctx
                in
                   (case p of
                       P.Pshift 0 => ()
 
                     | _ =>
                          List.app (fn m =>
                                       if Prune.pruneable m p then
                                          ()
                                       else
                                          raise HiddenVariable) ms)
                end)


      structure Arg =
         struct

            type result = J.judgement list * (T.term list -> T.term)
            type rule = string * T.term list * (J.judgement -> result)

            exception ExtractFailure = ExtractFailure

            datatype context_action =
               Nothing
             | Promote
             | Unhide
             | PromoteUnhide

            fun applyAction act g =
               (case act of
                   Nothing => g
                 | Promote => S.map J.promote g
                 | Unhide => S.map J.unhide g
                 | PromoteUnhide => S.map J.promoteAndUnhide g)

            fun make str all hidden a subgoals ext =
               (str, all,
                fn jud =>
                   let
                      val () = checkHidden (J.context jud) hidden

                      val g = J.context jud
                   in
                      if U.unify1 a (J.concl jud) then
                         (map 
                             (fn (act, h, b) =>
                                 let
                                    val g' = applyAction act g
                                 in
                                    J.make (S.appendList h g') b
                                 end)
                             subgoals,
                          ext)
                      else
                         raise Failure
                   end)

            fun lmake str hidden i hyps a subgoals ext =
               (str, [],
                fn jud =>
                   let
                      val () = checkHidden (J.context jud) hidden

                      val g = J.context jud
    
                      val (g3, g12) =
                         try
                            S.split g i
                         with Invalid _ => raise Failure
    
                      val g1 = unifyHyps hyps g12
                   in
                      if U.unify1 a (J.concl jud) then
                         (map
                             (fn (act, h, subo, b) =>
                                    let
                                       val g1' = applyAction act g1
    
                                       val g12 = S.appendList h g1'
    
                                       val g' =
                                          (case subo of
                                              NONE => g12
    
                                            | SOME (T.Shift 0) =>
                                                 S.append g3 g12
    
                                            | SOME sub =>
                                                 S.append (J.subContext g3 sub) g12)
                                    in
                                       J.make g' b
                                    end)
                                subgoals,
                             ext)
                      else
                         raise Failure
                   end)

         end

      structure R = RuleFun (structure Arg = Arg)
      open R


      (* Hardcoded rules *)

      fun id l =
         (case l of
             [x] => x

           | _ => raise ExtractFailure)

      fun fn0 x l =
         (case l of
             [] => x

           | _ => raise ExtractFailure)

      fun fn1 f l =
         (case l of
             [x] => f x

           | _ => raise ExtractFailure)


      (* This one could be done using the rule generator, but this should be a tiny bit faster. *)
      fun hypothesis i =
         ("hypothesis", [],
          fn jud =>
             (case J.hypOpt jud i of
                 SOME (J.Tm a) =>
                    if U.unify1 (J.concl jud) (T.Sub (a, T.Shift (i+1))) then
                       ([], fn0 (T.Var i))
                    else
                       raise Failure
    
               | _ =>
                    raise Failure))


      (* Okay to unhide, since the variable isn't used in the extract. *)
      fun hypothesisOf i =
         ("hypothesisOf", [],
          fn jud =>
             let
                val a =
                   (case J.hypOpt jud i of
                       SOME (J.Tm a) => a
                     | SOME (J.Tmh a) => a
                     | _ => raise Failure)
             in
                if
                   U.unify1 (J.concl jud)
                   (T.apply2 Prim.ov (T.Sub (a, T.Shift (i+1))) (T.Var i))
                then
                   ([], fn0 T.Triv)
                else
                   raise Failure
             end)


      (* Okay to unhide, since the variable isn't used in the extract. *)
      fun hypothesisEq i =
         ("hypothesisEq", [],
          fn jud =>
             let
                val a =
                   (case J.hypOpt jud i of
                       SOME (J.Tm a) => a
                     | SOME (J.Tmh a) => a
                     | _ => raise Failure)
             in
                if
                   U.unify1 (J.concl jud)
                   (T.apply3 Prim.eq (T.Sub (a, T.Shift (i+1))) (T.Var i) (T.Var i))
                then
                   ([], fn0 T.Triv)
                else
                   raise Failure
             end)


      fun hypothesisOfTp i =
         ("hypothesisOfTp", [],
          fn jud =>
             let
                val () =
                   (case J.hypOpt jud i of
                       SOME J.Tp => ()
                     | _ => raise Failure)
             in
                if
                   U.unify1 (J.concl jud)
                   (T.apply1 Prim.istp (T.Var i))
                then
                   ([], fn0 T.Triv)
                else
                   raise Failure
             end)


      fun hypothesisEqTp i =
         ("hypothesisEqTp", [],
          fn jud =>
             let
                val () =
                   (case J.hypOpt jud i of
                       SOME J.Tp => ()
                     | _ => raise Failure)
             in
                if
                   U.unify1 (J.concl jud)
                   (T.apply2 Prim.eqtp (T.Var i) (T.Var i))
                then
                   ([], fn0 T.Triv)
                else
                   raise Failure
             end)



      fun evarHyp h =
         (case h of
             J.Tm _ => J.Tm (T.evar ())
           | J.Tml _ => J.Tml (T.evar ())
           | J.Tmh _ => J.Tmh (T.evar ())
           | J.Tmlh _ => J.Tmlh (T.evar ())
           | J.Tp => J.Tp
           | J.Tpl => J.Tpl
           | J.Tph => J.Tph
           | J.Let _ => J.Let (T.evar ()))


      fun identity str =
         (str, [],
          (fn jud =>
              ([jud],
               fn1 (fn m => m))))


      fun weaken i j =
         ("weaken", [],
          fn jud =>
             if i < 0 orelse j < 0 orelse i + j > S.length (J.context jud) then
                raise Failure
             else
                let
                   fun loop g i =
                      if i = 0 then
                         S.drop g j
                      else
                         (case S.expose g of
                             S.Nil =>
                                raise (Fail "impossible")
    
                           | S.Cons (h, g') =>
                                let
                                   val h' = evarHyp h
                                in
                                   J.unifyHyp h (J.subHyp h' (T.under (i-1) (T.Shift j)));
                                   S.cons h' (loop g' (i-1))
                                end)
    
                   val g' = loop (J.context jud) i
    
                   val c = T.evar ()
                   val () = U.unify (J.concl jud) (T.Sub (c, T.under i (T.Shift j)))
                in
                   if U.solve () then
                      ([J.make g' c],
                       fn1 (fn m => T.Sub (m, T.under i (T.Shift j))))
                   else
                      raise Failure
                end)


      (* |G2| = k, |G3| = j

         G1, G3, G2 |- exchsub j k l : (G1, G2, G3)-l
         where
         G-n =def= drop G n
      *)
      fun exchsub j k l =
         if l < j then
            T.Idot (l + k, exchsub j k (l+1))
         else if l < j+k then
            T.Idot (l - j, exchsub j k (l+1))
         else
            T.Shift (j + k)

      fun exchange i j k =
         ("exchange", [],
          fn jud =>
             if i < 0 orelse j < 0 orelse k < 0 orelse i + j + k > S.length (J.context jud) then
                raise Failure
             else
                let
                   (* have G = G1 G2 G3 G4, where |G2| = k, |G3| = j, |G4| = i
                      want H = G1 H3 H2 H4,
                      where H2, H3, and H4 are G2, G3, and G4 under appropriate substitutions
                   *)
                   val g123 = S.drop (J.context jud) i
                   val (g3, g12) = S.split g123 j
                   val (g2, g1) = S.split g12 k
    
                   (* far g l
    
                      if    g = G3-l
                      then  return G1, H3-l
                   *)
                   fun far g l =
                      if l = j then
                         g1
                      else
                         (case S.expose g of
                             S.Cons (hyp, g') =>
                                (* G3-l = g', hyp
                                   so G3-(l+1) = g'
                                *)
                                let
                                   val h' = far g' (l+1)
                                   val hyp' = evarHyp hyp
                                in
                                   (* h' = G1, H3-(l+1)
                                      hyp lives in G1, G2, G3-(l+1)
    
                                      need to check:
                                      hyp = hyp'[under (j-l-1) ^k]
                                      so that hyp' lives in G1, H3-(l+1)
                                   *)
                                   J.unifyHyp hyp (J.subHyp hyp' (T.under (j-l-1) (T.Shift k)));
                                   S.cons hyp' h'
                                end
    
                           | S.Nil => raise (Fail "impossible"))
    
                   (* mid g l
    
                      if    g = G2-l
                      then  return G1, H3, H2-l
                   *)
                   fun mid g l =
                      if l = k then
                         far g3 0
                      else
                         (case S.expose g of
                             S.Cons (hyp, g') =>
                                (* G2-l = g', hyp
                                   so G2-(l+1) = g'
                                *)
                                let
                                   val h' = mid g' (l+1)
                                in
                                   (* h' = G1, H3, H2-(l+1)
                                      hyp lives in G1, G2-(l+1)
    
                                      need to put it in G1, H3, H2-(l+1)
                                   *)
                                   S.cons (J.subHyp hyp (T.under (k-l-1) (T.Shift j))) h'
                                end
    
                           | S.Nil => raise (Fail "impossible"))
    
                   val s = exchsub j k 0
                   val sinv = exchsub k j 0
    
                   fun near g i =
                      if i = 0 then
                         mid g2 0
                      else
                         (case S.expose g of
                             S.Cons (h, g') =>
                                S.cons (J.subHyp h (T.under (i-1) s)) (near g' (i-1))
    
                           | S.Nil =>
                                raise (Fail "impossible"))
    
                   val g' = near (J.context jud) i
    
                   val t = T.under i sinv
                in
                   if U.solve () then
                      ([J.make g' (T.Sub (J.concl jud, T.under i s))],
                       fn1 (fn m => T.Sub (m, t)))
                   else
                      raise Failure
                end)


      fun splitContext ctx i =
         (case S.splitOpt ctx i of
             NONE => raise Failure

           | SOME (bottom, h_top) =>
                (case S.expose h_top of
                    S.Nil => raise Failure

                  | S.Cons (h, top) =>
                       (bottom, h, top)))

      fun hypTm h =
         (case h of
             J.Tm a =>
                (a, J.Tm)

           | J.Tml a =>
                (a, J.Tml)

           | J.Tmh a =>
                (a, J.Tmh)

           | J.Tmlh a =>
                (a, J.Tmlh)

           | J.Let m =>
                (m, J.Let)

           | _ => raise Failure)

      fun onhyp jud i =
         let
            val (bottom, h, top) = splitContext (J.context jud) i
         in
            (h,
             (fn h' =>
                 J.make
                    (S.append bottom (S.cons h' top))
                    (J.concl jud)))
         end

      fun onhypTm jud i =
         let
            val (h, f) = onhyp jud i
            val (a, g) = hypTm h
         in
            (a, (fn a' => f (g a')))
         end


      fun reduce red =
         ("reduce", [],
          fn jud =>
             (try
                 ([J.make (J.context jud) (Reduction.reduce red (J.concl jud))],
                  id)
              with
                 Reduction.Reduce => raise Failure))
    

      fun unreduce c red =
         ("unreduce", [],
          fn jud =>
             (try
                 if U.unify1 (J.concl jud) (Reduction.reduce red c) then
                    ([J.make (J.context jud) c], id)
                 else
                    raise Failure
              with
                 Reduction.Reduce => raise Failure))

         
      fun reduceHyp i red =
         ("reduceHyp", [],
          fn jud =>
             let
                val (c, f) = onhypTm jud i
             in
                try 
                   ([f (Reduction.reduce red c)], id)
                with
                   Reduction.Reduce => raise Failure
             end)


      fun unreduceHyp i c red =
         ("unreduceHyp", [],
          fn jud =>
             let
                val (d, f) = onhypTm jud i
             in
                try
                   if U.unify1 d (Reduction.reduce red c) then
                      ([f c], id)
                   else
                      raise Failure
                with
                   Reduction.Reduce => raise Failure
             end)


      fun reduceAt i a c red =
         ("reduceAt", [],
          fn jud =>
             let
                val d =
                   try
                      Reduction.reduce red c
                   with
                      Reduction.Reduce => raise Failure
             in
                if U.unify1 (J.concl jud) (T.Sub (a, T.under i (T.Dot (c, T.id)))) then
                   ([J.make 
                        (J.context jud) 
                        (T.Sub (a, T.under i (T.Dot (d, T.id))))],
                    id)
                else
                   raise Failure
             end)


      fun unreduceAt i a c red =
         ("unreduceAt", [],
          fn jud =>
             let
                val d =
                   try
                      Reduction.reduce red c
                   with
                      Reduction.Reduce => raise Failure
             in
                if U.unify1 (J.concl jud) (T.Sub (a, T.under i (T.Dot (d, T.id)))) then
                   ([J.make 
                        (J.context jud) 
                        (T.Sub (a, T.under i (T.Dot (c, T.id))))],
                    id)
                else
                   raise Failure
             end)


      fun unifyHyp1 h h' =
         (
         J.unifyHyp h h';
         Unify.solve ()
         )


      fun reduceHypAt j i h c red =
         ("reduceHypAt", [],
          fn jud =>
             let
                val (hj, f) = onhyp jud j

                val d =
                   try
                      Reduction.reduce red c
                   with
                      Reduction.Reduce => raise Failure
             in
                if unifyHyp1 hj (J.subHyp h (T.under i (T.Dot (c, T.id)))) then
                   ([f (J.subHyp h (T.under i (T.Dot (d, T.id))))],
                    id)
                else
                   raise Failure
             end)


      fun unreduceHypAt j i h c red =
         ("unreduceHypAt", [],
          fn jud =>
             let
                val (hj, f) = onhyp jud j

                val d =
                   try
                      Reduction.reduce red c
                   with
                      Reduction.Reduce => raise Failure
             in
                if unifyHyp1 hj (J.subHyp h (T.under i (T.Dot (d, T.id)))) then
                   ([f (J.subHyp h (T.under i (T.Dot (c, T.id))))],
                    id)
                else
                   raise Failure
             end)
                   
    

      fun applySubterm f path c =
         try
            Simplify.applySubterm f path c
         with
            Simplify.ApplySubterm => raise Failure


      fun whnfHypAt i path =
         ("whnfHypAt", [],
          fn jud =>
             let
                val (c, f) = onhypTm jud i
             in
                ([f (applySubterm N.whnf path c)],
                 fn1 (fn m => m))
             end)


      fun whnfConclAt path =
         ("whnfConclAt", [],
          fn jud =>
             ([J.make (J.context jud) (applySubterm N.whnf path (J.concl jud))],
              fn1 (fn m => m)))


      fun whnfHyp i =
         ("whnfHyp", [],
          fn jud =>
             let
                val (c, f) = onhypTm jud i
             in
                ([f (N.whnf c)],
                 fn1 (fn m => m))
             end)


      val whnfConcl =
         ("whnfConcl", [],
          fn jud =>
             ([J.make (J.context jud) (N.whnf (J.concl jud))],
              fn1 (fn m => m)))


      fun whnfHardHyp i =
         ("whnfHardHyp", [],
          fn jud =>
             let
                val (c, f) = onhypTm jud i
             in
                ([f (N.whnfHard c)],
                 fn1 (fn m => m))
             end)


      val whnfHardConcl =
         ("whnfHardConcl", [],
          fn jud =>
             ([J.make (J.context jud) (N.whnfHard (J.concl jud))],
              fn1 (fn m => m)))


      fun normalizeHyp i =
         ("normalizeHyp", [],
          fn jud =>
             let
                val (c, f) = onhypTm jud i
             in
                ([f (N.normalize c)],
                  fn1 (fn m => m))
             end)


      val normalizeConcl =
         ("normalizeConcl", [],
          fn jud =>
             ([J.make (J.context jud) (N.normalize (J.concl jud))],
              fn1 (fn m => m)))



      (* true <=> positive; p = punder^i (undef . id);
         q = undef .. undef (i times) . id
      *)

      fun checkClosed sign p q a acc =
         let
            val mark = Trail.mark ()
         in
            if Prune.pruneable a p then
               (* we're happy if a doesn't mention i *)
               acc
            else
               (
               Trail.rewind mark;
               (* generate an obligation if a doesn't mention any variable < i *)
               (case P.prune a q of
                   NONE =>
                      (
                      Trail.rewind mark;
                      raise Failure
                      )

                 | SOME b => 
                      (sign, b) :: acc)
               )
         end

      fun checkPosNegMain sign i p q a acc = checkPosNegWhnf sign i p q (Normalize.whnf a) acc

      and checkPosNegWhnf sign i p q a acc =
         (case a of
             T.Elim (T.Var j, []) =>
                if sign orelse i <> j then
                   acc
                else
                   raise Failure

           | T.Elim (T.Const const, spine) =>
                if Constant.eq (const, Prim.prod) then
                   (case spine of
                       [T.App b, T.App c] =>
                          checkPosNegMain sign i p q b 
                             (checkPosNegMain sign i p q c acc)

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.sum) then
                   (case spine of
                       [T.App b, T.App c] =>
                          checkPosNegMain sign i p q b 
                             (checkPosNegMain sign i p q c acc)

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.arrow) then
                   (case spine of
                       [T.App b, T.App c] =>
                          checkPosNegMain (not sign) i p q b 
                             (checkPosNegMain sign i p q c acc)

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.forall) then
                   (case spine of
                       [T.App b, T.App c] =>
                          checkPosNegMain (not sign) i p q b
                             (checkPosNegLam sign i p q c acc)

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.exists) then
                   (case spine of
                       [T.App b, T.App c] =>
                          checkPosNegMain sign i p q b
                             (checkPosNegLam sign i p q c acc)

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.future) then
                   (case spine of
                       [T.App b] =>
                          checkPosNegMain sign i p q b acc

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.mu) then
                   (case spine of
                       [T.App b] =>
                          checkPosNegLam sign i p q b acc

                     | _ =>
                          raise Failure)

                else if Constant.eq (const, Prim.ite) then
                   (case spine of
                       [T.App m, T.App b, T.App c] =>
                          let
                             val mark = Trail.mark ()
                          in
                             if Prune.pruneable m p then
                                checkPosNegMain sign i p q b
                                   (checkPosNegMain sign i p q c acc)
                             else
                                (
                                Trail.rewind mark;
                                raise Failure
                                )
                          end

                     | _ =>
                          raise Failure)

                else
                   (case Constant.definition const of
                       SOME n =>
                          checkPosNegMain sign i p q (T.Elim (n, spine)) acc

                     | NONE =>
                          (* don't unfold an opaque constant *)
                          checkClosed sign p q a acc)

           | _ =>
                checkClosed sign p q a acc)

      and checkPosNegLam sign i p q a acc =
         (case Normalize.whnf a of
             T.Lam (_, b) =>
                checkPosNegMain sign (i+1) (P.punder p) (P.Pundef q) b acc

           | _ =>
                raise Failure)


      fun checkPosNeg sign jud =
         let
            val a = T.evar ()
         in
            if
               U.unify1
                  (T.apply1 (if sign then Prim.positive else Prim.negative) (T.Lam (NONE, a)))
                  (J.concl jud)
            then
               let
                  val obs =
                     checkPosNegMain sign 0 
                        (P.Pundef (P.Pshift 0)) (P.Pshift 0)
                        a []

                  val ctx = J.context jud

                  val subgoals =
                     List.map 
                        (fn (sign', b) => 
                               J.make ctx 
                                  (T.apply1 
                                      (if sign' then Prim.positive else Prim.negative)
                                      (T.Lam (NONE, b))))
                        obs

                  val n = List.length obs

                  fun validate (vs : T.term list) =
                     if List.length vs = n then
                        T.Triv
                     else
                        raise ExtractFailure
               in
                  (subgoals, validate)
               end
            else
               raise Failure
         end

      val checkPositive : rule = ("checkPositive", [], checkPosNeg true)

      val checkNegative : rule = ("checkNegative", [], checkPosNeg false)


      
      fun letIntro m =
         ("letIntro", [m],
          fn jud =>
             let
                val ctx = J.context jud

                val () = checkHidden ctx [m]

                val ctx' = S.cons (J.Let m) ctx
             in
                ([J.make ctx' (T.Sub (J.concl jud, T.shift1))],
                 fn1 (fn n => T.apply2 Prim.lett m (T.Lam (NONE, n))))
             end)

      fun letSubst i =
         ("letSubst", [],
          fn jud =>
             (case S.splitOpt (J.context jud) i of
                 SOME (g3, g12) =>
                    (case S.expose g12 of
                        S.Cons (J.Let m, g1) =>
                           let
                              val ctx =
                                 S.append
                                    (J.subContext g3 (T.Dot (m, T.id)))
                                    g1

                              val c = T.Sub (J.concl jud, T.under i (T.Dot (m, T.id)))
                           in
                              ([J.make ctx c],
                               fn1 (fn n => T.Sub (n, T.underShift i 1)))
                           end
    
                      | _ => raise Failure)

               | NONE =>
                    raise Failure))

      fun letFold i c =
         ("letFold", [],
          fn jud =>
             (case J.hypOpt jud i of
                 SOME (J.Let m) =>
                    let
                       val m' = T.Sub (m, T.Shift (i+1))
                    in
                       if U.unify1 (J.concl jud) (T.Sub (c, T.Dot (m', T.id))) then
                          ([J.make (J.context jud) (T.Sub (c, T.Idot (i, T.id)))],
                           fn1 (fn n => n))
                       else
                          raise Failure
                    end

               | _ => raise Failure))

      fun letUnfold i c =
         ("letUnfold", [],
          fn jud =>
             (case J.hypOpt jud i of
                 SOME (J.Let m) =>
                    let
                       val m' = T.Sub (m, T.Shift (i+1))
                    in
                       if U.unify1 (J.concl jud) (T.Sub (c, T.Idot (i, T.id))) then
                          ([J.make (J.context jud) (T.Sub (c, T.Dot (m', T.id)))],
                           fn1 (fn n => n))
                       else
                          raise Failure
                    end

               | _ => raise Failure))

      fun letFoldHyp i j h =
         ("letFoldHyp", [],
          fn jud =>
             if j < i then
                (case J.hypOpt jud i of
                    SOME (J.Let m) =>
                       let
                          val (h', f) = onhyp jud j

                          val m' = T.Sub (m, T.Shift (i-j))
                       in
                          J.unifyHyp h' (J.subHyp h (T.Dot (m', T.id)));

                          if U.solve () then
                             ([f (J.subHyp h (T.Idot (i-j-1, T.id)))],
                              fn1 (fn n => n))
                          else
                             raise Failure
                       end
   
                  | _ => raise Failure)
             else
                raise Failure)

      fun letUnfoldHyp i j h =
         ("letUnfoldHyp", [],
          fn jud =>
             if j < i then
                (case J.hypOpt jud i of
                    SOME (J.Let m) =>
                       let
                          val (h', f) = onhyp jud j

                          val m' = T.Sub (m, T.Shift (i-j))
                       in
                          J.unifyHyp h' (J.subHyp h (T.Idot (i-j-1, T.id)));

                          if U.solve () then
                             ([f (J.subHyp h (T.Dot (m', T.id)))],
                              fn1 (fn n => n))
                          else
                             raise Failure
                       end
   
                  | _ => raise Failure)
             else
                raise Failure)




      fun apply (_, _, f) = f
      fun name (str, _, _) = str
      fun info (str, args, _) = (str, args)


      val trustme =
         ("trustme", [],
          fn jud =>
             if Unsafe.allowed () then
                ([], fn0 (T.Const Prim.magic))
             else
                raise Unsafe.UnsafeNotAllowed)


      open Term

      fun substAt m i j k =
         if i = k then
            Dot (m, Shift (j+1))
         else
            Idot (j, substAt m (i+1) (j+1) k)


      (* The rule generator can't handle the form the extract takes in this rule
         (it combines variables from both the near and far zones), and it's not worth
         implementing it for only one rule.
      *)

      fun sumLeft gsize a b c =
         Arg.lmake "sumLeft" [] gsize
         [J.Tm (apply2 Prim.sum a b)]
         c
         [
         (Arg.Nothing, [J.Tm a], SOME (Dot (apply1 Prim.inl zero, Shift 1)),
          Sub (c, under gsize (Dot (apply1 Prim.inl zero, Shift 1)))),
          
         (Arg.Nothing, [J.Tm b], SOME (Dot (apply1 Prim.inr zero, Shift 1)),
          Sub (c, under gsize (Dot (apply1 Prim.inr zero, Shift 1))))
         ]
         (fn [m, n] =>
                apply3
                   Prim.sum_case
                   (Var gsize)
                   (Lam (NONE, Sub (m, substAt zero 0 1 gsize)))
                   (Lam (NONE, Sub (n, substAt zero 0 1 gsize)))

           | _ => raise ExtractFailure)


      (* The rule generator would require us to give the hypothesis currently at position i. *)
      fun insert i =
         ("insert", [],
          (fn jud =>
              (case S.splitOpt (J.context jud) i of
                  NONE =>
                     raise Failure

                | SOME (ctx2, ctx1) =>
                     let
                        val ctx' =
                           S.append
                              (J.subContext ctx2 T.shift1)
                              (S.cons (J.Tm (T.Const Prim.unit)) ctx1)
                     in
                        ([J.make ctx' (T.Sub (J.concl jud, T.underShift i 1))],
                         (fn [m] => 
                                T.Sub (m, T.under i (T.Dot (T.Triv, T.id)))

                           | _ => raise ExtractFailure))
                     end)))


      (* The rule generator won't create rules with a hypothesis in the conclusion. *)
      fun forallLeft m =
         ("forallLeft", [m],
          (fn jud =>
              (case S.expose (J.context jud) of
                  S.Cons (J.Tm t, ctx) =>
                     (case N.whnf t of
                         T.Elim (T.Const const, [T.App a, T.App lamb]) =>
                            if Constant.eq (const, Prim.forall) then
                               (case N.whnf lamb of
                                   T.Lam (_, b) =>
                                      let
                                         val csh = J.concl jud
                                         val c = T.evar ()
                                      in
                                         checkHidden ctx [m];
                                      
                                         if U.unify1 csh (T.Sub (c, T.shift1)) then
                                            ([
                                             J.make ctx (T.apply2 Prim.ov a m),
                                             J.make (S.cons (J.Tm (T.Sub (b, T.Dot (m, T.id)))) ctx) csh
                                             ],
                                             (fn [_, n] =>
                                                 T.Sub (n, T.Dot (T.Elim (T.zero, [T.App (T.Sub (m, T.shift1))]), T.shift1))
   
                                               | _ => raise ExtractFailure))
                                         else
                                            raise Failure
                                      end
   
                                 | _ => 
                                      raise Failure)
                            else
                               raise Failure

                       | _ =>
                            raise Failure)

                | _ =>
                     raise Failure)))


      (* The rule generator won't create rules with a hypothesis in the conclusion. *)
      val arrowLeft =
         ("arrowLeft", [],
          (fn jud =>
              (case S.expose (J.context jud) of
                  S.Cons (J.Tm t, ctx) =>
                     (case N.whnf t of
                         T.Elim (T.Const const, [T.App a, T.App b]) =>
                            if Constant.eq (const, Prim.arrow) then
                               let
                                  val csh = J.concl jud
                                  val c = T.evar ()
                               in
                                  if U.unify1 csh (T.Sub (c, T.shift1)) then
                                     ([
                                      J.make ctx a,
                                      J.make (S.cons (J.Tm b) ctx) csh
                                      ],
                                      (fn [m, n] =>
                                          T.Sub (n, T.Dot (T.Elim (T.zero, [T.App (T.Sub (m, T.shift1))]), T.shift1))
   
                                        | _ => raise ExtractFailure))
                                  else
                                     raise Failure
                               end
                            else
                               raise Failure

                       | _ =>
                            raise Failure)

                | _ =>
                     raise Failure)))

      (* The rule generator doesn't know about valuability. *)
      val haltsValue =
         ("haltsValue", [],
          fn jud =>
             (case N.whnf (J.concl jud) of
                 Elim (Const const, [App m]) =>
                    if 
                       Constant.eq (const, Prim.halts)
                       andalso
                       Valuability.valuability m > 0 
                    then
                       ([], fn0 T.Triv)
                    else
                       raise Failure

               | _ => 
                    raise Failure))



      (* We can almost do this with applySubterm, but we have to shift n and p when we go under binders. *)
      fun replacePath path m n p =
         (case path of
             [] => 
                (n, p)

           | i :: rest =>
                let
                   val (h, spine) = Simplify.simp m id []
                in
                   (case spine of
                       [] =>
                          (case h of
                              Lam (binder, m') =>
                                 if i = 0 then
                                    let
                                       val (n', p') = replacePath rest m' (Sub (n, shift1)) (Sub (p, shift1))
                                    in
                                       (Lam (binder, n'), Lam (binder, p'))
                                    end
                                 else
                                    raise Failure

                            | Pair (m1, m2) =>
                                 if i = 0 then
                                    let
                                       val (n1, p1) = replacePath rest m1 n p
                                    in
                                       (Pair (n1, m2), Pair (p1, m2))
                                    end
                                 else if i = 1 then
                                    let
                                       val (n2, p2) = replacePath rest m2 n p
                                    in
                                       (Pair (m1, n2), Pair (m1, p2))
                                    end
                                 else
                                    raise Failure

                            | Next m' =>
                                 if i = 0 then
                                    let
                                       val (n', p') = replacePath rest m' n p
                                    in
                                       (Next n', Next p')
                                    end
                                 else
                                    raise Failure

                            | _ =>
                                 raise Failure)

                     | _ :: _ =>
                          (case Int.compare i 0 of
                              LESS =>
                                 raise Failure

                            | EQUAL =>
                                 let
                                    val (n', p') = replacePath rest h n p
                                 in
                                    (Elim (n', spine), Elim (p', spine))
                                 end

                            | GREATER =>
                                 let
                                    val (nspine, pspine) = replacePathSpine rest (i-1) n p spine []
                                 in
                                    (Elim (h, nspine), Elim (h, pspine))
                                 end))
                end)

      and replacePathSpine path i n p spine acc =
         (case spine of
             [] =>
                raise Failure

           | (elim as App m) :: rest =>
                if i = 0 then
                   let
                      val (n', p') = replacePath path m n p
                   in
                      (List.revAppend acc (App n' :: rest),
                       List.revAppend acc (App p' :: rest))
                   end
                else
                   replacePathSpine path (i-1) n p rest (elim :: acc)
          
           | elim :: rest =>
                if i = 0 then
                   raise Failure
                else
                   replacePathSpine path (i-1) n p rest (elim :: acc))

      fun sequalCompatPath path m n p =
         ("sequalCompatPath", [],
          fn jud =>
             let
                val (n', p') = replacePath path m n p
             in
                if Unify.unify1 (J.concl jud) (apply2 Prim.sequal n' p') then
                   ([J.make (J.context jud) (apply2 Prim.sequal n p)],
                    (fn [_] => Triv
                      | _ => raise ExtractFailure))
                else
                   raise Failure
             end)


      (* The rule generator doesn't know about native terms, so it can't generate the 
         rules to talk about them.
      *)

      val integerIntroOf =
         ("integerIntroOf", [],
          fn jud =>
             (case N.whnf (J.concl jud) of
                 Elim (Const const, [App a, App m]) =>
                    if Constant.eq (const, Prim.ov) then
                       (case N.whnf a of
                           Elim (Const const', []) =>
                              if Constant.eq (const', Prim.integer) then
                                 (case N.whnf m of
                                     Native (Integer _) =>
                                        ([], fn0 T.Triv)

                                   | _ =>
                                        raise Failure)
                              else
                                 raise Failure

                         | _ =>
                              raise Failure)
                    else
                       raise Failure

               | _ =>
                    raise Failure))

      val integerIntroEq =
         ("integerIntroEq", [],
          fn jud =>
             (case N.whnf (J.concl jud) of
                 Elim (Const const, [App a, App m, App n]) =>
                    if Constant.eq (const, Prim.eq) then
                       (case N.whnf a of
                           Elim (Const const', []) =>
                              if Constant.eq (const', Prim.integer) then
                                 (case (N.whnf m, N.whnf n) of
                                     (Native (Integer x), Native (Integer y)) =>
                                        if IntInf.= x y then
                                           ([], fn0 T.Triv)
                                        else
                                           raise Failure

                                   | _ =>
                                        raise Failure)
                              else
                                 raise Failure

                         | _ =>
                              raise Failure)
                    else
                       raise Failure

               | _ =>
                    raise Failure))

      val symbolIntroOf =
         ("symbolIntroOf", [],
          fn jud =>
             (case N.whnf (J.concl jud) of
                 Elim (Const const, [App a, App m]) =>
                    if Constant.eq (const, Prim.ov) then
                       (case N.whnf a of
                           Elim (Const const', []) =>
                              if Constant.eq (const', Prim.symbol) then
                                 (case N.whnf m of
                                     Native (Symbol _) =>
                                        ([], fn0 T.Triv)

                                   | _ =>
                                        raise Failure)
                              else
                                 raise Failure

                         | _ =>
                              raise Failure)
                    else
                       raise Failure

               | _ =>
                    raise Failure))

      val symbolIntroEq =
         ("symbolIntroEq", [],
          fn jud =>
             (case N.whnf (J.concl jud) of
                 Elim (Const const, [App a, App m, App n]) =>
                    if Constant.eq (const, Prim.eq) then
                       (case N.whnf a of
                           Elim (Const const', []) =>
                              if Constant.eq (const', Prim.symbol) then
                                 (case (N.whnf m, N.whnf n) of
                                     (Native (Symbol x), Native (Symbol y)) =>
                                        if Symbol.eq (x, y) then
                                           ([], fn0 T.Triv)
                                        else
                                           raise Failure

                                   | _ =>
                                        raise Failure)
                              else
                                 raise Failure

                         | _ =>
                              raise Failure)
                    else
                       raise Failure

               | _ =>
                    raise Failure))

   end
