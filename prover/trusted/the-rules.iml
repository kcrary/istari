(* This file is generated by Rulegen. *)

signature RULE_ARG =
   sig

      type result
      type rule

      exception ExtractFailure

      datatype context_action =
         Nothing
       | Promote
       | Unhide
       | PromoteUnhide

      val make :
         string                                                      (* name *)
         -> Term.term list                                           (* hidden variables *)
         -> Term.term                                                (* conclusion *)
         -> (context_action * Judgement.hyp list * Term.term) list   (* premises *)
         -> (Term.term list -> Term.term)                            (* extract *)
         -> rule

      val lmake :
         string                             (* name *)
         -> Term.term list                  (* hidden variables *)
         -> int                             (* size of trailing context *)
         -> Judgement.hyp list              (* conclusion floating context *)
         -> Term.term                       (* conclusion rhs *)
         -> (context_action * Judgement.hyp list * Term.sub option * Term.term) list  (* premises *)
         -> (Term.term list -> Term.term)   (* extract *)
         -> rule

   end


signature THE_RULES =
   sig

      type term = Term.term
      type rule

      val forallForm : term -> term -> rule
      val forallEq : term -> term -> term -> term -> rule
      val forallFormUniv : term -> term -> term -> rule
      val forallEqUniv : term -> term -> term -> term -> term -> rule
      val forallSub : term -> term -> term -> term -> rule
      val forallIntroOf : term -> term -> term -> rule
      val forallIntroEq : term -> term -> term -> term -> rule
      val forallIntro : term -> term -> rule
      val forallElimOf : term -> term -> term -> term -> rule
      val forallElimEq : term -> term -> term -> term -> term -> term -> rule
      val forallElim : term -> term -> term -> rule
      val forallEta : term -> term -> term -> rule
      val forallExt : term -> term -> term -> term -> rule
      val forallOfExt : term -> term -> term -> term -> term -> rule
      val forallFormInv1 : term -> term -> rule
      val forallFormInv2 : term -> term -> term -> rule
      val arrowForm : term -> term -> rule
      val arrowEq : term -> term -> term -> term -> rule
      val arrowFormUniv : term -> term -> term -> rule
      val arrowEqUniv : term -> term -> term -> term -> term -> rule
      val arrowForallEq : term -> term -> term -> term -> rule
      val arrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val arrowSub : term -> term -> term -> term -> rule
      val arrowForallSub : term -> term -> term -> term -> rule
      val forallArrowSub : term -> term -> term -> term -> rule
      val arrowIntroOf : term -> term -> term -> rule
      val arrowIntroEq : term -> term -> term -> term -> rule
      val arrowIntro : term -> term -> rule
      val arrowElimOf : term -> term -> term -> term -> rule
      val arrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val arrowElim : term -> term -> rule
      val arrowEta : term -> term -> term -> rule
      val arrowExt : term -> term -> term -> term -> rule
      val arrowOfExt : term -> term -> term -> term -> term -> rule
      val arrowFormInv1 : term -> term -> rule
      val arrowFormInv2 : term -> term -> term -> rule
      val tarrowKind : term -> term -> term -> rule
      val tarrowKindEq : term -> term -> term -> term -> term -> rule
      val tarrowForm : term -> term -> rule
      val tarrowEq : term -> term -> term -> term -> rule
      val tarrowFormUniv : term -> term -> term -> rule
      val tarrowEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowArrowEq : term -> term -> term -> term -> rule
      val tarrowArrowEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowForallEq : term -> term -> term -> term -> rule
      val tarrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowIntroOf : term -> term -> term -> rule
      val tarrowIntroEq : term -> term -> term -> term -> rule
      val tarrowIntro : term -> term -> rule
      val tarrowElimOf : term -> term -> term -> term -> rule
      val tarrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val tarrowElim : term -> term -> rule
      val tarrowEta : term -> term -> term -> rule
      val tarrowExt : term -> term -> term -> term -> rule
      val karrowKind : term -> term -> term -> rule
      val karrowKindEq : term -> term -> term -> term -> term -> rule
      val karrowForm : term -> term -> rule
      val karrowEq : term -> term -> term -> term -> rule
      val karrowFormUniv : term -> term -> term -> rule
      val karrowEqUniv : term -> term -> term -> term -> term -> rule
      val karrowArrowEq : term -> term -> term -> term -> rule
      val karrowArrowEqUniv : term -> term -> term -> term -> term -> rule
      val karrowForallEq : term -> term -> term -> term -> rule
      val karrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val karrowIntroOf : term -> term -> term -> rule
      val karrowIntroEq : term -> term -> term -> term -> rule
      val karrowIntro : term -> term -> rule
      val karrowElimOf : term -> term -> term -> term -> rule
      val karrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val karrowElim : term -> term -> rule
      val karrowEta : term -> term -> term -> rule
      val karrowExt : term -> term -> term -> term -> rule
      val intersectForm : term -> term -> rule
      val intersectEq : term -> term -> term -> term -> rule
      val intersectFormUniv : term -> term -> term -> rule
      val intersectEqUniv : term -> term -> term -> term -> term -> rule
      val intersectIntroOf : term -> term -> term -> rule
      val intersectIntroEq : term -> term -> term -> term -> rule
      val intersectIntro : term -> term -> rule
      val intersectElimOf : term -> term -> term -> term -> rule
      val intersectElimEq : term -> term -> term -> term -> term -> rule
      val intersectElim : term -> term -> term -> rule
      val intersectFormInv1 : term -> term -> rule
      val intersectFormInv2 : term -> term -> term -> rule
      val guardForm : term -> term -> rule
      val guardEq : term -> term -> term -> term -> rule
      val guardFormUniv : term -> term -> term -> rule
      val guardEqUniv : term -> term -> term -> term -> term -> rule
      val guardIntroOf : term -> term -> term -> rule
      val guardIntroEq : term -> term -> term -> term -> rule
      val guardIntro : term -> term -> rule
      val guardElimOf : term -> term -> term -> rule
      val guardElimEq : term -> term -> term -> term -> rule
      val guardElim : term -> term -> rule
      val guardSatEq : term -> term -> rule
      val existsForm : term -> term -> rule
      val existsEq : term -> term -> term -> term -> rule
      val existsFormUniv : term -> term -> term -> rule
      val existsEqUniv : term -> term -> term -> term -> term -> rule
      val existsSub : term -> term -> term -> term -> rule
      val existsIntroOf : term -> term -> term -> term -> rule
      val existsIntroEq : term -> term -> term -> term -> term -> term -> rule
      val existsIntro : term -> term -> term -> rule
      val existsElim1Of : term -> term -> term -> rule
      val existsElim1Eq : term -> term -> term -> term -> rule
      val existsElim2Of : term -> term -> term -> rule
      val existsElim2Eq : term -> term -> term -> term -> rule
      val existsEta : term -> term -> term -> rule
      val existsExt : term -> term -> term -> term -> rule
      val existsLeft : int -> term -> term -> term -> rule
      val existsFormInv1 : term -> term -> rule
      val existsFormInv2 : term -> term -> term -> rule
      val existsFormInv2Eq : term -> term -> term -> term -> rule
      val prodKind : term -> term -> term -> rule
      val prodKindEq : term -> term -> term -> term -> term -> rule
      val prodForm : term -> term -> rule
      val prodEq : term -> term -> term -> term -> rule
      val prodFormUniv : term -> term -> term -> rule
      val prodEqUniv : term -> term -> term -> term -> term -> rule
      val prodExistsEq : term -> term -> term -> term -> rule
      val prodExistsEqUniv : term -> term -> term -> term -> term -> rule
      val prodSub : term -> term -> term -> term -> rule
      val prodExistsSub : term -> term -> term -> term -> rule
      val existsProdSub : term -> term -> term -> term -> rule
      val prodIntroOf : term -> term -> term -> term -> rule
      val prodIntroEq : term -> term -> term -> term -> term -> term -> rule
      val prodIntro : term -> term -> rule
      val prodElim1Of : term -> term -> term -> rule
      val prodElim1Eq : term -> term -> term -> term -> rule
      val prodElim1 : term -> term -> rule
      val prodElim2Of : term -> term -> term -> rule
      val prodElim2Eq : term -> term -> term -> term -> rule
      val prodElim2 : term -> term -> rule
      val prodEta : term -> term -> term -> rule
      val prodExt : term -> term -> term -> term -> rule
      val prodLeft : int -> term -> term -> term -> rule
      val prodFormInv1 : term -> term -> rule
      val prodFormInv2 : term -> term -> rule
      val sumForm : term -> term -> rule
      val sumEq : term -> term -> term -> term -> rule
      val sumFormUniv : term -> term -> term -> rule
      val sumEqUniv : term -> term -> term -> term -> term -> rule
      val sumSub : term -> term -> term -> term -> rule
      val sumIntro1Of : term -> term -> term -> rule
      val sumIntro1Eq : term -> term -> term -> term -> rule
      val sumIntro1 : term -> term -> rule
      val sumIntro2Of : term -> term -> term -> rule
      val sumIntro2Eq : term -> term -> term -> term -> rule
      val sumIntro2 : term -> term -> rule
      val sumElimOf : term -> term -> term -> term -> term -> term -> rule
      val sumElimOfNondep : term -> term -> term -> term -> term -> term -> rule
      val sumElimEq : term -> term -> term -> term -> term -> term -> term -> term -> term -> rule
      val sumElim : term -> term -> term -> term -> rule
      val sumElimNondep : term -> term -> term -> rule
      val sumElimIstype : term -> term -> term -> term -> term -> rule
      val sumElimEqtype : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val sum_caseType : rule
      val sumFormInv1 : term -> term -> rule
      val sumFormInv2 : term -> term -> rule
      val futureKind : term -> term -> rule
      val futureKindEq : term -> term -> term -> rule
      val futureForm : term -> rule
      val futureEq : term -> term -> rule
      val futureFormUniv : term -> term -> rule
      val futureEqUniv : term -> term -> term -> rule
      val futureSub : term -> term -> rule
      val futureIntroOf : term -> term -> rule
      val futureIntroEq : term -> term -> term -> rule
      val futureIntro : term -> rule
      val futureElimOf : term -> term -> term -> term -> rule
      val futureElimOfLetnext : term -> term -> term -> term -> rule
      val futureElimOfLetnextNondep : term -> term -> term -> term -> rule
      val futureElimEq : term -> term -> term -> term -> term -> term -> rule
      val futureElimIstype : term -> term -> term -> rule
      val futureElimIstypeLetnext : term -> term -> term -> rule
      val futureElimEqtype : term -> term -> term -> term -> term -> rule
      val futureEta : term -> term -> rule
      val futureExt : term -> term -> term -> rule
      val futureLeft : int -> term -> term -> rule
      val recKind : term -> term -> rule
      val recKindEq : term -> term -> term -> rule
      val recForm : term -> rule
      val recEq : term -> term -> rule
      val recFormUniv : term -> term -> rule
      val recEqUniv : term -> term -> term -> rule
      val recUnroll : term -> rule
      val recUnrollUniv : term -> term -> rule
      val recBisimilar : term -> term -> rule
      val muForm : term -> rule
      val muEq : term -> term -> rule
      val muFormUniv : term -> term -> rule
      val muEqUniv : term -> term -> term -> rule
      val muUnroll : term -> rule
      val muUnrollUniv : term -> term -> rule
      val muInd : term -> term -> term -> rule
      val muIndUniv : term -> term -> term -> term -> rule
      val voidForm : rule
      val voidEq : rule
      val voidFormUniv : term -> rule
      val voidEqUniv : term -> rule
      val voidElim : term -> rule
      val voidSub : term -> rule
      val abortType : rule
      val unitKind : term -> rule
      val unitKindEq : term -> rule
      val unitForm : rule
      val unitEq : rule
      val unitFormUniv : term -> rule
      val unitEqUniv : term -> rule
      val unitIntroOf : rule
      val unitIntro : rule
      val unitExt : term -> term -> rule
      val unitLeft : int -> term -> rule
      val boolForm : rule
      val boolEq : rule
      val boolFormUniv : term -> rule
      val boolEqUniv : term -> rule
      val boolIntro1Of : rule
      val boolIntro2Of : rule
      val boolElimOf : term -> term -> term -> term -> rule
      val boolElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val boolElim : term -> term -> rule
      val boolElimIstype : term -> term -> term -> rule
      val boolElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val boolLeft : int -> term -> rule
      val iteType : rule
      val natForm : rule
      val natEq : rule
      val natFormUniv : term -> rule
      val natEqUniv : term -> rule
      val natElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val natElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val zeroType : rule
      val succType : rule
      val univKind : term -> term -> rule
      val univKindEq : term -> term -> term -> rule
      val univForm : term -> rule
      val univEq : term -> term -> rule
      val univFormUniv : term -> term -> rule
      val univFormUnivSucc : term -> rule
      val univEqUniv : term -> term -> term -> rule
      val univCumulativeOf : term -> term -> term -> rule
      val univCumulativeEq : term -> term -> term -> term -> rule
      val univCumulativeSuccOf : term -> term -> rule
      val univSub : term -> term -> rule
      val univForgetOf : term -> term -> rule
      val univForgetEq : term -> term -> term -> rule
      val univIntroEqtype : term -> term -> term -> rule
      val univFormInv : term -> rule
      val kindForm : term -> rule
      val kindEq : term -> term -> rule
      val kindFormUniv : term -> term -> rule
      val kindEqUniv : term -> term -> term -> rule
      val kindForgetOf : term -> term -> rule
      val kindForgetEq : term -> term -> term -> rule
      val kindUnivSub : term -> term -> rule
      val levelForm : rule
      val levelEq : rule
      val levelFormUniv : term -> rule
      val levelEqUniv : term -> rule
      val lleqForm : term -> term -> rule
      val lleqEq : term -> term -> term -> term -> rule
      val lleqFormUniv : term -> term -> term -> rule
      val lleqEqUniv : term -> term -> term -> term -> term -> rule
      val lzeroLevel : rule
      val lsuccLevel : term -> rule
      val lsuccEq : term -> term -> rule
      val lmaxLevel : term -> term -> rule
      val lmaxEq : term -> term -> term -> term -> rule
      val lleqRefl : term -> rule
      val lleqTrans : term -> term -> term -> rule
      val lleqZero : term -> rule
      val lleqSucc : term -> term -> rule
      val lleqIncrease : term -> term -> rule
      val lleqMaxL : term -> term -> term -> rule
      val lleqMaxR1 : term -> term -> term -> rule
      val lleqMaxR2 : term -> term -> term -> rule
      val lleqResp : term -> term -> term -> term -> rule
      val lsuccMaxDistTrans : term -> term -> term -> rule
      val lzeroType : rule
      val lsuccType : rule
      val lmaxType : rule
      val eqForm : term -> term -> term -> rule
      val eqEq : term -> term -> term -> term -> term -> term -> rule
      val eqFormUniv : term -> term -> term -> term -> rule
      val eqEqUniv : term -> term -> term -> term -> term -> term -> term -> rule
      val eqIntro : term -> term -> term -> rule
      val eqElim : term -> term -> term -> term -> rule
      val eqExt : term -> term -> term -> term -> term -> rule
      val eqLeft : int -> term -> term -> term -> term -> rule
      val eqRefl : term -> term -> rule
      val eqSymm : term -> term -> term -> rule
      val eqTrans : term -> term -> term -> term -> rule
      val eqFormInv1 : term -> term -> term -> rule
      val eqFormInv2 : term -> term -> term -> rule
      val eqFormInv3 : term -> term -> term -> rule
      val ofForm : term -> term -> rule
      val ofEq : term -> term -> term -> term -> rule
      val ofFormUniv : term -> term -> term -> rule
      val ofEqUniv : term -> term -> term -> term -> term -> rule
      val ofIntro : term -> term -> rule
      val ofElim : term -> term -> term -> rule
      val ofTrivialize : term -> term -> rule
      val ofExt : term -> term -> term -> term -> rule
      val ofLeft : int -> term -> term -> term -> rule
      val ofEquand1 : term -> term -> term -> rule
      val ofEquand2 : term -> term -> term -> rule
      val eqtpForm : term -> term -> rule
      val eqtpEq : term -> term -> term -> term -> rule
      val eqtpFormUniv : term -> term -> term -> rule
      val eqtpEqUniv : term -> term -> term -> term -> term -> rule
      val eqtpIntro : term -> term -> rule
      val eqtpElim : term -> term -> term -> rule
      val eqtpExt : term -> term -> term -> term -> rule
      val eqtpLeft : int -> term -> term -> term -> rule
      val eqtpFunct : term -> term -> term -> term -> rule
      val equivalenceOf : term -> term -> term -> rule
      val equivalenceEq : term -> term -> term -> term -> rule
      val equivalence : term -> term -> rule
      val equivalenceLeft : int -> term -> term -> term -> rule
      val eqtpRefl : term -> rule
      val eqtpSymm : term -> term -> rule
      val eqtpTrans : term -> term -> term -> rule
      val istpForm : term -> rule
      val istpEq : term -> term -> rule
      val istpFormUniv : term -> term -> rule
      val istpEqUniv : term -> term -> term -> rule
      val istpIntro : term -> rule
      val istpElim : term -> term -> rule
      val istpExt : term -> term -> term -> rule
      val istpLeft : int -> term -> term -> rule
      val inhabitedForm : term -> rule
      val subtypeForm : term -> term -> rule
      val subtypeEq : term -> term -> term -> term -> rule
      val subtypeFormUniv : term -> term -> term -> rule
      val subtypeEqUniv : term -> term -> term -> term -> term -> rule
      val subtypeIntro : term -> term -> rule
      val subtypeExt : term -> term -> term -> term -> rule
      val subtypeLeft : int -> term -> term -> term -> rule
      val subsumptionOf : term -> term -> term -> rule
      val subsumptionEq : term -> term -> term -> term -> rule
      val subsumption : term -> term -> rule
      val subsumptionLeft : int -> term -> term -> term -> rule
      val subtypeRefl : term -> rule
      val subtypeReflEqtype : term -> term -> rule
      val subtypeTrans : term -> term -> term -> rule
      val subtypeIstp1 : term -> term -> rule
      val subtypeIstp2 : term -> term -> rule
      val setForm : term -> term -> rule
      val setEq : term -> term -> term -> term -> rule
      val setFormUniv : term -> term -> term -> rule
      val setEqUniv : term -> term -> term -> term -> term -> rule
      val setWeakenOf : term -> term -> term -> rule
      val setWeakenEq : term -> term -> term -> term -> rule
      val setWeaken : term -> term -> rule
      val setIntroOf : term -> term -> term -> rule
      val setIntroEq : term -> term -> term -> term -> rule
      val setIntro : term -> term -> term -> rule
      val setIntroOfSquash : term -> term -> term -> rule
      val squashIntroOfSquash : term -> rule
      val setElim : term -> term -> term -> term -> rule
      val setLeft : int -> term -> term -> term -> rule
      val setSquash : term -> term -> rule
      val setFormInv : term -> term -> rule
      val setSubElim : term -> term -> term -> rule
      val squashForm : term -> rule
      val squashEq : term -> term -> rule
      val squashFormUniv : term -> term -> rule
      val squashEqUniv : term -> term -> term -> rule
      val squashIntroOf : term -> rule
      val squashIntro : term -> rule
      val squashElim : term -> term -> term -> rule
      val squashExt : term -> term -> term -> rule
      val squashLeft : int -> term -> term -> rule
      val quotientForm : term -> term -> rule
      val quotientEq : term -> term -> term -> term -> rule
      val quotientFormUniv : term -> term -> term -> rule
      val quotientEqUniv : term -> term -> term -> term -> term -> rule
      val quotientIntroOf : term -> term -> term -> rule
      val quotientIntroEq : term -> term -> term -> term -> rule
      val quotientElimOf : term -> term -> term -> term -> term -> rule
      val quotientElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val quotientElimIstype : term -> term -> term -> term -> rule
      val quotientElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val quotientDescent : term -> term -> term -> term -> term -> rule
      val quotientLeft : int -> term -> term -> term -> rule
      val quotientLeftRefl : int -> term -> term -> term -> rule
      val quotientLeftIstype : int -> term -> term -> term -> rule
      val quotientLeftEqtype : int -> term -> term -> term -> term -> rule
      val quotientLeftOf : int -> term -> term -> term -> term -> rule
      val quotientLeftEq : int -> term -> term -> term -> term -> term -> rule
      val quotientLeftOfDep : int -> term -> term -> term -> term -> rule
      val quotientLeftEqDep : int -> term -> term -> term -> term -> term -> rule
      val quotientFormInv : term -> term -> rule
      val iforallForm : term -> term -> term -> rule
      val iforallEq : term -> term -> term -> term -> term -> rule
      val iforallFormUniv : term -> term -> term -> term -> rule
      val iforallEqUniv : term -> term -> term -> term -> term -> term -> rule
      val iforallIntroOf : term -> term -> term -> term -> rule
      val iforallIntroEq : term -> term -> term -> term -> term -> rule
      val iforallIntro : term -> term -> term -> rule
      val iforallElimOf : term -> term -> term -> term -> term -> rule
      val iforallElimEq : term -> term -> term -> term -> term -> term -> rule
      val iforallElim : term -> term -> term -> term -> rule
      val foralltpForm : term -> rule
      val foralltpEq : term -> term -> rule
      val foralltpIntroOf : term -> term -> rule
      val foralltpIntroEq : term -> term -> term -> rule
      val foralltpIntro : term -> rule
      val foralltpElimOf : term -> term -> term -> rule
      val foralltpElimEq : term -> term -> term -> term -> rule
      val foralltpElim : term -> term -> rule
      val iexistsForm : term -> term -> term -> rule
      val iexistsEq : term -> term -> term -> term -> term -> rule
      val iexistsFormUniv : term -> term -> term -> term -> rule
      val iexistsEqUniv : term -> term -> term -> term -> term -> term -> rule
      val iexistsIntroOf : term -> term -> term -> term -> term -> rule
      val iexistsIntroEq : term -> term -> term -> term -> term -> term -> rule
      val iexistsIntro : term -> term -> term -> term -> rule
      val iexistsElimOf : term -> term -> term -> term -> term -> term -> rule
      val iexistsElimEq : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val iexistsElim : term -> term -> term -> term -> term -> rule
      val iexistsElimIstype : term -> term -> term -> term -> term -> rule
      val iexistsElimEqtype : term -> term -> term -> term -> term -> term -> term -> rule
      val substitution : int -> term -> term -> term -> rule
      val substitutionSimple : int -> term -> term -> term -> rule
      val generalize : term -> term -> term -> rule
      val assert : term -> term -> rule
      val assert' : term -> term -> rule
      val inhabitant : term -> term -> rule
      val letForm : term -> term -> term -> term -> rule
      val eeqtpSymm : term -> term -> rule
      val weakenEqtpEeqtp : term -> term -> rule
      val accInd : term -> term -> term -> term -> term -> term -> rule
      val integerForm : rule
      val integerEq : rule
      val integerFormUniv : term -> rule
      val integerEqUniv : term -> rule
      val integerToDefType : rule
      val integerFromDefType : rule
      val integerIsomorphism1 : rule
      val integerIsomorphism2 : rule
      val pluszSpec : rule
      val negzSpec : rule
      val eqzbSpec : rule
      val leqzbSpec : rule
      val timeszSpec : rule

   end


functor RuleFun (structure Arg : RULE_ARG)
   :> THE_RULES where type rule = Arg.rule
=
struct

type rule = Arg.rule
open Term
structure J = Judgement

val const_of = Const Prim.ov
val const_true = Const Prim.tru
val const_false = Const Prim.fals
val const_let = Const Prim.lett
val const_abort = Const Prim.abort
val const_acc = Const Prim.acc
val const_arrow = Const Prim.arrow
val const_bool = Const Prim.bool
val const_eeqtp = Const Prim.eeqtp
val const_eq = Const Prim.eq
val const_eqtp = Const Prim.eqtp
val const_eqzb = Const Prim.eqzb
val const_eqzb_def = Const Prim.eqzb_def
val const_exists = Const Prim.exists
val const_fix = Const Prim.fix
val const_forall = Const Prim.forall
val const_foralltp = Const Prim.foralltp
val const_future = Const Prim.future
val const_guard = Const Prim.guard
val const_iexists = Const Prim.iexists
val const_iforall = Const Prim.iforall
val const_inl = Const Prim.inl
val const_inr = Const Prim.inr
val const_integer = Const Prim.integer
val const_integer_def = Const Prim.integer_def
val const_integer_from_def = Const Prim.integer_from_def
val const_integer_to_def = Const Prim.integer_to_def
val const_intersect = Const Prim.intersect
val const_istp = Const Prim.istp
val const_ite = Const Prim.ite
val const_karrow = Const Prim.karrow
val const_kind = Const Prim.kind
val const_leqzb = Const Prim.leqzb
val const_leqzb_def = Const Prim.leqzb_def
val const_letnext = Const Prim.letnext
val const_level = Const Prim.level
val const_lleq = Const Prim.lleq
val const_lmax = Const Prim.lmax
val const_lsucc = Const Prim.lsucc
val const_lzero = Const Prim.lzero
val const_mu = Const Prim.mu
val const_nat = Const Prim.nat
val const_nat_case = Const Prim.nat_case
val const_negz = Const Prim.negz
val const_negz_def = Const Prim.negz_def
val const_plusz = Const Prim.plusz
val const_plusz_def = Const Prim.plusz_def
val const_positive = Const Prim.positive
val const_prod = Const Prim.prod
val const_quotient = Const Prim.quotient
val const_rec = Const Prim.rec
val const_set = Const Prim.set
val const_squash = Const Prim.squash
val const_subtype = Const Prim.subtype
val const_succ = Const Prim.succ
val const_sum = Const Prim.sum
val const_sum_case = Const Prim.sum_case
val const_tarrow = Const Prim.tarrow
val const_timesz = Const Prim.timesz
val const_timesz_def = Const Prim.timesz_def
val const_unit = Const Prim.unit
val const_univ = Const Prim.univ
val const_void = Const Prim.void
val const_zero = Const Prim.zero

fun forallForm a b = Arg.make "forallForm" [] (Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEq a a' b b' = Arg.make "forallEq" [] (Elim (const_eqtp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormUniv a b i = Arg.make "forallFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEqUniv a a' b b' i = Arg.make "forallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallSub a a' b b' = Arg.make "forallSub" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntroOf a b m = Arg.make "forallIntroOf" [] (Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntroEq a b m n = Arg.make "forallIntroEq" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntro a b = Arg.make "forallIntro" [] (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun forallElimOf a b m p = Arg.make "forallElimOf" [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallElimEq a b m n p q = Arg.make "forallElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallElim a b p = Arg.make "forallElim" [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun forallEta a b m = Arg.make "forallEta" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallExt a b m n = Arg.make "forallExt" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallOfExt a a' b b' m = Arg.make "forallOfExt" [] (Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormInv1 a b = Arg.make "forallFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormInv2 a b m = Arg.make "forallFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForm a b = Arg.make "arrowForm" [] (Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEq a a' b b' = Arg.make "arrowEq" [] (Elim (const_eqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormUniv a b i = Arg.make "arrowFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEqUniv a a' b b' i = Arg.make "arrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallEq a a' b b' = Arg.make "arrowForallEq" [] (Elim (const_eqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallEqUniv a a' b b' i = Arg.make "arrowForallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowSub a a' b b' = Arg.make "arrowSub" [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallSub a a' b b' = Arg.make "arrowForallSub" [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallArrowSub a a' b b' = Arg.make "forallArrowSub" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntroOf a b m = Arg.make "arrowIntroOf" [] (Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntroEq a b m n = Arg.make "arrowIntroEq" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntro a b = Arg.make "arrowIntro" [] (Elim (const_arrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun arrowElimOf a b m p = Arg.make "arrowElimOf" [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowElimEq a b m n p q = Arg.make "arrowElimEq" [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowElim a b = Arg.make "arrowElim" [] (b) [(Arg.Nothing, [], Elim (const_arrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun arrowEta a b m = Arg.make "arrowEta" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowExt a b m n = Arg.make "arrowExt" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowOfExt a a' b b' m = Arg.make "arrowOfExt" [] (Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormInv1 a b = Arg.make "arrowFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormInv2 a b m = Arg.make "arrowFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowKind a i k = Arg.make "tarrowKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_tarrow, [App (a), App (k), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowKindEq a a' i k k' = Arg.make "tarrowKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_tarrow, [App (a), App (k), ])), App (Elim (const_tarrow, [App (a'), App (k'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForm a b = Arg.make "tarrowForm" [] (Elim (const_istp, [App (Elim (const_tarrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowEq a a' b b' = Arg.make "tarrowEq" [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_tarrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowFormUniv a b i = Arg.make "tarrowFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowEqUniv a a' b b' i = Arg.make "tarrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_tarrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowArrowEq a a' b b' = Arg.make "tarrowArrowEq" [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowArrowEqUniv a a' b b' i = Arg.make "tarrowArrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForallEq a a' b b' = Arg.make "tarrowForallEq" [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForallEqUniv a a' b b' i = Arg.make "tarrowForallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntroOf a b m = Arg.make "tarrowIntroOf" [] (Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntroEq a b m n = Arg.make "tarrowIntroEq" [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntro a b = Arg.make "tarrowIntro" [] (Elim (const_tarrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun tarrowElimOf a b m p = Arg.make "tarrowElimOf" [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowElimEq a b m n p q = Arg.make "tarrowElimEq" [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowElim a b = Arg.make "tarrowElim" [] (b) [(Arg.Nothing, [], Elim (const_tarrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun tarrowEta a b m = Arg.make "tarrowEta" [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowExt a b m n = Arg.make "tarrowExt" [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowKind i k l = Arg.make "karrowKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_karrow, [App (k), App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowKindEq i k k' l l' = Arg.make "karrowKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_karrow, [App (k), App (l), ])), App (Elim (const_karrow, [App (k'), App (l'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (l), App (l'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForm a b = Arg.make "karrowForm" [] (Elim (const_istp, [App (Elim (const_karrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowEq a a' b b' = Arg.make "karrowEq" [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_karrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowFormUniv a b i = Arg.make "karrowFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowEqUniv a a' b b' i = Arg.make "karrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_karrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowArrowEq a a' b b' = Arg.make "karrowArrowEq" [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowArrowEqUniv a a' b b' i = Arg.make "karrowArrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForallEq a a' b b' = Arg.make "karrowForallEq" [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForallEqUniv a a' b b' i = Arg.make "karrowForallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntroOf a b m = Arg.make "karrowIntroOf" [] (Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntroEq a b m n = Arg.make "karrowIntroEq" [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntro a b = Arg.make "karrowIntro" [] (Elim (const_karrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun karrowElimOf a b m p = Arg.make "karrowElimOf" [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowElimEq a b m n p q = Arg.make "karrowElimEq" [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowElim a b = Arg.make "karrowElim" [] (b) [(Arg.Nothing, [], Elim (const_karrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun karrowEta a b m = Arg.make "karrowEta" [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowExt a b m n = Arg.make "karrowExt" [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectForm a b = Arg.make "intersectForm" [] (Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectEq a a' b b' = Arg.make "intersectEq" [] (Elim (const_eqtp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectFormUniv a b i = Arg.make "intersectFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectEqUniv a a' b b' i = Arg.make "intersectEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntroOf a b m = Arg.make "intersectIntroOf" [] (Elim (const_of, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntroEq a b m n = Arg.make "intersectIntroEq" [] (Elim (const_eq, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntro a b = Arg.make "intersectIntro" [] (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], b), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun intersectElimOf a b m p = Arg.make "intersectElimOf" [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectElimEq a b m n p = Arg.make "intersectElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectElim a b p = Arg.make "intersectElim" [] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun intersectFormInv1 a b = Arg.make "intersectFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectFormInv2 a b m = Arg.make "intersectFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardForm a b = Arg.make "guardForm" [] (Elim (const_istp, [App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardEq a a' b b' = Arg.make "guardEq" [] (Elim (const_eqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardFormUniv a b i = Arg.make "guardFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardEqUniv a a' b b' i = Arg.make "guardEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntroOf a b m = Arg.make "guardIntroOf" [] (Elim (const_of, [App (Elim (const_guard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntroEq a b m n = Arg.make "guardIntroEq" [] (Elim (const_eq, [App (Elim (const_guard, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntro a b = Arg.make "guardIntro" [] (Elim (const_guard, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (b, Shift 1)), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun guardElimOf a b m = Arg.make "guardElimOf" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_guard, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardElimEq a b m n = Arg.make "guardElimEq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_guard, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardElim a b = Arg.make "guardElim" [] (b) [(Arg.Nothing, [], Elim (const_guard, [App (a), App (b), ])), (Arg.Unhide, [], a), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun guardSatEq a b = Arg.make "guardSatEq" [] (Elim (const_eqtp, [App (b), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsForm a b = Arg.make "existsForm" [] (Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEq a a' b b' = Arg.make "existsEq" [] (Elim (const_eqtp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormUniv a b i = Arg.make "existsFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEqUniv a a' b b' i = Arg.make "existsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsSub a a' b b' = Arg.make "existsSub" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntroOf a b m n = Arg.make "existsIntroOf" [] (Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntroEq a b m m' n n' = Arg.make "existsIntroEq" [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (n), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntro a b m = Arg.make "existsIntro" [m, ] (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun existsElim1Of a b m = Arg.make "existsElim1Of" [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim1Eq a b m n = Arg.make "existsElim1Eq" [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim2Of a b m = Arg.make "existsElim2Of" [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim2Eq a b m n = Arg.make "existsElim2Eq" [] (Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEta a b m = Arg.make "existsEta" [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsExt a b m n = Arg.make "existsExt" [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsLeft gsize a b c = Arg.lmake "existsLeft" [] gsize [J.Tm (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Nothing, [J.Tm (b), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun existsFormInv1 a b = Arg.make "existsFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormInv2 a b m = Arg.make "existsFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormInv2Eq a b m n = Arg.make "existsFormInv2Eq" [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (b, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodKind i k l = Arg.make "prodKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_prod, [App (k), App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodKindEq i k k' l l' = Arg.make "prodKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_prod, [App (k), App (l), ])), App (Elim (const_prod, [App (k'), App (l'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (l), App (l'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodForm a b = Arg.make "prodForm" [] (Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEq a a' b b' = Arg.make "prodEq" [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodFormUniv a b i = Arg.make "prodFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEqUniv a a' b b' i = Arg.make "prodEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsEq a a' b b' = Arg.make "prodExistsEq" [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, Sub (b, Shift 1))), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsEqUniv a a' b b' i = Arg.make "prodExistsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, Sub (b, Shift 1))), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodSub a a' b b' = Arg.make "prodSub" [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsSub a a' b b' = Arg.make "prodExistsSub" [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsProdSub a a' b b' = Arg.make "existsProdSub" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntroOf a b m n = Arg.make "prodIntroOf" [] (Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntroEq a b m m' n n' = Arg.make "prodIntroEq" [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntro a b = Arg.make "prodIntro" [] (Elim (const_prod, [App (a), App (b), ])) [(Arg.Nothing, [], a), (Arg.Nothing, [], b), ] (fn [m, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun prodElim1Of a b m = Arg.make "prodElim1Of" [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim1Eq a b m n = Arg.make "prodElim1Eq" [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim1 a b = Arg.make "prodElim1" [] (a) [(Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun prodElim2Of a b m = Arg.make "prodElim2Of" [] (Elim (const_of, [App (b), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim2Eq a b m n = Arg.make "prodElim2Eq" [] (Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim2 a b = Arg.make "prodElim2" [] (b) [(Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi2, ]) | _ => raise Arg.ExtractFailure)
fun prodEta a b m = Arg.make "prodEta" [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExt a b m n = Arg.make "prodExt" [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodLeft gsize a b c = Arg.lmake "prodLeft" [] gsize [J.Tm (Elim (const_prod, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [J.Tm (Sub (b, Shift 1)), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun prodFormInv1 a b = Arg.make "prodFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodFormInv2 a b = Arg.make "prodFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumForm a b = Arg.make "sumForm" [] (Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumEq a a' b b' = Arg.make "sumEq" [] (Elim (const_eqtp, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormUniv a b i = Arg.make "sumFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumEqUniv a a' b b' i = Arg.make "sumEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumSub a a' b b' = Arg.make "sumSub" [] (Elim (const_subtype, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1Of a b m = Arg.make "sumIntro1Of" [] (Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1Eq a b m n = Arg.make "sumIntro1Eq" [] (Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inl, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1 a b = Arg.make "sumIntro1" [] (Elim (const_sum, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => Elim (const_inl, [App (m), ]) | _ => raise Arg.ExtractFailure)
fun sumIntro2Of a b m = Arg.make "sumIntro2Of" [] (Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro2Eq a b m n = Arg.make "sumIntro2Eq" [] (Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro2 a b = Arg.make "sumIntro2" [] (Elim (const_sum, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], b), ] (fn [_, m, ] => Elim (const_inr, [App (m), ]) | _ => raise Arg.ExtractFailure)
fun sumElimOf a b c m p r = Arg.make "sumElimOf" [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), App (p), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_of, [App (Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimOfNondep a b c m p r = Arg.make "sumElimOfNondep" [] (Elim (const_of, [App (c), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (c, Shift 1)), App (p), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_of, [App (Sub (c, Shift 1)), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimEq a b c m n p q r s = Arg.make "sumElimEq" [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), App (Elim (const_sum_case, [App (n), App (Lam (NONE, q)), App (Lam (NONE, s)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), App (p), App (q), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_eq, [App (Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElim a b c m = Arg.make "sumElim" [m, ] (Sub (c, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Nothing, [J.Tm (a), ], Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), (Arg.Nothing, [J.Tm (b), ], Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), ] (fn [_, p, r, ] => Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ]) | _ => raise Arg.ExtractFailure)
fun sumElimNondep a b c = Arg.make "sumElimNondep" [] (c) [(Arg.Nothing, [], Elim (const_sum, [App (a), App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (c, Shift 1)), (Arg.Nothing, [J.Tm (b), ], Sub (c, Shift 1)), ] (fn [m, p, r, ] => Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ]) | _ => raise Arg.ExtractFailure)
fun sumElimIstype a b c e m = Arg.make "sumElimIstype" [] (Elim (const_istp, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, c)), App (Lam (NONE, e)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_istp, [App (e), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimEqtype a b c d e f m n = Arg.make "sumElimEqtype" [] (Elim (const_eqtp, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, c)), App (Lam (NONE, e)), ])), App (Elim (const_sum_case, [App (n), App (Lam (NONE, d)), App (Lam (NONE, f)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (c), App (d), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_eqtp, [App (e), App (f), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val sum_caseType = Arg.make "sum_caseType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 1), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 2), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_sum, [App (Var 2), App (Var 1), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 2), App (Var 0), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 1), App (Var 0), ])), App (Var 0), ])), ])), ]))), ]))), ]))), ]))), ])), App (const_sum_case), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormInv1 a b = Arg.make "sumFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormInv2 a b = Arg.make "sumFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureKind i k = Arg.make "futureKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_future, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureKindEq i k l = Arg.make "futureKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_future, [App (k), ])), App (Elim (const_future, [App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureForm a = Arg.make "futureForm" [] (Elim (const_istp, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEq a b = Arg.make "futureEq" [] (Elim (const_eqtp, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureFormUniv a i = Arg.make "futureFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_future, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEqUniv a b i = Arg.make "futureEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureSub a b = Arg.make "futureSub" [] (Elim (const_subtype, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntroOf a m = Arg.make "futureIntroOf" [] (Elim (const_of, [App (Elim (const_future, [App (a), ])), App (Next (m)), ])) [(Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntroEq a m n = Arg.make "futureIntroEq" [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (Next (m)), App (Next (n)), ])) [(Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntro a = Arg.make "futureIntro" [] (Elim (const_future, [App (a), ])) [(Arg.Promote, [], a), ] (fn [m, ] => Next (m) | _ => raise Arg.ExtractFailure)
fun futureElimOf a b m p = Arg.make "futureElimOf" [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (p, Dot (Elim (m, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimOfLetnext a b m p = Arg.make "futureElimOfLetnext" [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Elim (const_letnext, [App (m), App (Lam (NONE, p)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimOfLetnextNondep a b m p = Arg.make "futureElimOfLetnextNondep" [] (Elim (const_of, [App (b), App (Elim (const_letnext, [App (m), App (Lam (NONE, p)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimEq a b m n p q = Arg.make "futureElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (p, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (q, Dot (Elim (n, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimIstype a b m = Arg.make "futureElimIstype" [] (Elim (const_istp, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimIstypeLetnext a b m = Arg.make "futureElimIstypeLetnext" [] (Elim (const_istp, [App (Elim (const_letnext, [App (m), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimEqtype a b c m n = Arg.make "futureElimEqtype" [] (Elim (const_eqtp, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (c, Dot (Elim (n, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEta a m = Arg.make "futureEta" [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (Next (Elim (m, [Prev, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureExt a m n = Arg.make "futureExt" [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (Elim (m, [Prev, ])), App (Elim (n, [Prev, ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureLeft gsize a b = Arg.lmake "futureLeft" [] gsize [J.Tm (Elim (const_future, [App (a), ])), ] (b) [(Arg.PromoteUnhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tml (a), ], SOME (Dot (Next (Var 0), Shift 1)), Sub (b, under gsize (Dot (Next (Var 0), Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Prev, ]), Shift 1))) | _ => raise Arg.ExtractFailure)
fun recKind i k = Arg.make "recKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, k)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_kind, [App (i), ])), ], Elim (const_of, [App (Elim (const_kind, [App (Sub (i, Shift 1)), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recKindEq i k l = Arg.make "recKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, k)), ])), App (Elim (const_rec, [App (Lam (NONE, l)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_kind, [App (i), ])), ], Elim (const_eq, [App (Elim (const_kind, [App (Sub (i, Shift 1)), ])), App (k), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recForm a = Arg.make "recForm" [] (Elim (const_istp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recEq a b = Arg.make "recEq" [] (Elim (const_eqtp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Elim (const_rec, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recFormUniv a i = Arg.make "recFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recEqUniv a b i = Arg.make "recEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Elim (const_rec, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUnroll a = Arg.make "recUnroll" [] (Elim (const_eqtp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_rec, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUnrollUniv a i = Arg.make "recUnrollUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_rec, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recBisimilar a b = Arg.make "recBisimilar" [] (Elim (const_eqtp, [App (b), App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (Sub (a, Dot (b, Shift 0))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muForm a = Arg.make "muForm" [] (Elim (const_istp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muEq a b = Arg.make "muEq" [] (Elim (const_eqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Elim (const_mu, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, b)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muFormUniv a i = Arg.make "muFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muEqUniv a b i = Arg.make "muEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Elim (const_mu, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, b)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUnroll a = Arg.make "muUnroll" [] (Elim (const_eeqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_mu, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun muUnrollUniv a i = Arg.make "muUnrollUniv" [] (Elim (const_eeqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_mu, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun muInd a b m = Arg.make "muInd" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Var 2), App (Lam (NONE, Sub (b, Idot (0, Shift 4)))), ])), J.Tm (Elim (const_subtype, [App (Var 1), App (Elim (const_mu, [App (Lam (NONE, Sub (a, Idot (0, Shift 3)))), ])), ])), J.Tm (a), J.Tph, ], Sub (b, Idot (2, Shift 4))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, n, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Sub (n, Idot (1, Dot (Triv, Idot (0, Dot (Triv, Shift 2)))))))), App (m), ]) | _ => raise Arg.ExtractFailure)
fun muIndUniv a b i m = Arg.make "muIndUniv" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Var 2), App (Lam (NONE, Sub (b, Idot (0, Shift 4)))), ])), J.Tm (Elim (const_subtype, [App (Var 1), App (Elim (const_mu, [App (Lam (NONE, Sub (a, Idot (0, Shift 3)))), ])), ])), J.Tm (a), J.Tmh (Elim (const_univ, [App (i), ])), ], Elim (const_prod, [App (Sub (b, Idot (2, Shift 4))), App (Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 4)), ])), App (Sub (b, Idot (2, Shift 4))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, n, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Elim (Sub (n, Idot (1, Dot (Triv, Idot (0, Dot (Triv, Shift 2))))), [Pi1, ])))), App (m), ]) | _ => raise Arg.ExtractFailure)
val voidForm = Arg.make "voidForm" [] (Elim (const_istp, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val voidEq = Arg.make "voidEq" [] (Elim (const_eqtp, [App (const_void), App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun voidFormUniv i = Arg.make "voidFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_void), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidEqUniv i = Arg.make "voidEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_void), App (const_void), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidElim a = Arg.make "voidElim" [] (a) [(Arg.Unhide, [], const_void), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidSub a = Arg.make "voidSub" [] (Elim (const_subtype, [App (const_void), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val abortType = Arg.make "abortType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (const_void), App (Var 0), ]))), ]))), ])), App (const_abort), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitKind i = Arg.make "unitKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitKindEq i = Arg.make "unitKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (const_unit), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitForm = Arg.make "unitForm" [] (Elim (const_istp, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitEq = Arg.make "unitEq" [] (Elim (const_eqtp, [App (const_unit), App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitFormUniv i = Arg.make "unitFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitEqUniv i = Arg.make "unitEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_unit), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitIntroOf = Arg.make "unitIntroOf" [] (Elim (const_of, [App (const_unit), App (Triv), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitIntro = Arg.make "unitIntro" [] (const_unit) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitExt m n = Arg.make "unitExt" [] (Elim (const_eq, [App (const_unit), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_unit), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (const_unit), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitLeft gsize b = Arg.lmake "unitLeft" [] gsize [J.Tm (const_unit), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
val boolForm = Arg.make "boolForm" [] (Elim (const_istp, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolEq = Arg.make "boolEq" [] (Elim (const_eqtp, [App (const_bool), App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolFormUniv i = Arg.make "boolFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_bool), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolEqUniv i = Arg.make "boolEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_bool), App (const_bool), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val boolIntro1Of = Arg.make "boolIntro1Of" [] (Elim (const_of, [App (const_bool), App (const_true), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolIntro2Of = Arg.make "boolIntro2Of" [] (Elim (const_of, [App (const_bool), App (const_false), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimOf a m p r = Arg.make "boolElimOf" [] (Elim (const_of, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_ite, [App (m), App (p), App (r), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (const_true, Shift 0))), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (const_false, Shift 0))), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimEq a m n p q r s = Arg.make "boolElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_ite, [App (m), App (p), App (r), ])), App (Elim (const_ite, [App (n), App (q), App (s), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_true, Shift 0))), App (p), App (q), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_false, Shift 0))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElim a m = Arg.make "boolElim" [m, ] (Sub (a, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Nothing, [], Sub (a, Dot (const_true, Shift 0))), (Arg.Nothing, [], Sub (a, Dot (const_false, Shift 0))), ] (fn [_, p, r, ] => Elim (const_ite, [App (m), App (p), App (r), ]) | _ => raise Arg.ExtractFailure)
fun boolElimIstype a c m = Arg.make "boolElimIstype" [] (Elim (const_istp, [App (Elim (const_ite, [App (m), App (a), App (c), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimEqtype a b c d m n = Arg.make "boolElimEqtype" [] (Elim (const_eqtp, [App (Elim (const_ite, [App (m), App (a), App (c), ])), App (Elim (const_ite, [App (n), App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolLeft gsize a = Arg.lmake "boolLeft" [] gsize [J.Tm (const_bool), ] (a) [(Arg.Nothing, [], SOME (Dot (const_true, Shift 0)), Sub (a, under gsize (Dot (const_true, Shift 0)))), (Arg.Nothing, [], SOME (Dot (const_false, Shift 0)), Sub (a, under gsize (Dot (const_false, Shift 0)))), ] (fn [m, n, ] => Elim (const_ite, [App (Var gsize ), App (Sub (m, under gsize (Shift 1))), App (Sub (n, under gsize (Shift 1))), ]) | _ => raise Arg.ExtractFailure)
val iteType = Arg.make "iteType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (const_bool), App (Elim (const_arrow, [App (Var 0), App (Elim (const_arrow, [App (Var 0), App (Var 0), ])), ])), ]))), ]))), ])), App (const_ite), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val natForm = Arg.make "natForm" [] (Elim (const_istp, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val natEq = Arg.make "natEq" [] (Elim (const_eqtp, [App (const_nat), App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun natFormUniv i = Arg.make "natFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_nat), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natEqUniv i = Arg.make "natEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_nat), App (const_nat), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natElimEq a m n p q r s = Arg.make "natElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_nat_case, [App (m), App (p), App (Lam (NONE, r)), ])), App (Elim (const_nat_case, [App (n), App (q), App (Lam (NONE, s)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_zero, Shift 0))), App (p), App (q), ])), (Arg.Unhide, [J.Tm (const_nat), ], Elim (const_eq, [App (Sub (a, Dot (Elim (const_succ, [App (Var 0), ]), Shift 1))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun natElimEqtype a b c d m n = Arg.make "natElimEqtype" [] (Elim (const_eqtp, [App (Elim (const_nat_case, [App (m), App (a), App (Lam (NONE, c)), ])), App (Elim (const_nat_case, [App (n), App (b), App (Lam (NONE, d)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [J.Tm (const_nat), ], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val zeroType = Arg.make "zeroType" [] (Elim (const_of, [App (const_nat), App (const_zero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val succType = Arg.make "succType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_nat), App (const_nat), ])), App (const_succ), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun univKind i j = Arg.make "univKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univKindEq i j k = Arg.make "univKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), App (Elim (const_univ, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (k), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (i), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForm i = Arg.make "univForm" [] (Elim (const_istp, [App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univEq i j = Arg.make "univEq" [] (Elim (const_eqtp, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormUniv i j = Arg.make "univFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (j), ])), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormUnivSucc i = Arg.make "univFormUnivSucc" [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univEqUniv i j k = Arg.make "univEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), App (Elim (const_univ, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (j), ])), App (i), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeOf a i j = Arg.make "univCumulativeOf" [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeEq a b i j = Arg.make "univCumulativeEq" [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeSuccOf a i = Arg.make "univCumulativeSuccOf" [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univSub i j = Arg.make "univSub" [] (Elim (const_subtype, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForgetOf a i = Arg.make "univForgetOf" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForgetEq a b i = Arg.make "univForgetEq" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univIntroEqtype a b i = Arg.make "univIntroEqtype" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormInv i = Arg.make "univFormInv" [] (Elim (const_of, [App (const_level), App (i), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_univ, [App (i), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForm i = Arg.make "kindForm" [] (Elim (const_istp, [App (Elim (const_kind, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindEq i j = Arg.make "kindEq" [] (Elim (const_eqtp, [App (Elim (const_kind, [App (i), ])), App (Elim (const_kind, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindFormUniv i k = Arg.make "kindFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (k), ])), App (Elim (const_kind, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (Elim (const_lsucc, [App (i), ])), ])), App (k), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindEqUniv i j k = Arg.make "kindEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (k), ])), App (Elim (const_kind, [App (i), ])), App (Elim (const_kind, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), (Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (Elim (const_lsucc, [App (i), ])), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForgetOf a i = Arg.make "kindForgetOf" [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForgetEq a b i = Arg.make "kindForgetEq" [] (Elim (const_eq, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindUnivSub i j = Arg.make "kindUnivSub" [] (Elim (const_subtype, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (i), ])), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val levelForm = Arg.make "levelForm" [] (Elim (const_istp, [App (const_level), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val levelEq = Arg.make "levelEq" [] (Elim (const_eqtp, [App (const_level), App (const_level), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun levelFormUniv i = Arg.make "levelFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_level), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun levelEqUniv i = Arg.make "levelEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_level), App (const_level), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqForm i j = Arg.make "lleqForm" [] (Elim (const_istp, [App (Elim (const_lleq, [App (i), App (j), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqEq i i' j j' = Arg.make "lleqEq" [] (Elim (const_eqtp, [App (Elim (const_lleq, [App (i), App (j), ])), App (Elim (const_lleq, [App (i'), App (j'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (i'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (j'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqFormUniv i j k = Arg.make "lleqFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (k), ])), App (Elim (const_lleq, [App (i), App (j), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (j), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (k), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqEqUniv i i' j j' k = Arg.make "lleqEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (k), ])), App (Elim (const_lleq, [App (i), App (j), ])), App (Elim (const_lleq, [App (i'), App (j'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (i'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (j'), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (k), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val lzeroLevel = Arg.make "lzeroLevel" [] (Elim (const_of, [App (const_level), App (const_lzero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccLevel m = Arg.make "lsuccLevel" [] (Elim (const_of, [App (const_level), App (Elim (const_lsucc, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccEq m n = Arg.make "lsuccEq" [] (Elim (const_eq, [App (const_level), App (Elim (const_lsucc, [App (m), ])), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lmaxLevel m n = Arg.make "lmaxLevel" [] (Elim (const_of, [App (const_level), App (Elim (const_lmax, [App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lmaxEq m m' n n' = Arg.make "lmaxEq" [] (Elim (const_eq, [App (const_level), App (Elim (const_lmax, [App (m), App (n), ])), App (Elim (const_lmax, [App (m'), App (n'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqRefl m = Arg.make "lleqRefl" [] (Elim (const_lleq, [App (m), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqTrans m n p = Arg.make "lleqTrans" [] (Elim (const_lleq, [App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_lleq, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqZero m = Arg.make "lleqZero" [] (Elim (const_lleq, [App (const_lzero), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqSucc m n = Arg.make "lleqSucc" [] (Elim (const_lleq, [App (Elim (const_lsucc, [App (m), ])), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqIncrease m n = Arg.make "lleqIncrease" [] (Elim (const_lleq, [App (m), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxL m n p = Arg.make "lleqMaxL" [] (Elim (const_lleq, [App (Elim (const_lmax, [App (m), App (n), ])), App (p), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (p), ])), (Arg.Unhide, [], Elim (const_lleq, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxR1 m n p = Arg.make "lleqMaxR1" [] (Elim (const_lleq, [App (m), App (Elim (const_lmax, [App (n), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxR2 m n p = Arg.make "lleqMaxR2" [] (Elim (const_lleq, [App (m), App (Elim (const_lmax, [App (n), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqResp m m' n n' = Arg.make "lleqResp" [] (Elim (const_lleq, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m'), App (m), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (n'), App (n), ])), (Arg.Unhide, [], Elim (const_lleq, [App (m'), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccMaxDistTrans m n p = Arg.make "lsuccMaxDistTrans" [] (Elim (const_eq, [App (const_level), App (m), App (Elim (const_lsucc, [App (Elim (const_lmax, [App (n), App (p), ])), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (Elim (const_lmax, [App (Elim (const_lsucc, [App (n), ])), App (Elim (const_lsucc, [App (p), ])), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val lzeroType = Arg.make "lzeroType" [] (Elim (const_of, [App (const_level), App (const_lzero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val lsuccType = Arg.make "lsuccType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_level), App (const_level), ])), App (const_lsucc), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val lmaxType = Arg.make "lmaxType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_level), App (Elim (const_arrow, [App (const_level), App (const_level), ])), ])), App (const_lmax), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun eqForm a m p = Arg.make "eqForm" [] (Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqEq a b m n p q = Arg.make "eqEq" [] (Elim (const_eqtp, [App (Elim (const_eq, [App (a), App (m), App (p), ])), App (Elim (const_eq, [App (b), App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormUniv a i m p = Arg.make "eqFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eq, [App (a), App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqEqUniv a b i m n p q = Arg.make "eqEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eq, [App (a), App (m), App (p), ])), App (Elim (const_eq, [App (b), App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqIntro a m n = Arg.make "eqIntro" [] (Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqElim a m n p = Arg.make "eqElim" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqExt a m n p q = Arg.make "eqExt" [] (Elim (const_eq, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqLeft gsize a b p q = Arg.lmake "eqLeft" [] gsize [J.Tm (Elim (const_eq, [App (a), App (p), App (q), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun eqRefl a m = Arg.make "eqRefl" [] (Elim (const_eq, [App (a), App (m), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqSymm a m n = Arg.make "eqSymm" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (n), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqTrans a m n p = Arg.make "eqTrans" [] (Elim (const_eq, [App (a), App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv1 a m n = Arg.make "eqFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv2 a m n = Arg.make "eqFormInv2" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv3 a m n = Arg.make "eqFormInv3" [] (Elim (const_of, [App (a), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofForm a m = Arg.make "ofForm" [] (Elim (const_istp, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEq a b m n = Arg.make "ofEq" [] (Elim (const_eqtp, [App (Elim (const_of, [App (a), App (m), ])), App (Elim (const_of, [App (b), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofFormUniv a i m = Arg.make "ofFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEqUniv a b i m n = Arg.make "ofEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_of, [App (a), App (m), ])), App (Elim (const_of, [App (b), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofIntro a m = Arg.make "ofIntro" [] (Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofElim a m p = Arg.make "ofElim" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofTrivialize a m = Arg.make "ofTrivialize" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofExt a m p q = Arg.make "ofExt" [] (Elim (const_eq, [App (Elim (const_of, [App (a), App (m), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofLeft gsize a b p = Arg.lmake "ofLeft" [] gsize [J.Tm (Elim (const_of, [App (a), App (p), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun ofEquand1 a m n = Arg.make "ofEquand1" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEquand2 a m n = Arg.make "ofEquand2" [] (Elim (const_of, [App (a), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpForm a b = Arg.make "eqtpForm" [] (Elim (const_istp, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpEq a b c d = Arg.make "eqtpEq" [] (Elim (const_eqtp, [App (Elim (const_eqtp, [App (a), App (c), ])), App (Elim (const_eqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpFormUniv a b i = Arg.make "eqtpFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpEqUniv a b c d i = Arg.make "eqtpEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eqtp, [App (a), App (c), ])), App (Elim (const_eqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpIntro a b = Arg.make "eqtpIntro" [] (Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpElim a b p = Arg.make "eqtpElim" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpExt a b p q = Arg.make "eqtpExt" [] (Elim (const_eq, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpLeft gsize a b c = Arg.lmake "eqtpLeft" [] gsize [J.Tm (Elim (const_eqtp, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun eqtpFunct a b m n = Arg.make "eqtpFunct" [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (b, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalenceOf a b m = Arg.make "equivalenceOf" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalenceEq a b m n = Arg.make "equivalenceEq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalence a b = Arg.make "equivalence" [] (b) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun equivalenceLeft gsize a b c = Arg.lmake "equivalenceLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_istp, [App (a), ])), ], NONE, Elim (const_eqtp, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun eqtpRefl a = Arg.make "eqtpRefl" [] (Elim (const_eqtp, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpSymm a b = Arg.make "eqtpSymm" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (b), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpTrans a b c = Arg.make "eqtpTrans" [] (Elim (const_eqtp, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpForm a = Arg.make "istpForm" [] (Elim (const_istp, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpEq a b = Arg.make "istpEq" [] (Elim (const_eqtp, [App (Elim (const_istp, [App (a), ])), App (Elim (const_istp, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpFormUniv a i = Arg.make "istpFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpEqUniv a b i = Arg.make "istpEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_istp, [App (a), ])), App (Elim (const_istp, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpIntro a = Arg.make "istpIntro" [] (Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpElim a p = Arg.make "istpElim" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpExt a p q = Arg.make "istpExt" [] (Elim (const_eq, [App (Elim (const_istp, [App (a), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpLeft gsize a b = Arg.lmake "istpLeft" [] gsize [J.Tm (Elim (const_istp, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun inhabitedForm a = Arg.make "inhabitedForm" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeForm a b = Arg.make "subtypeForm" [] (Elim (const_istp, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeEq a b c d = Arg.make "subtypeEq" [] (Elim (const_eqtp, [App (Elim (const_subtype, [App (a), App (c), ])), App (Elim (const_subtype, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeFormUniv a b i = Arg.make "subtypeFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeEqUniv a b c d i = Arg.make "subtypeEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_subtype, [App (a), App (c), ])), App (Elim (const_subtype, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIntro a b = Arg.make "subtypeIntro" [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Var 0), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeExt a b p q = Arg.make "subtypeExt" [] (Elim (const_eq, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeLeft gsize a b c = Arg.lmake "subtypeLeft" [] gsize [J.Tm (Elim (const_subtype, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun subsumptionOf a b m = Arg.make "subsumptionOf" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumptionEq a b m n = Arg.make "subsumptionEq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumption a b = Arg.make "subsumption" [] (b) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLeft gsize a b c = Arg.lmake "subsumptionLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_istp, [App (a), ])), ], NONE, Elim (const_eeqtp, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subtypeRefl a = Arg.make "subtypeRefl" [] (Elim (const_subtype, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeReflEqtype a b = Arg.make "subtypeReflEqtype" [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeTrans a b c = Arg.make "subtypeTrans" [] (Elim (const_subtype, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIstp1 a b = Arg.make "subtypeIstp1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIstp2 a b = Arg.make "subtypeIstp2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setForm a b = Arg.make "setForm" [] (Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setEq a a' b b' = Arg.make "setEq" [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setFormUniv a b i = Arg.make "setFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setEqUniv a a' b b' i = Arg.make "setEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeakenOf a b m = Arg.make "setWeakenOf" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeakenEq a b m n = Arg.make "setWeakenEq" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeaken a b = Arg.make "setWeaken" [] (a) [(Arg.Nothing, [], Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun setIntroOf a b m = Arg.make "setIntroOf" [] (Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntroEq a b m n = Arg.make "setIntroEq" [] (Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntro a b m = Arg.make "setIntro" [m, ] (Elim (const_set, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => m | _ => raise Arg.ExtractFailure)
fun setIntroOfSquash a b m = Arg.make "setIntroOfSquash" [] (Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntroOfSquash a = Arg.make "squashIntroOfSquash" [] (Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setElim a b c m = Arg.make "setElim" [] (c) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (m, Shift 0))), ], Sub (c, Shift 1)), ] (fn [_, _, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun setLeft gsize a b c = Arg.lmake "setLeft" [] gsize [J.Tm (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Unhide, [J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tmh (b), J.Tm (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun setSquash a b = Arg.make "setSquash" [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a), App (Lam (NONE, Elim (const_squash, [App (b), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setFormInv a b = Arg.make "setFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setSubElim a a' b = Arg.make "setSubElim" [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (a'), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashForm a = Arg.make "squashForm" [] (Elim (const_istp, [App (Elim (const_squash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashEq a b = Arg.make "squashEq" [] (Elim (const_eqtp, [App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), ], Sub (a, Shift 1)), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashFormUniv a i = Arg.make "squashFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_squash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashEqUniv a b i = Arg.make "squashEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), (Arg.Unhide, [J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), ], Sub (a, Shift 1)), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntroOf a = Arg.make "squashIntroOf" [] (Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntro a = Arg.make "squashIntro" [] (Elim (const_squash, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashElim a c m = Arg.make "squashElim" [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (c, Shift 1)), ] (fn [_, _, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun squashExt a m n = Arg.make "squashExt" [] (Elim (const_eq, [App (Elim (const_squash, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (n), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashLeft gsize a c = Arg.lmake "squashLeft" [] gsize [J.Tm (Elim (const_squash, [App (a), ])), ] (c) [(Arg.Unhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], SOME (Dot (Triv, Shift 1)), Sub (c, under gsize (Dot (Triv, Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun quotientForm a b = Arg.make "quotientForm" [] (Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientEq a a' b b' = Arg.make "quotientEq" [] (Elim (const_eqtp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (Elim (const_quotient, [App (a'), App (Lam (NONE, Lam (NONE, b'))), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientFormUniv a b i = Arg.make "quotientFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientEqUniv a a' b b' i = Arg.make "quotientEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (Elim (const_quotient, [App (a'), App (Lam (NONE, Lam (NONE, b'))), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientIntroOf a b m = Arg.make "quotientIntroOf" [] (Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Dot (m, Shift 0)))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientIntroEq a b m n = Arg.make "quotientIntroEq" [] (Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (n, Dot (m, Shift 0)))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimOf a b c m p = Arg.make "quotientElimOf" [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Shift 2)), App (Sub (p, Idot (1, Shift 3))), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimEq a b c m n p q = Arg.make "quotientElimEq" [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Shift 2)), App (Sub (q, Idot (1, Shift 3))), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimIstype a b c m = Arg.make "quotientElimIstype" [] (Elim (const_istp, [App (Sub (c, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Shift 2)), App (Sub (c, Idot (1, Shift 3))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimEqtype a b c d m n = Arg.make "quotientElimEqtype" [] (Elim (const_eqtp, [App (Sub (c, Dot (m, Shift 0))), App (Sub (d, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Shift 2)), App (Sub (d, Idot (1, Shift 3))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientDescent a b c m n = Arg.make "quotientDescent" [] (c) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (n, Dot (m, Shift 0)))), ], Sub (c, Shift 1)), ] (fn [_, _, _, _, _, p, ] => Sub (p, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun quotientLeft gsize a b c = Arg.lmake "quotientLeft" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], SOME (Shift 0), Elim (const_istp, [App (c), ])), (Arg.Nothing, [J.Tmh (a), ], SOME (Shift 0), c), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun quotientLeftRefl gsize a b c = Arg.lmake "quotientLeftRefl" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (c) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], SOME (Shift 0), Elim (const_istp, [App (c), ])), (Arg.Nothing, [J.Tmh (Sub (b, Idot (0, Shift 0))), J.Tmh (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, _, m, ] => Sub (m, under gsize (Dot (Triv, Dot (Triv, Shift 1)))) | _ => raise Arg.ExtractFailure)
fun quotientLeftIstype gsize a b c = Arg.lmake "quotientLeftIstype" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_istp, [App (c), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEqtype gsize a b c d = Arg.lmake "quotientLeftEqtype" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eqtp, [App (c), App (d), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (d, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftOf gsize a b c m = Arg.lmake "quotientLeftOf" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_of, [App (Sub (c, under gsize (Shift 1))), App (m), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 3))), App (Sub (m, under gsize (Shift 2))), App (Sub (m, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEq gsize a b c m n = Arg.lmake "quotientLeftEq" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eq, [App (Sub (c, under gsize (Shift 1))), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 3))), App (Sub (m, under gsize (Shift 2))), App (Sub (n, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftOfDep gsize a b c m = Arg.lmake "quotientLeftOfDep" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_of, [App (c), App (m), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 2))), App (Sub (m, under gsize (Shift 2))), App (Sub (m, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEqDep gsize a b c m n = Arg.lmake "quotientLeftEqDep" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eq, [App (c), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 2))), App (Sub (m, under gsize (Shift 2))), App (Sub (n, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientFormInv a b = Arg.make "quotientFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallForm a i k = Arg.make "iforallForm" [] (Elim (const_istp, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallEq a b i k l = Arg.make "iforallEq" [] (Elim (const_eqtp, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iforall, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallFormUniv a i j k = Arg.make "iforallFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallEqUniv a b i j k l = Arg.make "iforallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iforall, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntroOf a i k m = Arg.make "iforallIntroOf" [] (Elim (const_of, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (a), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntroEq a i k m n = Arg.make "iforallIntroEq" [] (Elim (const_eq, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (a), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntro a i k = Arg.make "iforallIntro" [] (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Nothing, [J.Tmh (k), ], a), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun iforallElimOf a i k m p = Arg.make "iforallElimOf" [] (Elim (const_of, [App (Sub (a, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallElimEq a i k m n p = Arg.make "iforallElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallElim a i k p = Arg.make "iforallElim" [] (Sub (a, Dot (p, Shift 0))) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, m, _, ] => m | _ => raise Arg.ExtractFailure)
fun foralltpForm a = Arg.make "foralltpForm" [] (Elim (const_istp, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpEq a b = Arg.make "foralltpEq" [] (Elim (const_eqtp, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (Elim (const_foralltp, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntroOf a m = Arg.make "foralltpIntroOf" [] (Elim (const_of, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_of, [App (a), App (Sub (m, Shift 1)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntroEq a m n = Arg.make "foralltpIntroEq" [] (Elim (const_eq, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eq, [App (a), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntro a = Arg.make "foralltpIntro" [] (Elim (const_foralltp, [App (Lam (NONE, a)), ])) [(Arg.Nothing, [J.Tph, ], a), ] (fn [m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun foralltpElimOf a b m = Arg.make "foralltpElimOf" [] (Elim (const_of, [App (Sub (a, Dot (b, Shift 0))), App (m), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpElimEq a b m n = Arg.make "foralltpElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (b, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpElim a b = Arg.make "foralltpElim" [] (Sub (a, Dot (b, Shift 0))) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_foralltp, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, m, _, ] => m | _ => raise Arg.ExtractFailure)
fun iexistsForm a i k = Arg.make "iexistsForm" [] (Elim (const_istp, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsEq a b i k l = Arg.make "iexistsEq" [] (Elim (const_eqtp, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iexists, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsFormUniv a i j k = Arg.make "iexistsFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsEqUniv a b i j k l = Arg.make "iexistsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iexists, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntroOf a b i k m = Arg.make "iexistsIntroOf" [] (Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (b, Shift 0))), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntroEq a b i k m n = Arg.make "iexistsIntroEq" [] (Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (b, Shift 0))), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntro a b i k = Arg.make "iexistsIntro" [] (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Nothing, [], Sub (a, Dot (b, Shift 0))), ] (fn [_, _, _, m, ] => m | _ => raise Arg.ExtractFailure)
fun iexistsElimOf a b i k m p = Arg.make "iexistsElimOf" [] (Elim (const_of, [App (b), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_of, [App (Sub (b, Shift 2)), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEq a b i k m n p q = Arg.make "iexistsElimEq" [] (Elim (const_eq, [App (b), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eq, [App (Sub (b, Shift 2)), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElim a b i k m = Arg.make "iexistsElim" [m, ] (b) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), J.Tmh (k), ], Sub (b, Shift 2)), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun iexistsElimIstype a b i k m = Arg.make "iexistsElimIstype" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_istp, [App (Sub (b, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEqtype a b c i k m n = Arg.make "iexistsElimEqtype" [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (c, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eqtp, [App (Sub (b, Idot (0, Shift 2))), App (Sub (c, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun substitution gsize a b m = Arg.lmake "substitution" [] gsize [J.Tm (a), ] (b) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), Sub (b, under gsize (Dot (m, Shift 0)))), ] (fn [_, _, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun substitutionSimple gsize a b m = Arg.lmake "substitutionSimple" [] gsize [J.Tm (a), ] (Sub (b, under gsize (Shift 1))) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), b), ] (fn [_, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun generalize a b m = Arg.make "generalize" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [J.Tm (a), ], b), ] (fn [_, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun assert a b = Arg.make "assert" [] (b) [(Arg.Nothing, [], a), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Elim (const_let, [App (m), App (Lam (NONE, n)), ]) | _ => raise Arg.ExtractFailure)
fun assert' a b = Arg.make "assert'" [] (b) [(Arg.Nothing, [], a), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun inhabitant a m = Arg.make "inhabitant" [m, ] (a) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => m | _ => raise Arg.ExtractFailure)
fun letForm a b m n = Arg.make "letForm" [] (Elim (const_of, [App (b), App (Elim (const_let, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpSymm a b = Arg.make "eeqtpSymm" [] (Elim (const_eeqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun weakenEqtpEeqtp a b = Arg.make "weakenEqtpEeqtp" [] (Elim (const_eeqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun accInd a b i m n r = Arg.make "accInd" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (Elim (const_arrow, [App (a), App (Elim (const_univ, [App (i), ])), ])), ])), App (r), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Sub (a, Shift 1)), App (Lam (NONE, Elim (const_arrow, [App (Elim (Sub (r, Shift 2), [App (Var 0), App (Var 1), ])), App (Sub (b, Idot (0, Shift 2))), ]))), ])), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_acc, [App (a), App (r), App (m), ])), App (n), ])), ] (fn [_, _, p, _, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Sub (p, Dot (Lam (NONE, Lam (NONE, Elim (Var 3, [App (Var 1), ]))), Idot (0, Shift 2)))))), App (m), ]) | _ => raise Arg.ExtractFailure)
val integerForm = Arg.make "integerForm" [] (Elim (const_istp, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerEq = Arg.make "integerEq" [] (Elim (const_eqtp, [App (const_integer), App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerFormUniv i = Arg.make "integerFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_integer), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun integerEqUniv i = Arg.make "integerEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_integer), App (const_integer), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val integerToDefType = Arg.make "integerToDefType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_integer), App (const_integer_def), ])), App (const_integer_to_def), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerFromDefType = Arg.make "integerFromDefType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_integer_def), App (const_integer), ])), App (const_integer_from_def), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerIsomorphism1 = Arg.make "integerIsomorphism1" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), App (Lam (NONE, Elim (const_integer_from_def, [App (Elim (const_integer_to_def, [App (Var 0), ])), ]))), App (Lam (NONE, Var 0)), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerIsomorphism2 = Arg.make "integerIsomorphism2" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer_def), App (const_integer_def), ])), App (Lam (NONE, Elim (const_integer_to_def, [App (Elim (const_integer_from_def, [App (Var 0), ])), ]))), App (Lam (NONE, Var 0)), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val pluszSpec = Arg.make "pluszSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), ])), App (const_plusz), App (Lam (NONE, Lam (NONE, Elim (const_integer_from_def, [App (Elim (const_plusz_def, [App (Elim (const_integer_to_def, [App (Var 1), ])), App (Elim (const_integer_to_def, [App (Var 0), ])), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val negzSpec = Arg.make "negzSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), App (const_negz), App (Lam (NONE, Elim (const_integer_from_def, [App (Elim (const_negz_def, [App (Elim (const_integer_to_def, [App (Var 0), ])), ])), ]))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val eqzbSpec = Arg.make "eqzbSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_bool), ])), ])), App (const_eqzb), App (Lam (NONE, Lam (NONE, Elim (const_eqzb_def, [App (Elim (const_integer_to_def, [App (Var 1), ])), App (Elim (const_integer_to_def, [App (Var 0), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val leqzbSpec = Arg.make "leqzbSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_bool), ])), ])), App (const_leqzb), App (Lam (NONE, Lam (NONE, Elim (const_leqzb_def, [App (Elim (const_integer_to_def, [App (Var 1), ])), App (Elim (const_integer_to_def, [App (Var 0), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val timeszSpec = Arg.make "timeszSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), ])), App (const_timesz), App (Lam (NONE, Lam (NONE, Elim (const_integer_from_def, [App (Elim (const_timesz_def, [App (Elim (const_integer_to_def, [App (Var 1), ])), App (Elim (const_integer_to_def, [App (Var 0), ])), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)

end
