(* This file is generated by Rulegen. *)

signature RULE_ARG =
   sig

      type result
      type rule

      exception ExtractFailure

      datatype context_action =
         Nothing
       | Promote
       | Unhide
       | PromoteUnhide

      val make :
         string                                                      (* name *)
         -> Term.term list                                           (* hidden variables *)
         -> Term.term                                                (* conclusion *)
         -> (context_action * Judgement.hyp list * Term.term) list   (* premises *)
         -> (Term.term list -> Term.term)                            (* extract *)
         -> rule

      val lmake :
         string                             (* name *)
         -> Term.term list                  (* hidden variables *)
         -> int                             (* size of trailing context *)
         -> Judgement.hyp list              (* conclusion floating context *)
         -> Term.term                       (* conclusion rhs *)
         -> (context_action * Judgement.hyp list * Term.sub option * Term.term) list  (* premises *)
         -> (Term.term list -> Term.term)   (* extract *)
         -> rule

   end


signature THE_RULES =
   sig

      type term = Term.term
      type rule

      val forallForm : term -> term -> rule
      val forallEq : term -> term -> term -> term -> rule
      val forallFormUniv : term -> term -> term -> rule
      val forallEqUniv : term -> term -> term -> term -> term -> rule
      val forallSub : term -> term -> term -> term -> rule
      val forallIntroOf : term -> term -> term -> rule
      val forallIntroEq : term -> term -> term -> term -> rule
      val forallIntro : term -> term -> rule
      val forallElimOf : term -> term -> term -> term -> rule
      val forallElimEq : term -> term -> term -> term -> term -> term -> rule
      val forallElim : term -> term -> term -> rule
      val forallEta : term -> term -> term -> rule
      val forallExt : term -> term -> term -> term -> rule
      val forallExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val forallOfExt : term -> term -> term -> term -> term -> rule
      val forallFormInv1 : term -> term -> rule
      val forallFormInv2 : term -> term -> term -> rule
      val arrowForm : term -> term -> rule
      val arrowEq : term -> term -> term -> term -> rule
      val arrowFormUniv : term -> term -> term -> rule
      val arrowEqUniv : term -> term -> term -> term -> term -> rule
      val arrowForallEq : term -> term -> term -> term -> rule
      val arrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val arrowSub : term -> term -> term -> term -> rule
      val arrowForallSub : term -> term -> term -> term -> rule
      val forallArrowSub : term -> term -> term -> term -> rule
      val arrowIntroOf : term -> term -> term -> rule
      val arrowIntroEq : term -> term -> term -> term -> rule
      val arrowIntro : term -> term -> rule
      val arrowElimOf : term -> term -> term -> term -> rule
      val arrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val arrowElim : term -> term -> rule
      val arrowEta : term -> term -> term -> rule
      val arrowExt : term -> term -> term -> term -> rule
      val arrowExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val arrowOfExt : term -> term -> term -> term -> term -> rule
      val arrowFormInv1 : term -> term -> rule
      val arrowFormInv2 : term -> term -> term -> rule
      val tarrowKind : term -> term -> term -> rule
      val tarrowKindEq : term -> term -> term -> term -> term -> rule
      val tarrowForm : term -> term -> rule
      val tarrowEq : term -> term -> term -> term -> rule
      val tarrowFormUniv : term -> term -> term -> rule
      val tarrowEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowArrowEq : term -> term -> term -> term -> rule
      val tarrowArrowEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowForallEq : term -> term -> term -> term -> rule
      val tarrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowIntroOf : term -> term -> term -> rule
      val tarrowIntroEq : term -> term -> term -> term -> rule
      val tarrowIntro : term -> term -> rule
      val tarrowElimOf : term -> term -> term -> term -> rule
      val tarrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val tarrowElim : term -> term -> rule
      val tarrowEta : term -> term -> term -> rule
      val tarrowExt : term -> term -> term -> term -> rule
      val tarrowOfExt : term -> term -> term -> term -> term -> rule
      val karrowKind : term -> term -> term -> rule
      val karrowKindEq : term -> term -> term -> term -> term -> rule
      val karrowForm : term -> term -> rule
      val karrowEq : term -> term -> term -> term -> rule
      val karrowFormUniv : term -> term -> term -> rule
      val karrowEqUniv : term -> term -> term -> term -> term -> rule
      val karrowArrowEq : term -> term -> term -> term -> rule
      val karrowArrowEqUniv : term -> term -> term -> term -> term -> rule
      val karrowForallEq : term -> term -> term -> term -> rule
      val karrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val karrowIntroOf : term -> term -> term -> rule
      val karrowIntroEq : term -> term -> term -> term -> rule
      val karrowIntro : term -> term -> rule
      val karrowElimOf : term -> term -> term -> term -> rule
      val karrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val karrowElim : term -> term -> rule
      val karrowEta : term -> term -> term -> rule
      val karrowExt : term -> term -> term -> term -> rule
      val karrowOfExt : term -> term -> term -> term -> term -> rule
      val intersectForm : term -> term -> rule
      val intersectEq : term -> term -> term -> term -> rule
      val intersectFormUniv : term -> term -> term -> rule
      val intersectEqUniv : term -> term -> term -> term -> term -> rule
      val intersectSub : term -> term -> term -> term -> rule
      val intersectIntroOf : term -> term -> term -> rule
      val intersectIntroEq : term -> term -> term -> term -> rule
      val intersectIntro : term -> term -> rule
      val intersectElimOf : term -> term -> term -> term -> rule
      val intersectElimEq : term -> term -> term -> term -> term -> rule
      val intersectElim : term -> term -> term -> rule
      val intersectFormInv1 : term -> term -> rule
      val intersectFormInv2 : term -> term -> term -> rule
      val parametricForm : term -> term -> rule
      val parametricEq : term -> term -> term -> term -> rule
      val parametricFormUniv : term -> term -> term -> rule
      val parametricEqUniv : term -> term -> term -> term -> term -> rule
      val parametricSub : term -> term -> term -> term -> rule
      val parametricForallSub : term -> term -> term -> term -> rule
      val parametricIntroOf : term -> term -> term -> rule
      val parametricIntroEq : term -> term -> term -> term -> rule
      val parametricIntro : term -> term -> rule
      val parametricIntroOfForall : term -> term -> term -> rule
      val parametricElimOf : term -> term -> term -> term -> rule
      val parametricElimEq : term -> term -> term -> term -> term -> term -> rule
      val parametricElim : term -> term -> term -> rule
      val parametricBeta : term -> term -> rule
      val parametricEta : term -> term -> term -> rule
      val parametricExt : term -> term -> term -> term -> rule
      val parametricExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val parametricOfExt : term -> term -> term -> term -> term -> rule
      val parametricFormInv1 : term -> term -> rule
      val parametricFormInv2 : term -> term -> term -> rule
      val parametricElimIrrelevant : term -> term -> term -> rule
      val irrelevance : term -> rule
      val forallfutForm : term -> term -> rule
      val forallfutEq : term -> term -> term -> term -> rule
      val forallfutFormUniv : term -> term -> term -> rule
      val forallfutEqUniv : term -> term -> term -> term -> term -> rule
      val forallfutSub : term -> term -> term -> term -> rule
      val forallfutForallVoidSub : term -> term -> term -> rule
      val forallfutIntroOf : term -> term -> term -> rule
      val forallfutIntroEq : term -> term -> term -> term -> rule
      val forallfutIntro : term -> term -> rule
      val forallfutElimOf : term -> term -> term -> term -> rule
      val forallfutElimEq : term -> term -> term -> term -> term -> term -> rule
      val forallfutElim : term -> term -> term -> rule
      val forallfutExt : term -> term -> term -> term -> rule
      val forallfutExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val forallfutOfExt : term -> term -> term -> term -> term -> rule
      val guardForm : term -> term -> rule
      val guardEq : term -> term -> term -> term -> rule
      val guardFormUniv : term -> term -> term -> rule
      val guardEqUniv : term -> term -> term -> term -> term -> rule
      val guardIntroOf : term -> term -> term -> rule
      val guardIntroEq : term -> term -> term -> term -> rule
      val guardIntro : term -> term -> rule
      val guardElimOf : term -> term -> term -> rule
      val guardElimEq : term -> term -> term -> term -> rule
      val guardElim : term -> term -> rule
      val guardSatEq : term -> term -> rule
      val guardSub : term -> term -> term -> term -> rule
      val guardSubIntro : term -> term -> term -> rule
      val guardSubElim : term -> term -> term -> rule
      val coguardForm : term -> term -> rule
      val coguardEq : term -> term -> term -> term -> rule
      val coguardFormUniv : term -> term -> term -> rule
      val coguardEqUniv : term -> term -> term -> term -> term -> rule
      val coguardIntroEq : term -> term -> term -> term -> rule
      val coguardIntroOf : term -> term -> term -> rule
      val coguardIntroOfSquash : term -> term -> term -> rule
      val coguardIntro : term -> term -> rule
      val coguardElim1 : term -> term -> rule
      val coguardElim2Eq : term -> term -> term -> term -> rule
      val coguardElim2Of : term -> term -> term -> rule
      val coguardElim2 : term -> term -> rule
      val coguardLeft : int -> term -> term -> term -> rule
      val coguardSatEq : term -> term -> rule
      val coguardSub : term -> term -> term -> term -> rule
      val coguardSubIntro : term -> term -> term -> rule
      val coguardSubElim : term -> term -> term -> rule
      val existsForm : term -> term -> rule
      val existsEq : term -> term -> term -> term -> rule
      val existsFormUniv : term -> term -> term -> rule
      val existsEqUniv : term -> term -> term -> term -> term -> rule
      val existsSub : term -> term -> term -> term -> rule
      val existsIntroOf : term -> term -> term -> term -> rule
      val existsIntroEq : term -> term -> term -> term -> term -> term -> rule
      val existsIntro : term -> term -> term -> rule
      val existsElim1Of : term -> term -> term -> rule
      val existsElim1Eq : term -> term -> term -> term -> rule
      val existsElim1 : term -> term -> rule
      val existsElim2Of : term -> term -> term -> rule
      val existsElim2Eq : term -> term -> term -> term -> rule
      val existsEta : term -> term -> term -> rule
      val existsExt : term -> term -> term -> term -> rule
      val existsLeft : int -> term -> term -> term -> rule
      val existsFormInv1 : term -> term -> rule
      val existsFormInv2 : term -> term -> term -> rule
      val existsFormInv2Eq : term -> term -> term -> term -> rule
      val prodKind : term -> term -> term -> rule
      val prodKindEq : term -> term -> term -> term -> term -> rule
      val prodForm : term -> term -> rule
      val prodEq : term -> term -> term -> term -> rule
      val prodFormUniv : term -> term -> term -> rule
      val prodEqUniv : term -> term -> term -> term -> term -> rule
      val prodExistsEq : term -> term -> term -> term -> rule
      val prodExistsEqUniv : term -> term -> term -> term -> term -> rule
      val prodSub : term -> term -> term -> term -> rule
      val prodExistsSub : term -> term -> term -> term -> rule
      val existsProdSub : term -> term -> term -> term -> rule
      val prodIntroOf : term -> term -> term -> term -> rule
      val prodIntroEq : term -> term -> term -> term -> term -> term -> rule
      val prodIntro : term -> term -> rule
      val prodElim1Of : term -> term -> term -> rule
      val prodElim1Eq : term -> term -> term -> term -> rule
      val prodElim1 : term -> term -> rule
      val prodElim2Of : term -> term -> term -> rule
      val prodElim2Eq : term -> term -> term -> term -> rule
      val prodElim2 : term -> term -> rule
      val prodEta : term -> term -> term -> rule
      val prodExt : term -> term -> term -> term -> rule
      val prodLeft : int -> term -> term -> term -> rule
      val prodFormInv1 : term -> term -> rule
      val prodFormInv2 : term -> term -> rule
      val dprodForm : term -> term -> rule
      val dprodEq : term -> term -> term -> term -> rule
      val dprodFormUniv : term -> term -> term -> rule
      val dprodEqUniv : term -> term -> term -> term -> term -> rule
      val dprodExistsEq : term -> term -> term -> term -> rule
      val dprodExistsEqUniv : term -> term -> term -> term -> term -> rule
      val prodDprodEq : term -> term -> term -> term -> rule
      val prodDprodEqUniv : term -> term -> term -> term -> term -> rule
      val dprodSub : term -> term -> term -> term -> rule
      val dprodExistsSub : term -> term -> term -> term -> rule
      val existsDprodSub : term -> term -> term -> term -> rule
      val dprodProdSub : term -> term -> term -> term -> rule
      val prodDprodSub : term -> term -> term -> term -> rule
      val dprodIntroOf : term -> term -> term -> term -> rule
      val dprodIntroEq : term -> term -> term -> term -> term -> term -> rule
      val dprodIntro : term -> term -> rule
      val dprodElim1Of : term -> term -> term -> rule
      val dprodElim1Eq : term -> term -> term -> term -> rule
      val dprodElim1 : term -> term -> rule
      val dprodElim2Of : term -> term -> term -> rule
      val dprodElim2Eq : term -> term -> term -> term -> rule
      val dprodElim2 : term -> term -> rule
      val dprodEta : term -> term -> term -> rule
      val dprodExt : term -> term -> term -> term -> rule
      val dprodLeft : int -> term -> term -> term -> rule
      val dprodFormInv1 : term -> term -> rule
      val dprodFormInv2 : term -> term -> term -> rule
      val unionForm : term -> term -> rule
      val unionEq : term -> term -> term -> term -> rule
      val unionFormUniv : term -> term -> term -> rule
      val unionEqUniv : term -> term -> term -> term -> term -> rule
      val unionSub : term -> term -> term -> term -> rule
      val unionIntroOf : term -> term -> term -> term -> rule
      val unionIntroEq : term -> term -> term -> term -> term -> rule
      val unionIntro : term -> term -> term -> rule
      val unionElimOf : term -> term -> term -> term -> term -> rule
      val unionElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val unionElim : term -> term -> term -> term -> rule
      val unionElimOfDep : term -> term -> term -> term -> term -> rule
      val unionElimEqDep : term -> term -> term -> term -> term -> term -> term -> rule
      val unionElimDep : term -> term -> term -> term -> rule
      val unionElimIstype : term -> term -> term -> term -> rule
      val unionElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val sumForm : term -> term -> rule
      val sumEq : term -> term -> term -> term -> rule
      val sumFormUniv : term -> term -> term -> rule
      val sumEqUniv : term -> term -> term -> term -> term -> rule
      val sumSub : term -> term -> term -> term -> rule
      val sumIntro1Of : term -> term -> term -> rule
      val sumIntro1Eq : term -> term -> term -> term -> rule
      val sumIntro1 : term -> term -> rule
      val sumIntro2Of : term -> term -> term -> rule
      val sumIntro2Eq : term -> term -> term -> term -> rule
      val sumIntro2 : term -> term -> rule
      val sumElimOf : term -> term -> term -> term -> term -> term -> rule
      val sumElimOfNondep : term -> term -> term -> term -> term -> term -> rule
      val sumElimEq : term -> term -> term -> term -> term -> term -> term -> term -> term -> rule
      val sumElim : term -> term -> term -> term -> rule
      val sumElimNondep : term -> term -> term -> rule
      val sumElimIstype : term -> term -> term -> term -> term -> rule
      val sumElimEqtype : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val sumContradiction : term -> term -> term -> term -> term -> rule
      val sumInjection1 : term -> term -> term -> term -> rule
      val sumInjection2 : term -> term -> term -> term -> rule
      val sum_caseType : rule
      val sumFormInv1 : term -> term -> rule
      val sumFormInv2 : term -> term -> rule
      val futureKind : term -> term -> rule
      val futureKindEq : term -> term -> term -> rule
      val futureForm : term -> rule
      val futureEq : term -> term -> rule
      val futureFormUniv : term -> term -> rule
      val futureEqUniv : term -> term -> term -> rule
      val futureSub : term -> term -> rule
      val futureIntroOf : term -> term -> rule
      val futureIntroEq : term -> term -> term -> rule
      val futureIntro : term -> rule
      val futureElimOf : term -> term -> term -> term -> rule
      val futureElimOfLetnext : term -> term -> term -> term -> rule
      val futureElimOfLetnextNondep : term -> term -> term -> term -> rule
      val futureElimEq : term -> term -> term -> term -> term -> term -> rule
      val futureElim : term -> term -> term -> rule
      val futureElimIstype : term -> term -> term -> rule
      val futureElimIstypeLetnext : term -> term -> term -> rule
      val futureElimEqtype : term -> term -> term -> term -> term -> rule
      val futureEta : term -> term -> rule
      val futureExt : term -> term -> term -> rule
      val futureLeft : int -> term -> term -> rule
      val futureInjection : term -> term -> term -> rule
      val squashFutureSwap : term -> rule
      val isquashFutureSwap : term -> rule
      val futureSquashSwap : term -> rule
      val futureIsquashSwap : term -> rule
      val recKind : term -> term -> rule
      val recKindEq : term -> term -> term -> rule
      val recForm : term -> rule
      val recEq : term -> term -> rule
      val recFormUniv : term -> term -> rule
      val recEqUniv : term -> term -> term -> rule
      val recUnroll : term -> rule
      val recUnrollUniv : term -> term -> rule
      val recBisimilar : term -> term -> rule
      val muForm : term -> rule
      val muEq : term -> term -> rule
      val muFormUniv : term -> term -> rule
      val muEqUniv : term -> term -> term -> rule
      val muUnroll : term -> rule
      val muUnrollUniv : term -> term -> rule
      val muInd : term -> term -> term -> rule
      val muIndUniv : term -> term -> term -> term -> rule
      val voidForm : rule
      val voidEq : rule
      val voidFormUniv : term -> rule
      val voidEqUniv : term -> rule
      val voidElim : term -> rule
      val voidSub : term -> rule
      val abortType : rule
      val unitKind : term -> rule
      val unitKindEq : term -> rule
      val unitForm : rule
      val unitEq : rule
      val unitFormUniv : term -> rule
      val unitEqUniv : term -> rule
      val unitIntroOf : rule
      val unitIntro : rule
      val unitExt : term -> term -> rule
      val unitLeft : int -> term -> rule
      val boolForm : rule
      val boolEq : rule
      val boolFormUniv : term -> rule
      val boolEqUniv : term -> rule
      val boolIntro1Of : rule
      val boolIntro2Of : rule
      val boolElimOf : term -> term -> term -> term -> rule
      val boolElimOfNondep : term -> term -> term -> term -> rule
      val boolElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val boolElim : term -> term -> rule
      val boolElimIstype : term -> term -> term -> rule
      val boolElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val boolLeft : int -> term -> rule
      val boolContradiction : term -> rule
      val iteType : rule
      val natForm : rule
      val natEq : rule
      val natFormUniv : term -> rule
      val natEqUniv : term -> rule
      val natElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val natElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val natUnroll : rule
      val natContradiction : term -> term -> rule
      val natInjection : term -> term -> rule
      val zeroType : rule
      val succType : rule
      val univKind : term -> term -> rule
      val univKindEq : term -> term -> term -> rule
      val univForm : term -> rule
      val univEq : term -> term -> rule
      val univFormUniv : term -> term -> rule
      val univFormUnivSucc : term -> rule
      val univEqUniv : term -> term -> term -> rule
      val univCumulativeOf : term -> term -> term -> rule
      val univCumulativeEq : term -> term -> term -> term -> rule
      val univCumulativeSuccOf : term -> term -> rule
      val univSub : term -> term -> rule
      val univForgetOf : term -> term -> rule
      val univForgetEq : term -> term -> term -> rule
      val univIntroEqtype : term -> term -> term -> rule
      val univFormInv : term -> rule
      val kindForm : term -> rule
      val kindEq : term -> term -> rule
      val kindFormUniv : term -> term -> rule
      val kindEqUniv : term -> term -> term -> rule
      val kindForgetOf : term -> term -> rule
      val kindForgetEq : term -> term -> term -> rule
      val kindUnivSub : term -> term -> rule
      val levelForm : rule
      val levelEq : rule
      val levelFormUniv : term -> rule
      val levelEqUniv : term -> rule
      val lleqForm : term -> term -> rule
      val lleqEq : term -> term -> term -> term -> rule
      val lleqFormUniv : term -> term -> term -> rule
      val lleqEqUniv : term -> term -> term -> term -> term -> rule
      val lzeroLevel : rule
      val lsuccLevel : term -> rule
      val lsuccEq : term -> term -> rule
      val lmaxLevel : term -> term -> rule
      val lmaxEq : term -> term -> term -> term -> rule
      val lleqRefl : term -> rule
      val lleqTrans : term -> term -> term -> rule
      val lleqZero : term -> rule
      val lleqSucc : term -> term -> rule
      val lleqIncrease : term -> term -> rule
      val lleqMaxL : term -> term -> term -> rule
      val lleqMaxR1 : term -> term -> term -> rule
      val lleqMaxR2 : term -> term -> term -> rule
      val lleqResp : term -> term -> term -> term -> rule
      val lsuccMaxDistTrans : term -> term -> term -> rule
      val lzeroType : rule
      val lsuccType : rule
      val lmaxType : rule
      val eqForm : term -> term -> term -> rule
      val eqEq : term -> term -> term -> term -> term -> term -> rule
      val eqFormUniv : term -> term -> term -> term -> rule
      val eqEqUniv : term -> term -> term -> term -> term -> term -> term -> rule
      val eqIntro : term -> term -> term -> rule
      val eqElim : term -> term -> term -> term -> rule
      val eqTrivialize : term -> term -> term -> rule
      val eqExt : term -> term -> term -> term -> term -> rule
      val eqLeft : int -> term -> term -> term -> term -> rule
      val eqRefl : term -> term -> rule
      val eqSymm : term -> term -> term -> rule
      val eqTrans : term -> term -> term -> term -> rule
      val eqFormInv1 : term -> term -> term -> rule
      val eqFormInv2 : term -> term -> term -> rule
      val eqFormInv3 : term -> term -> term -> rule
      val ofForm : term -> term -> rule
      val ofEq : term -> term -> term -> term -> rule
      val ofFormUniv : term -> term -> term -> rule
      val ofEqUniv : term -> term -> term -> term -> term -> rule
      val ofIntro : term -> term -> rule
      val ofElim : term -> term -> term -> rule
      val ofTrivialize : term -> term -> rule
      val ofExt : term -> term -> term -> term -> rule
      val ofLeft : int -> term -> term -> term -> rule
      val ofEquand1 : term -> term -> term -> rule
      val ofEquand2 : term -> term -> term -> rule
      val eqtpForm : term -> term -> rule
      val eqtpEq : term -> term -> term -> term -> rule
      val eqtpFormUniv : term -> term -> term -> rule
      val eqtpEqUniv : term -> term -> term -> term -> term -> rule
      val eqtpIntro : term -> term -> rule
      val eqtpElim : term -> term -> term -> rule
      val eqtpExt : term -> term -> term -> term -> rule
      val eqtpLeft : int -> term -> term -> term -> rule
      val eqtpFunct : term -> term -> term -> term -> rule
      val eqtpFunctType : term -> term -> term -> rule
      val equivalenceOf : term -> term -> term -> rule
      val equivalenceEq : term -> term -> term -> term -> rule
      val equivalence : term -> term -> rule
      val equivalenceLeft : int -> term -> term -> term -> rule
      val equivalenceLeftAlt : int -> term -> term -> term -> rule
      val eqtpRefl : term -> rule
      val eqtpSymm : term -> term -> rule
      val eqtpTrans : term -> term -> term -> rule
      val istpForm : term -> rule
      val istpEq : term -> term -> rule
      val istpFormUniv : term -> term -> rule
      val istpEqUniv : term -> term -> term -> rule
      val istpIntro : term -> rule
      val istpElim : term -> term -> rule
      val istpExt : term -> term -> term -> rule
      val istpLeft : int -> term -> term -> rule
      val inhabitedForm : term -> rule
      val subtypeForm : term -> term -> rule
      val subtypeEq : term -> term -> term -> term -> rule
      val subtypeFormUniv : term -> term -> term -> rule
      val subtypeEqUniv : term -> term -> term -> term -> term -> rule
      val subtypeIntro : term -> term -> rule
      val subtypeElim : term -> term -> term -> rule
      val subtypeExt : term -> term -> term -> term -> rule
      val subtypeLeft : int -> term -> term -> term -> rule
      val subtypeEstablish : term -> term -> rule
      val subsumptionOf : term -> term -> term -> rule
      val subsumptionEq : term -> term -> term -> term -> rule
      val subsumption : term -> term -> rule
      val subsumptionAlt : term -> term -> rule
      val subsumptionLeft : int -> term -> term -> term -> rule
      val subsumptionLeftAlt : int -> term -> term -> term -> rule
      val subsumptionLast : int -> term -> term -> term -> rule
      val tighten : int -> term -> term -> term -> rule
      val subtypeRefl : term -> rule
      val subtypeReflEqtype : term -> term -> rule
      val subtypeTrans : term -> term -> term -> rule
      val subtypeIstp1 : term -> term -> rule
      val subtypeIstp2 : term -> term -> rule
      val eeqtpForm : term -> term -> rule
      val eeqtpEq : term -> term -> term -> term -> rule
      val eeqtpFormUniv : term -> term -> term -> rule
      val eeqtpEqUniv : term -> term -> term -> term -> term -> rule
      val setForm : term -> term -> rule
      val setEq : term -> term -> term -> term -> rule
      val setFormUniv : term -> term -> term -> rule
      val setEqUniv : term -> term -> term -> term -> term -> rule
      val setWeakenOf : term -> term -> term -> rule
      val setWeakenEq : term -> term -> term -> term -> rule
      val setWeaken : term -> term -> rule
      val setIntroOf : term -> term -> term -> rule
      val setIntroEq : term -> term -> term -> term -> rule
      val setIntro : term -> term -> term -> rule
      val setIntroOfSquash : term -> term -> term -> rule
      val setIntroEqSquash : term -> term -> term -> term -> rule
      val squashIntroOfSquash : term -> rule
      val setElim : term -> term -> term -> term -> rule
      val setLeft : int -> term -> term -> term -> rule
      val setSquash : term -> term -> rule
      val setFormInv : term -> term -> rule
      val setSubElim : term -> term -> term -> rule
      val isetForm : term -> term -> rule
      val isetEq : term -> term -> term -> term -> rule
      val isetFormUniv : term -> term -> term -> rule
      val isetEqUniv : term -> term -> term -> term -> term -> rule
      val isetWeakenOf : term -> term -> term -> rule
      val isetWeakenEq : term -> term -> term -> term -> rule
      val isetWeaken : term -> term -> rule
      val isetIntroOf : term -> term -> term -> rule
      val isetIntroEq : term -> term -> term -> term -> rule
      val isetIntro : term -> term -> term -> rule
      val isetIntroOfSquash : term -> term -> term -> rule
      val isetIntroEqSquash : term -> term -> term -> term -> rule
      val isetElim : term -> term -> term -> term -> rule
      val isetLeft : int -> term -> term -> term -> rule
      val isetFormInv1 : term -> term -> rule
      val isetFormInv2 : term -> term -> term -> rule
      val isetSubElim : term -> term -> term -> rule
      val squashForm : term -> rule
      val squashEq : term -> term -> rule
      val squashFormUniv : term -> term -> rule
      val squashEqUniv : term -> term -> term -> rule
      val squashIntroOf : term -> rule
      val squashIntro : term -> rule
      val squashElim : term -> term -> term -> rule
      val squashExt : term -> term -> term -> rule
      val squashLeft : int -> term -> term -> rule
      val squashSub : term -> term -> rule
      val isquashForm : term -> rule
      val isquashEq : term -> term -> rule
      val isquashFormUniv : term -> term -> rule
      val isquashEqUniv : term -> term -> term -> rule
      val isquashIntroOf : term -> rule
      val isquashIntro : term -> rule
      val isquashIntroOfIsquash : term -> rule
      val isquashElim : term -> term -> term -> rule
      val isquashExt : term -> term -> term -> rule
      val isquashLeft : int -> term -> term -> rule
      val isquashSub : term -> term -> rule
      val isquashFormInv : term -> rule
      val quotientForm : term -> term -> rule
      val quotientEq : term -> term -> term -> term -> rule
      val quotientFormUniv : term -> term -> term -> rule
      val quotientEqUniv : term -> term -> term -> term -> term -> rule
      val quotientIntroOf : term -> term -> term -> rule
      val quotientIntroEq : term -> term -> term -> term -> rule
      val quotientElimOf : term -> term -> term -> term -> term -> rule
      val quotientElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val quotientElimIstype : term -> term -> term -> term -> rule
      val quotientElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val quotientDescent : term -> term -> term -> term -> term -> rule
      val quotientLeft : int -> term -> term -> term -> rule
      val quotientLeftRefl : int -> term -> term -> term -> rule
      val quotientLeftIstype : int -> term -> term -> term -> rule
      val quotientLeftEqtype : int -> term -> term -> term -> term -> rule
      val quotientLeftOf : int -> term -> term -> term -> term -> rule
      val quotientLeftEq : int -> term -> term -> term -> term -> term -> rule
      val quotientLeftOfDep : int -> term -> term -> term -> term -> rule
      val quotientLeftEqDep : int -> term -> term -> term -> term -> term -> rule
      val quotientFormInv : term -> term -> rule
      val iforallForm : term -> term -> term -> rule
      val iforallEq : term -> term -> term -> term -> term -> rule
      val iforallFormUniv : term -> term -> term -> term -> rule
      val iforallEqUniv : term -> term -> term -> term -> term -> term -> rule
      val iforallIntroOf : term -> term -> term -> term -> rule
      val iforallIntroEq : term -> term -> term -> term -> term -> rule
      val iforallIntro : term -> term -> term -> rule
      val iforallElimOf : term -> term -> term -> term -> term -> rule
      val iforallElimEq : term -> term -> term -> term -> term -> term -> rule
      val iforallElim : term -> term -> term -> term -> rule
      val foralltpForm : term -> rule
      val foralltpEq : term -> term -> rule
      val foralltpIntroOf : term -> term -> rule
      val foralltpIntroEq : term -> term -> term -> rule
      val foralltpIntro : term -> rule
      val foralltpElimOf : term -> term -> term -> rule
      val foralltpElimEq : term -> term -> term -> term -> rule
      val foralltpElim : term -> term -> rule
      val iexistsForm : term -> term -> term -> rule
      val iexistsEq : term -> term -> term -> term -> term -> rule
      val iexistsFormUniv : term -> term -> term -> term -> rule
      val iexistsEqUniv : term -> term -> term -> term -> term -> term -> rule
      val iexistsIntroOf : term -> term -> term -> term -> term -> rule
      val iexistsIntroEq : term -> term -> term -> term -> term -> term -> rule
      val iexistsIntro : term -> term -> term -> term -> rule
      val iexistsElimOf : term -> term -> term -> term -> term -> term -> rule
      val iexistsElimEq : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val iexistsElim : term -> term -> term -> term -> term -> rule
      val iexistsElimOfDep : term -> term -> term -> term -> term -> term -> rule
      val iexistsElimEqDep : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val iexistsElimDep : term -> term -> term -> term -> term -> rule
      val iexistsElimIstype : term -> term -> term -> term -> term -> rule
      val iexistsElimEqtype : term -> term -> term -> term -> term -> term -> term -> rule
      val substitution : int -> term -> term -> term -> rule
      val substitutionSimple : int -> term -> term -> term -> rule
      val generalize : term -> term -> term -> rule
      val assert : term -> term -> rule
      val assert' : term -> term -> rule
      val assertLater : term -> term -> rule
      val assertLater' : term -> term -> rule
      val inhabitant : term -> term -> rule
      val letForm : term -> term -> term -> term -> rule
      val lethForm : term -> term -> term -> term -> rule
      val leteForm : term -> term -> term -> term -> rule
      val accInd : term -> term -> term -> term -> term -> term -> rule
      val sequalForm : term -> rule
      val sequalIntroOf : term -> rule
      val sequalIntro : term -> rule
      val sequalTrivialize : term -> term -> rule
      val sequalExt : term -> term -> term -> term -> rule
      val sequalLeft : int -> term -> term -> term -> rule
      val sequalEq : term -> term -> term -> rule
      val sequalEqtp : term -> term -> rule
      val sequivalence : term -> term -> rule
      val sequivalenceLeft : int -> term -> term -> term -> rule
      val substitutionSyntactic : int -> term -> term -> term -> rule
      val sequalSymm : term -> term -> rule
      val sequalTrans : term -> term -> term -> rule
      val sequalCompat : term -> term -> term -> rule
      val sequalCompatLam : term -> term -> rule
      val forallEtaSequal : term -> term -> term -> rule
      val arrowEtaSequal : term -> term -> term -> rule
      val existsEtaSequal : term -> term -> term -> rule
      val prodEtaSequal : term -> term -> term -> rule
      val futureEtaSequal : term -> term -> rule
      val partialForm : term -> rule
      val partialEq : term -> term -> rule
      val partialFormUniv : term -> term -> rule
      val partialEqUniv : term -> term -> term -> rule
      val partialSub : term -> term -> rule
      val partialStrict : term -> rule
      val partialStrictConverse : term -> rule
      val partialIdem : term -> rule
      val haltsForm : term -> term -> rule
      val haltsEq : term -> term -> term -> rule
      val haltsFormUniv : term -> term -> term -> rule
      val haltsEqUniv : term -> term -> term -> term -> rule
      val partialIntroBottomOf : term -> rule
      val bottomDiverges : rule
      val partialExt : term -> term -> term -> rule
      val partialElimEq : term -> term -> term -> rule
      val partialElimOf : term -> term -> rule
      val haltsTrivialize : term -> rule
      val haltsExt : term -> term -> term -> rule
      val haltsLeft : int -> term -> term -> rule
      val fixpointInductionEq : term -> term -> term -> rule
      val fixpointInductionOf : term -> term -> rule
      val partialFormInv : term -> rule
      val seqBind : term -> term -> term -> term -> term -> term -> rule
      val activeApp : term -> term -> term -> term -> rule
      val activeAppSeq : term -> term -> term -> term -> rule
      val appHaltsInv : term -> term -> rule
      val activePi1 : term -> term -> term -> rule
      val activePi1Seq : term -> term -> term -> rule
      val pi1HaltsInv : term -> rule
      val activePi2 : term -> term -> term -> rule
      val activePi2Seq : term -> term -> term -> rule
      val pi2HaltsInv : term -> rule
      val prevHaltsInv : term -> rule
      val activeCase : term -> term -> term -> term -> term -> rule
      val activeCaseSeq : term -> term -> term -> term -> term -> rule
      val caseHaltsInv : term -> term -> term -> rule
      val seqHaltsSequal : term -> term -> rule
      val seqHaltsInv : term -> term -> rule
      val sequalUnderSeq : term -> term -> term -> rule
      val totalStrict : term -> rule
      val voidTotal' : rule
      val voidStrict : rule
      val unitTotal : term -> rule
      val unitTotal' : rule
      val unitStrict : rule
      val boolTotal : term -> rule
      val boolTotal' : rule
      val boolStrict : rule
      val forallTotal : term -> term -> term -> rule
      val forallTotal' : term -> term -> rule
      val forallStrict : term -> term -> rule
      val arrowTotal : term -> term -> term -> rule
      val arrowTotal' : term -> term -> rule
      val arrowStrict : term -> term -> rule
      val intersectStrict : term -> term -> rule
      val existsTotal : term -> term -> term -> rule
      val existsTotal' : term -> term -> rule
      val existsStrict : term -> term -> rule
      val prodTotal : term -> term -> term -> rule
      val prodTotal' : term -> term -> rule
      val prodStrict : term -> term -> rule
      val dprodTotal : term -> term -> term -> rule
      val dprodTotal' : term -> term -> rule
      val dprodStrict : term -> term -> rule
      val sumTotal : term -> term -> term -> rule
      val sumTotal' : term -> term -> rule
      val sumStrict : term -> term -> rule
      val futureTotal : term -> term -> rule
      val futureTotal' : term -> rule
      val futureStrict : term -> rule
      val setTotal' : term -> term -> rule
      val setStrict : term -> term -> rule
      val isetTotal' : term -> term -> rule
      val isetStrict : term -> term -> rule
      val quotientTotal' : term -> term -> rule
      val natTotal : term -> rule
      val natTotal' : rule
      val natStrict : rule
      val typeHalts : term -> rule
      val univTotal' : term -> rule
      val univStrict : term -> rule
      val reduceSeqTotal : term -> term -> term -> rule
      val haltsTotal : term -> term -> rule
      val uptypeForm : term -> rule
      val uptypeEq : term -> term -> rule
      val uptypeFormUniv : term -> term -> rule
      val uptypeEqUniv : term -> term -> term -> rule
      val uptypeTrivialize : term -> rule
      val uptypeExt : term -> term -> term -> rule
      val uptypeLeft : int -> term -> term -> rule
      val uptypeEeqtp : term -> term -> rule
      val uptypeUnitary : term -> rule
      val voidUptype : rule
      val unitUptype : rule
      val boolUptype : rule
      val forallUptype : term -> term -> rule
      val arrowUptype : term -> term -> rule
      val intersectUptype : term -> term -> rule
      val existsUptype : term -> term -> rule
      val prodUptype : term -> term -> rule
      val dprodUptype : term -> term -> rule
      val sumUptype : term -> term -> rule
      val futureUptype : term -> rule
      val eqUptype : term -> term -> term -> rule
      val ofUptype : term -> term -> rule
      val eqtpUptype : term -> term -> rule
      val istpUptype : term -> rule
      val subtypeUptype : term -> term -> rule
      val setUptype : term -> term -> rule
      val isetUptype : term -> term -> rule
      val muUptype : term -> rule
      val muUptypeUniv : term -> term -> rule
      val recUptype : term -> rule
      val recUptypeUniv : term -> term -> rule
      val natUptype : rule
      val uptypeFormInv : term -> rule
      val admissForm : term -> rule
      val admissEq : term -> term -> rule
      val admissFormUniv : term -> term -> rule
      val admissEqUniv : term -> term -> term -> rule
      val admissTrivialize : term -> rule
      val admissExt : term -> term -> term -> rule
      val admissLeft : int -> term -> term -> rule
      val admissEeqtp : term -> term -> rule
      val uptypeAdmiss : term -> rule
      val partialAdmiss : term -> rule
      val voidAdmiss : rule
      val unitAdmiss : rule
      val boolAdmiss : rule
      val forallAdmiss : term -> term -> rule
      val arrowAdmiss : term -> term -> rule
      val intersectAdmiss : term -> term -> rule
      val existsAdmissUptype : term -> term -> rule
      val prodAdmiss : term -> term -> rule
      val dprodAdmissUptype : term -> term -> rule
      val sumAdmiss : term -> term -> rule
      val futureAdmiss : term -> rule
      val eqAdmiss : term -> term -> term -> rule
      val ofAdmiss : term -> term -> rule
      val eqtpAdmiss : term -> term -> rule
      val istpAdmiss : term -> rule
      val subtypeAdmiss : term -> term -> rule
      val recAdmiss : term -> rule
      val recAdmissUniv : term -> term -> rule
      val natAdmiss : rule
      val admissFormInv : term -> rule
      val partialType : rule
      val haltsType : rule
      val admissType : rule
      val uptypeType : rule
      val seqType : rule
      val eeqtpRefl : term -> rule
      val eeqtpSymm : term -> term -> rule
      val eeqtpTrans : term -> term -> term -> rule
      val weakenEqtpEeqtp : term -> term -> rule
      val weakenSubtypeArrow : term -> term -> rule
      val weakenEeqtpIff : term -> term -> rule
      val compatGuardEqtp1 : term -> term -> term -> rule
      val compatSetEqtp0 : term -> term -> term -> rule
      val forallEeq : term -> term -> term -> term -> rule
      val existsEeq : term -> term -> term -> term -> rule
      val arrowEeq : term -> term -> term -> term -> rule
      val prodEeq : term -> term -> term -> term -> rule
      val dprodEeq : term -> term -> term -> term -> rule
      val sumEeq : term -> term -> term -> term -> rule
      val futureEeq : term -> term -> rule
      val letnextEeq : term -> term -> term -> term -> rule
      val intersectEeq : term -> term -> term -> term -> rule
      val unionEeq : term -> term -> term -> term -> rule
      val eqEeq : term -> term -> term -> term -> rule
      val eeqEeq : term -> term -> term -> term -> rule
      val compatGuardEeq1 : term -> term -> term -> rule
      val compatSetEeq0 : term -> term -> term -> rule
      val compatIsetEeq0 : term -> term -> term -> rule
      val compatIsetIff1 : term -> term -> term -> rule
      val compatForallSubtype0 : term -> term -> term -> rule
      val compatForallSubtype1 : term -> term -> term -> rule
      val compatExistsSubtype0 : term -> term -> term -> rule
      val compatExistsSubtype1 : term -> term -> term -> rule
      val compatIntersectSubtype0 : term -> term -> term -> rule
      val compatIntersectSubtype1 : term -> term -> term -> rule
      val compatUnionSubtype0 : term -> term -> term -> rule
      val compatUnionSubtype1 : term -> term -> term -> rule
      val compatGuardArrow0 : term -> term -> term -> rule
      val compatGuardSubtype1 : term -> term -> term -> rule
      val compatSetSubtype0 : term -> term -> term -> rule
      val compatSetArrow1 : term -> term -> term -> rule
      val compatIsetSubtype0 : term -> term -> term -> rule
      val compatIsetArrow1 : term -> term -> term -> rule
      val compatForallIff1 : term -> term -> term -> rule
      val compatExistsIff1 : term -> term -> term -> rule
      val compatArrowIff0 : term -> term -> term -> rule
      val compatArrowIff1 : term -> term -> term -> rule
      val compatProdIff0 : term -> term -> term -> rule
      val compatProdIff1 : term -> term -> term -> rule
      val compatDprodIff0 : term -> term -> term -> rule
      val compatDprodIff1 : term -> term -> term -> rule
      val compatSumIff0 : term -> term -> term -> rule
      val compatSumIff1 : term -> term -> term -> rule
      val compatFutureIff : term -> term -> rule
      val compatForallArrow1 : term -> term -> term -> rule
      val compatExistsArrow1 : term -> term -> term -> rule
      val compatArrowArrow0 : term -> term -> term -> rule
      val compatArrowArrow1 : term -> term -> term -> rule
      val compatProdArrow0 : term -> term -> term -> rule
      val compatProdArrow1 : term -> term -> term -> rule
      val compatDprodArrow0 : term -> term -> term -> rule
      val compatDprodArrow1 : term -> term -> term -> rule
      val compatSumArrow0 : term -> term -> term -> rule
      val compatSumArrow1 : term -> term -> term -> rule
      val compatFutureArrow : term -> term -> rule
      val compatForallEntails1 : term -> term -> term -> rule
      val compatArrowEntails1 : term -> term -> term -> rule
      val compatProdEntails0 : term -> term -> term -> rule
      val compatProdEntails1 : term -> term -> term -> rule
      val compatDprodEntails0 : term -> term -> term -> rule
      val compatDprodEntails1 : term -> term -> term -> rule
      val integerForm : rule
      val integerEq : rule
      val integerFormUniv : term -> rule
      val integerEqUniv : term -> rule
      val integerToDefType : rule
      val integerFromDefType : rule
      val integerIsomorphism1 : rule
      val integerIsomorphism2 : rule
      val pluszSpec : rule
      val negzSpec : rule
      val eqzbSpec : rule
      val leqzbSpec : rule
      val timeszSpec : rule
      val integerTotal : term -> rule
      val integerStrict : rule
      val integerUptype : rule
      val integerAdmiss : rule
      val integerSequal : term -> term -> rule
      val symbolForm : rule
      val symbolEq : rule
      val symbolFormUniv : term -> rule
      val symbolEqUniv : term -> rule
      val symbol_eqbType : rule
      val symbol_eqbSpec1 : term -> term -> rule
      val symbol_eqbSpec2 : term -> term -> rule
      val symbolTotal : term -> rule
      val symbolStrict : rule
      val symbolUptype : rule
      val symbolAdmiss : rule
      val symbolSequal : term -> term -> rule

   end


functor RuleFun (structure Arg : RULE_ARG)
   :> THE_RULES where type rule = Arg.rule
=
struct

type rule = Arg.rule
open Term
structure J = Judgement

val const_of = Const Prim.ov
val const_true = Const Prim.tru
val const_false = Const Prim.fals
val const_let = Const Prim.lett
val const_abort = Const Prim.abort
val const_acc = Const Prim.acc
val const_admiss = Const Prim.admiss
val const_arrow = Const Prim.arrow
val const_bool = Const Prim.bool
val const_bottom = Const Prim.bottom
val const_cEqzb = Const Prim.cEqzb
val const_cInteger = Const Prim.cInteger
val const_cLeqzb = Const Prim.cLeqzb
val const_cNegz = Const Prim.cNegz
val const_cPlusz = Const Prim.cPlusz
val const_cTimesz = Const Prim.cTimesz
val const_coguard = Const Prim.coguard
val const_dprod = Const Prim.dprod
val const_eeqtp = Const Prim.eeqtp
val const_eq = Const Prim.eq
val const_eqtp = Const Prim.eqtp
val const_eqzb = Const Prim.eqzb
val const_exists = Const Prim.exists
val const_fix = Const Prim.fix
val const_forall = Const Prim.forall
val const_forallfut = Const Prim.forallfut
val const_foralltp = Const Prim.foralltp
val const_future = Const Prim.future
val const_guard = Const Prim.guard
val const_halts = Const Prim.halts
val const_iexists = Const Prim.iexists
val const_iff = Const Prim.iff
val const_iforall = Const Prim.iforall
val const_inl = Const Prim.inl
val const_inr = Const Prim.inr
val const_integer = Const Prim.integer
val const_integer_from_Integer = Const Prim.integer_from_Integer
val const_integer_to_Integer = Const Prim.integer_to_Integer
val const_intersect = Const Prim.intersect
val const_irrelevant = Const Prim.irrelevant
val const_iset = Const Prim.iset
val const_isquash = Const Prim.isquash
val const_istp = Const Prim.istp
val const_ite = Const Prim.ite
val const_karrow = Const Prim.karrow
val const_kind = Const Prim.kind
val const_leqzb = Const Prim.leqzb
val const_lete = Const Prim.lete
val const_leth = Const Prim.leth
val const_letnext = Const Prim.letnext
val const_level = Const Prim.level
val const_lleq = Const Prim.lleq
val const_lmax = Const Prim.lmax
val const_lsucc = Const Prim.lsucc
val const_lzero = Const Prim.lzero
val const_mu = Const Prim.mu
val const_nat = Const Prim.nat
val const_nat_case = Const Prim.nat_case
val const_negz = Const Prim.negz
val const_nonsense = Const Prim.nonsense
val const_paramapp = Const Prim.paramapp
val const_parametric = Const Prim.parametric
val const_partial = Const Prim.partial
val const_plusz = Const Prim.plusz
val const_positive = Const Prim.positive
val const_prod = Const Prim.prod
val const_quotient = Const Prim.quotient
val const_rec = Const Prim.rec
val const_seq = Const Prim.seq
val const_sequal = Const Prim.sequal
val const_set = Const Prim.set
val const_squash = Const Prim.squash
val const_subtype = Const Prim.subtype
val const_succ = Const Prim.succ
val const_sum = Const Prim.sum
val const_sum_case = Const Prim.sum_case
val const_symbol = Const Prim.symbol
val const_symbol_eqb = Const Prim.symbol_eqb
val const_tarrow = Const Prim.tarrow
val const_timesz = Const Prim.timesz
val const_total = Const Prim.total
val const_unavailable = Const Prim.unavailable
val const_union = Const Prim.union
val const_unit = Const Prim.unit
val const_univ = Const Prim.univ
val const_uptype = Const Prim.uptype
val const_void = Const Prim.void
val const_zero = Const Prim.zero

fun forallForm a b = Arg.make "forallForm" [] (Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEq a a' b b' = Arg.make "forallEq" [] (Elim (const_eqtp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormUniv a b i = Arg.make "forallFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEqUniv a a' b b' i = Arg.make "forallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallSub a a' b b' = Arg.make "forallSub" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntroOf a b m = Arg.make "forallIntroOf" [] (Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntroEq a b m n = Arg.make "forallIntroEq" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntro a b = Arg.make "forallIntro" [] (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun forallElimOf a b m p = Arg.make "forallElimOf" [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallElimEq a b m n p q = Arg.make "forallElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallElim a b p = Arg.make "forallElim" [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun forallEta a b m = Arg.make "forallEta" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallExt a b m n = Arg.make "forallExt" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallExt' a a' a'' b b' b'' m n = Arg.make "forallExt'" [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallOfExt a a' b b' m = Arg.make "forallOfExt" [] (Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormInv1 a b = Arg.make "forallFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormInv2 a b m = Arg.make "forallFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForm a b = Arg.make "arrowForm" [] (Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEq a a' b b' = Arg.make "arrowEq" [] (Elim (const_eqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormUniv a b i = Arg.make "arrowFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEqUniv a a' b b' i = Arg.make "arrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallEq a a' b b' = Arg.make "arrowForallEq" [] (Elim (const_eqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallEqUniv a a' b b' i = Arg.make "arrowForallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowSub a a' b b' = Arg.make "arrowSub" [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallSub a a' b b' = Arg.make "arrowForallSub" [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallArrowSub a a' b b' = Arg.make "forallArrowSub" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntroOf a b m = Arg.make "arrowIntroOf" [] (Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntroEq a b m n = Arg.make "arrowIntroEq" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntro a b = Arg.make "arrowIntro" [] (Elim (const_arrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun arrowElimOf a b m p = Arg.make "arrowElimOf" [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowElimEq a b m n p q = Arg.make "arrowElimEq" [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowElim a b = Arg.make "arrowElim" [] (b) [(Arg.Nothing, [], Elim (const_arrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun arrowEta a b m = Arg.make "arrowEta" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowExt a b m n = Arg.make "arrowExt" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowExt' a a' a'' b b' b'' m n = Arg.make "arrowExt'" [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowOfExt a a' b b' m = Arg.make "arrowOfExt" [] (Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormInv1 a b = Arg.make "arrowFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormInv2 a b m = Arg.make "arrowFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowKind a i k = Arg.make "tarrowKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_tarrow, [App (a), App (k), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowKindEq a a' i k k' = Arg.make "tarrowKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_tarrow, [App (a), App (k), ])), App (Elim (const_tarrow, [App (a'), App (k'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForm a b = Arg.make "tarrowForm" [] (Elim (const_istp, [App (Elim (const_tarrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowEq a a' b b' = Arg.make "tarrowEq" [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_tarrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowFormUniv a b i = Arg.make "tarrowFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowEqUniv a a' b b' i = Arg.make "tarrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_tarrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowArrowEq a a' b b' = Arg.make "tarrowArrowEq" [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowArrowEqUniv a a' b b' i = Arg.make "tarrowArrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForallEq a a' b b' = Arg.make "tarrowForallEq" [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForallEqUniv a a' b b' i = Arg.make "tarrowForallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntroOf a b m = Arg.make "tarrowIntroOf" [] (Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntroEq a b m n = Arg.make "tarrowIntroEq" [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntro a b = Arg.make "tarrowIntro" [] (Elim (const_tarrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun tarrowElimOf a b m p = Arg.make "tarrowElimOf" [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowElimEq a b m n p q = Arg.make "tarrowElimEq" [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowElim a b = Arg.make "tarrowElim" [] (b) [(Arg.Nothing, [], Elim (const_tarrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun tarrowEta a b m = Arg.make "tarrowEta" [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowExt a b m n = Arg.make "tarrowExt" [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowOfExt a a' b b' m = Arg.make "tarrowOfExt" [] (Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowKind i k l = Arg.make "karrowKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_karrow, [App (k), App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowKindEq i k k' l l' = Arg.make "karrowKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_karrow, [App (k), App (l), ])), App (Elim (const_karrow, [App (k'), App (l'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (l), App (l'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForm a b = Arg.make "karrowForm" [] (Elim (const_istp, [App (Elim (const_karrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowEq a a' b b' = Arg.make "karrowEq" [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_karrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowFormUniv a b i = Arg.make "karrowFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowEqUniv a a' b b' i = Arg.make "karrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_karrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowArrowEq a a' b b' = Arg.make "karrowArrowEq" [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowArrowEqUniv a a' b b' i = Arg.make "karrowArrowEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForallEq a a' b b' = Arg.make "karrowForallEq" [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForallEqUniv a a' b b' i = Arg.make "karrowForallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntroOf a b m = Arg.make "karrowIntroOf" [] (Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntroEq a b m n = Arg.make "karrowIntroEq" [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntro a b = Arg.make "karrowIntro" [] (Elim (const_karrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun karrowElimOf a b m p = Arg.make "karrowElimOf" [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowElimEq a b m n p q = Arg.make "karrowElimEq" [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowElim a b = Arg.make "karrowElim" [] (b) [(Arg.Nothing, [], Elim (const_karrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun karrowEta a b m = Arg.make "karrowEta" [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowExt a b m n = Arg.make "karrowExt" [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowOfExt a a' b b' m = Arg.make "karrowOfExt" [] (Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectForm a b = Arg.make "intersectForm" [] (Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectEq a a' b b' = Arg.make "intersectEq" [] (Elim (const_eqtp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectFormUniv a b i = Arg.make "intersectFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectEqUniv a a' b b' i = Arg.make "intersectEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectSub a a' b b' = Arg.make "intersectSub" [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntroOf a b m = Arg.make "intersectIntroOf" [] (Elim (const_of, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntroEq a b m n = Arg.make "intersectIntroEq" [] (Elim (const_eq, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntro a b = Arg.make "intersectIntro" [] (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], b), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun intersectElimOf a b m p = Arg.make "intersectElimOf" [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectElimEq a b m n p = Arg.make "intersectElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectElim a b p = Arg.make "intersectElim" [] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun intersectFormInv1 a b = Arg.make "intersectFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectFormInv2 a b m = Arg.make "intersectFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricForm a b = Arg.make "parametricForm" [] (Elim (const_istp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricEq a a' b b' = Arg.make "parametricEq" [] (Elim (const_eqtp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricFormUniv a b i = Arg.make "parametricFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricEqUniv a a' b b' i = Arg.make "parametricEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricSub a a' b b' = Arg.make "parametricSub" [] (Elim (const_subtype, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricForallSub a a' b b' = Arg.make "parametricForallSub" [] (Elim (const_subtype, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricIntroOf a b m = Arg.make "parametricIntroOf" [] (Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricIntroEq a b m n = Arg.make "parametricIntroEq" [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, n)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricIntro a b = Arg.make "parametricIntro" [] (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun parametricIntroOfForall a b m = Arg.make "parametricIntroOfForall" [] (Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElimOf a b m p = Arg.make "parametricElimOf" [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (const_paramapp, [App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElimEq a b m n p q = Arg.make "parametricElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (const_paramapp, [App (m), App (p), ])), App (Elim (const_paramapp, [App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElim a b p = Arg.make "parametricElim" [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (const_paramapp, [App (m), App (p), ]) | _ => raise Arg.ExtractFailure)
fun parametricBeta m n = Arg.make "parametricBeta" [] (Elim (const_sequal, [App (Elim (const_paramapp, [App (Lam (NONE, m)), App (n), ])), App (Sub (m, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricEta a b m = Arg.make "parametricEta" [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (Lam (NONE, Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricExt a b m n = Arg.make "parametricExt" [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), App (Elim (const_paramapp, [App (Sub (n, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricExt' a a' a'' b b' b'' m n = Arg.make "parametricExt'" [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), App (Elim (const_paramapp, [App (Sub (n, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricOfExt a a' b b' m = Arg.make "parametricOfExt" [] (Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricFormInv1 a b = Arg.make "parametricFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricFormInv2 a b m = Arg.make "parametricFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElimIrrelevant m p q = Arg.make "parametricElimIrrelevant" [] (Elim (const_sequal, [App (Elim (const_paramapp, [App (m), App (p), ])), App (Elim (const_paramapp, [App (m), App (q), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun irrelevance m = Arg.make "irrelevance" [] (Elim (const_irrelevant, [App (Lam (NONE, m)), ])) [(Arg.Unhide, [J.Tm (const_nonsense), ], Elim (const_sequal, [App (m), App (Sub (m, Dot (const_unavailable, Shift 1))), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutForm a b = Arg.make "forallfutForm" [] (Elim (const_istp, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutEq a a' b b' = Arg.make "forallfutEq" [] (Elim (const_eqtp, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forallfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutFormUniv a b i = Arg.make "forallfutFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutEqUniv a a' b b' i = Arg.make "forallfutEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forallfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutSub a a' b b' = Arg.make "forallfutSub" [] (Elim (const_subtype, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forallfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tml (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutForallVoidSub a b b' = Arg.make "forallfutForallVoidSub" [] (Elim (const_subtype, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (const_void), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutIntroOf a b m = Arg.make "forallfutIntroOf" [] (Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutIntroEq a b m n = Arg.make "forallfutIntroEq" [] (Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutIntro a b = Arg.make "forallfutIntro" [] (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tml (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun forallfutElimOf a b m p = Arg.make "forallfutElimOf" [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutElimEq a b m n p q = Arg.make "forallfutElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutElim a b p = Arg.make "forallfutElim" [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun forallfutExt a b m n = Arg.make "forallfutExt" [] (Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutExt' a a' a'' b b' b'' m n = Arg.make "forallfutExt'" [] (Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutOfExt a a' b b' m = Arg.make "forallfutOfExt" [] (Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardForm a b = Arg.make "guardForm" [] (Elim (const_istp, [App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardEq a a' b b' = Arg.make "guardEq" [] (Elim (const_eqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardFormUniv a b i = Arg.make "guardFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardEqUniv a a' b b' i = Arg.make "guardEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a'), ])), (Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntroOf a b m = Arg.make "guardIntroOf" [] (Elim (const_of, [App (Elim (const_guard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntroEq a b m n = Arg.make "guardIntroEq" [] (Elim (const_eq, [App (Elim (const_guard, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntro a b = Arg.make "guardIntro" [] (Elim (const_guard, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (b, Shift 1)), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun guardElimOf a b m = Arg.make "guardElimOf" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_guard, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardElimEq a b m n = Arg.make "guardElimEq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_guard, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardElim a b = Arg.make "guardElim" [] (b) [(Arg.Nothing, [], Elim (const_guard, [App (a), App (b), ])), (Arg.Unhide, [], a), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun guardSatEq a b = Arg.make "guardSatEq" [] (Elim (const_eqtp, [App (b), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardSub a a' b b' = Arg.make "guardSub" [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_arrow, [App (a'), App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardSubIntro a b c = Arg.make "guardSubIntro" [] (Elim (const_subtype, [App (c), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (c, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardSubElim a b c = Arg.make "guardSubElim" [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (c), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardForm a b = Arg.make "coguardForm" [] (Elim (const_istp, [App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardEq a a' b b' = Arg.make "coguardEq" [] (Elim (const_eqtp, [App (Elim (const_coguard, [App (a), App (b), ])), App (Elim (const_coguard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardFormUniv a b i = Arg.make "coguardFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardEqUniv a a' b b' i = Arg.make "coguardEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_coguard, [App (a), App (b), ])), App (Elim (const_coguard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a'), ])), (Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntroEq a b m n = Arg.make "coguardIntroEq" [] (Elim (const_eq, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntroOf a b m = Arg.make "coguardIntroOf" [] (Elim (const_of, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntroOfSquash a b m = Arg.make "coguardIntroOfSquash" [] (Elim (const_of, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntro a b = Arg.make "coguardIntro" [] (Elim (const_coguard, [App (a), App (b), ])) [(Arg.Unhide, [], a), (Arg.Nothing, [], b), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun coguardElim1 a b = Arg.make "coguardElim1" [] (Elim (const_squash, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_coguard, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardElim2Eq a b m n = Arg.make "coguardElim2Eq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardElim2Of a b m = Arg.make "coguardElim2Of" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardElim2 a b = Arg.make "coguardElim2" [] (b) [(Arg.Nothing, [], Elim (const_coguard, [App (a), App (b), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun coguardLeft gsize a b c = Arg.lmake "coguardLeft" [] gsize [J.Tm (Elim (const_coguard, [App (a), App (b), ])), ] (c) [(Arg.Unhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (Sub (a, Shift 1)), J.Tm (b), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun coguardSatEq a b = Arg.make "coguardSatEq" [] (Elim (const_eqtp, [App (b), App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardSub a a' b b' = Arg.make "coguardSub" [] (Elim (const_subtype, [App (Elim (const_coguard, [App (a), App (b), ])), App (Elim (const_coguard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_arrow, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_istp, [App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardSubIntro a b c = Arg.make "coguardSubIntro" [] (Elim (const_subtype, [App (c), App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_subtype, [App (c), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardSubElim a b c = Arg.make "coguardSubElim" [] (Elim (const_subtype, [App (Elim (const_coguard, [App (a), App (b), ])), App (c), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (c, Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsForm a b = Arg.make "existsForm" [] (Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEq a a' b b' = Arg.make "existsEq" [] (Elim (const_eqtp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormUniv a b i = Arg.make "existsFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEqUniv a a' b b' i = Arg.make "existsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsSub a a' b b' = Arg.make "existsSub" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntroOf a b m n = Arg.make "existsIntroOf" [] (Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntroEq a b m m' n n' = Arg.make "existsIntroEq" [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (n), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntro a b m = Arg.make "existsIntro" [m, ] (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun existsElim1Of a b m = Arg.make "existsElim1Of" [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim1Eq a b m n = Arg.make "existsElim1Eq" [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim1 a b = Arg.make "existsElim1" [] (a) [(Arg.Nothing, [], Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun existsElim2Of a b m = Arg.make "existsElim2Of" [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim2Eq a b m n = Arg.make "existsElim2Eq" [] (Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEta a b m = Arg.make "existsEta" [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsExt a b m n = Arg.make "existsExt" [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsLeft gsize a b c = Arg.lmake "existsLeft" [] gsize [J.Tm (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Nothing, [J.Tm (b), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun existsFormInv1 a b = Arg.make "existsFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormInv2 a b m = Arg.make "existsFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormInv2Eq a b m n = Arg.make "existsFormInv2Eq" [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (b, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodKind i k l = Arg.make "prodKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_prod, [App (k), App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodKindEq i k k' l l' = Arg.make "prodKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_prod, [App (k), App (l), ])), App (Elim (const_prod, [App (k'), App (l'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (l), App (l'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodForm a b = Arg.make "prodForm" [] (Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEq a a' b b' = Arg.make "prodEq" [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodFormUniv a b i = Arg.make "prodFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEqUniv a a' b b' i = Arg.make "prodEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsEq a a' b b' = Arg.make "prodExistsEq" [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, Sub (b', Shift 1))), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsEqUniv a a' b b' i = Arg.make "prodExistsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, Sub (b', Shift 1))), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodSub a a' b b' = Arg.make "prodSub" [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsSub a a' b b' = Arg.make "prodExistsSub" [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsProdSub a a' b b' = Arg.make "existsProdSub" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntroOf a b m n = Arg.make "prodIntroOf" [] (Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntroEq a b m m' n n' = Arg.make "prodIntroEq" [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntro a b = Arg.make "prodIntro" [] (Elim (const_prod, [App (a), App (b), ])) [(Arg.Nothing, [], a), (Arg.Nothing, [], b), ] (fn [m, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun prodElim1Of a b m = Arg.make "prodElim1Of" [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim1Eq a b m n = Arg.make "prodElim1Eq" [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim1 a b = Arg.make "prodElim1" [] (a) [(Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun prodElim2Of a b m = Arg.make "prodElim2Of" [] (Elim (const_of, [App (b), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim2Eq a b m n = Arg.make "prodElim2Eq" [] (Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim2 a b = Arg.make "prodElim2" [] (b) [(Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi2, ]) | _ => raise Arg.ExtractFailure)
fun prodEta a b m = Arg.make "prodEta" [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExt a b m n = Arg.make "prodExt" [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodLeft gsize a b c = Arg.lmake "prodLeft" [] gsize [J.Tm (Elim (const_prod, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [J.Tm (Sub (b, Shift 1)), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun prodFormInv1 a b = Arg.make "prodFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodFormInv2 a b = Arg.make "prodFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodForm a b = Arg.make "dprodForm" [] (Elim (const_istp, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodEq a a' b b' = Arg.make "dprodEq" [] (Elim (const_eqtp, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodFormUniv a b i = Arg.make "dprodFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodEqUniv a a' b b' i = Arg.make "dprodEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExistsEq a a' b b' = Arg.make "dprodExistsEq" [] (Elim (const_eqtp, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExistsEqUniv a a' b b' i = Arg.make "dprodExistsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodDprodEq a a' b b' = Arg.make "prodDprodEq" [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodDprodEqUniv a a' b b' i = Arg.make "prodDprodEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodSub a a' b b' = Arg.make "dprodSub" [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExistsSub a a' b b' = Arg.make "dprodExistsSub" [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsDprodSub a a' b b' = Arg.make "existsDprodSub" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodProdSub a a' b b' = Arg.make "dprodProdSub" [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodDprodSub a a' b b' = Arg.make "prodDprodSub" [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodIntroOf a b m n = Arg.make "dprodIntroOf" [] (Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodIntroEq a b m m' n n' = Arg.make "dprodIntroEq" [] (Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodIntro a b = Arg.make "dprodIntro" [] (Elim (const_dprod, [App (a), App (b), ])) [(Arg.Nothing, [], a), (Arg.Nothing, [], b), ] (fn [m, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun dprodElim1Of a b m = Arg.make "dprodElim1Of" [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim1Eq a b m n = Arg.make "dprodElim1Eq" [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim1 a b = Arg.make "dprodElim1" [] (a) [(Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun dprodElim2Of a b m = Arg.make "dprodElim2Of" [] (Elim (const_of, [App (b), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim2Eq a b m n = Arg.make "dprodElim2Eq" [] (Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim2 a b = Arg.make "dprodElim2" [] (b) [(Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi2, ]) | _ => raise Arg.ExtractFailure)
fun dprodEta a b m = Arg.make "dprodEta" [] (Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExt a b m n = Arg.make "dprodExt" [] (Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodLeft gsize a b c = Arg.lmake "dprodLeft" [] gsize [J.Tm (Elim (const_dprod, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [J.Tm (Sub (b, Shift 1)), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun dprodFormInv1 a b = Arg.make "dprodFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_dprod, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodFormInv2 a b m = Arg.make "dprodFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_dprod, [App (a), App (b), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionForm a b = Arg.make "unionForm" [] (Elim (const_istp, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionEq a a' b b' = Arg.make "unionEq" [] (Elim (const_eqtp, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionFormUniv a b i = Arg.make "unionFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionEqUniv a a' b b' i = Arg.make "unionEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionSub a a' b b' = Arg.make "unionSub" [] (Elim (const_subtype, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionIntroOf a b m n = Arg.make "unionIntroOf" [] (Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionIntroEq a b m n n' = Arg.make "unionIntroEq" [] (Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (n), App (n'), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (n), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionIntro a b m = Arg.make "unionIntro" [] (Elim (const_union, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, n, ] => n | _ => raise Arg.ExtractFailure)
fun unionElimOf a b c m p = Arg.make "unionElimOf" [] (Elim (const_of, [App (c), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_of, [App (Sub (c, Shift 2)), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimEq a b c m n p q = Arg.make "unionElimEq" [] (Elim (const_eq, [App (c), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElim a b c m = Arg.make "unionElim" [m, ] (c) [(Arg.Nothing, [J.Tm (b), J.Tmh (a), ], Sub (c, Shift 2)), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun unionElimOfDep a b c m p = Arg.make "unionElimOfDep" [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_of, [App (Sub (c, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimEqDep a b c m n p q = Arg.make "unionElimEqDep" [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimDep a b c m = Arg.make "unionElimDep" [m, ] (Sub (c, Dot (m, Shift 0))) [(Arg.Nothing, [J.Tm (b), J.Tmh (a), ], Sub (c, Idot (0, Shift 2))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun unionElimIstype a b c m = Arg.make "unionElimIstype" [] (Elim (const_istp, [App (Sub (c, Dot (m, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_istp, [App (Sub (c, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimEqtype a b c d m n = Arg.make "unionElimEqtype" [] (Elim (const_eqtp, [App (Sub (c, Dot (m, Shift 0))), App (Sub (d, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Idot (0, Shift 2))), App (Sub (d, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumForm a b = Arg.make "sumForm" [] (Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumEq a a' b b' = Arg.make "sumEq" [] (Elim (const_eqtp, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormUniv a b i = Arg.make "sumFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumEqUniv a a' b b' i = Arg.make "sumEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumSub a a' b b' = Arg.make "sumSub" [] (Elim (const_subtype, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1Of a b m = Arg.make "sumIntro1Of" [] (Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1Eq a b m n = Arg.make "sumIntro1Eq" [] (Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inl, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1 a b = Arg.make "sumIntro1" [] (Elim (const_sum, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => Elim (const_inl, [App (m), ]) | _ => raise Arg.ExtractFailure)
fun sumIntro2Of a b m = Arg.make "sumIntro2Of" [] (Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro2Eq a b m n = Arg.make "sumIntro2Eq" [] (Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro2 a b = Arg.make "sumIntro2" [] (Elim (const_sum, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], b), ] (fn [_, m, ] => Elim (const_inr, [App (m), ]) | _ => raise Arg.ExtractFailure)
fun sumElimOf a b c m p r = Arg.make "sumElimOf" [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), App (p), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_of, [App (Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimOfNondep a b c m p r = Arg.make "sumElimOfNondep" [] (Elim (const_of, [App (c), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (c, Shift 1)), App (p), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_of, [App (Sub (c, Shift 1)), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimEq a b c m n p q r s = Arg.make "sumElimEq" [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), App (Elim (const_sum_case, [App (n), App (Lam (NONE, q)), App (Lam (NONE, s)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), App (p), App (q), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_eq, [App (Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElim a b c m = Arg.make "sumElim" [m, ] (Sub (c, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Nothing, [J.Tm (a), ], Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), (Arg.Nothing, [J.Tm (b), ], Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), ] (fn [_, p, r, ] => Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ]) | _ => raise Arg.ExtractFailure)
fun sumElimNondep a b c = Arg.make "sumElimNondep" [] (c) [(Arg.Nothing, [], Elim (const_sum, [App (a), App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (c, Shift 1)), (Arg.Nothing, [J.Tm (b), ], Sub (c, Shift 1)), ] (fn [m, p, r, ] => Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ]) | _ => raise Arg.ExtractFailure)
fun sumElimIstype a b c e m = Arg.make "sumElimIstype" [] (Elim (const_istp, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, c)), App (Lam (NONE, e)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_istp, [App (e), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimEqtype a b c d e f m n = Arg.make "sumElimEqtype" [] (Elim (const_eqtp, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, c)), App (Lam (NONE, e)), ])), App (Elim (const_sum_case, [App (n), App (Lam (NONE, d)), App (Lam (NONE, f)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (c), App (d), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_eqtp, [App (e), App (f), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumContradiction a b c m n = Arg.make "sumContradiction" [] (c) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumInjection1 a b m n = Arg.make "sumInjection1" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inl, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumInjection2 a b m n = Arg.make "sumInjection2" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val sum_caseType = Arg.make "sum_caseType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 1), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 2), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_sum, [App (Var 2), App (Var 1), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 2), App (Var 0), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 1), App (Var 0), ])), App (Var 0), ])), ])), ]))), ]))), ]))), ]))), ])), App (const_sum_case), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormInv1 a b = Arg.make "sumFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormInv2 a b = Arg.make "sumFormInv2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureKind i k = Arg.make "futureKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_future, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureKindEq i k l = Arg.make "futureKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_future, [App (k), ])), App (Elim (const_future, [App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureForm a = Arg.make "futureForm" [] (Elim (const_istp, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEq a b = Arg.make "futureEq" [] (Elim (const_eqtp, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureFormUniv a i = Arg.make "futureFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_future, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEqUniv a b i = Arg.make "futureEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureSub a b = Arg.make "futureSub" [] (Elim (const_subtype, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntroOf a m = Arg.make "futureIntroOf" [] (Elim (const_of, [App (Elim (const_future, [App (a), ])), App (Next (m)), ])) [(Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntroEq a m n = Arg.make "futureIntroEq" [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (Next (m)), App (Next (n)), ])) [(Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntro a = Arg.make "futureIntro" [] (Elim (const_future, [App (a), ])) [(Arg.Promote, [], a), ] (fn [m, ] => Next (m) | _ => raise Arg.ExtractFailure)
fun futureElimOf a b m p = Arg.make "futureElimOf" [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (p, Dot (Elim (m, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimOfLetnext a b m p = Arg.make "futureElimOfLetnext" [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Elim (const_letnext, [App (m), App (Lam (NONE, p)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimOfLetnextNondep a b m p = Arg.make "futureElimOfLetnextNondep" [] (Elim (const_of, [App (b), App (Elim (const_letnext, [App (m), App (Lam (NONE, p)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimEq a b m n p q = Arg.make "futureElimEq" [] (Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (p, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (q, Dot (Elim (n, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElim a b m = Arg.make "futureElim" [m, ] (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Nothing, [J.Tml (a), ], b), ] (fn [_, _, p, ] => Sub (p, Dot (Elim (m, [Prev, ]), Shift 0)) | _ => raise Arg.ExtractFailure)
fun futureElimIstype a b m = Arg.make "futureElimIstype" [] (Elim (const_istp, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimIstypeLetnext a b m = Arg.make "futureElimIstypeLetnext" [] (Elim (const_istp, [App (Elim (const_letnext, [App (m), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimEqtype a b c m n = Arg.make "futureElimEqtype" [] (Elim (const_eqtp, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (c, Dot (Elim (n, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEta a m = Arg.make "futureEta" [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (Next (Elim (m, [Prev, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureExt a m n = Arg.make "futureExt" [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (Elim (m, [Prev, ])), App (Elim (n, [Prev, ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureLeft gsize a b = Arg.lmake "futureLeft" [] gsize [J.Tm (Elim (const_future, [App (a), ])), ] (b) [(Arg.PromoteUnhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tml (a), ], SOME (Dot (Next (Var 0), Shift 1)), Sub (b, under gsize (Dot (Next (Var 0), Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Prev, ]), Shift 1))) | _ => raise Arg.ExtractFailure)
fun futureInjection a m n = Arg.make "futureInjection" [] (Elim (const_future, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (Next (m)), App (Next (n)), ])), ] (fn [_, _, ] => Next (Triv) | _ => raise Arg.ExtractFailure)
fun squashFutureSwap a = Arg.make "squashFutureSwap" [] (Elim (const_squash, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_future, [App (Elim (const_squash, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashFutureSwap a = Arg.make "isquashFutureSwap" [] (Elim (const_isquash, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_future, [App (Elim (const_isquash, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureSquashSwap a = Arg.make "futureSquashSwap" [] (Elim (const_future, [App (Elim (const_squash, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (Elim (const_future, [App (a), ])), ])), ] (fn [_, _, ] => Next (Triv) | _ => raise Arg.ExtractFailure)
fun futureIsquashSwap a = Arg.make "futureIsquashSwap" [] (Elim (const_future, [App (Elim (const_isquash, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_isquash, [App (Elim (const_future, [App (a), ])), ])), ] (fn [_, _, ] => Next (Triv) | _ => raise Arg.ExtractFailure)
fun recKind i k = Arg.make "recKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, k)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_kind, [App (i), ])), ], Elim (const_of, [App (Elim (const_kind, [App (Sub (i, Shift 1)), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recKindEq i k l = Arg.make "recKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, k)), ])), App (Elim (const_rec, [App (Lam (NONE, l)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_kind, [App (i), ])), ], Elim (const_eq, [App (Elim (const_kind, [App (Sub (i, Shift 1)), ])), App (k), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recForm a = Arg.make "recForm" [] (Elim (const_istp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recEq a b = Arg.make "recEq" [] (Elim (const_eqtp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Elim (const_rec, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recFormUniv a i = Arg.make "recFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recEqUniv a b i = Arg.make "recEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Elim (const_rec, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUnroll a = Arg.make "recUnroll" [] (Elim (const_eqtp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_rec, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUnrollUniv a i = Arg.make "recUnrollUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_rec, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recBisimilar a b = Arg.make "recBisimilar" [] (Elim (const_eqtp, [App (b), App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (Sub (a, Dot (b, Shift 0))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muForm a = Arg.make "muForm" [] (Elim (const_istp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muEq a b = Arg.make "muEq" [] (Elim (const_eqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Elim (const_mu, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, b)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muFormUniv a i = Arg.make "muFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muEqUniv a b i = Arg.make "muEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Elim (const_mu, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, b)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUnroll a = Arg.make "muUnroll" [] (Elim (const_eeqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_mu, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun muUnrollUniv a i = Arg.make "muUnrollUniv" [] (Elim (const_eeqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_mu, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun muInd a b m = Arg.make "muInd" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Var 2), App (Lam (NONE, Sub (b, Idot (0, Shift 4)))), ])), J.Tm (Elim (const_subtype, [App (Var 1), App (Elim (const_mu, [App (Lam (NONE, Sub (a, Idot (0, Shift 3)))), ])), ])), J.Tm (a), J.Tph, ], Sub (b, Idot (2, Shift 4))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, n, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Sub (n, Idot (1, Dot (Triv, Idot (0, Dot (Triv, Shift 2)))))))), App (m), ]) | _ => raise Arg.ExtractFailure)
fun muIndUniv a b i m = Arg.make "muIndUniv" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Var 2), App (Lam (NONE, Sub (b, Idot (0, Shift 4)))), ])), J.Tm (Elim (const_subtype, [App (Var 1), App (Elim (const_mu, [App (Lam (NONE, Sub (a, Idot (0, Shift 3)))), ])), ])), J.Tm (a), J.Tmh (Elim (const_univ, [App (i), ])), ], Elim (const_prod, [App (Sub (b, Idot (2, Shift 4))), App (Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 4)), ])), App (Sub (b, Idot (2, Shift 4))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, n, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Elim (Sub (n, Idot (1, Dot (Triv, Idot (0, Dot (Triv, Shift 2))))), [Pi1, ])))), App (m), ]) | _ => raise Arg.ExtractFailure)
val voidForm = Arg.make "voidForm" [] (Elim (const_istp, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val voidEq = Arg.make "voidEq" [] (Elim (const_eqtp, [App (const_void), App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun voidFormUniv i = Arg.make "voidFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_void), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidEqUniv i = Arg.make "voidEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_void), App (const_void), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidElim a = Arg.make "voidElim" [] (a) [(Arg.Unhide, [], const_void), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidSub a = Arg.make "voidSub" [] (Elim (const_subtype, [App (const_void), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val abortType = Arg.make "abortType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (const_void), App (Var 0), ]))), ]))), ])), App (const_abort), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitKind i = Arg.make "unitKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitKindEq i = Arg.make "unitKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (const_unit), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitForm = Arg.make "unitForm" [] (Elim (const_istp, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitEq = Arg.make "unitEq" [] (Elim (const_eqtp, [App (const_unit), App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitFormUniv i = Arg.make "unitFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitEqUniv i = Arg.make "unitEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_unit), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitIntroOf = Arg.make "unitIntroOf" [] (Elim (const_of, [App (const_unit), App (Triv), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitIntro = Arg.make "unitIntro" [] (const_unit) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitExt m n = Arg.make "unitExt" [] (Elim (const_eq, [App (const_unit), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_unit), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (const_unit), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitLeft gsize b = Arg.lmake "unitLeft" [] gsize [J.Tm (const_unit), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
val boolForm = Arg.make "boolForm" [] (Elim (const_istp, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolEq = Arg.make "boolEq" [] (Elim (const_eqtp, [App (const_bool), App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolFormUniv i = Arg.make "boolFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_bool), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolEqUniv i = Arg.make "boolEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_bool), App (const_bool), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val boolIntro1Of = Arg.make "boolIntro1Of" [] (Elim (const_of, [App (const_bool), App (const_true), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolIntro2Of = Arg.make "boolIntro2Of" [] (Elim (const_of, [App (const_bool), App (const_false), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimOf a m p r = Arg.make "boolElimOf" [] (Elim (const_of, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_ite, [App (m), App (p), App (r), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (const_true, Shift 0))), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (const_false, Shift 0))), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimOfNondep a m p r = Arg.make "boolElimOfNondep" [] (Elim (const_of, [App (a), App (Elim (const_ite, [App (m), App (p), App (r), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimEq a m n p q r s = Arg.make "boolElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_ite, [App (m), App (p), App (r), ])), App (Elim (const_ite, [App (n), App (q), App (s), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_true, Shift 0))), App (p), App (q), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_false, Shift 0))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElim a m = Arg.make "boolElim" [m, ] (Sub (a, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Nothing, [], Sub (a, Dot (const_true, Shift 0))), (Arg.Nothing, [], Sub (a, Dot (const_false, Shift 0))), ] (fn [_, p, r, ] => Elim (const_ite, [App (m), App (p), App (r), ]) | _ => raise Arg.ExtractFailure)
fun boolElimIstype a c m = Arg.make "boolElimIstype" [] (Elim (const_istp, [App (Elim (const_ite, [App (m), App (a), App (c), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimEqtype a b c d m n = Arg.make "boolElimEqtype" [] (Elim (const_eqtp, [App (Elim (const_ite, [App (m), App (a), App (c), ])), App (Elim (const_ite, [App (n), App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolLeft gsize a = Arg.lmake "boolLeft" [] gsize [J.Tm (const_bool), ] (a) [(Arg.Nothing, [], SOME (Dot (const_true, Shift 0)), Sub (a, under gsize (Dot (const_true, Shift 0)))), (Arg.Nothing, [], SOME (Dot (const_false, Shift 0)), Sub (a, under gsize (Dot (const_false, Shift 0)))), ] (fn [m, n, ] => Elim (const_ite, [App (Var gsize ), App (Sub (m, under gsize (Shift 1))), App (Sub (n, under gsize (Shift 1))), ]) | _ => raise Arg.ExtractFailure)
fun boolContradiction a = Arg.make "boolContradiction" [] (a) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (const_true), App (const_false), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val iteType = Arg.make "iteType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (const_bool), App (Elim (const_arrow, [App (Var 0), App (Elim (const_arrow, [App (Var 0), App (Var 0), ])), ])), ]))), ]))), ])), App (const_ite), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val natForm = Arg.make "natForm" [] (Elim (const_istp, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val natEq = Arg.make "natEq" [] (Elim (const_eqtp, [App (const_nat), App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun natFormUniv i = Arg.make "natFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_nat), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natEqUniv i = Arg.make "natEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_nat), App (const_nat), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natElimEq a m n p q r s = Arg.make "natElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_nat_case, [App (m), App (p), App (Lam (NONE, r)), ])), App (Elim (const_nat_case, [App (n), App (q), App (Lam (NONE, s)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_zero, Shift 0))), App (p), App (q), ])), (Arg.Unhide, [J.Tm (const_nat), ], Elim (const_eq, [App (Sub (a, Dot (Elim (const_succ, [App (Var 0), ]), Shift 1))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun natElimEqtype a b c d m n = Arg.make "natElimEqtype" [] (Elim (const_eqtp, [App (Elim (const_nat_case, [App (m), App (a), App (Lam (NONE, c)), ])), App (Elim (const_nat_case, [App (n), App (b), App (Lam (NONE, d)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [J.Tm (const_nat), ], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val natUnroll = Arg.make "natUnroll" [] (Elim (const_eeqtp, [App (const_nat), App (Elim (const_sum, [App (const_unit), App (const_nat), ])), ])) [] (fn [] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun natContradiction a m = Arg.make "natContradiction" [] (a) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (const_zero), App (Elim (const_succ, [App (m), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natInjection m n = Arg.make "natInjection" [] (Elim (const_eq, [App (const_nat), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (Elim (const_succ, [App (m), ])), App (Elim (const_succ, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val zeroType = Arg.make "zeroType" [] (Elim (const_of, [App (const_nat), App (const_zero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val succType = Arg.make "succType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_nat), App (const_nat), ])), App (const_succ), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun univKind i j = Arg.make "univKind" [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univKindEq i j k = Arg.make "univKindEq" [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), App (Elim (const_univ, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (k), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (i), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForm i = Arg.make "univForm" [] (Elim (const_istp, [App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univEq i j = Arg.make "univEq" [] (Elim (const_eqtp, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormUniv i j = Arg.make "univFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (j), ])), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormUnivSucc i = Arg.make "univFormUnivSucc" [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univEqUniv i j k = Arg.make "univEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), App (Elim (const_univ, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (j), ])), App (i), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeOf a i j = Arg.make "univCumulativeOf" [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeEq a b i j = Arg.make "univCumulativeEq" [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeSuccOf a i = Arg.make "univCumulativeSuccOf" [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univSub i j = Arg.make "univSub" [] (Elim (const_subtype, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForgetOf a i = Arg.make "univForgetOf" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForgetEq a b i = Arg.make "univForgetEq" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univIntroEqtype a b i = Arg.make "univIntroEqtype" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormInv i = Arg.make "univFormInv" [] (Elim (const_of, [App (const_level), App (i), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_univ, [App (i), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForm i = Arg.make "kindForm" [] (Elim (const_istp, [App (Elim (const_kind, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindEq i j = Arg.make "kindEq" [] (Elim (const_eqtp, [App (Elim (const_kind, [App (i), ])), App (Elim (const_kind, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindFormUniv i k = Arg.make "kindFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (k), ])), App (Elim (const_kind, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (Elim (const_lsucc, [App (i), ])), ])), App (k), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindEqUniv i j k = Arg.make "kindEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (k), ])), App (Elim (const_kind, [App (i), ])), App (Elim (const_kind, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), (Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (Elim (const_lsucc, [App (i), ])), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForgetOf a i = Arg.make "kindForgetOf" [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForgetEq a b i = Arg.make "kindForgetEq" [] (Elim (const_eq, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindUnivSub i j = Arg.make "kindUnivSub" [] (Elim (const_subtype, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (i), ])), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val levelForm = Arg.make "levelForm" [] (Elim (const_istp, [App (const_level), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val levelEq = Arg.make "levelEq" [] (Elim (const_eqtp, [App (const_level), App (const_level), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun levelFormUniv i = Arg.make "levelFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_level), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun levelEqUniv i = Arg.make "levelEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_level), App (const_level), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqForm i j = Arg.make "lleqForm" [] (Elim (const_istp, [App (Elim (const_lleq, [App (i), App (j), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqEq i i' j j' = Arg.make "lleqEq" [] (Elim (const_eqtp, [App (Elim (const_lleq, [App (i), App (j), ])), App (Elim (const_lleq, [App (i'), App (j'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (i'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (j'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqFormUniv i j k = Arg.make "lleqFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (k), ])), App (Elim (const_lleq, [App (i), App (j), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (j), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (k), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqEqUniv i i' j j' k = Arg.make "lleqEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (k), ])), App (Elim (const_lleq, [App (i), App (j), ])), App (Elim (const_lleq, [App (i'), App (j'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (i'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (j'), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (k), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val lzeroLevel = Arg.make "lzeroLevel" [] (Elim (const_of, [App (const_level), App (const_lzero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccLevel m = Arg.make "lsuccLevel" [] (Elim (const_of, [App (const_level), App (Elim (const_lsucc, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccEq m n = Arg.make "lsuccEq" [] (Elim (const_eq, [App (const_level), App (Elim (const_lsucc, [App (m), ])), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lmaxLevel m n = Arg.make "lmaxLevel" [] (Elim (const_of, [App (const_level), App (Elim (const_lmax, [App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lmaxEq m m' n n' = Arg.make "lmaxEq" [] (Elim (const_eq, [App (const_level), App (Elim (const_lmax, [App (m), App (n), ])), App (Elim (const_lmax, [App (m'), App (n'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqRefl m = Arg.make "lleqRefl" [] (Elim (const_lleq, [App (m), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqTrans m n p = Arg.make "lleqTrans" [] (Elim (const_lleq, [App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_lleq, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqZero m = Arg.make "lleqZero" [] (Elim (const_lleq, [App (const_lzero), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqSucc m n = Arg.make "lleqSucc" [] (Elim (const_lleq, [App (Elim (const_lsucc, [App (m), ])), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqIncrease m n = Arg.make "lleqIncrease" [] (Elim (const_lleq, [App (m), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxL m n p = Arg.make "lleqMaxL" [] (Elim (const_lleq, [App (Elim (const_lmax, [App (m), App (n), ])), App (p), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (p), ])), (Arg.Unhide, [], Elim (const_lleq, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxR1 m n p = Arg.make "lleqMaxR1" [] (Elim (const_lleq, [App (m), App (Elim (const_lmax, [App (n), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxR2 m n p = Arg.make "lleqMaxR2" [] (Elim (const_lleq, [App (m), App (Elim (const_lmax, [App (n), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqResp m m' n n' = Arg.make "lleqResp" [] (Elim (const_lleq, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m'), App (m), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (n'), App (n), ])), (Arg.Unhide, [], Elim (const_lleq, [App (m'), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccMaxDistTrans m n p = Arg.make "lsuccMaxDistTrans" [] (Elim (const_eq, [App (const_level), App (m), App (Elim (const_lsucc, [App (Elim (const_lmax, [App (n), App (p), ])), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (Elim (const_lmax, [App (Elim (const_lsucc, [App (n), ])), App (Elim (const_lsucc, [App (p), ])), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val lzeroType = Arg.make "lzeroType" [] (Elim (const_of, [App (const_level), App (const_lzero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val lsuccType = Arg.make "lsuccType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_level), App (const_level), ])), App (const_lsucc), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val lmaxType = Arg.make "lmaxType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_level), App (Elim (const_arrow, [App (const_level), App (const_level), ])), ])), App (const_lmax), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun eqForm a m p = Arg.make "eqForm" [] (Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqEq a b m n p q = Arg.make "eqEq" [] (Elim (const_eqtp, [App (Elim (const_eq, [App (a), App (m), App (p), ])), App (Elim (const_eq, [App (b), App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormUniv a i m p = Arg.make "eqFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eq, [App (a), App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqEqUniv a b i m n p q = Arg.make "eqEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eq, [App (a), App (m), App (p), ])), App (Elim (const_eq, [App (b), App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqIntro a m n = Arg.make "eqIntro" [] (Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqElim a m n p = Arg.make "eqElim" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqTrivialize a m n = Arg.make "eqTrivialize" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqExt a m n p q = Arg.make "eqExt" [] (Elim (const_eq, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqLeft gsize a b p q = Arg.lmake "eqLeft" [] gsize [J.Tm (Elim (const_eq, [App (a), App (p), App (q), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun eqRefl a m = Arg.make "eqRefl" [] (Elim (const_eq, [App (a), App (m), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqSymm a m n = Arg.make "eqSymm" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (n), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqTrans a m n p = Arg.make "eqTrans" [] (Elim (const_eq, [App (a), App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv1 a m n = Arg.make "eqFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv2 a m n = Arg.make "eqFormInv2" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv3 a m n = Arg.make "eqFormInv3" [] (Elim (const_of, [App (a), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofForm a m = Arg.make "ofForm" [] (Elim (const_istp, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEq a b m n = Arg.make "ofEq" [] (Elim (const_eqtp, [App (Elim (const_of, [App (a), App (m), ])), App (Elim (const_of, [App (b), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofFormUniv a i m = Arg.make "ofFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEqUniv a b i m n = Arg.make "ofEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_of, [App (a), App (m), ])), App (Elim (const_of, [App (b), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofIntro a m = Arg.make "ofIntro" [] (Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofElim a m p = Arg.make "ofElim" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofTrivialize a m = Arg.make "ofTrivialize" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofExt a m p q = Arg.make "ofExt" [] (Elim (const_eq, [App (Elim (const_of, [App (a), App (m), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofLeft gsize a b p = Arg.lmake "ofLeft" [] gsize [J.Tm (Elim (const_of, [App (a), App (p), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun ofEquand1 a m n = Arg.make "ofEquand1" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEquand2 a m n = Arg.make "ofEquand2" [] (Elim (const_of, [App (a), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpForm a b = Arg.make "eqtpForm" [] (Elim (const_istp, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpEq a b c d = Arg.make "eqtpEq" [] (Elim (const_eqtp, [App (Elim (const_eqtp, [App (a), App (c), ])), App (Elim (const_eqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpFormUniv a b i = Arg.make "eqtpFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpEqUniv a b c d i = Arg.make "eqtpEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eqtp, [App (a), App (c), ])), App (Elim (const_eqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpIntro a b = Arg.make "eqtpIntro" [] (Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpElim a b p = Arg.make "eqtpElim" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpExt a b p q = Arg.make "eqtpExt" [] (Elim (const_eq, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpLeft gsize a b c = Arg.lmake "eqtpLeft" [] gsize [J.Tm (Elim (const_eqtp, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun eqtpFunct a b m n = Arg.make "eqtpFunct" [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (b, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpFunctType a b b' = Arg.make "eqtpFunctType" [] (Elim (const_eqtp, [App (Sub (a, Dot (b, Shift 0))), App (Sub (a, Dot (b', Shift 0))), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalenceOf a b m = Arg.make "equivalenceOf" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalenceEq a b m n = Arg.make "equivalenceEq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalence a b = Arg.make "equivalence" [] (b) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun equivalenceLeft gsize a b c = Arg.lmake "equivalenceLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_istp, [App (a), ])), ], NONE, Elim (const_eqtp, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun equivalenceLeftAlt gsize a b c = Arg.lmake "equivalenceLeftAlt" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eqtp, [App (Sub (a, Shift (gsize + 1))), App (Sub (b, Shift (gsize + 1))), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun eqtpRefl a = Arg.make "eqtpRefl" [] (Elim (const_eqtp, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpSymm a b = Arg.make "eqtpSymm" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (b), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpTrans a b c = Arg.make "eqtpTrans" [] (Elim (const_eqtp, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpForm a = Arg.make "istpForm" [] (Elim (const_istp, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpEq a b = Arg.make "istpEq" [] (Elim (const_eqtp, [App (Elim (const_istp, [App (a), ])), App (Elim (const_istp, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpFormUniv a i = Arg.make "istpFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpEqUniv a b i = Arg.make "istpEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_istp, [App (a), ])), App (Elim (const_istp, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpIntro a = Arg.make "istpIntro" [] (Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpElim a p = Arg.make "istpElim" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpExt a p q = Arg.make "istpExt" [] (Elim (const_eq, [App (Elim (const_istp, [App (a), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpLeft gsize a b = Arg.lmake "istpLeft" [] gsize [J.Tm (Elim (const_istp, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun inhabitedForm a = Arg.make "inhabitedForm" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeForm a b = Arg.make "subtypeForm" [] (Elim (const_istp, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeEq a b c d = Arg.make "subtypeEq" [] (Elim (const_eqtp, [App (Elim (const_subtype, [App (a), App (c), ])), App (Elim (const_subtype, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeFormUniv a b i = Arg.make "subtypeFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeEqUniv a b c d i = Arg.make "subtypeEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_subtype, [App (a), App (c), ])), App (Elim (const_subtype, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIntro a b = Arg.make "subtypeIntro" [] (Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeElim a b p = Arg.make "subtypeElim" [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeExt a b p q = Arg.make "subtypeExt" [] (Elim (const_eq, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeLeft gsize a b c = Arg.lmake "subtypeLeft" [] gsize [J.Tm (Elim (const_subtype, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun subtypeEstablish a b = Arg.make "subtypeEstablish" [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Var 0), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumptionOf a b m = Arg.make "subsumptionOf" [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumptionEq a b m n = Arg.make "subsumptionEq" [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumption a b = Arg.make "subsumption" [] (b) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionAlt a b = Arg.make "subsumptionAlt" [] (b) [(Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (a), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLeft gsize a b c = Arg.lmake "subsumptionLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_istp, [App (a), ])), ], NONE, Elim (const_eeqtp, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLeftAlt gsize a b c = Arg.lmake "subsumptionLeftAlt" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eeqtp, [App (Sub (a, Shift (gsize + 1))), App (Sub (b, Shift (gsize + 1))), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLast gsize a b c = Arg.lmake "subsumptionLast" [] gsize [J.Tm (a), ] (Sub (c, Shift gsize )) [(Arg.Unhide, [J.Tm (a), ], NONE, Elim (const_subtype, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], NONE, c), ] (fn [_, m, ] => Sub (m, Shift gsize ) | _ => raise Arg.ExtractFailure)
fun tighten gsize a b c = Arg.lmake "tighten" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_subtype, [App (Sub (b, Shift (gsize + 1))), App (Sub (a, Shift (gsize + 1))), ])), (Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_of, [App (Sub (b, Shift (gsize + 1))), App (Var gsize ), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, _, m, ] => m | _ => raise Arg.ExtractFailure)
fun subtypeRefl a = Arg.make "subtypeRefl" [] (Elim (const_subtype, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeReflEqtype a b = Arg.make "subtypeReflEqtype" [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeTrans a b c = Arg.make "subtypeTrans" [] (Elim (const_subtype, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIstp1 a b = Arg.make "subtypeIstp1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIstp2 a b = Arg.make "subtypeIstp2" [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpForm a b = Arg.make "eeqtpForm" [] (Elim (const_istp, [App (Elim (const_eeqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpEq a b c d = Arg.make "eeqtpEq" [] (Elim (const_eqtp, [App (Elim (const_eeqtp, [App (a), App (c), ])), App (Elim (const_eeqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpFormUniv a b i = Arg.make "eeqtpFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eeqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpEqUniv a b c d i = Arg.make "eeqtpEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eeqtp, [App (a), App (c), ])), App (Elim (const_eeqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setForm a b = Arg.make "setForm" [] (Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setEq a a' b b' = Arg.make "setEq" [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setFormUniv a b i = Arg.make "setFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setEqUniv a a' b b' i = Arg.make "setEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeakenOf a b m = Arg.make "setWeakenOf" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeakenEq a b m n = Arg.make "setWeakenEq" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeaken a b = Arg.make "setWeaken" [] (a) [(Arg.Nothing, [], Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun setIntroOf a b m = Arg.make "setIntroOf" [] (Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntroEq a b m n = Arg.make "setIntroEq" [] (Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntro a b m = Arg.make "setIntro" [m, ] (Elim (const_set, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => m | _ => raise Arg.ExtractFailure)
fun setIntroOfSquash a b m = Arg.make "setIntroOfSquash" [] (Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntroEqSquash a b m n = Arg.make "setIntroEqSquash" [] (Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntroOfSquash a = Arg.make "squashIntroOfSquash" [] (Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setElim a b c m = Arg.make "setElim" [] (c) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (m, Shift 0))), ], Sub (c, Shift 1)), ] (fn [_, _, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun setLeft gsize a b c = Arg.lmake "setLeft" [] gsize [J.Tm (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Unhide, [J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tmh (b), J.Tm (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun setSquash a b = Arg.make "setSquash" [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a), App (Lam (NONE, Elim (const_squash, [App (b), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setFormInv a b = Arg.make "setFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setSubElim a a' b = Arg.make "setSubElim" [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (a'), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetForm a b = Arg.make "isetForm" [] (Elim (const_istp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetEq a a' b b' = Arg.make "isetEq" [] (Elim (const_eqtp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetFormUniv a b i = Arg.make "isetFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetEqUniv a a' b b' i = Arg.make "isetEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetWeakenOf a b m = Arg.make "isetWeakenOf" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetWeakenEq a b m n = Arg.make "isetWeakenEq" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetWeaken a b = Arg.make "isetWeaken" [] (a) [(Arg.Nothing, [], Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun isetIntroOf a b m = Arg.make "isetIntroOf" [] (Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetIntroEq a b m n = Arg.make "isetIntroEq" [] (Elim (const_eq, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetIntro a b m = Arg.make "isetIntro" [m, ] (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => m | _ => raise Arg.ExtractFailure)
fun isetIntroOfSquash a b m = Arg.make "isetIntroOfSquash" [] (Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetIntroEqSquash a b m n = Arg.make "isetIntroEqSquash" [] (Elim (const_eq, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetElim a b c m = Arg.make "isetElim" [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (m, Shift 0))), ], Sub (c, Shift 1)), ] (fn [_, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun isetLeft gsize a b c = Arg.lmake "isetLeft" [] gsize [J.Tm (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Nothing, [J.Tmh (b), J.Tm (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun isetFormInv1 a b = Arg.make "isetFormInv1" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetFormInv2 a b m = Arg.make "isetFormInv2" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetSubElim a a' b = Arg.make "isetSubElim" [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (a'), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashForm a = Arg.make "squashForm" [] (Elim (const_istp, [App (Elim (const_squash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashEq a b = Arg.make "squashEq" [] (Elim (const_eqtp, [App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_iff, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashFormUniv a i = Arg.make "squashFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_squash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashEqUniv a b i = Arg.make "squashEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), (Arg.Unhide, [], Elim (const_iff, [App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntroOf a = Arg.make "squashIntroOf" [] (Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntro a = Arg.make "squashIntro" [] (Elim (const_squash, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashElim a c m = Arg.make "squashElim" [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (c, Shift 1)), ] (fn [_, _, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun squashExt a m n = Arg.make "squashExt" [] (Elim (const_eq, [App (Elim (const_squash, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (n), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashLeft gsize a c = Arg.lmake "squashLeft" [] gsize [J.Tm (Elim (const_squash, [App (a), ])), ] (c) [(Arg.Unhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], SOME (Dot (Triv, Shift 1)), Sub (c, under gsize (Dot (Triv, Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun squashSub a b = Arg.make "squashSub" [] (Elim (const_subtype, [App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_arrow, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashForm a = Arg.make "isquashForm" [] (Elim (const_istp, [App (Elim (const_isquash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashEq a b = Arg.make "isquashEq" [] (Elim (const_eqtp, [App (Elim (const_isquash, [App (a), ])), App (Elim (const_isquash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashFormUniv a i = Arg.make "isquashFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_isquash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashEqUniv a b i = Arg.make "isquashEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_isquash, [App (a), ])), App (Elim (const_isquash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashIntroOf a = Arg.make "isquashIntroOf" [] (Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashIntro a = Arg.make "isquashIntro" [] (Elim (const_isquash, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashIntroOfIsquash a = Arg.make "isquashIntroOfIsquash" [] (Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_isquash, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashElim a c m = Arg.make "isquashElim" [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (m), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (c, Shift 1)), ] (fn [_, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun isquashExt a m n = Arg.make "isquashExt" [] (Elim (const_eq, [App (Elim (const_isquash, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashLeft gsize a c = Arg.lmake "isquashLeft" [] gsize [J.Tm (Elim (const_isquash, [App (a), ])), ] (c) [(Arg.Nothing, [J.Tmh (a), ], SOME (Dot (Triv, Shift 1)), Sub (c, under gsize (Dot (Triv, Shift 1)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun isquashSub a b = Arg.make "isquashSub" [] (Elim (const_subtype, [App (Elim (const_isquash, [App (a), ])), App (Elim (const_isquash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_arrow, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashFormInv a = Arg.make "isquashFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_isquash, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientForm a b = Arg.make "quotientForm" [] (Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientEq a a' b b' = Arg.make "quotientEq" [] (Elim (const_eqtp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (Elim (const_quotient, [App (a'), App (Lam (NONE, Lam (NONE, b'))), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientFormUniv a b i = Arg.make "quotientFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientEqUniv a a' b b' i = Arg.make "quotientEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (Elim (const_quotient, [App (a'), App (Lam (NONE, Lam (NONE, b'))), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientIntroOf a b m = Arg.make "quotientIntroOf" [] (Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Dot (m, Shift 0)))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientIntroEq a b m n = Arg.make "quotientIntroEq" [] (Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (n, Dot (m, Shift 0)))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimOf a b c m p = Arg.make "quotientElimOf" [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Shift 2)), App (Sub (p, Idot (1, Shift 3))), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimEq a b c m n p q = Arg.make "quotientElimEq" [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Shift 2)), App (Sub (q, Idot (1, Shift 3))), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimIstype a b c m = Arg.make "quotientElimIstype" [] (Elim (const_istp, [App (Sub (c, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Shift 2)), App (Sub (c, Idot (1, Shift 3))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimEqtype a b c d m n = Arg.make "quotientElimEqtype" [] (Elim (const_eqtp, [App (Sub (c, Dot (m, Shift 0))), App (Sub (d, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Shift 2)), App (Sub (d, Idot (1, Shift 3))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientDescent a b c m n = Arg.make "quotientDescent" [] (c) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (n, Dot (m, Shift 0)))), ], Sub (c, Shift 1)), ] (fn [_, _, _, _, _, p, ] => Sub (p, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun quotientLeft gsize a b c = Arg.lmake "quotientLeft" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], SOME (Shift 0), Elim (const_istp, [App (c), ])), (Arg.Nothing, [J.Tmh (a), ], SOME (Shift 0), c), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun quotientLeftRefl gsize a b c = Arg.lmake "quotientLeftRefl" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (c) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], SOME (Shift 0), Elim (const_istp, [App (c), ])), (Arg.Nothing, [J.Tmh (Sub (b, Idot (0, Shift 0))), J.Tmh (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, _, m, ] => Sub (m, under gsize (Dot (Triv, Dot (Triv, Shift 1)))) | _ => raise Arg.ExtractFailure)
fun quotientLeftIstype gsize a b c = Arg.lmake "quotientLeftIstype" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_istp, [App (c), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEqtype gsize a b c d = Arg.lmake "quotientLeftEqtype" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eqtp, [App (c), App (d), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (d, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftOf gsize a b c m = Arg.lmake "quotientLeftOf" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_of, [App (Sub (c, under gsize (Shift 1))), App (m), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 3))), App (Sub (m, under gsize (Shift 2))), App (Sub (m, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEq gsize a b c m n = Arg.lmake "quotientLeftEq" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eq, [App (Sub (c, under gsize (Shift 1))), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 3))), App (Sub (m, under gsize (Shift 2))), App (Sub (n, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftOfDep gsize a b c m = Arg.lmake "quotientLeftOfDep" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_of, [App (c), App (m), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 2))), App (Sub (m, under gsize (Shift 2))), App (Sub (m, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEqDep gsize a b c m n = Arg.lmake "quotientLeftEqDep" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eq, [App (c), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 2))), App (Sub (m, under gsize (Shift 2))), App (Sub (n, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientFormInv a b = Arg.make "quotientFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallForm a i k = Arg.make "iforallForm" [] (Elim (const_istp, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallEq a b i k l = Arg.make "iforallEq" [] (Elim (const_eqtp, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iforall, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallFormUniv a i j k = Arg.make "iforallFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallEqUniv a b i j k l = Arg.make "iforallEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iforall, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntroOf a i k m = Arg.make "iforallIntroOf" [] (Elim (const_of, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (a), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntroEq a i k m n = Arg.make "iforallIntroEq" [] (Elim (const_eq, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (a), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntro a i k = Arg.make "iforallIntro" [] (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Nothing, [J.Tmh (k), ], a), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun iforallElimOf a i k m p = Arg.make "iforallElimOf" [] (Elim (const_of, [App (Sub (a, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallElimEq a i k m n p = Arg.make "iforallElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallElim a i k p = Arg.make "iforallElim" [] (Sub (a, Dot (p, Shift 0))) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, m, _, ] => m | _ => raise Arg.ExtractFailure)
fun foralltpForm a = Arg.make "foralltpForm" [] (Elim (const_istp, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpEq a b = Arg.make "foralltpEq" [] (Elim (const_eqtp, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (Elim (const_foralltp, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntroOf a m = Arg.make "foralltpIntroOf" [] (Elim (const_of, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_of, [App (a), App (Sub (m, Shift 1)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntroEq a m n = Arg.make "foralltpIntroEq" [] (Elim (const_eq, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eq, [App (a), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntro a = Arg.make "foralltpIntro" [] (Elim (const_foralltp, [App (Lam (NONE, a)), ])) [(Arg.Nothing, [J.Tph, ], a), ] (fn [m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun foralltpElimOf a b m = Arg.make "foralltpElimOf" [] (Elim (const_of, [App (Sub (a, Dot (b, Shift 0))), App (m), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpElimEq a b m n = Arg.make "foralltpElimEq" [] (Elim (const_eq, [App (Sub (a, Dot (b, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpElim a b = Arg.make "foralltpElim" [] (Sub (a, Dot (b, Shift 0))) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_foralltp, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, m, _, ] => m | _ => raise Arg.ExtractFailure)
fun iexistsForm a i k = Arg.make "iexistsForm" [] (Elim (const_istp, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsEq a b i k l = Arg.make "iexistsEq" [] (Elim (const_eqtp, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iexists, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsFormUniv a i j k = Arg.make "iexistsFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsEqUniv a b i j k l = Arg.make "iexistsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iexists, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntroOf a b i k m = Arg.make "iexistsIntroOf" [] (Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (b, Shift 0))), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntroEq a b i k m n = Arg.make "iexistsIntroEq" [] (Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (b, Shift 0))), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntro a b i k = Arg.make "iexistsIntro" [] (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Nothing, [], Sub (a, Dot (b, Shift 0))), ] (fn [_, _, _, m, ] => m | _ => raise Arg.ExtractFailure)
fun iexistsElimOf a b i k m p = Arg.make "iexistsElimOf" [] (Elim (const_of, [App (b), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_of, [App (Sub (b, Shift 2)), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEq a b i k m n p q = Arg.make "iexistsElimEq" [] (Elim (const_eq, [App (b), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eq, [App (Sub (b, Shift 2)), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElim a b i k m = Arg.make "iexistsElim" [m, ] (b) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), J.Tmh (k), ], Sub (b, Shift 2)), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun iexistsElimOfDep a b i k m p = Arg.make "iexistsElimOfDep" [] (Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_of, [App (Sub (b, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEqDep a b i k m n p q = Arg.make "iexistsElimEqDep" [] (Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eq, [App (Sub (b, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimDep a b i k m = Arg.make "iexistsElimDep" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), J.Tmh (k), ], Sub (b, Idot (0, Shift 2))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun iexistsElimIstype a b i k m = Arg.make "iexistsElimIstype" [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_istp, [App (Sub (b, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEqtype a b c i k m n = Arg.make "iexistsElimEqtype" [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (c, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eqtp, [App (Sub (b, Idot (0, Shift 2))), App (Sub (c, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun substitution gsize a b m = Arg.lmake "substitution" [] gsize [J.Tm (a), ] (b) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), Sub (b, under gsize (Dot (m, Shift 0)))), ] (fn [_, _, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun substitutionSimple gsize a b m = Arg.lmake "substitutionSimple" [] gsize [J.Tm (a), ] (Sub (b, under gsize (Shift 1))) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), b), ] (fn [_, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun generalize a b m = Arg.make "generalize" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [J.Tm (a), ], b), ] (fn [_, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun assert a b = Arg.make "assert" [] (b) [(Arg.Nothing, [], a), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Elim (const_let, [App (m), App (Lam (NONE, n)), ]) | _ => raise Arg.ExtractFailure)
fun assert' a b = Arg.make "assert'" [] (b) [(Arg.Nothing, [], a), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun assertLater a b = Arg.make "assertLater" [] (b) [(Arg.Promote, [], a), (Arg.Nothing, [J.Tml (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Elim (const_let, [App (m), App (Lam (NONE, n)), ]) | _ => raise Arg.ExtractFailure)
fun assertLater' a b = Arg.make "assertLater'" [] (b) [(Arg.Promote, [], a), (Arg.Nothing, [J.Tml (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun inhabitant a m = Arg.make "inhabitant" [m, ] (a) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => m | _ => raise Arg.ExtractFailure)
fun letForm a b m n = Arg.make "letForm" [] (Elim (const_of, [App (b), App (Elim (const_let, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lethForm a b m n = Arg.make "lethForm" [] (Elim (const_of, [App (b), App (Elim (const_leth, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun leteForm a b m n = Arg.make "leteForm" [] (Elim (const_of, [App (b), App (Elim (const_lete, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun accInd a b i m n r = Arg.make "accInd" [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (Elim (const_arrow, [App (a), App (Elim (const_univ, [App (i), ])), ])), ])), App (r), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Sub (a, Shift 1)), App (Lam (NONE, Elim (const_arrow, [App (Elim (Sub (r, Shift 2), [App (Var 0), App (Var 1), ])), App (Sub (b, Idot (0, Shift 2))), ]))), ])), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_acc, [App (a), App (r), App (m), ])), App (n), ])), ] (fn [_, _, p, _, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Sub (p, Dot (Lam (NONE, Lam (NONE, Elim (Var 3, [App (Var 1), ]))), Idot (0, Shift 2)))))), App (m), ]) | _ => raise Arg.ExtractFailure)
fun sequalForm m = Arg.make "sequalForm" [] (Elim (const_istp, [App (Elim (const_sequal, [App (m), App (m), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sequalIntroOf m = Arg.make "sequalIntroOf" [] (Elim (const_of, [App (Elim (const_sequal, [App (m), App (m), ])), App (Triv), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sequalIntro m = Arg.make "sequalIntro" [] (Elim (const_sequal, [App (m), App (m), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sequalTrivialize m n = Arg.make "sequalTrivialize" [] (Elim (const_sequal, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalExt m n p q = Arg.make "sequalExt" [] (Elim (const_eq, [App (Elim (const_sequal, [App (m), App (n), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sequal, [App (m), App (n), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_sequal, [App (m), App (n), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalLeft gsize c m n = Arg.lmake "sequalLeft" [] gsize [J.Tm (Elim (const_sequal, [App (m), App (n), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [p, ] => Sub (p, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun sequalEq a m n = Arg.make "sequalEq" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalEqtp a b = Arg.make "sequalEqtp" [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequivalence a b = Arg.make "sequivalence" [] (b) [(Arg.Unhide, [], Elim (const_sequal, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun sequivalenceLeft gsize a b c = Arg.lmake "sequivalenceLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_sequal, [App (Sub (a, Shift (gsize + 1))), App (Sub (b, Shift (gsize + 1))), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun substitutionSyntactic gsize a b m = Arg.lmake "substitutionSyntactic" [] gsize [J.Tm (a), ] (b) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_sequal, [App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), Sub (b, under gsize (Dot (m, Shift 0)))), ] (fn [_, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun sequalSymm m n = Arg.make "sequalSymm" [] (Elim (const_sequal, [App (n), App (m), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalTrans m n p = Arg.make "sequalTrans" [] (Elim (const_sequal, [App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_sequal, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalCompat m n p = Arg.make "sequalCompat" [] (Elim (const_sequal, [App (Sub (p, Dot (m, Shift 0))), App (Sub (p, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalCompatLam m n = Arg.make "sequalCompatLam" [] (Elim (const_sequal, [App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [J.Tm (const_nonsense), ], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEtaSequal a b m = Arg.make "forallEtaSequal" [] (Elim (const_sequal, [App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEtaSequal a b m = Arg.make "arrowEtaSequal" [] (Elim (const_sequal, [App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEtaSequal a b m = Arg.make "existsEtaSequal" [] (Elim (const_sequal, [App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEtaSequal a b m = Arg.make "prodEtaSequal" [] (Elim (const_sequal, [App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEtaSequal a m = Arg.make "futureEtaSequal" [] (Elim (const_sequal, [App (m), App (Next (Elim (m, [Prev, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialForm a = Arg.make "partialForm" [] (Elim (const_istp, [App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialEq a b = Arg.make "partialEq" [] (Elim (const_eqtp, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialFormUniv a i = Arg.make "partialFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialEqUniv a b i = Arg.make "partialEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialSub a b = Arg.make "partialSub" [] (Elim (const_subtype, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialStrict a = Arg.make "partialStrict" [] (Elim (const_subtype, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (Elim (const_partial, [App (a), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialStrictConverse a = Arg.make "partialStrictConverse" [] (Elim (const_subtype, [App (Elim (const_partial, [App (Elim (const_partial, [App (a), ])), ])), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialIdem a = Arg.make "partialIdem" [] (Elim (const_eeqtp, [App (Elim (const_partial, [App (Elim (const_partial, [App (a), ])), ])), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun haltsForm a m = Arg.make "haltsForm" [] (Elim (const_istp, [App (Elim (const_halts, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsEq a m n = Arg.make "haltsEq" [] (Elim (const_eqtp, [App (Elim (const_halts, [App (m), ])), App (Elim (const_halts, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsFormUniv a i m = Arg.make "haltsFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_halts, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsEqUniv a i m n = Arg.make "haltsEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_halts, [App (m), ])), App (Elim (const_halts, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialIntroBottomOf a = Arg.make "partialIntroBottomOf" [] (Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (const_bottom), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val bottomDiverges = Arg.make "bottomDiverges" [] (const_void) [(Arg.Unhide, [], Elim (const_halts, [App (const_bottom), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialExt a m n = Arg.make "partialExt" [] (Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_iff, [App (Elim (const_halts, [App (m), ])), App (Elim (const_halts, [App (n), ])), ])), (Arg.Unhide, [J.Tm (Elim (const_halts, [App (m), ])), ], Elim (const_eq, [App (Sub (a, Shift 1)), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialElimEq a m n = Arg.make "partialElimEq" [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialElimOf a m = Arg.make "partialElimOf" [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsTrivialize m = Arg.make "haltsTrivialize" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsExt m n p = Arg.make "haltsExt" [] (Elim (const_eq, [App (Elim (const_halts, [App (m), ])), App (n), App (p), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_halts, [App (m), ])), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_halts, [App (m), ])), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsLeft gsize c m = Arg.lmake "haltsLeft" [] gsize [J.Tm (Elim (const_halts, [App (m), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun fixpointInductionEq a m n = Arg.make "fixpointInductionEq" [] (Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (Elim (const_fix, [App (m), ])), App (Elim (const_fix, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_arrow, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (a), ])), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun fixpointInductionOf a m = Arg.make "fixpointInductionOf" [] (Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (Elim (const_fix, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (a), ])), ])), App (m), ])), (Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialFormInv a = Arg.make "partialFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_partial, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun seqBind a b m m' n n' = Arg.make "seqBind" [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Elim (const_seq, [App (m'), App (Lam (NONE, n')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (m'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (n), App (n'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeApp a b m n = Arg.make "activeApp" [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [App (Sub (n, Shift 1)), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeAppSeq a b m n = Arg.make "activeAppSeq" [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [App (n), ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (Var 0, [App (Sub (n, Shift 1)), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [App (Sub (n, Shift 1)), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun appHaltsInv m n = Arg.make "appHaltsInv" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi1 a b m = Arg.make "activePi1" [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi1Seq a b m = Arg.make "activePi1Seq" [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi1, ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (Var 0, [Pi1, ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun pi1HaltsInv m = Arg.make "pi1HaltsInv" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [Pi1, ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi2 a b m = Arg.make "activePi2" [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi2, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi2Seq a b m = Arg.make "activePi2Seq" [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi2, ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (Var 0, [Pi2, ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi2, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun pi2HaltsInv m = Arg.make "pi2HaltsInv" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [Pi2, ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prevHaltsInv m = Arg.make "prevHaltsInv" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [Prev, ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeCase a b m p r = Arg.make "activeCase" [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Sub (p, Idot (0, Shift 2)))), App (Lam (NONE, Sub (r, Idot (0, Shift 2)))), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeCaseSeq a b m p r = Arg.make "activeCaseSeq" [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Sub (p, Idot (0, Shift 2)))), App (Lam (NONE, Sub (r, Idot (0, Shift 2)))), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Sub (p, Idot (0, Shift 2)))), App (Lam (NONE, Sub (r, Idot (0, Shift 2)))), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun caseHaltsInv m p r = Arg.make "caseHaltsInv" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun seqHaltsSequal m n = Arg.make "seqHaltsSequal" [] (Elim (const_sequal, [App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Sub (n, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun seqHaltsInv m n = Arg.make "seqHaltsInv" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (const_seq, [App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalUnderSeq m m' n = Arg.make "sequalUnderSeq" [] (Elim (const_sequal, [App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Sub (n, Dot (m', Shift 0))), ])) [(Arg.Unhide, [], Elim (const_seq, [App (m), App (Lam (NONE, Elim (const_sequal, [App (Var 0), App (Sub (m', Shift 1)), ]))), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun totalStrict a = Arg.make "totalStrict" [] (Elim (const_subtype, [App (a), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_halts, [App (Var 0), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
val voidTotal' = Arg.make "voidTotal'" [] (Elim (const_total, [App (const_void), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val voidStrict = Arg.make "voidStrict" [] (Elim (const_subtype, [App (const_void), App (Elim (const_partial, [App (const_void), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitTotal m = Arg.make "unitTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_unit), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitTotal' = Arg.make "unitTotal'" [] (Elim (const_total, [App (const_unit), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val unitStrict = Arg.make "unitStrict" [] (Elim (const_subtype, [App (const_unit), App (Elim (const_partial, [App (const_unit), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolTotal m = Arg.make "boolTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val boolTotal' = Arg.make "boolTotal'" [] (Elim (const_total, [App (const_bool), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val boolStrict = Arg.make "boolStrict" [] (Elim (const_subtype, [App (const_bool), App (Elim (const_partial, [App (const_bool), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun forallTotal a b m = Arg.make "forallTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallTotal' a b = Arg.make "forallTotal'" [] (Elim (const_total, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun forallStrict a b = Arg.make "forallStrict" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowTotal a b m = Arg.make "arrowTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowTotal' a b = Arg.make "arrowTotal'" [] (Elim (const_total, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun arrowStrict a b = Arg.make "arrowStrict" [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_arrow, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectStrict a b = Arg.make "intersectStrict" [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Elim (const_partial, [App (b), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsTotal a b m = Arg.make "existsTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsTotal' a b = Arg.make "existsTotal'" [] (Elim (const_total, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun existsStrict a b = Arg.make "existsStrict" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodTotal a b m = Arg.make "prodTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodTotal' a b = Arg.make "prodTotal'" [] (Elim (const_total, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun prodStrict a b = Arg.make "prodStrict" [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_prod, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodTotal a b m = Arg.make "dprodTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodTotal' a b = Arg.make "dprodTotal'" [] (Elim (const_total, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun dprodStrict a b = Arg.make "dprodStrict" [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_dprod, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumTotal a b m = Arg.make "sumTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumTotal' a b = Arg.make "sumTotal'" [] (Elim (const_total, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun sumStrict a b = Arg.make "sumStrict" [] (Elim (const_subtype, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_sum, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureTotal a m = Arg.make "futureTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureTotal' a = Arg.make "futureTotal'" [] (Elim (const_total, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun futureStrict a = Arg.make "futureStrict" [] (Elim (const_subtype, [App (Elim (const_future, [App (a), ])), App (Elim (const_partial, [App (Elim (const_future, [App (a), ])), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setTotal' a b = Arg.make "setTotal'" [] (Elim (const_total, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun setStrict a b = Arg.make "setStrict" [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (a), App (Elim (const_partial, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetTotal' a b = Arg.make "isetTotal'" [] (Elim (const_total, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun isetStrict a b = Arg.make "isetStrict" [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (a), App (Elim (const_partial, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientTotal' a b = Arg.make "quotientTotal'" [] (Elim (const_total, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun natTotal m = Arg.make "natTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_nat), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val natTotal' = Arg.make "natTotal'" [] (Elim (const_total, [App (const_nat), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val natStrict = Arg.make "natStrict" [] (Elim (const_subtype, [App (const_nat), App (Elim (const_partial, [App (const_nat), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun typeHalts a = Arg.make "typeHalts" [] (Elim (const_halts, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univTotal' i = Arg.make "univTotal'" [] (Elim (const_total, [App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun univStrict i = Arg.make "univStrict" [] (Elim (const_subtype, [App (Elim (const_univ, [App (i), ])), App (Elim (const_partial, [App (Elim (const_univ, [App (i), ])), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun reduceSeqTotal a m n = Arg.make "reduceSeqTotal" [] (Elim (const_sequal, [App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Sub (n, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsTotal a m = Arg.make "haltsTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeForm a = Arg.make "uptypeForm" [] (Elim (const_istp, [App (Elim (const_uptype, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeEq a b = Arg.make "uptypeEq" [] (Elim (const_eqtp, [App (Elim (const_uptype, [App (a), ])), App (Elim (const_uptype, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeFormUniv a i = Arg.make "uptypeFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_uptype, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeEqUniv a b i = Arg.make "uptypeEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_uptype, [App (a), ])), App (Elim (const_uptype, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeTrivialize a = Arg.make "uptypeTrivialize" [] (Elim (const_uptype, [App (a), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeExt a m n = Arg.make "uptypeExt" [] (Elim (const_eq, [App (Elim (const_uptype, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_uptype, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_uptype, [App (a), ])), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeLeft gsize a b = Arg.lmake "uptypeLeft" [] gsize [J.Tm (Elim (const_uptype, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun uptypeEeqtp a b = Arg.make "uptypeEeqtp" [] (Elim (const_uptype, [App (b), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeUnitary a = Arg.make "uptypeUnitary" [] (Elim (const_uptype, [App (a), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (const_unit), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val voidUptype = Arg.make "voidUptype" [] (Elim (const_uptype, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitUptype = Arg.make "unitUptype" [] (Elim (const_uptype, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolUptype = Arg.make "boolUptype" [] (Elim (const_uptype, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun forallUptype a b = Arg.make "forallUptype" [] (Elim (const_uptype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowUptype a b = Arg.make "arrowUptype" [] (Elim (const_uptype, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectUptype a b = Arg.make "intersectUptype" [] (Elim (const_uptype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsUptype a b = Arg.make "existsUptype" [] (Elim (const_uptype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodUptype a b = Arg.make "prodUptype" [] (Elim (const_uptype, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodUptype a b = Arg.make "dprodUptype" [] (Elim (const_uptype, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumUptype a b = Arg.make "sumUptype" [] (Elim (const_uptype, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureUptype a = Arg.make "futureUptype" [] (Elim (const_uptype, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_uptype, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqUptype a m n = Arg.make "eqUptype" [] (Elim (const_uptype, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofUptype a m = Arg.make "ofUptype" [] (Elim (const_uptype, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpUptype a b = Arg.make "eqtpUptype" [] (Elim (const_uptype, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpUptype a = Arg.make "istpUptype" [] (Elim (const_uptype, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeUptype a b = Arg.make "subtypeUptype" [] (Elim (const_uptype, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setUptype a b = Arg.make "setUptype" [] (Elim (const_uptype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetUptype a b = Arg.make "isetUptype" [] (Elim (const_uptype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUptype a = Arg.make "muUptype" [] (Elim (const_uptype, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (Elim (const_uptype, [App (Var 0), ])), J.Tp, ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUptypeUniv a i = Arg.make "muUptypeUniv" [] (Elim (const_uptype, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [J.Tm (Elim (const_uptype, [App (Var 0), ])), J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUptype a = Arg.make "recUptype" [] (Elim (const_uptype, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_uptype, [App (Var 0), ])), J.Tpl, ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUptypeUniv a i = Arg.make "recUptypeUniv" [] (Elim (const_uptype, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_uptype, [App (Var 0), ])), J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val natUptype = Arg.make "natUptype" [] (Elim (const_uptype, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeFormInv a = Arg.make "uptypeFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_uptype, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissForm a = Arg.make "admissForm" [] (Elim (const_istp, [App (Elim (const_admiss, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissEq a b = Arg.make "admissEq" [] (Elim (const_eqtp, [App (Elim (const_admiss, [App (a), ])), App (Elim (const_admiss, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissFormUniv a i = Arg.make "admissFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_admiss, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissEqUniv a b i = Arg.make "admissEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_admiss, [App (a), ])), App (Elim (const_admiss, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissTrivialize a = Arg.make "admissTrivialize" [] (Elim (const_admiss, [App (a), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissExt a m n = Arg.make "admissExt" [] (Elim (const_eq, [App (Elim (const_admiss, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_admiss, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_admiss, [App (a), ])), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissLeft gsize a b = Arg.lmake "admissLeft" [] gsize [J.Tm (Elim (const_admiss, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun admissEeqtp a b = Arg.make "admissEeqtp" [] (Elim (const_admiss, [App (b), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeAdmiss a = Arg.make "uptypeAdmiss" [] (Elim (const_admiss, [App (a), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialAdmiss a = Arg.make "partialAdmiss" [] (Elim (const_admiss, [App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val voidAdmiss = Arg.make "voidAdmiss" [] (Elim (const_admiss, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitAdmiss = Arg.make "unitAdmiss" [] (Elim (const_admiss, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolAdmiss = Arg.make "boolAdmiss" [] (Elim (const_admiss, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun forallAdmiss a b = Arg.make "forallAdmiss" [] (Elim (const_admiss, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowAdmiss a b = Arg.make "arrowAdmiss" [] (Elim (const_admiss, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectAdmiss a b = Arg.make "intersectAdmiss" [] (Elim (const_admiss, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsAdmissUptype a b = Arg.make "existsAdmissUptype" [] (Elim (const_admiss, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodAdmiss a b = Arg.make "prodAdmiss" [] (Elim (const_admiss, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), (Arg.Unhide, [], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodAdmissUptype a b = Arg.make "dprodAdmissUptype" [] (Elim (const_admiss, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumAdmiss a b = Arg.make "sumAdmiss" [] (Elim (const_admiss, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), (Arg.Unhide, [], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureAdmiss a = Arg.make "futureAdmiss" [] (Elim (const_admiss, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqAdmiss a m n = Arg.make "eqAdmiss" [] (Elim (const_admiss, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofAdmiss a m = Arg.make "ofAdmiss" [] (Elim (const_admiss, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpAdmiss a b = Arg.make "eqtpAdmiss" [] (Elim (const_admiss, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpAdmiss a = Arg.make "istpAdmiss" [] (Elim (const_admiss, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeAdmiss a b = Arg.make "subtypeAdmiss" [] (Elim (const_admiss, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recAdmiss a = Arg.make "recAdmiss" [] (Elim (const_admiss, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_admiss, [App (Var 0), ])), J.Tpl, ], Elim (const_admiss, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recAdmissUniv a i = Arg.make "recAdmissUniv" [] (Elim (const_admiss, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_admiss, [App (Var 0), ])), J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_admiss, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val natAdmiss = Arg.make "natAdmiss" [] (Elim (const_admiss, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun admissFormInv a = Arg.make "admissFormInv" [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_admiss, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val partialType = Arg.make "partialType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_univ, [App (Var 0), ])), App (Elim (const_univ, [App (Var 0), ])), ]))), ])), App (const_partial), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val haltsType = Arg.make "haltsType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_partial, [App (Var 0), ])), App (Elim (const_univ, [App (const_lzero), ])), ]))), ]))), ])), App (const_halts), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val admissType = Arg.make "admissType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_univ, [App (Var 0), ])), App (Elim (const_univ, [App (Var 0), ])), ]))), ])), App (const_admiss), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val uptypeType = Arg.make "uptypeType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_univ, [App (Var 0), ])), App (Elim (const_univ, [App (Var 0), ])), ]))), ])), App (const_uptype), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val seqType = Arg.make "seqType" [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 1), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_partial, [App (Var 1), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 1), App (Elim (const_partial, [App (Var 0), ])), ])), App (Elim (const_partial, [App (Var 0), ])), ])), ]))), ]))), ]))), ])), App (const_seq), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpRefl a = Arg.make "eeqtpRefl" [] (Elim (const_eeqtp, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eeqtpSymm a b = Arg.make "eeqtpSymm" [] (Elim (const_eeqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eeqtpTrans a b c = Arg.make "eeqtpTrans" [] (Elim (const_eeqtp, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (c), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun weakenEqtpEeqtp a b = Arg.make "weakenEqtpEeqtp" [] (Elim (const_eeqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun weakenSubtypeArrow a b = Arg.make "weakenSubtypeArrow" [] (Elim (const_arrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Lam (NONE, Var 0) | _ => raise Arg.ExtractFailure)
fun weakenEeqtpIff a b = Arg.make "weakenEeqtpIff" [] (Elim (const_iff, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), ] (fn [_, ] => Pair (Lam (NONE, Var 0), Lam (NONE, Var 0)) | _ => raise Arg.ExtractFailure)
fun compatGuardEqtp1 a b b' = Arg.make "compatGuardEqtp1" [] (Elim (const_eqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatSetEqtp0 a a' b = Arg.make "compatSetEqtp0" [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEeq a a' b b' = Arg.make "forallEeq" [] (Elim (const_eeqtp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun existsEeq a a' b b' = Arg.make "existsEeq" [] (Elim (const_eeqtp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun arrowEeq a a' b b' = Arg.make "arrowEeq" [] (Elim (const_eeqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun prodEeq a a' b b' = Arg.make "prodEeq" [] (Elim (const_eeqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun dprodEeq a a' b b' = Arg.make "dprodEeq" [] (Elim (const_eeqtp, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun sumEeq a a' b b' = Arg.make "sumEeq" [] (Elim (const_eeqtp, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun futureEeq a a' = Arg.make "futureEeq" [] (Elim (const_eeqtp, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (a'), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun letnextEeq a b b' m = Arg.make "letnextEeq" [] (Elim (const_eeqtp, [App (Elim (const_letnext, [App (m), App (Lam (NONE, b)), ])), App (Elim (const_letnext, [App (m), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun intersectEeq a a' b b' = Arg.make "intersectEeq" [] (Elim (const_eeqtp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun unionEeq a a' b b' = Arg.make "unionEeq" [] (Elim (const_eeqtp, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eqEeq a a' m n = Arg.make "eqEeq" [] (Elim (const_eeqtp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (Elim (const_eq, [App (a'), App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eeqEeq a a' b b' = Arg.make "eeqEeq" [] (Elim (const_eeqtp, [App (Elim (const_eeqtp, [App (a), App (b), ])), App (Elim (const_eeqtp, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatGuardEeq1 a b b' = Arg.make "compatGuardEeq1" [] (Elim (const_eeqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatSetEeq0 a a' b = Arg.make "compatSetEeq0" [] (Elim (const_eeqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatIsetEeq0 a a' b = Arg.make "compatIsetEeq0" [] (Elim (const_eeqtp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatIsetIff1 a b b' = Arg.make "compatIsetIff1" [] (Elim (const_eeqtp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatForallSubtype0 a a' b = Arg.make "compatForallSubtype0" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatForallSubtype1 a b b' = Arg.make "compatForallSubtype1" [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatExistsSubtype0 a a' b = Arg.make "compatExistsSubtype0" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatExistsSubtype1 a b b' = Arg.make "compatExistsSubtype1" [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIntersectSubtype0 a a' b = Arg.make "compatIntersectSubtype0" [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIntersectSubtype1 a b b' = Arg.make "compatIntersectSubtype1" [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatUnionSubtype0 a a' b = Arg.make "compatUnionSubtype0" [] (Elim (const_subtype, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatUnionSubtype1 a b b' = Arg.make "compatUnionSubtype1" [] (Elim (const_subtype, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatGuardArrow0 a a' b = Arg.make "compatGuardArrow0" [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_arrow, [App (a'), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatGuardSubtype1 a b b' = Arg.make "compatGuardSubtype1" [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatSetSubtype0 a a' b = Arg.make "compatSetSubtype0" [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatSetArrow1 a b b' = Arg.make "compatSetArrow1" [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIsetSubtype0 a a' b = Arg.make "compatIsetSubtype0" [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIsetArrow1 a b b' = Arg.make "compatIsetArrow1" [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatForallIff1 a b b' = Arg.make "compatForallIff1" [] (Elim (const_iff, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Lam (NONE, Elim (Sub (m, Idot (0, Shift 2)), [Pi1, App (Elim (Var 1, [App (Var 0), ])), ]))), Lam (NONE, Lam (NONE, Elim (Sub (m, Idot (0, Shift 2)), [Pi2, App (Elim (Var 1, [App (Var 0), ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatExistsIff1 a b b' = Arg.make "compatExistsIff1" [] (Elim (const_iff, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Dot (Elim (Var 0, [Pi1, ]), Shift 1)), [Pi1, App (Elim (Var 0, [Pi2, ])), ]))), Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Dot (Elim (Var 0, [Pi1, ]), Shift 1)), [Pi2, App (Elim (Var 0, [Pi2, ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatArrowIff0 a a' b = Arg.make "compatArrowIff0" [] (Elim (const_iff, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Lam (NONE, Elim (Var 1, [App (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])), ]))), Lam (NONE, Lam (NONE, Elim (Var 1, [App (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatArrowIff1 a b b' = Arg.make "compatArrowIff1" [] (Elim (const_iff, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Lam (NONE, Elim (Sub (m, Shift 2), [Pi1, App (Elim (Var 1, [App (Var 0), ])), ]))), Lam (NONE, Lam (NONE, Elim (Sub (m, Shift 2), [Pi2, App (Elim (Var 1, [App (Var 0), ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatProdIff0 a a' b = Arg.make "compatProdIff0" [] (Elim (const_iff, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))), Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ])))) | _ => raise Arg.ExtractFailure)
fun compatProdIff1 a b b' = Arg.make "compatProdIff1" [] (Elim (const_iff, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi2, ])), ]))), Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi2, ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatDprodIff0 a a' b = Arg.make "compatDprodIff0" [] (Elim (const_iff, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))), Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ])))) | _ => raise Arg.ExtractFailure)
fun compatDprodIff1 a b b' = Arg.make "compatDprodIff1" [] (Elim (const_iff, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi2, ])), ]))), Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi2, ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatSumIff0 a a' b = Arg.make "compatSumIff0" [] (Elim (const_iff, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])), ]))), App (Lam (NONE, Elim (const_inr, [App (Var 0), ]))), ])), Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])), ]))), App (Lam (NONE, Elim (const_inr, [App (Var 0), ]))), ]))) | _ => raise Arg.ExtractFailure)
fun compatSumIff1 a b b' = Arg.make "compatSumIff1" [] (Elim (const_iff, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Var 0), ]))), App (Lam (NONE, Elim (const_inr, [App (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])), ]))), ])), Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Var 0), ]))), App (Lam (NONE, Elim (const_inr, [App (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])), ]))), ]))) | _ => raise Arg.ExtractFailure)
fun compatFutureIff a a' = Arg.make "compatFutureIff" [] (Elim (const_iff, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (a'), ])), ])) [(Arg.Promote, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [m, ] => Pair (Lam (NONE, Elim (const_letnext, [App (Var 0), App (Lam (NONE, Next (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])))), ])), Lam (NONE, Elim (const_letnext, [App (Var 0), App (Lam (NONE, Next (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])))), ]))) | _ => raise Arg.ExtractFailure)
fun compatForallArrow1 a b b' = Arg.make "compatForallArrow1" [] (Elim (const_arrow, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Lam (NONE, Elim (Sub (m, Idot (0, Shift 2)), [App (Elim (Var 1, [App (Var 0), ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatExistsArrow1 a b b' = Arg.make "compatExistsArrow1" [] (Elim (const_arrow, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, m, ] => Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Dot (Elim (Var 0, [Pi1, ]), Shift 1)), [App (Elim (Var 0, [Pi2, ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatArrowArrow0 a a' b = Arg.make "compatArrowArrow0" [] (Elim (const_arrow, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a'), App (a), ])), ] (fn [_, _, m, ] => Lam (NONE, Lam (NONE, Elim (Var 1, [App (Elim (Sub (m, Shift 2), [App (Var 0), ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatArrowArrow1 a b b' = Arg.make "compatArrowArrow1" [] (Elim (const_arrow, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Lam (NONE, Elim (Sub (m, Shift 2), [App (Elim (Var 1, [App (Var 0), ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatProdArrow0 a a' b = Arg.make "compatProdArrow0" [] (Elim (const_arrow, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))) | _ => raise Arg.ExtractFailure)
fun compatProdArrow1 a b b' = Arg.make "compatProdArrow1" [] (Elim (const_arrow, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi2, ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatDprodArrow0 a a' b = Arg.make "compatDprodArrow0" [] (Elim (const_arrow, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))) | _ => raise Arg.ExtractFailure)
fun compatDprodArrow1 a b b' = Arg.make "compatDprodArrow1" [] (Elim (const_arrow, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi2, ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatSumArrow0 a a' b = Arg.make "compatSumArrow0" [] (Elim (const_arrow, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [_, _, m, ] => Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Elim (Sub (m, Shift 2), [App (Var 0), ])), ]))), App (Lam (NONE, Elim (const_inr, [App (Var 0), ]))), ])) | _ => raise Arg.ExtractFailure)
fun compatSumArrow1 a b b' = Arg.make "compatSumArrow1" [] (Elim (const_arrow, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, m, ] => Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Var 0), ]))), App (Lam (NONE, Elim (const_inr, [App (Elim (Sub (m, Shift 2), [App (Var 0), ])), ]))), ])) | _ => raise Arg.ExtractFailure)
fun compatFutureArrow a a' = Arg.make "compatFutureArrow" [] (Elim (const_arrow, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (a'), ])), ])) [(Arg.Promote, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [m, ] => Lam (NONE, Elim (const_letnext, [App (Var 0), App (Lam (NONE, Next (Elim (Sub (m, Shift 2), [App (Var 0), ])))), ])) | _ => raise Arg.ExtractFailure)
fun compatForallEntails1 a b b' = Arg.make "compatForallEntails1" [] (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])) [(Arg.Nothing, [J.Tm (b), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, f, ] => Lam (NONE, Sub (m, Dot (Elim (Sub (f, Shift 1), [App (Var 0), ]), Shift 0))) | _ => raise Arg.ExtractFailure)
fun compatArrowEntails1 a b b' = Arg.make "compatArrowEntails1" [] (Elim (const_arrow, [App (a), App (b'), ])) [(Arg.Nothing, [J.Tm (b), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (b), ])), ] (fn [m, f, ] => Lam (NONE, Sub (m, Dot (Elim (Sub (f, Shift 1), [App (Var 0), ]), Shift 1))) | _ => raise Arg.ExtractFailure)
fun compatProdEntails0 a a' b = Arg.make "compatProdEntails0" [] (Elim (const_prod, [App (a'), App (b), ])) [(Arg.Nothing, [J.Tm (a), ], Sub (a', Shift 1)), (Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Sub (m, Dot (Elim (p, [Pi1, ]), Shift 0)), Elim (p, [Pi2, ])) | _ => raise Arg.ExtractFailure)
fun compatProdEntails1 a b b' = Arg.make "compatProdEntails1" [] (Elim (const_prod, [App (a), App (b'), ])) [(Arg.Nothing, [J.Tm (b), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Elim (p, [Pi1, ]), Sub (m, Dot (Elim (p, [Pi2, ]), Shift 0))) | _ => raise Arg.ExtractFailure)
fun compatDprodEntails0 a a' b = Arg.make "compatDprodEntails0" [] (Elim (const_dprod, [App (a'), App (b), ])) [(Arg.Nothing, [J.Tm (a), ], Sub (a', Shift 1)), (Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Sub (m, Dot (Elim (p, [Pi1, ]), Shift 0)), Elim (p, [Pi2, ])) | _ => raise Arg.ExtractFailure)
fun compatDprodEntails1 a b b' = Arg.make "compatDprodEntails1" [] (Elim (const_dprod, [App (a), App (b'), ])) [(Arg.Nothing, [J.Tm (b), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Elim (p, [Pi1, ]), Sub (m, Dot (Elim (p, [Pi2, ]), Shift 0))) | _ => raise Arg.ExtractFailure)
val integerForm = Arg.make "integerForm" [] (Elim (const_istp, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerEq = Arg.make "integerEq" [] (Elim (const_eqtp, [App (const_integer), App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerFormUniv i = Arg.make "integerFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_integer), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun integerEqUniv i = Arg.make "integerEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_integer), App (const_integer), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val integerToDefType = Arg.make "integerToDefType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_integer), App (const_cInteger), ])), App (const_integer_to_Integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerFromDefType = Arg.make "integerFromDefType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_cInteger), App (const_integer), ])), App (const_integer_from_Integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerIsomorphism1 = Arg.make "integerIsomorphism1" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), App (Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_integer_to_Integer, [App (Var 0), ])), ]))), App (Lam (NONE, Var 0)), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerIsomorphism2 = Arg.make "integerIsomorphism2" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_cInteger), App (const_cInteger), ])), App (Lam (NONE, Elim (const_integer_to_Integer, [App (Elim (const_integer_from_Integer, [App (Var 0), ])), ]))), App (Lam (NONE, Var 0)), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val pluszSpec = Arg.make "pluszSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), ])), App (const_plusz), App (Lam (NONE, Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_cPlusz, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val negzSpec = Arg.make "negzSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), App (const_negz), App (Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_cNegz, [App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])), ]))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val eqzbSpec = Arg.make "eqzbSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_bool), ])), ])), App (const_eqzb), App (Lam (NONE, Lam (NONE, Elim (const_cEqzb, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val leqzbSpec = Arg.make "leqzbSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_bool), ])), ])), App (const_leqzb), App (Lam (NONE, Lam (NONE, Elim (const_cLeqzb, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val timeszSpec = Arg.make "timeszSpec" [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), ])), App (const_timesz), App (Lam (NONE, Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_cTimesz, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerTotal m = Arg.make "integerTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_integer), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val integerStrict = Arg.make "integerStrict" [] (Elim (const_subtype, [App (const_integer), App (Elim (const_partial, [App (const_integer), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerUptype = Arg.make "integerUptype" [] (Elim (const_uptype, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerAdmiss = Arg.make "integerAdmiss" [] (Elim (const_admiss, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerSequal m n = Arg.make "integerSequal" [] (Elim (const_sequal, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_integer), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val symbolForm = Arg.make "symbolForm" [] (Elim (const_istp, [App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val symbolEq = Arg.make "symbolEq" [] (Elim (const_eqtp, [App (const_symbol), App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun symbolFormUniv i = Arg.make "symbolFormUniv" [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_symbol), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun symbolEqUniv i = Arg.make "symbolEqUniv" [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_symbol), App (const_symbol), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val symbol_eqbType = Arg.make "symbol_eqbType" [] (Elim (const_of, [App (Elim (const_arrow, [App (const_symbol), App (Elim (const_arrow, [App (const_symbol), App (const_bool), ])), ])), App (const_symbol_eqb), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun symbol_eqbSpec1 m n = Arg.make "symbol_eqbSpec1" [] (Elim (const_eq, [App (const_bool), App (Elim (const_symbol_eqb, [App (m), App (n), ])), App (const_true), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_symbol), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun symbol_eqbSpec2 m n = Arg.make "symbol_eqbSpec2" [] (Elim (const_eq, [App (const_symbol), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (Elim (const_symbol_eqb, [App (m), App (n), ])), App (const_true), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun symbolTotal m = Arg.make "symbolTotal" [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_symbol), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val symbolStrict = Arg.make "symbolStrict" [] (Elim (const_subtype, [App (const_symbol), App (Elim (const_partial, [App (const_symbol), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val symbolUptype = Arg.make "symbolUptype" [] (Elim (const_uptype, [App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val symbolAdmiss = Arg.make "symbolAdmiss" [] (Elim (const_admiss, [App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun symbolSequal m n = Arg.make "symbolSequal" [] (Elim (const_sequal, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_symbol), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)

end
