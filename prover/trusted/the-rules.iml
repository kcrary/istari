(* This file is generated by Rulegen. *)

signature RULE_ARG =
   sig

      type rule

      exception ExtractFailure

      datatype context_action =
         Nothing
       | Promote
       | Unhide
       | PromoteUnhide

      val make :
         string                                                      (* name *)
         -> Term.term list                                           (* all variables *)
         -> Term.term list                                           (* extract variables *)
         -> Term.term                                                (* conclusion *)
         -> (context_action * Judgement.hyp list * Term.term) list   (* premises *)
         -> (Term.term list -> Term.term)                            (* extract *)
         -> rule

      val lmake :
         string                             (* name *)
         -> Term.term list                  (* extract variables *)
         -> int                             (* size of trailing context *)
         -> Judgement.hyp list              (* conclusion floating context *)
         -> Term.term                       (* conclusion rhs *)
         -> (context_action * Judgement.hyp list * Term.sub option * Term.term) list  (* premises *)
         -> (Term.term list -> Term.term)   (* extract *)
         -> rule

   end


signature THE_RULES =
   sig

      type term = Term.term
      type rule

      val forallForm : term -> term -> rule
      val forallEq : term -> term -> term -> term -> rule
      val forallFormUniv : term -> term -> term -> rule
      val forallEqUniv : term -> term -> term -> term -> term -> rule
      val forallSub : term -> term -> term -> term -> rule
      val forallIntroOf : term -> term -> term -> rule
      val forallIntroEq : term -> term -> term -> term -> rule
      val forallIntro : term -> term -> rule
      val forallElimOf : term -> term -> term -> term -> rule
      val forallElimEq : term -> term -> term -> term -> term -> term -> rule
      val forallElim : term -> term -> term -> rule
      val forallEta : term -> term -> term -> rule
      val forallExt : term -> term -> term -> term -> rule
      val forallExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val forallOfExt : term -> term -> term -> term -> term -> rule
      val forallFormInv1 : term -> term -> rule
      val forallFormInv2 : term -> term -> term -> rule
      val arrowForm : term -> term -> rule
      val arrowEq : term -> term -> term -> term -> rule
      val arrowFormUniv : term -> term -> term -> rule
      val arrowEqUniv : term -> term -> term -> term -> term -> rule
      val arrowForallEq : term -> term -> term -> term -> rule
      val arrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val arrowSub : term -> term -> term -> term -> rule
      val arrowForallSub : term -> term -> term -> term -> rule
      val forallArrowSub : term -> term -> term -> term -> rule
      val arrowIntroOf : term -> term -> term -> rule
      val arrowIntroEq : term -> term -> term -> term -> rule
      val arrowIntro : term -> term -> rule
      val arrowElimOf : term -> term -> term -> term -> rule
      val arrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val arrowElim : term -> term -> rule
      val arrowEta : term -> term -> term -> rule
      val arrowExt : term -> term -> term -> term -> rule
      val arrowExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val arrowOfExt : term -> term -> term -> term -> term -> rule
      val arrowFormInv1 : term -> term -> rule
      val arrowFormInv2 : term -> term -> term -> rule
      val tarrowKind : term -> term -> term -> rule
      val tarrowKindEq : term -> term -> term -> term -> term -> rule
      val tarrowForm : term -> term -> rule
      val tarrowEq : term -> term -> term -> term -> rule
      val tarrowFormUniv : term -> term -> term -> rule
      val tarrowEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowArrowEq : term -> term -> term -> term -> rule
      val tarrowArrowEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowForallEq : term -> term -> term -> term -> rule
      val tarrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val tarrowIntroOf : term -> term -> term -> rule
      val tarrowIntroEq : term -> term -> term -> term -> rule
      val tarrowIntro : term -> term -> rule
      val tarrowElimOf : term -> term -> term -> term -> rule
      val tarrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val tarrowElim : term -> term -> rule
      val tarrowEta : term -> term -> term -> rule
      val tarrowExt : term -> term -> term -> term -> rule
      val tarrowOfExt : term -> term -> term -> term -> term -> rule
      val karrowKind : term -> term -> term -> rule
      val karrowKindEq : term -> term -> term -> term -> term -> rule
      val karrowForm : term -> term -> rule
      val karrowEq : term -> term -> term -> term -> rule
      val karrowFormUniv : term -> term -> term -> rule
      val karrowEqUniv : term -> term -> term -> term -> term -> rule
      val karrowArrowEq : term -> term -> term -> term -> rule
      val karrowArrowEqUniv : term -> term -> term -> term -> term -> rule
      val karrowForallEq : term -> term -> term -> term -> rule
      val karrowForallEqUniv : term -> term -> term -> term -> term -> rule
      val karrowIntroOf : term -> term -> term -> rule
      val karrowIntroEq : term -> term -> term -> term -> rule
      val karrowIntro : term -> term -> rule
      val karrowElimOf : term -> term -> term -> term -> rule
      val karrowElimEq : term -> term -> term -> term -> term -> term -> rule
      val karrowElim : term -> term -> rule
      val karrowEta : term -> term -> term -> rule
      val karrowExt : term -> term -> term -> term -> rule
      val karrowOfExt : term -> term -> term -> term -> term -> rule
      val intersectForm : term -> term -> rule
      val intersectEq : term -> term -> term -> term -> rule
      val intersectFormUniv : term -> term -> term -> rule
      val intersectEqUniv : term -> term -> term -> term -> term -> rule
      val intersectSub : term -> term -> term -> term -> rule
      val intersectIntroOf : term -> term -> term -> rule
      val intersectIntroEq : term -> term -> term -> term -> rule
      val intersectIntro : term -> term -> rule
      val intersectElimOf : term -> term -> term -> term -> rule
      val intersectElimEq : term -> term -> term -> term -> term -> rule
      val intersectElim : term -> term -> term -> rule
      val intersectFormInv1 : term -> term -> rule
      val intersectFormInv2 : term -> term -> term -> rule
      val parametricForm : term -> term -> rule
      val parametricEq : term -> term -> term -> term -> rule
      val parametricFormUniv : term -> term -> term -> rule
      val parametricEqUniv : term -> term -> term -> term -> term -> rule
      val parametricSub : term -> term -> term -> term -> rule
      val parametricForallSub : term -> term -> term -> term -> rule
      val parametricIntroOf : term -> term -> term -> rule
      val parametricIntroEq : term -> term -> term -> term -> rule
      val parametricIntro : term -> term -> rule
      val parametricIntroOfForall : term -> term -> term -> rule
      val parametricElimOf : term -> term -> term -> term -> rule
      val parametricElimEq : term -> term -> term -> term -> term -> term -> rule
      val parametricElim : term -> term -> term -> rule
      val parametricElim' : term -> term -> term -> rule
      val parametricBeta : term -> term -> rule
      val parametricEta : term -> term -> term -> rule
      val parametricExt : term -> term -> term -> term -> rule
      val parametricExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val parametricOfExt : term -> term -> term -> term -> term -> rule
      val parametricFormInv1 : term -> term -> rule
      val parametricFormInv2 : term -> term -> term -> rule
      val parametricElimIrrelevant : term -> term -> term -> rule
      val irrelevance : term -> rule
      val forallfutForm : term -> term -> rule
      val forallfutEq : term -> term -> term -> term -> rule
      val forallfutFormUniv : term -> term -> term -> rule
      val forallfutEqUniv : term -> term -> term -> term -> term -> rule
      val forallfutSub : term -> term -> term -> term -> rule
      val forallfutForallVoidSub : term -> term -> term -> rule
      val forallfutIntroOf : term -> term -> term -> rule
      val forallfutIntroEq : term -> term -> term -> term -> rule
      val forallfutIntro : term -> term -> rule
      val forallfutElimOf : term -> term -> term -> term -> rule
      val forallfutElimEq : term -> term -> term -> term -> term -> term -> rule
      val forallfutElim : term -> term -> term -> rule
      val forallfutExt : term -> term -> term -> term -> rule
      val forallfutExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val forallfutOfExt : term -> term -> term -> term -> term -> rule
      val intersectfutForm : term -> term -> rule
      val intersectfutEq : term -> term -> term -> term -> rule
      val intersectfutFormUniv : term -> term -> term -> rule
      val intersectfutEqUniv : term -> term -> term -> term -> term -> rule
      val intersectfutSub : term -> term -> term -> term -> rule
      val intersectfutIntroOf : term -> term -> term -> rule
      val intersectfutIntroEq : term -> term -> term -> term -> rule
      val intersectfutIntro : term -> term -> rule
      val intersectfutElimOf : term -> term -> term -> term -> rule
      val intersectfutElimEq : term -> term -> term -> term -> term -> rule
      val intersectfutElim : term -> term -> term -> rule
      val parametricfutForm : term -> term -> rule
      val parametricfutEq : term -> term -> term -> term -> rule
      val parametricfutFormUniv : term -> term -> term -> rule
      val parametricfutEqUniv : term -> term -> term -> term -> term -> rule
      val parametricfutSub : term -> term -> term -> term -> rule
      val parametricfutIntroOf : term -> term -> term -> rule
      val parametricfutIntroEq : term -> term -> term -> term -> rule
      val parametricfutIntro : term -> term -> rule
      val parametricfutElimOf : term -> term -> term -> term -> rule
      val parametricfutElimEq : term -> term -> term -> term -> term -> term -> rule
      val parametricfutElim : term -> term -> term -> rule
      val parametricfutElim' : term -> term -> term -> rule
      val parametricfutExt : term -> term -> term -> term -> rule
      val parametricfutExt' : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val parametricfutOfExt : term -> term -> term -> term -> term -> rule
      val guardForm : term -> term -> rule
      val guardEq : term -> term -> term -> term -> rule
      val guardFormUniv : term -> term -> term -> rule
      val guardEqUniv : term -> term -> term -> term -> term -> rule
      val guardIntroOf : term -> term -> term -> rule
      val guardIntroEq : term -> term -> term -> term -> rule
      val guardIntro : term -> term -> rule
      val guardElimOf : term -> term -> term -> rule
      val guardElimEq : term -> term -> term -> term -> rule
      val guardElim : term -> term -> rule
      val guardSatEq : term -> term -> rule
      val guardSub : term -> term -> term -> term -> rule
      val guardSubIntro : term -> term -> term -> rule
      val guardSubElim : term -> term -> term -> rule
      val coguardForm : term -> term -> rule
      val coguardEq : term -> term -> term -> term -> rule
      val coguardFormUniv : term -> term -> term -> rule
      val coguardEqUniv : term -> term -> term -> term -> term -> rule
      val coguardIntroEq : term -> term -> term -> term -> rule
      val coguardIntroOf : term -> term -> term -> rule
      val coguardIntroOfSquash : term -> term -> term -> rule
      val coguardIntro : term -> term -> rule
      val coguardElim1 : term -> term -> rule
      val coguardElim2Eq : term -> term -> term -> term -> rule
      val coguardElim2Of : term -> term -> term -> rule
      val coguardElim2 : term -> term -> rule
      val coguardLeft : int -> term -> term -> term -> rule
      val coguardSatEq : term -> term -> rule
      val coguardSub : term -> term -> term -> term -> rule
      val coguardSubIntro : term -> term -> term -> rule
      val coguardSubElim : term -> term -> term -> rule
      val existsForm : term -> term -> rule
      val existsEq : term -> term -> term -> term -> rule
      val existsFormUniv : term -> term -> term -> rule
      val existsEqUniv : term -> term -> term -> term -> term -> rule
      val existsSub : term -> term -> term -> term -> rule
      val existsIntroOf : term -> term -> term -> term -> rule
      val existsIntroEq : term -> term -> term -> term -> term -> term -> rule
      val existsIntro : term -> term -> term -> rule
      val existsElim1Of : term -> term -> term -> rule
      val existsElim1Eq : term -> term -> term -> term -> rule
      val existsElim1 : term -> term -> rule
      val existsElim2Of : term -> term -> term -> rule
      val existsElim2Eq : term -> term -> term -> term -> rule
      val existsEta : term -> term -> term -> rule
      val existsExt : term -> term -> term -> term -> rule
      val existsLeft : int -> term -> term -> term -> rule
      val existsFormInv1 : term -> term -> rule
      val existsFormInv2 : term -> term -> term -> rule
      val existsFormInv2Eq : term -> term -> term -> term -> rule
      val prodKind : term -> term -> term -> rule
      val prodKindEq : term -> term -> term -> term -> term -> rule
      val prodForm : term -> term -> rule
      val prodEq : term -> term -> term -> term -> rule
      val prodFormUniv : term -> term -> term -> rule
      val prodEqUniv : term -> term -> term -> term -> term -> rule
      val prodExistsEq : term -> term -> term -> term -> rule
      val prodExistsEqUniv : term -> term -> term -> term -> term -> rule
      val prodSub : term -> term -> term -> term -> rule
      val prodExistsSub : term -> term -> term -> term -> rule
      val existsProdSub : term -> term -> term -> term -> rule
      val prodIntroOf : term -> term -> term -> term -> rule
      val prodIntroEq : term -> term -> term -> term -> term -> term -> rule
      val prodIntro : term -> term -> rule
      val prodElim1Of : term -> term -> term -> rule
      val prodElim1Eq : term -> term -> term -> term -> rule
      val prodElim1 : term -> term -> rule
      val prodElim2Of : term -> term -> term -> rule
      val prodElim2Eq : term -> term -> term -> term -> rule
      val prodElim2 : term -> term -> rule
      val prodEta : term -> term -> term -> rule
      val prodExt : term -> term -> term -> term -> rule
      val prodLeft : int -> term -> term -> term -> rule
      val prodFormInv1 : term -> term -> rule
      val prodFormInv2 : term -> term -> rule
      val dprodForm : term -> term -> rule
      val dprodEq : term -> term -> term -> term -> rule
      val dprodFormUniv : term -> term -> term -> rule
      val dprodEqUniv : term -> term -> term -> term -> term -> rule
      val dprodExistsEq : term -> term -> term -> term -> rule
      val dprodExistsEqUniv : term -> term -> term -> term -> term -> rule
      val prodDprodEq : term -> term -> term -> term -> rule
      val prodDprodEqUniv : term -> term -> term -> term -> term -> rule
      val dprodSub : term -> term -> term -> term -> rule
      val dprodExistsSub : term -> term -> term -> term -> rule
      val existsDprodSub : term -> term -> term -> term -> rule
      val dprodProdSub : term -> term -> term -> term -> rule
      val prodDprodSub : term -> term -> term -> term -> rule
      val dprodIntroOf : term -> term -> term -> term -> rule
      val dprodIntroEq : term -> term -> term -> term -> term -> term -> rule
      val dprodIntro : term -> term -> rule
      val dprodElim1Of : term -> term -> term -> rule
      val dprodElim1Eq : term -> term -> term -> term -> rule
      val dprodElim1 : term -> term -> rule
      val dprodElim2Of : term -> term -> term -> rule
      val dprodElim2Eq : term -> term -> term -> term -> rule
      val dprodElim2 : term -> term -> rule
      val dprodEta : term -> term -> term -> rule
      val dprodExt : term -> term -> term -> term -> rule
      val dprodLeft : int -> term -> term -> term -> rule
      val dprodFormInv1 : term -> term -> rule
      val dprodFormInv2 : term -> term -> term -> rule
      val unionForm : term -> term -> rule
      val unionEq : term -> term -> term -> term -> rule
      val unionFormUniv : term -> term -> term -> rule
      val unionEqUniv : term -> term -> term -> term -> term -> rule
      val unionSub : term -> term -> term -> term -> rule
      val unionIntroOf : term -> term -> term -> term -> rule
      val unionIntroEq : term -> term -> term -> term -> term -> rule
      val unionIntro : term -> term -> term -> rule
      val unionElimOf : term -> term -> term -> term -> term -> rule
      val unionElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val unionElim : term -> term -> term -> term -> rule
      val unionElimOfDep : term -> term -> term -> term -> term -> rule
      val unionElimEqDep : term -> term -> term -> term -> term -> term -> term -> rule
      val unionElimDep : term -> term -> term -> term -> rule
      val unionElimIstype : term -> term -> term -> term -> rule
      val unionElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val sumForm : term -> term -> rule
      val sumEq : term -> term -> term -> term -> rule
      val sumFormUniv : term -> term -> term -> rule
      val sumEqUniv : term -> term -> term -> term -> term -> rule
      val sumSub : term -> term -> term -> term -> rule
      val sumIntro1Of : term -> term -> term -> rule
      val sumIntro1Eq : term -> term -> term -> term -> rule
      val sumIntro1 : term -> term -> rule
      val sumIntro2Of : term -> term -> term -> rule
      val sumIntro2Eq : term -> term -> term -> term -> rule
      val sumIntro2 : term -> term -> rule
      val sumElimOf : term -> term -> term -> term -> term -> term -> rule
      val sumElimOfNondep : term -> term -> term -> term -> term -> term -> rule
      val sumElimEq : term -> term -> term -> term -> term -> term -> term -> term -> term -> rule
      val sumElim : term -> term -> term -> term -> rule
      val sumElimNondep : term -> term -> term -> rule
      val sumElimIstype : term -> term -> term -> term -> term -> rule
      val sumElimEqtype : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val sumContradiction : term -> term -> term -> term -> term -> rule
      val sumInjection1 : term -> term -> term -> term -> rule
      val sumInjection2 : term -> term -> term -> term -> rule
      val sum_caseType : rule
      val sumFormInv1 : term -> term -> rule
      val sumFormInv2 : term -> term -> rule
      val futureKind : term -> term -> rule
      val futureKindEq : term -> term -> term -> rule
      val futureForm : term -> rule
      val futureEq : term -> term -> rule
      val futureFormUniv : term -> term -> rule
      val futureEqUniv : term -> term -> term -> rule
      val futureSub : term -> term -> rule
      val futureIntroOf : term -> term -> rule
      val futureIntroEq : term -> term -> term -> rule
      val futureIntro : term -> rule
      val futureElimOf : term -> term -> term -> term -> rule
      val futureElimOfLetnext : term -> term -> term -> term -> rule
      val futureElimOfLetnextNondep : term -> term -> term -> term -> rule
      val futureElimEq : term -> term -> term -> term -> term -> term -> rule
      val futureElim : term -> term -> term -> rule
      val futureElimIstype : term -> term -> term -> rule
      val futureElimIstypeLetnext : term -> term -> term -> rule
      val futureElimEqtype : term -> term -> term -> term -> term -> rule
      val futureEta : term -> term -> rule
      val futureExt : term -> term -> term -> rule
      val futureLeft : int -> term -> term -> rule
      val futureLeftHidden : int -> term -> term -> rule
      val futureInjection : term -> term -> term -> rule
      val squashFutureSwap : term -> rule
      val isquashFutureSwap : term -> rule
      val futureSquashSwap : term -> rule
      val futureIsquashSwap : term -> rule
      val recKind : term -> term -> rule
      val recKindEq : term -> term -> term -> rule
      val recForm : term -> rule
      val recEq : term -> term -> rule
      val recFormUniv : term -> term -> rule
      val recEqUniv : term -> term -> term -> rule
      val recUnroll : term -> rule
      val recUnrollUniv : term -> term -> rule
      val recBisimilar : term -> term -> rule
      val muForm : term -> rule
      val muEq : term -> term -> rule
      val muFormUniv : term -> term -> rule
      val muEqUniv : term -> term -> term -> rule
      val muUnroll : term -> rule
      val muUnrollUniv : term -> term -> rule
      val muInd : term -> term -> term -> rule
      val muIndUniv : term -> term -> term -> term -> rule
      val voidForm : rule
      val voidEq : rule
      val voidFormUniv : term -> rule
      val voidEqUniv : term -> rule
      val voidElim : term -> rule
      val voidSub : term -> rule
      val abortType : rule
      val unitKind : term -> rule
      val unitKindEq : term -> rule
      val unitForm : rule
      val unitEq : rule
      val unitFormUniv : term -> rule
      val unitEqUniv : term -> rule
      val unitIntroOf : rule
      val unitIntro : rule
      val unitExt : term -> term -> rule
      val unitLeft : int -> term -> rule
      val boolForm : rule
      val boolEq : rule
      val boolFormUniv : term -> rule
      val boolEqUniv : term -> rule
      val boolIntro1Of : rule
      val boolIntro2Of : rule
      val boolElimOf : term -> term -> term -> term -> rule
      val boolElimOfNondep : term -> term -> term -> term -> rule
      val boolElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val boolElim : term -> term -> rule
      val boolElimIstype : term -> term -> term -> rule
      val boolElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val boolLeft : int -> term -> rule
      val boolContradiction : term -> rule
      val iteType : rule
      val natForm : rule
      val natEq : rule
      val natFormUniv : term -> rule
      val natEqUniv : term -> rule
      val natElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val natElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val natUnroll : rule
      val natContradiction : term -> term -> rule
      val natInjection : term -> term -> rule
      val zeroType : rule
      val succType : rule
      val univKind : term -> term -> rule
      val univKindEq : term -> term -> term -> rule
      val univForm : term -> rule
      val univEq : term -> term -> rule
      val univFormUniv : term -> term -> rule
      val univFormUnivSucc : term -> rule
      val univEqUniv : term -> term -> term -> rule
      val univCumulativeOf : term -> term -> term -> rule
      val univCumulativeEq : term -> term -> term -> term -> rule
      val univCumulativeSuccOf : term -> term -> rule
      val univSub : term -> term -> rule
      val univForgetOf : term -> term -> rule
      val univForgetEq : term -> term -> term -> rule
      val univIntroEqtype : term -> term -> term -> rule
      val univFormInv : term -> rule
      val kindForm : term -> rule
      val kindEq : term -> term -> rule
      val kindFormUniv : term -> term -> rule
      val kindEqUniv : term -> term -> term -> rule
      val kindForgetOf : term -> term -> rule
      val kindForgetEq : term -> term -> term -> rule
      val kindUnivSub : term -> term -> rule
      val levelForm : rule
      val levelEq : rule
      val levelFormUniv : term -> rule
      val levelEqUniv : term -> rule
      val lleqForm : term -> term -> rule
      val lleqEq : term -> term -> term -> term -> rule
      val lleqFormUniv : term -> term -> term -> rule
      val lleqEqUniv : term -> term -> term -> term -> term -> rule
      val lzeroLevel : rule
      val lsuccLevel : term -> rule
      val lsuccEq : term -> term -> rule
      val lmaxLevel : term -> term -> rule
      val lmaxEq : term -> term -> term -> term -> rule
      val lleqRefl : term -> rule
      val lleqTrans : term -> term -> term -> rule
      val lleqZero : term -> rule
      val lleqSucc : term -> term -> rule
      val lleqIncrease : term -> term -> rule
      val lleqMaxL : term -> term -> term -> rule
      val lleqMaxR1 : term -> term -> term -> rule
      val lleqMaxR2 : term -> term -> term -> rule
      val lleqResp : term -> term -> term -> term -> rule
      val lsuccMaxDistTrans : term -> term -> term -> rule
      val lzeroType : rule
      val lsuccType : rule
      val lmaxType : rule
      val eqForm : term -> term -> term -> rule
      val eqEq : term -> term -> term -> term -> term -> term -> rule
      val eqFormUniv : term -> term -> term -> term -> rule
      val eqEqUniv : term -> term -> term -> term -> term -> term -> term -> rule
      val eqIntro : term -> term -> term -> rule
      val eqElim : term -> term -> term -> term -> rule
      val eqTrivialize : term -> term -> term -> rule
      val eqExt : term -> term -> term -> term -> term -> rule
      val eqLeft : int -> term -> term -> term -> term -> rule
      val eqRefl : term -> term -> rule
      val eqSymm : term -> term -> term -> rule
      val eqTrans : term -> term -> term -> term -> rule
      val eqFormInv1 : term -> term -> term -> rule
      val eqFormInv2 : term -> term -> term -> rule
      val eqFormInv3 : term -> term -> term -> rule
      val ofForm : term -> term -> rule
      val ofEq : term -> term -> term -> term -> rule
      val ofFormUniv : term -> term -> term -> rule
      val ofEqUniv : term -> term -> term -> term -> term -> rule
      val ofIntro : term -> term -> rule
      val ofElim : term -> term -> term -> rule
      val ofTrivialize : term -> term -> rule
      val ofExt : term -> term -> term -> term -> rule
      val ofLeft : int -> term -> term -> term -> rule
      val ofEquand1 : term -> term -> term -> rule
      val ofEquand2 : term -> term -> term -> rule
      val eqtpForm : term -> term -> rule
      val eqtpEq : term -> term -> term -> term -> rule
      val eqtpFormUniv : term -> term -> term -> rule
      val eqtpEqUniv : term -> term -> term -> term -> term -> rule
      val eqtpIntro : term -> term -> rule
      val eqtpElim : term -> term -> term -> rule
      val eqtpExt : term -> term -> term -> term -> rule
      val eqtpLeft : int -> term -> term -> term -> rule
      val eqtpFunct : term -> term -> term -> term -> rule
      val eqtpFunctType : term -> term -> term -> rule
      val equivalenceOf : term -> term -> term -> rule
      val equivalenceEq : term -> term -> term -> term -> rule
      val equivalence : term -> term -> rule
      val equivalenceLeft : int -> term -> term -> term -> rule
      val equivalenceLeftAlt : int -> term -> term -> term -> rule
      val eqtpRefl : term -> rule
      val eqtpSymm : term -> term -> rule
      val eqtpTrans : term -> term -> term -> rule
      val istpForm : term -> rule
      val istpEq : term -> term -> rule
      val istpFormUniv : term -> term -> rule
      val istpEqUniv : term -> term -> term -> rule
      val istpIntro : term -> rule
      val istpElim : term -> term -> rule
      val istpExt : term -> term -> term -> rule
      val istpLeft : int -> term -> term -> rule
      val inhabitedForm : term -> rule
      val subtypeForm : term -> term -> rule
      val subtypeEq : term -> term -> term -> term -> rule
      val subtypeFormUniv : term -> term -> term -> rule
      val subtypeEqUniv : term -> term -> term -> term -> term -> rule
      val subtypeIntro : term -> term -> rule
      val subtypeElim : term -> term -> term -> rule
      val subtypeExt : term -> term -> term -> term -> rule
      val subtypeLeft : int -> term -> term -> term -> rule
      val subtypeEstablish : term -> term -> rule
      val subsumptionOf : term -> term -> term -> rule
      val subsumptionEq : term -> term -> term -> term -> rule
      val subsumption : term -> term -> rule
      val subsumptionAlt : term -> term -> rule
      val subsumptionLeft : int -> term -> term -> term -> rule
      val subsumptionLeftAlt : int -> term -> term -> term -> rule
      val subsumptionLast : int -> term -> term -> term -> rule
      val tighten : int -> term -> term -> term -> rule
      val subtypeRefl : term -> rule
      val subtypeReflEqtype : term -> term -> rule
      val subtypeTrans : term -> term -> term -> rule
      val subtypeIstp1 : term -> term -> rule
      val subtypeIstp2 : term -> term -> rule
      val eeqtpForm : term -> term -> rule
      val eeqtpEq : term -> term -> term -> term -> rule
      val eeqtpFormUniv : term -> term -> term -> rule
      val eeqtpEqUniv : term -> term -> term -> term -> term -> rule
      val setForm : term -> term -> rule
      val setEq : term -> term -> term -> term -> rule
      val setFormUniv : term -> term -> term -> rule
      val setEqUniv : term -> term -> term -> term -> term -> rule
      val setWeakenOf : term -> term -> term -> rule
      val setWeakenEq : term -> term -> term -> term -> rule
      val setWeaken : term -> term -> rule
      val setIntroOf : term -> term -> term -> rule
      val setIntroEq : term -> term -> term -> term -> rule
      val setIntro : term -> term -> term -> rule
      val setIntroOfSquash : term -> term -> term -> rule
      val setIntroEqSquash : term -> term -> term -> term -> rule
      val squashIntroOfSquash : term -> rule
      val setElim : term -> term -> term -> term -> rule
      val setLeft : int -> term -> term -> term -> rule
      val setSquash : term -> term -> rule
      val setFormInv : term -> term -> rule
      val setSubElim : term -> term -> term -> rule
      val isetForm : term -> term -> rule
      val isetEq : term -> term -> term -> term -> rule
      val isetFormUniv : term -> term -> term -> rule
      val isetEqUniv : term -> term -> term -> term -> term -> rule
      val isetWeakenOf : term -> term -> term -> rule
      val isetWeakenEq : term -> term -> term -> term -> rule
      val isetWeaken : term -> term -> rule
      val isetIntroOf : term -> term -> term -> rule
      val isetIntroEq : term -> term -> term -> term -> rule
      val isetIntro : term -> term -> term -> rule
      val isetIntroOfSquash : term -> term -> term -> rule
      val isetIntroEqSquash : term -> term -> term -> term -> rule
      val isetElim : term -> term -> term -> term -> rule
      val isetLeft : int -> term -> term -> term -> rule
      val isetFormInv1 : term -> term -> rule
      val isetFormInv2 : term -> term -> term -> rule
      val isetSubElim : term -> term -> term -> rule
      val squashForm : term -> rule
      val squashEq : term -> term -> rule
      val squashFormUniv : term -> term -> rule
      val squashEqUniv : term -> term -> term -> rule
      val squashIntroOf : term -> rule
      val squashIntro : term -> rule
      val squashElim : term -> term -> term -> rule
      val squashExt : term -> term -> term -> rule
      val squashLeft : int -> term -> term -> rule
      val squashSub : term -> term -> rule
      val isquashForm : term -> rule
      val isquashEq : term -> term -> rule
      val isquashFormUniv : term -> term -> rule
      val isquashEqUniv : term -> term -> term -> rule
      val isquashIntroOf : term -> rule
      val isquashIntro : term -> rule
      val isquashIntroOfIsquash : term -> rule
      val isquashElim : term -> term -> term -> rule
      val isquashExt : term -> term -> term -> rule
      val isquashLeft : int -> term -> term -> rule
      val isquashSub : term -> term -> rule
      val isquashFormInv : term -> rule
      val quotientForm : term -> term -> rule
      val quotientEq : term -> term -> term -> term -> rule
      val quotientFormUniv : term -> term -> term -> rule
      val quotientEqUniv : term -> term -> term -> term -> term -> rule
      val quotientIntroOf : term -> term -> term -> rule
      val quotientIntroEq : term -> term -> term -> term -> rule
      val quotientElimOf : term -> term -> term -> term -> term -> rule
      val quotientElimEq : term -> term -> term -> term -> term -> term -> term -> rule
      val quotientElimIstype : term -> term -> term -> term -> rule
      val quotientElimEqtype : term -> term -> term -> term -> term -> term -> rule
      val quotientDescent : term -> term -> term -> term -> term -> rule
      val quotientLeft : int -> term -> term -> term -> rule
      val quotientLeftRefl : int -> term -> term -> term -> rule
      val quotientLeftIstype : int -> term -> term -> term -> rule
      val quotientLeftEqtype : int -> term -> term -> term -> term -> rule
      val quotientLeftOf : int -> term -> term -> term -> term -> rule
      val quotientLeftEq : int -> term -> term -> term -> term -> term -> rule
      val quotientLeftOfDep : int -> term -> term -> term -> term -> rule
      val quotientLeftEqDep : int -> term -> term -> term -> term -> term -> rule
      val quotientFormInv : term -> term -> rule
      val iforallForm : term -> term -> term -> rule
      val iforallEq : term -> term -> term -> term -> term -> rule
      val iforallFormUniv : term -> term -> term -> term -> rule
      val iforallEqUniv : term -> term -> term -> term -> term -> term -> rule
      val iforallIntroOf : term -> term -> term -> term -> rule
      val iforallIntroEq : term -> term -> term -> term -> term -> rule
      val iforallIntro : term -> term -> term -> rule
      val iforallElimOf : term -> term -> term -> term -> term -> rule
      val iforallElimEq : term -> term -> term -> term -> term -> term -> rule
      val iforallElim : term -> term -> term -> term -> rule
      val foralltpForm : term -> rule
      val foralltpEq : term -> term -> rule
      val foralltpIntroOf : term -> term -> rule
      val foralltpIntroEq : term -> term -> term -> rule
      val foralltpIntro : term -> rule
      val foralltpElimOf : term -> term -> term -> rule
      val foralltpElimEq : term -> term -> term -> term -> rule
      val foralltpElim : term -> term -> rule
      val iexistsForm : term -> term -> term -> rule
      val iexistsEq : term -> term -> term -> term -> term -> rule
      val iexistsFormUniv : term -> term -> term -> term -> rule
      val iexistsEqUniv : term -> term -> term -> term -> term -> term -> rule
      val iexistsIntroOf : term -> term -> term -> term -> term -> rule
      val iexistsIntroEq : term -> term -> term -> term -> term -> term -> rule
      val iexistsIntro : term -> term -> term -> term -> rule
      val iexistsElimOf : term -> term -> term -> term -> term -> term -> rule
      val iexistsElimEq : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val iexistsElim : term -> term -> term -> term -> term -> rule
      val iexistsElimOfDep : term -> term -> term -> term -> term -> term -> rule
      val iexistsElimEqDep : term -> term -> term -> term -> term -> term -> term -> term -> rule
      val iexistsElimDep : term -> term -> term -> term -> term -> rule
      val iexistsElimIstype : term -> term -> term -> term -> term -> rule
      val iexistsElimEqtype : term -> term -> term -> term -> term -> term -> term -> rule
      val substitution : int -> term -> term -> term -> rule
      val substitutionSimple : int -> term -> term -> term -> rule
      val substitutionLater : int -> term -> term -> term -> rule
      val substitutionLaterSimple : int -> term -> term -> term -> rule
      val generalize : term -> term -> term -> rule
      val assert : term -> term -> rule
      val assert' : term -> term -> rule
      val assertLater : term -> term -> rule
      val assertLater' : term -> term -> rule
      val inhabitant : term -> term -> rule
      val letForm : term -> term -> term -> term -> rule
      val lethForm : term -> term -> term -> term -> rule
      val leteForm : term -> term -> term -> term -> rule
      val accInd : term -> term -> term -> term -> term -> term -> rule
      val sequalForm : term -> rule
      val sequalIntroOf : term -> rule
      val sequalIntro : term -> rule
      val sequalTrivialize : term -> term -> rule
      val sequalExt : term -> term -> term -> term -> rule
      val sequalLeft : int -> term -> term -> term -> rule
      val sequalEq : term -> term -> term -> rule
      val sequalEqtp : term -> term -> rule
      val sequivalence : term -> term -> rule
      val sequivalenceLeft : int -> term -> term -> term -> rule
      val substitutionSyntactic : int -> term -> term -> term -> rule
      val sequalSymm : term -> term -> rule
      val sequalTrans : term -> term -> term -> rule
      val sequalCompat : term -> term -> term -> rule
      val sequalCompatLam : term -> term -> rule
      val forallEtaSequal : term -> term -> term -> rule
      val arrowEtaSequal : term -> term -> term -> rule
      val existsEtaSequal : term -> term -> term -> rule
      val prodEtaSequal : term -> term -> term -> rule
      val futureEtaSequal : term -> term -> rule
      val partialForm : term -> rule
      val partialEq : term -> term -> rule
      val partialFormUniv : term -> term -> rule
      val partialEqUniv : term -> term -> term -> rule
      val partialSub : term -> term -> rule
      val partialStrict : term -> rule
      val partialStrictConverse : term -> rule
      val partialIdem : term -> rule
      val haltsForm : term -> term -> rule
      val haltsEq : term -> term -> term -> rule
      val haltsFormUniv : term -> term -> term -> rule
      val haltsEqUniv : term -> term -> term -> term -> rule
      val partialIntroBottomOf : term -> rule
      val bottomDiverges : rule
      val partialExt : term -> term -> term -> rule
      val partialElimEq : term -> term -> term -> rule
      val partialElimOf : term -> term -> rule
      val haltsTrivialize : term -> rule
      val haltsExt : term -> term -> term -> rule
      val haltsLeft : int -> term -> term -> rule
      val fixpointInductionEq : term -> term -> term -> rule
      val fixpointInductionOf : term -> term -> rule
      val partialFormInv : term -> rule
      val seqBind : term -> term -> term -> term -> term -> term -> rule
      val activeApp : term -> term -> term -> term -> rule
      val activeAppSeq : term -> term -> term -> term -> rule
      val appHaltsInv : term -> term -> rule
      val activePi1 : term -> term -> term -> rule
      val activePi1Seq : term -> term -> term -> rule
      val pi1HaltsInv : term -> rule
      val activePi2 : term -> term -> term -> rule
      val activePi2Seq : term -> term -> term -> rule
      val pi2HaltsInv : term -> rule
      val prevHaltsInv : term -> rule
      val activeCase : term -> term -> term -> term -> term -> rule
      val activeCaseSeq : term -> term -> term -> term -> term -> rule
      val caseHaltsInv : term -> term -> term -> rule
      val seqHaltsSequal : term -> term -> rule
      val seqHaltsInv : term -> term -> rule
      val sequalUnderSeq : term -> term -> term -> rule
      val totalStrict : term -> rule
      val voidTotal' : rule
      val voidStrict : rule
      val unitTotal : term -> rule
      val unitTotal' : rule
      val unitStrict : rule
      val boolTotal : term -> rule
      val boolTotal' : rule
      val boolStrict : rule
      val forallTotal : term -> term -> term -> rule
      val forallTotal' : term -> term -> rule
      val forallStrict : term -> term -> rule
      val forallfutTotal : term -> term -> term -> rule
      val forallfutTotal' : term -> term -> rule
      val forallfutStrict : term -> term -> rule
      val arrowTotal : term -> term -> term -> rule
      val arrowTotal' : term -> term -> rule
      val arrowStrict : term -> term -> rule
      val parametricTotal : term -> term -> term -> rule
      val parametricTotal' : term -> term -> rule
      val parametricStrict : term -> term -> rule
      val parametricfutTotal : term -> term -> term -> rule
      val parametricfutTotal' : term -> term -> rule
      val parametricfutStrict : term -> term -> rule
      val intersectStrict : term -> term -> rule
      val intersectfutStrict : term -> term -> rule
      val existsTotal : term -> term -> term -> rule
      val existsTotal' : term -> term -> rule
      val existsStrict : term -> term -> rule
      val prodTotal : term -> term -> term -> rule
      val prodTotal' : term -> term -> rule
      val prodStrict : term -> term -> rule
      val dprodTotal : term -> term -> term -> rule
      val dprodTotal' : term -> term -> rule
      val dprodStrict : term -> term -> rule
      val sumTotal : term -> term -> term -> rule
      val sumTotal' : term -> term -> rule
      val sumStrict : term -> term -> rule
      val futureTotal : term -> term -> rule
      val futureTotal' : term -> rule
      val futureStrict : term -> rule
      val setTotal' : term -> term -> rule
      val setStrict : term -> term -> rule
      val isetTotal' : term -> term -> rule
      val isetStrict : term -> term -> rule
      val quotientTotal' : term -> term -> rule
      val natTotal : term -> rule
      val natTotal' : rule
      val natStrict : rule
      val typeHalts : term -> rule
      val univTotal' : term -> rule
      val univStrict : term -> rule
      val reduceSeqTotal : term -> term -> term -> rule
      val haltsTotal : term -> term -> rule
      val uptypeForm : term -> rule
      val uptypeEq : term -> term -> rule
      val uptypeFormUniv : term -> term -> rule
      val uptypeEqUniv : term -> term -> term -> rule
      val uptypeTrivialize : term -> rule
      val uptypeExt : term -> term -> term -> rule
      val uptypeLeft : int -> term -> term -> rule
      val uptypeEeqtp : term -> term -> rule
      val uptypeUnitary : term -> rule
      val voidUptype : rule
      val unitUptype : rule
      val boolUptype : rule
      val forallUptype : term -> term -> rule
      val forallfutUptype : term -> term -> rule
      val arrowUptype : term -> term -> rule
      val intersectUptype : term -> term -> rule
      val intersectfutUptype : term -> term -> rule
      val existsUptype : term -> term -> rule
      val prodUptype : term -> term -> rule
      val dprodUptype : term -> term -> rule
      val sumUptype : term -> term -> rule
      val futureUptype : term -> rule
      val eqUptype : term -> term -> term -> rule
      val ofUptype : term -> term -> rule
      val eqtpUptype : term -> term -> rule
      val istpUptype : term -> rule
      val subtypeUptype : term -> term -> rule
      val setUptype : term -> term -> rule
      val isetUptype : term -> term -> rule
      val muUptype : term -> rule
      val muUptypeUniv : term -> term -> rule
      val recUptype : term -> rule
      val recUptypeUniv : term -> term -> rule
      val natUptype : rule
      val uptypeFormInv : term -> rule
      val admissForm : term -> rule
      val admissEq : term -> term -> rule
      val admissFormUniv : term -> term -> rule
      val admissEqUniv : term -> term -> term -> rule
      val admissTrivialize : term -> rule
      val admissExt : term -> term -> term -> rule
      val admissLeft : int -> term -> term -> rule
      val admissEeqtp : term -> term -> rule
      val uptypeAdmiss : term -> rule
      val partialAdmiss : term -> rule
      val voidAdmiss : rule
      val unitAdmiss : rule
      val boolAdmiss : rule
      val forallAdmiss : term -> term -> rule
      val forallfutAdmiss : term -> term -> rule
      val arrowAdmiss : term -> term -> rule
      val intersectAdmiss : term -> term -> rule
      val intersectfutAdmiss : term -> term -> rule
      val existsAdmissUptype : term -> term -> rule
      val prodAdmiss : term -> term -> rule
      val dprodAdmissUptype : term -> term -> rule
      val sumAdmiss : term -> term -> rule
      val futureAdmiss : term -> rule
      val eqAdmiss : term -> term -> term -> rule
      val ofAdmiss : term -> term -> rule
      val eqtpAdmiss : term -> term -> rule
      val istpAdmiss : term -> rule
      val subtypeAdmiss : term -> term -> rule
      val recAdmiss : term -> rule
      val recAdmissUniv : term -> term -> rule
      val natAdmiss : rule
      val admissFormInv : term -> rule
      val partialType : rule
      val haltsType : rule
      val admissType : rule
      val uptypeType : rule
      val seqType : rule
      val eeqtpRefl : term -> rule
      val eeqtpSymm : term -> term -> rule
      val eeqtpTrans : term -> term -> term -> rule
      val weakenEqtpEeqtp : term -> term -> rule
      val weakenSubtypeArrow : term -> term -> rule
      val weakenEeqtpIff : term -> term -> rule
      val compatGuardEqtp1 : term -> term -> term -> rule
      val compatSetEqtp0 : term -> term -> term -> rule
      val forallEeq : term -> term -> term -> term -> rule
      val existsEeq : term -> term -> term -> term -> rule
      val arrowEeq : term -> term -> term -> term -> rule
      val prodEeq : term -> term -> term -> term -> rule
      val dprodEeq : term -> term -> term -> term -> rule
      val sumEeq : term -> term -> term -> term -> rule
      val futureEeq : term -> term -> rule
      val letnextEeq : term -> term -> term -> term -> rule
      val intersectEeq : term -> term -> term -> term -> rule
      val unionEeq : term -> term -> term -> term -> rule
      val eqEeq : term -> term -> term -> term -> rule
      val eeqEeq : term -> term -> term -> term -> rule
      val compatGuardEeq1 : term -> term -> term -> rule
      val compatSetEeq0 : term -> term -> term -> rule
      val compatIsetEeq0 : term -> term -> term -> rule
      val compatIsetIff1 : term -> term -> term -> rule
      val compatForallSubtype0 : term -> term -> term -> rule
      val compatForallSubtype1 : term -> term -> term -> rule
      val compatExistsSubtype0 : term -> term -> term -> rule
      val compatExistsSubtype1 : term -> term -> term -> rule
      val compatIntersectSubtype0 : term -> term -> term -> rule
      val compatIntersectSubtype1 : term -> term -> term -> rule
      val compatUnionSubtype0 : term -> term -> term -> rule
      val compatUnionSubtype1 : term -> term -> term -> rule
      val compatGuardArrow0 : term -> term -> term -> rule
      val compatGuardSubtype1 : term -> term -> term -> rule
      val compatSetSubtype0 : term -> term -> term -> rule
      val compatSetArrow1 : term -> term -> term -> rule
      val compatIsetSubtype0 : term -> term -> term -> rule
      val compatIsetArrow1 : term -> term -> term -> rule
      val compatForallIff1 : term -> term -> term -> rule
      val compatExistsIff1 : term -> term -> term -> rule
      val compatArrowIff0 : term -> term -> term -> rule
      val compatArrowIff1 : term -> term -> term -> rule
      val compatProdIff0 : term -> term -> term -> rule
      val compatProdIff1 : term -> term -> term -> rule
      val compatDprodIff0 : term -> term -> term -> rule
      val compatDprodIff1 : term -> term -> term -> rule
      val compatSumIff0 : term -> term -> term -> rule
      val compatSumIff1 : term -> term -> term -> rule
      val compatFutureIff : term -> term -> rule
      val compatForallArrow1 : term -> term -> term -> rule
      val compatExistsArrow1 : term -> term -> term -> rule
      val compatArrowArrow0 : term -> term -> term -> rule
      val compatArrowArrow1 : term -> term -> term -> rule
      val compatProdArrow0 : term -> term -> term -> rule
      val compatProdArrow1 : term -> term -> term -> rule
      val compatDprodArrow0 : term -> term -> term -> rule
      val compatDprodArrow1 : term -> term -> term -> rule
      val compatSumArrow0 : term -> term -> term -> rule
      val compatSumArrow1 : term -> term -> term -> rule
      val compatFutureArrow : term -> term -> rule
      val compatForallEntails1 : term -> term -> term -> rule
      val compatArrowEntails1 : term -> term -> term -> rule
      val compatProdEntails0 : term -> term -> term -> rule
      val compatProdEntails1 : term -> term -> term -> rule
      val compatDprodEntails0 : term -> term -> term -> rule
      val compatDprodEntails1 : term -> term -> term -> rule
      val integerForm : rule
      val integerEq : rule
      val integerFormUniv : term -> rule
      val integerEqUniv : term -> rule
      val integerToDefType : rule
      val integerFromDefType : rule
      val integerIsomorphism1 : rule
      val integerIsomorphism2 : rule
      val pluszSpec : rule
      val negzSpec : rule
      val eqzbSpec : rule
      val leqzbSpec : rule
      val timeszSpec : rule
      val integerTotal : term -> rule
      val integerStrict : rule
      val integerUptype : rule
      val integerAdmiss : rule
      val integerSequal : term -> term -> rule
      val symbolForm : rule
      val symbolEq : rule
      val symbolFormUniv : term -> rule
      val symbolEqUniv : term -> rule
      val symbol_eqbType : rule
      val symbol_eqbSpec1 : term -> term -> rule
      val symbol_eqbSpec2 : term -> term -> rule
      val symbolTotal : term -> rule
      val symbolStrict : rule
      val symbolUptype : rule
      val symbolAdmiss : rule
      val symbolSequal : term -> term -> rule

   end


functor RuleFun (structure Arg : RULE_ARG)
   :> THE_RULES where type rule = Arg.rule
=
struct

type rule = Arg.rule
open Term
structure J = Judgement

val const_of = Const Prim.ov
val const_true = Const Prim.tru
val const_false = Const Prim.fals
val const_let = Const Prim.lett
val const_abort = Const Prim.abort
val const_acc = Const Prim.acc
val const_admiss = Const Prim.admiss
val const_arrow = Const Prim.arrow
val const_bool = Const Prim.bool
val const_bottom = Const Prim.bottom
val const_cEqzb = Const Prim.cEqzb
val const_cInteger = Const Prim.cInteger
val const_cLeqzb = Const Prim.cLeqzb
val const_cNegz = Const Prim.cNegz
val const_cPlusz = Const Prim.cPlusz
val const_cTimesz = Const Prim.cTimesz
val const_coguard = Const Prim.coguard
val const_dprod = Const Prim.dprod
val const_eeqtp = Const Prim.eeqtp
val const_eq = Const Prim.eq
val const_eqtp = Const Prim.eqtp
val const_eqzb = Const Prim.eqzb
val const_exists = Const Prim.exists
val const_fix = Const Prim.fix
val const_forall = Const Prim.forall
val const_forallfut = Const Prim.forallfut
val const_foralltp = Const Prim.foralltp
val const_future = Const Prim.future
val const_guard = Const Prim.guard
val const_halts = Const Prim.halts
val const_iexists = Const Prim.iexists
val const_iff = Const Prim.iff
val const_iforall = Const Prim.iforall
val const_inl = Const Prim.inl
val const_inr = Const Prim.inr
val const_integer = Const Prim.integer
val const_integer_from_Integer = Const Prim.integer_from_Integer
val const_integer_to_Integer = Const Prim.integer_to_Integer
val const_intersect = Const Prim.intersect
val const_intersectfut = Const Prim.intersectfut
val const_irrelevant = Const Prim.irrelevant
val const_iset = Const Prim.iset
val const_isquash = Const Prim.isquash
val const_istp = Const Prim.istp
val const_ite = Const Prim.ite
val const_karrow = Const Prim.karrow
val const_kind = Const Prim.kind
val const_leqzb = Const Prim.leqzb
val const_lete = Const Prim.lete
val const_leth = Const Prim.leth
val const_letnext = Const Prim.letnext
val const_level = Const Prim.level
val const_lleq = Const Prim.lleq
val const_lmax = Const Prim.lmax
val const_lsucc = Const Prim.lsucc
val const_lzero = Const Prim.lzero
val const_mu = Const Prim.mu
val const_nat = Const Prim.nat
val const_nat_case = Const Prim.nat_case
val const_negz = Const Prim.negz
val const_nonsense = Const Prim.nonsense
val const_paramapp = Const Prim.paramapp
val const_parametric = Const Prim.parametric
val const_parametricfut = Const Prim.parametricfut
val const_partial = Const Prim.partial
val const_plusz = Const Prim.plusz
val const_positive = Const Prim.positive
val const_prod = Const Prim.prod
val const_quotient = Const Prim.quotient
val const_rec = Const Prim.rec
val const_seq = Const Prim.seq
val const_sequal = Const Prim.sequal
val const_set = Const Prim.set
val const_squash = Const Prim.squash
val const_subtype = Const Prim.subtype
val const_succ = Const Prim.succ
val const_sum = Const Prim.sum
val const_sum_case = Const Prim.sum_case
val const_symbol = Const Prim.symbol
val const_symbol_eqb = Const Prim.symbol_eqb
val const_tarrow = Const Prim.tarrow
val const_timesz = Const Prim.timesz
val const_total = Const Prim.total
val const_unavailable = Const Prim.unavailable
val const_union = Const Prim.union
val const_unit = Const Prim.unit
val const_univ = Const Prim.univ
val const_uptype = Const Prim.uptype
val const_void = Const Prim.void
val const_zero = Const Prim.zero

fun forallForm a b = Arg.make "forallForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEq a a' b b' = Arg.make "forallEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormUniv a b i = Arg.make "forallFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEqUniv a a' b b' i = Arg.make "forallEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallSub a a' b b' = Arg.make "forallSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntroOf a b m = Arg.make "forallIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntroEq a b m n = Arg.make "forallIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallIntro a b = Arg.make "forallIntro" [a, b, ] [] (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun forallElimOf a b m p = Arg.make "forallElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallElimEq a b m n p q = Arg.make "forallElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallElim a b p = Arg.make "forallElim" [a, b, p, ] [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun forallEta a b m = Arg.make "forallEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallExt a b m n = Arg.make "forallExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallExt' a a' a'' b b' b'' m n = Arg.make "forallExt'" [a, a', a'', b, b', b'', m, n, ] [] (Elim (const_eq, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallOfExt a a' b b' m = Arg.make "forallOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormInv1 a b = Arg.make "forallFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallFormInv2 a b m = Arg.make "forallFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForm a b = Arg.make "arrowForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEq a a' b b' = Arg.make "arrowEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormUniv a b i = Arg.make "arrowFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEqUniv a a' b b' i = Arg.make "arrowEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallEq a a' b b' = Arg.make "arrowForallEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallEqUniv a a' b b' i = Arg.make "arrowForallEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowSub a a' b b' = Arg.make "arrowSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowForallSub a a' b b' = Arg.make "arrowForallSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallArrowSub a a' b b' = Arg.make "forallArrowSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntroOf a b m = Arg.make "arrowIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntroEq a b m n = Arg.make "arrowIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowIntro a b = Arg.make "arrowIntro" [a, b, ] [] (Elim (const_arrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun arrowElimOf a b m p = Arg.make "arrowElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowElimEq a b m n p q = Arg.make "arrowElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowElim a b = Arg.make "arrowElim" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_arrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun arrowEta a b m = Arg.make "arrowEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowExt a b m n = Arg.make "arrowExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowExt' a a' a'' b b' b'' m n = Arg.make "arrowExt'" [a, a', a'', b, b', b'', m, n, ] [] (Elim (const_eq, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowOfExt a a' b b' m = Arg.make "arrowOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormInv1 a b = Arg.make "arrowFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowFormInv2 a b m = Arg.make "arrowFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_arrow, [App (a), App (b), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowKind a i k = Arg.make "tarrowKind" [a, i, k, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_tarrow, [App (a), App (k), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowKindEq a a' i k k' = Arg.make "tarrowKindEq" [a, a', i, k, k', ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_tarrow, [App (a), App (k), ])), App (Elim (const_tarrow, [App (a'), App (k'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForm a b = Arg.make "tarrowForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_tarrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowEq a a' b b' = Arg.make "tarrowEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_tarrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowFormUniv a b i = Arg.make "tarrowFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowEqUniv a a' b b' i = Arg.make "tarrowEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_tarrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowArrowEq a a' b b' = Arg.make "tarrowArrowEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowArrowEqUniv a a' b b' i = Arg.make "tarrowArrowEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForallEq a a' b b' = Arg.make "tarrowForallEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowForallEqUniv a a' b b' i = Arg.make "tarrowForallEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_tarrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntroOf a b m = Arg.make "tarrowIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntroEq a b m n = Arg.make "tarrowIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowIntro a b = Arg.make "tarrowIntro" [a, b, ] [] (Elim (const_tarrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun tarrowElimOf a b m p = Arg.make "tarrowElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowElimEq a b m n p q = Arg.make "tarrowElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowElim a b = Arg.make "tarrowElim" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_tarrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun tarrowEta a b m = Arg.make "tarrowEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowExt a b m n = Arg.make "tarrowExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun tarrowOfExt a a' b b' m = Arg.make "tarrowOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_tarrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowKind i k l = Arg.make "karrowKind" [i, k, l, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_karrow, [App (k), App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowKindEq i k k' l l' = Arg.make "karrowKindEq" [i, k, k', l, l', ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_karrow, [App (k), App (l), ])), App (Elim (const_karrow, [App (k'), App (l'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (l), App (l'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForm a b = Arg.make "karrowForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_karrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowEq a a' b b' = Arg.make "karrowEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_karrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowFormUniv a b i = Arg.make "karrowFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowEqUniv a a' b b' i = Arg.make "karrowEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_karrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowArrowEq a a' b b' = Arg.make "karrowArrowEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowArrowEqUniv a a' b b' i = Arg.make "karrowArrowEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForallEq a a' b b' = Arg.make "karrowForallEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowForallEqUniv a a' b b' i = Arg.make "karrowForallEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_karrow, [App (a), App (b), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntroOf a b m = Arg.make "karrowIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntroEq a b m n = Arg.make "karrowIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (m), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowIntro a b = Arg.make "karrowIntro" [a, b, ] [] (Elim (const_karrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [_, _, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun karrowElimOf a b m p = Arg.make "karrowElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (b), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowElimEq a b m n p q = Arg.make "karrowElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (b), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowElim a b = Arg.make "karrowElim" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_karrow, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [m, p, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun karrowEta a b m = Arg.make "karrowEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowExt a b m n = Arg.make "karrowExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun karrowOfExt a a' b b' m = Arg.make "karrowOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_karrow, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectForm a b = Arg.make "intersectForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectEq a a' b b' = Arg.make "intersectEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectFormUniv a b i = Arg.make "intersectFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectEqUniv a a' b b' i = Arg.make "intersectEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectSub a a' b b' = Arg.make "intersectSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntroOf a b m = Arg.make "intersectIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntroEq a b m n = Arg.make "intersectIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectIntro a b = Arg.make "intersectIntro" [a, b, ] [] (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], b), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun intersectElimOf a b m p = Arg.make "intersectElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectElimEq a b m n p = Arg.make "intersectElimEq" [a, b, m, n, p, ] [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectElim a b p = Arg.make "intersectElim" [a, b, p, ] [] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun intersectFormInv1 a b = Arg.make "intersectFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectFormInv2 a b m = Arg.make "intersectFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricForm a b = Arg.make "parametricForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricEq a a' b b' = Arg.make "parametricEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricFormUniv a b i = Arg.make "parametricFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricEqUniv a a' b b' i = Arg.make "parametricEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricSub a a' b b' = Arg.make "parametricSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricForallSub a a' b b' = Arg.make "parametricForallSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricIntroOf a b m = Arg.make "parametricIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricIntroEq a b m n = Arg.make "parametricIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, n)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricIntro a b = Arg.make "parametricIntro" [a, b, ] [] (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun parametricIntroOfForall a b m = Arg.make "parametricIntroOfForall" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElimOf a b m p = Arg.make "parametricElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (const_paramapp, [App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElimEq a b m n p q = Arg.make "parametricElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (const_paramapp, [App (m), App (p), ])), App (Elim (const_paramapp, [App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElim a b p = Arg.make "parametricElim" [a, b, p, ] [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (const_paramapp, [App (m), App (p), ]) | _ => raise Arg.ExtractFailure)
fun parametricElim' a b p = Arg.make "parametricElim'" [a, b, p, ] [] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (const_paramapp, [App (m), App (const_unavailable), ]) | _ => raise Arg.ExtractFailure)
fun parametricBeta m n = Arg.make "parametricBeta" [m, n, ] [] (Elim (const_sequal, [App (Elim (const_paramapp, [App (Lam (NONE, m)), App (n), ])), App (Sub (m, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricEta a b m = Arg.make "parametricEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (Lam (NONE, Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricExt a b m n = Arg.make "parametricExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), App (Elim (const_paramapp, [App (Sub (n, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricExt' a a' a'' b b' b'' m n = Arg.make "parametricExt'" [a, a', a'', b, b', b'', m, n, ] [] (Elim (const_eq, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), App (Elim (const_paramapp, [App (Sub (n, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricOfExt a a' b b' m = Arg.make "parametricOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricFormInv1 a b = Arg.make "parametricFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricFormInv2 a b m = Arg.make "parametricFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricElimIrrelevant m p q = Arg.make "parametricElimIrrelevant" [m, p, q, ] [] (Elim (const_sequal, [App (Elim (const_paramapp, [App (m), App (p), ])), App (Elim (const_paramapp, [App (m), App (q), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun irrelevance m = Arg.make "irrelevance" [m, ] [] (Elim (const_irrelevant, [App (Lam (NONE, m)), ])) [(Arg.Unhide, [J.Tm (const_nonsense), ], Elim (const_sequal, [App (m), App (Sub (m, Dot (const_unavailable, Shift 1))), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutForm a b = Arg.make "forallfutForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutEq a a' b b' = Arg.make "forallfutEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forallfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutFormUniv a b i = Arg.make "forallfutFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutEqUniv a a' b b' i = Arg.make "forallfutEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forallfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutSub a a' b b' = Arg.make "forallfutSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forallfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tml (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutForallVoidSub a b b' = Arg.make "forallfutForallVoidSub" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (const_void), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutIntroOf a b m = Arg.make "forallfutIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutIntroEq a b m n = Arg.make "forallfutIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutIntro a b = Arg.make "forallfutIntro" [a, b, ] [] (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tml (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun forallfutElimOf a b m p = Arg.make "forallfutElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutElimEq a b m n p q = Arg.make "forallfutElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (m, [App (p), ])), App (Elim (n, [App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutElim a b p = Arg.make "forallfutElim" [a, b, p, ] [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (m, [App (p), ]) | _ => raise Arg.ExtractFailure)
fun forallfutExt a b m n = Arg.make "forallfutExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutExt' a a' a'' b b' b'' m n = Arg.make "forallfutExt'" [a, a', a'', b, b', b'', m, n, ] [] (Elim (const_eq, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), App (Elim (Sub (n, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutOfExt a a' b b' m = Arg.make "forallfutOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (Elim (Sub (m, Shift 1), [App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutForm a b = Arg.make "intersectfutForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutEq a a' b b' = Arg.make "intersectfutEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersectfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutFormUniv a b i = Arg.make "intersectfutFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutEqUniv a a' b b' i = Arg.make "intersectfutEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersectfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutSub a a' b b' = Arg.make "intersectfutSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersectfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tml (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutIntroOf a b m = Arg.make "intersectfutIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutIntroEq a b m n = Arg.make "intersectfutIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutIntro a b = Arg.make "intersectfutIntro" [a, b, ] [] (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmlh (a), ], b), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun intersectfutElimOf a b m p = Arg.make "intersectfutElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutElimEq a b m n p = Arg.make "intersectfutElimEq" [a, b, m, n, p, ] [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutElim a b p = Arg.make "intersectfutElim" [a, b, p, ] [] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun parametricfutForm a b = Arg.make "parametricfutForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutEq a a' b b' = Arg.make "parametricfutEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametricfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutFormUniv a b i = Arg.make "parametricfutFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutEqUniv a a' b b' i = Arg.make "parametricfutEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametricfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutSub a a' b b' = Arg.make "parametricfutSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_parametricfut, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tml (a'), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutIntroOf a b m = Arg.make "parametricfutIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutIntroEq a b m n = Arg.make "parametricfutIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, m)), ])), (Arg.Unhide, [], Elim (const_irrelevant, [App (Lam (NONE, n)), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutIntro a b = Arg.make "parametricfutIntro" [a, b, ] [] (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmlh (a), ], b), ] (fn [_, m, ] => Lam (NONE, m) | _ => raise Arg.ExtractFailure)
fun parametricfutElimOf a b m p = Arg.make "parametricfutElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (p, Shift 0))), App (Elim (const_paramapp, [App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutElimEq a b m n p q = Arg.make "parametricfutElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (b, Dot (p, Shift 0))), App (Elim (const_paramapp, [App (m), App (p), ])), App (Elim (const_paramapp, [App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutElim a b p = Arg.make "parametricfutElim" [a, b, p, ] [p, ] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (const_paramapp, [App (m), App (p), ]) | _ => raise Arg.ExtractFailure)
fun parametricfutElim' a b p = Arg.make "parametricfutElim'" [a, b, p, ] [] (Sub (b, Dot (p, Shift 0))) [(Arg.Nothing, [], Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [m, _, ] => Elim (const_paramapp, [App (m), App (const_unavailable), ]) | _ => raise Arg.ExtractFailure)
fun parametricfutExt a b m n = Arg.make "parametricfutExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), App (Elim (const_paramapp, [App (Sub (n, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutExt' a a' a'' b b' b'' m n = Arg.make "parametricfutExt'" [a, a', a'', b, b', b'', m, n, ] [] (Elim (const_eq, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a''), App (Lam (NONE, b'')), ])), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), App (Elim (const_paramapp, [App (Sub (n, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutOfExt a a' b b' m = Arg.make "parametricfutOfExt" [a, a', b, b', m, ] [] (Elim (const_of, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a'), App (Lam (NONE, b')), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (Elim (const_paramapp, [App (Sub (m, Shift 1)), App (Var 0), ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardForm a b = Arg.make "guardForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardEq a a' b b' = Arg.make "guardEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardFormUniv a b i = Arg.make "guardFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardEqUniv a a' b b' i = Arg.make "guardEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a'), ])), (Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntroOf a b m = Arg.make "guardIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_guard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntroEq a b m n = Arg.make "guardIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_guard, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (b, Shift 1)), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardIntro a b = Arg.make "guardIntro" [a, b, ] [] (Elim (const_guard, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (b, Shift 1)), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun guardElimOf a b m = Arg.make "guardElimOf" [a, b, m, ] [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_guard, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardElimEq a b m n = Arg.make "guardElimEq" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_guard, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardElim a b = Arg.make "guardElim" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_guard, [App (a), App (b), ])), (Arg.Unhide, [], a), ] (fn [m, _, ] => m | _ => raise Arg.ExtractFailure)
fun guardSatEq a b = Arg.make "guardSatEq" [a, b, ] [] (Elim (const_eqtp, [App (b), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardSub a a' b b' = Arg.make "guardSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_arrow, [App (a'), App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardSubIntro a b c = Arg.make "guardSubIntro" [a, b, c, ] [] (Elim (const_subtype, [App (c), App (Elim (const_guard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (c, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun guardSubElim a b c = Arg.make "guardSubElim" [a, b, c, ] [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (c), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardForm a b = Arg.make "coguardForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardEq a a' b b' = Arg.make "coguardEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_coguard, [App (a), App (b), ])), App (Elim (const_coguard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardFormUniv a b i = Arg.make "coguardFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardEqUniv a a' b b' i = Arg.make "coguardEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_coguard, [App (a), App (b), ])), App (Elim (const_coguard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a'), ])), (Arg.Unhide, [], Elim (const_iff, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntroEq a b m n = Arg.make "coguardIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntroOf a b m = Arg.make "coguardIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntroOfSquash a b m = Arg.make "coguardIntroOfSquash" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardIntro a b = Arg.make "coguardIntro" [a, b, ] [] (Elim (const_coguard, [App (a), App (b), ])) [(Arg.Unhide, [], a), (Arg.Nothing, [], b), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun coguardElim1 a b = Arg.make "coguardElim1" [a, b, ] [] (Elim (const_squash, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_coguard, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardElim2Eq a b m n = Arg.make "coguardElim2Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardElim2Of a b m = Arg.make "coguardElim2Of" [a, b, m, ] [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_coguard, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardElim2 a b = Arg.make "coguardElim2" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_coguard, [App (a), App (b), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun coguardLeft gsize a b c = Arg.lmake "coguardLeft" [] gsize [J.Tm (Elim (const_coguard, [App (a), App (b), ])), ] (c) [(Arg.Unhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (Sub (a, Shift 1)), J.Tm (b), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun coguardSatEq a b = Arg.make "coguardSatEq" [a, b, ] [] (Elim (const_eqtp, [App (b), App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardSub a a' b b' = Arg.make "coguardSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_coguard, [App (a), App (b), ])), App (Elim (const_coguard, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_arrow, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_istp, [App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardSubIntro a b c = Arg.make "coguardSubIntro" [a, b, c, ] [] (Elim (const_subtype, [App (c), App (Elim (const_coguard, [App (a), App (b), ])), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [], Elim (const_subtype, [App (c), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun coguardSubElim a b c = Arg.make "coguardSubElim" [a, b, c, ] [] (Elim (const_subtype, [App (Elim (const_coguard, [App (a), App (b), ])), App (c), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (c, Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsForm a b = Arg.make "existsForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEq a a' b b' = Arg.make "existsEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormUniv a b i = Arg.make "existsFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEqUniv a a' b b' i = Arg.make "existsEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsSub a a' b b' = Arg.make "existsSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntroOf a b m n = Arg.make "existsIntroOf" [a, b, m, n, ] [] (Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntroEq a b m m' n n' = Arg.make "existsIntroEq" [a, b, m, m', n, n', ] [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (n), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsIntro a b m = Arg.make "existsIntro" [a, b, m, ] [m, ] (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun existsElim1Of a b m = Arg.make "existsElim1Of" [a, b, m, ] [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim1Eq a b m n = Arg.make "existsElim1Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim1 a b = Arg.make "existsElim1" [a, b, ] [] (a) [(Arg.Nothing, [], Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun existsElim2Of a b m = Arg.make "existsElim2Of" [a, b, m, ] [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsElim2Eq a b m n = Arg.make "existsElim2Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEta a b m = Arg.make "existsEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsExt a b m n = Arg.make "existsExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Pi1, ]), Shift 0))), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsLeft gsize a b c = Arg.lmake "existsLeft" [] gsize [J.Tm (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Nothing, [J.Tm (b), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun existsFormInv1 a b = Arg.make "existsFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormInv2 a b m = Arg.make "existsFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsFormInv2Eq a b m n = Arg.make "existsFormInv2Eq" [a, b, m, n, ] [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (b, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodKind i k l = Arg.make "prodKind" [i, k, l, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_prod, [App (k), App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodKindEq i k k' l l' = Arg.make "prodKindEq" [i, k, k', l, l', ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_prod, [App (k), App (l), ])), App (Elim (const_prod, [App (k'), App (l'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (k'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (l), App (l'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodForm a b = Arg.make "prodForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEq a a' b b' = Arg.make "prodEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodFormUniv a b i = Arg.make "prodFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEqUniv a a' b b' i = Arg.make "prodEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsEq a a' b b' = Arg.make "prodExistsEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, Sub (b', Shift 1))), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsEqUniv a a' b b' i = Arg.make "prodExistsEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, Sub (b', Shift 1))), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodSub a a' b b' = Arg.make "prodSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExistsSub a a' b b' = Arg.make "prodExistsSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsProdSub a a' b b' = Arg.make "existsProdSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntroOf a b m n = Arg.make "prodIntroOf" [a, b, m, n, ] [] (Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntroEq a b m m' n n' = Arg.make "prodIntroEq" [a, b, m, m', n, n', ] [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodIntro a b = Arg.make "prodIntro" [a, b, ] [] (Elim (const_prod, [App (a), App (b), ])) [(Arg.Nothing, [], a), (Arg.Nothing, [], b), ] (fn [m, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun prodElim1Of a b m = Arg.make "prodElim1Of" [a, b, m, ] [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim1Eq a b m n = Arg.make "prodElim1Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim1 a b = Arg.make "prodElim1" [a, b, ] [] (a) [(Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun prodElim2Of a b m = Arg.make "prodElim2Of" [a, b, m, ] [] (Elim (const_of, [App (b), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim2Eq a b m n = Arg.make "prodElim2Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodElim2 a b = Arg.make "prodElim2" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi2, ]) | _ => raise Arg.ExtractFailure)
fun prodEta a b m = Arg.make "prodEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodExt a b m n = Arg.make "prodExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_prod, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodLeft gsize a b c = Arg.lmake "prodLeft" [] gsize [J.Tm (Elim (const_prod, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [J.Tm (Sub (b, Shift 1)), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun prodFormInv1 a b = Arg.make "prodFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodFormInv2 a b = Arg.make "prodFormInv2" [a, b, ] [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_prod, [App (a), App (b), ])), ])), (Arg.Unhide, [], a), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodForm a b = Arg.make "dprodForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodEq a a' b b' = Arg.make "dprodEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodFormUniv a b i = Arg.make "dprodFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodEqUniv a a' b b' i = Arg.make "dprodEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExistsEq a a' b b' = Arg.make "dprodExistsEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExistsEqUniv a a' b b' i = Arg.make "dprodExistsEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (Sub (b, Shift 1)), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodDprodEq a a' b b' = Arg.make "prodDprodEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodDprodEqUniv a a' b b' i = Arg.make "prodDprodEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodSub a a' b b' = Arg.make "dprodSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExistsSub a a' b b' = Arg.make "dprodExistsSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsDprodSub a a' b b' = Arg.make "existsDprodSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodProdSub a a' b b' = Arg.make "dprodProdSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodDprodSub a a' b b' = Arg.make "prodDprodSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (Sub (b', Shift 1)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodIntroOf a b m n = Arg.make "dprodIntroOf" [a, b, m, n, ] [] (Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (Pair (m, n)), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodIntroEq a b m m' n n' = Arg.make "dprodIntroEq" [a, b, m, m', n, n', ] [] (Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (Pair (m, n)), App (Pair (m', n')), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodIntro a b = Arg.make "dprodIntro" [a, b, ] [] (Elim (const_dprod, [App (a), App (b), ])) [(Arg.Nothing, [], a), (Arg.Nothing, [], b), ] (fn [m, n, ] => Pair (m, n) | _ => raise Arg.ExtractFailure)
fun dprodElim1Of a b m = Arg.make "dprodElim1Of" [a, b, m, ] [] (Elim (const_of, [App (a), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim1Eq a b m n = Arg.make "dprodElim1Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim1 a b = Arg.make "dprodElim1" [a, b, ] [] (a) [(Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi1, ]) | _ => raise Arg.ExtractFailure)
fun dprodElim2Of a b m = Arg.make "dprodElim2Of" [a, b, m, ] [] (Elim (const_of, [App (b), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim2Eq a b m n = Arg.make "dprodElim2Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodElim2 a b = Arg.make "dprodElim2" [a, b, ] [] (b) [(Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, ] => Elim (m, [Pi2, ]) | _ => raise Arg.ExtractFailure)
fun dprodEta a b m = Arg.make "dprodEta" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodExt a b m n = Arg.make "dprodExt" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (Elim (m, [Pi1, ])), App (Elim (n, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (Elim (m, [Pi2, ])), App (Elim (n, [Pi2, ])), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodLeft gsize a b c = Arg.lmake "dprodLeft" [] gsize [J.Tm (Elim (const_dprod, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [J.Tm (Sub (b, Shift 1)), J.Tm (a), ], SOME (Dot (Pair (Var 1, Var 0), Shift 2)), Sub (c, under gsize (Dot (Pair (Var 1, Var 0), Shift 2)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Pi2, ]), Dot (Elim (Var 0, [Pi1, ]), Shift 1)))) | _ => raise Arg.ExtractFailure)
fun dprodFormInv1 a b = Arg.make "dprodFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_dprod, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodFormInv2 a b m = Arg.make "dprodFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_dprod, [App (a), App (b), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionForm a b = Arg.make "unionForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionEq a a' b b' = Arg.make "unionEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionFormUniv a b i = Arg.make "unionFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionEqUniv a a' b b' i = Arg.make "unionEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionSub a a' b b' = Arg.make "unionSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionIntroOf a b m n = Arg.make "unionIntroOf" [a, b, m, n, ] [] (Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (n), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionIntroEq a b m n n' = Arg.make "unionIntroEq" [a, b, m, n, n', ] [] (Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (n), App (n'), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (n), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionIntro a b m = Arg.make "unionIntro" [a, b, m, ] [] (Elim (const_union, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, n, ] => n | _ => raise Arg.ExtractFailure)
fun unionElimOf a b c m p = Arg.make "unionElimOf" [a, b, c, m, p, ] [] (Elim (const_of, [App (c), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_of, [App (Sub (c, Shift 2)), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimEq a b c m n p q = Arg.make "unionElimEq" [a, b, c, m, n, p, q, ] [] (Elim (const_eq, [App (c), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElim a b c m = Arg.make "unionElim" [a, b, c, m, ] [m, ] (c) [(Arg.Nothing, [J.Tm (b), J.Tmh (a), ], Sub (c, Shift 2)), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun unionElimOfDep a b c m p = Arg.make "unionElimOfDep" [a, b, c, m, p, ] [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_of, [App (Sub (c, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimEqDep a b c m n p q = Arg.make "unionElimEqDep" [a, b, c, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimDep a b c m = Arg.make "unionElimDep" [a, b, c, m, ] [m, ] (Sub (c, Dot (m, Shift 0))) [(Arg.Nothing, [J.Tm (b), J.Tmh (a), ], Sub (c, Idot (0, Shift 2))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun unionElimIstype a b c m = Arg.make "unionElimIstype" [a, b, c, m, ] [] (Elim (const_istp, [App (Sub (c, Dot (m, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_istp, [App (Sub (c, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unionElimEqtype a b c d m n = Arg.make "unionElimEqtype" [a, b, c, d, m, n, ] [] (Elim (const_eqtp, [App (Sub (c, Dot (m, Shift 0))), App (Sub (d, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (b), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Idot (0, Shift 2))), App (Sub (d, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumForm a b = Arg.make "sumForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumEq a a' b b' = Arg.make "sumEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormUniv a b i = Arg.make "sumFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumEqUniv a a' b b' i = Arg.make "sumEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumSub a a' b b' = Arg.make "sumSub" [a, a', b, b', ] [] (Elim (const_subtype, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1Of a b m = Arg.make "sumIntro1Of" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1Eq a b m n = Arg.make "sumIntro1Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inl, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro1 a b = Arg.make "sumIntro1" [a, b, ] [] (Elim (const_sum, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => Elim (const_inl, [App (m), ]) | _ => raise Arg.ExtractFailure)
fun sumIntro2Of a b m = Arg.make "sumIntro2Of" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (b), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro2Eq a b m n = Arg.make "sumIntro2Eq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (b), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumIntro2 a b = Arg.make "sumIntro2" [a, b, ] [] (Elim (const_sum, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], b), ] (fn [_, m, ] => Elim (const_inr, [App (m), ]) | _ => raise Arg.ExtractFailure)
fun sumElimOf a b c m p r = Arg.make "sumElimOf" [a, b, c, m, p, r, ] [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), App (p), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_of, [App (Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimOfNondep a b c m p r = Arg.make "sumElimOfNondep" [a, b, c, m, p, r, ] [] (Elim (const_of, [App (c), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (c, Shift 1)), App (p), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_of, [App (Sub (c, Shift 1)), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimEq a b c m n p q r s = Arg.make "sumElimEq" [a, b, c, m, n, p, q, r, s, ] [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), App (Elim (const_sum_case, [App (n), App (Lam (NONE, q)), App (Lam (NONE, s)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), App (p), App (q), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_eq, [App (Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElim a b c m = Arg.make "sumElim" [a, b, c, m, ] [m, ] (Sub (c, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Nothing, [J.Tm (a), ], Sub (c, Dot (Elim (const_inl, [App (Var 0), ]), Shift 1))), (Arg.Nothing, [J.Tm (b), ], Sub (c, Dot (Elim (const_inr, [App (Var 0), ]), Shift 1))), ] (fn [_, p, r, ] => Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ]) | _ => raise Arg.ExtractFailure)
fun sumElimNondep a b c = Arg.make "sumElimNondep" [a, b, c, ] [] (c) [(Arg.Nothing, [], Elim (const_sum, [App (a), App (b), ])), (Arg.Nothing, [J.Tm (a), ], Sub (c, Shift 1)), (Arg.Nothing, [J.Tm (b), ], Sub (c, Shift 1)), ] (fn [m, p, r, ] => Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ]) | _ => raise Arg.ExtractFailure)
fun sumElimIstype a b c e m = Arg.make "sumElimIstype" [a, b, c, e, m, ] [] (Elim (const_istp, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, c)), App (Lam (NONE, e)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_istp, [App (e), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumElimEqtype a b c d e f m n = Arg.make "sumElimEqtype" [a, b, c, d, e, f, m, n, ] [] (Elim (const_eqtp, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, c)), App (Lam (NONE, e)), ])), App (Elim (const_sum_case, [App (n), App (Lam (NONE, d)), App (Lam (NONE, f)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (c), App (d), ])), (Arg.Unhide, [J.Tm (b), ], Elim (const_eqtp, [App (e), App (f), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumContradiction a b c m n = Arg.make "sumContradiction" [a, b, c, m, n, ] [] (c) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumInjection1 a b m n = Arg.make "sumInjection1" [a, b, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inl, [App (m), ])), App (Elim (const_inl, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumInjection2 a b m n = Arg.make "sumInjection2" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_inr, [App (m), ])), App (Elim (const_inr, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val sum_caseType = Arg.make "sum_caseType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 1), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 2), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_sum, [App (Var 2), App (Var 1), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 2), App (Var 0), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 1), App (Var 0), ])), App (Var 0), ])), ])), ]))), ]))), ]))), ]))), ])), App (const_sum_case), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormInv1 a b = Arg.make "sumFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumFormInv2 a b = Arg.make "sumFormInv2" [a, b, ] [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_sum, [App (a), App (b), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureKind i k = Arg.make "futureKind" [i, k, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_future, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureKindEq i k l = Arg.make "futureKindEq" [i, k, l, ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_future, [App (k), ])), App (Elim (const_future, [App (l), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureForm a = Arg.make "futureForm" [a, ] [] (Elim (const_istp, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEq a b = Arg.make "futureEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureFormUniv a i = Arg.make "futureFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_future, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEqUniv a b i = Arg.make "futureEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureSub a b = Arg.make "futureSub" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (b), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntroOf a m = Arg.make "futureIntroOf" [a, m, ] [] (Elim (const_of, [App (Elim (const_future, [App (a), ])), App (Next (m)), ])) [(Arg.PromoteUnhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntroEq a m n = Arg.make "futureIntroEq" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (Next (m)), App (Next (n)), ])) [(Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureIntro a = Arg.make "futureIntro" [a, ] [] (Elim (const_future, [App (a), ])) [(Arg.Promote, [], a), ] (fn [m, ] => Next (m) | _ => raise Arg.ExtractFailure)
fun futureElimOf a b m p = Arg.make "futureElimOf" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (p, Dot (Elim (m, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimOfLetnext a b m p = Arg.make "futureElimOfLetnext" [a, b, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Elim (const_letnext, [App (m), App (Lam (NONE, p)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (b), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimOfLetnextNondep a b m p = Arg.make "futureElimOfLetnextNondep" [a, b, m, p, ] [] (Elim (const_of, [App (b), App (Elim (const_letnext, [App (m), App (Lam (NONE, p)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimEq a b m n p q = Arg.make "futureElimEq" [a, b, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (p, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (q, Dot (Elim (n, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eq, [App (b), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElim a b m = Arg.make "futureElim" [a, b, m, ] [m, ] (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Nothing, [J.Tml (a), ], b), ] (fn [_, _, p, ] => Sub (p, Dot (Elim (m, [Prev, ]), Shift 0)) | _ => raise Arg.ExtractFailure)
fun futureElimIstype a b m = Arg.make "futureElimIstype" [a, b, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimIstypeLetnext a b m = Arg.make "futureElimIstypeLetnext" [a, b, m, ] [] (Elim (const_istp, [App (Elim (const_letnext, [App (m), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureElimEqtype a b c m n = Arg.make "futureElimEqtype" [a, b, c, m, n, ] [] (Elim (const_eqtp, [App (Sub (b, Dot (Elim (m, [Prev, ]), Shift 0))), App (Sub (c, Dot (Elim (n, [Prev, ]), Shift 0))), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eqtp, [App (b), App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEta a m = Arg.make "futureEta" [a, m, ] [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (Next (Elim (m, [Prev, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureExt a m n = Arg.make "futureExt" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (n), ])), (Arg.PromoteUnhide, [], Elim (const_eq, [App (a), App (Elim (m, [Prev, ])), App (Elim (n, [Prev, ])), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureLeft gsize a b = Arg.lmake "futureLeft" [] gsize [J.Tm (Elim (const_future, [App (a), ])), ] (b) [(Arg.PromoteUnhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tml (a), ], SOME (Dot (Next (Var 0), Shift 1)), Sub (b, under gsize (Dot (Next (Var 0), Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Elim (Var 0, [Prev, ]), Shift 1))) | _ => raise Arg.ExtractFailure)
fun futureLeftHidden gsize a b = Arg.lmake "futureLeftHidden" [] gsize [J.Tmh (Elim (const_future, [App (a), ])), ] (b) [(Arg.PromoteUnhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmlh (a), ], SOME (Dot (Next (Var 0), Shift 1)), Sub (b, under gsize (Dot (Next (Var 0), Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun futureInjection a m n = Arg.make "futureInjection" [a, m, n, ] [] (Elim (const_future, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_future, [App (a), ])), App (Next (m)), App (Next (n)), ])), ] (fn [_, _, ] => Next (Triv) | _ => raise Arg.ExtractFailure)
fun squashFutureSwap a = Arg.make "squashFutureSwap" [a, ] [] (Elim (const_squash, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_future, [App (Elim (const_squash, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashFutureSwap a = Arg.make "isquashFutureSwap" [a, ] [] (Elim (const_isquash, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_future, [App (Elim (const_isquash, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureSquashSwap a = Arg.make "futureSquashSwap" [a, ] [] (Elim (const_future, [App (Elim (const_squash, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (Elim (const_future, [App (a), ])), ])), ] (fn [_, _, ] => Next (Triv) | _ => raise Arg.ExtractFailure)
fun futureIsquashSwap a = Arg.make "futureIsquashSwap" [a, ] [] (Elim (const_future, [App (Elim (const_isquash, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_isquash, [App (Elim (const_future, [App (a), ])), ])), ] (fn [_, _, ] => Next (Triv) | _ => raise Arg.ExtractFailure)
fun recKind i k = Arg.make "recKind" [i, k, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, k)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_kind, [App (i), ])), ], Elim (const_of, [App (Elim (const_kind, [App (Sub (i, Shift 1)), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recKindEq i k l = Arg.make "recKindEq" [i, k, l, ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, k)), ])), App (Elim (const_rec, [App (Lam (NONE, l)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_kind, [App (i), ])), ], Elim (const_eq, [App (Elim (const_kind, [App (Sub (i, Shift 1)), ])), App (k), App (l), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recForm a = Arg.make "recForm" [a, ] [] (Elim (const_istp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recEq a b = Arg.make "recEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Elim (const_rec, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recFormUniv a i = Arg.make "recFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recEqUniv a b i = Arg.make "recEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Elim (const_rec, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUnroll a = Arg.make "recUnroll" [a, ] [] (Elim (const_eqtp, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_rec, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUnrollUniv a i = Arg.make "recUnrollUniv" [a, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_rec, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_rec, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recBisimilar a b = Arg.make "recBisimilar" [a, b, ] [] (Elim (const_eqtp, [App (b), App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (Sub (a, Dot (b, Shift 0))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muForm a = Arg.make "muForm" [a, ] [] (Elim (const_istp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muEq a b = Arg.make "muEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Elim (const_mu, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, b)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muFormUniv a i = Arg.make "muFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muEqUniv a b i = Arg.make "muEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Elim (const_mu, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, b)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUnroll a = Arg.make "muUnroll" [a, ] [] (Elim (const_eeqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_mu, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun muUnrollUniv a i = Arg.make "muUnrollUniv" [a, i, ] [] (Elim (const_eeqtp, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (Sub (a, Dot (Elim (const_mu, [App (Lam (NONE, a)), ]), Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun muInd a b m = Arg.make "muInd" [a, b, m, ] [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Var 2), App (Lam (NONE, Sub (b, Idot (0, Shift 4)))), ])), J.Tm (Elim (const_subtype, [App (Var 1), App (Elim (const_mu, [App (Lam (NONE, Sub (a, Idot (0, Shift 3)))), ])), ])), J.Tm (a), J.Tph, ], Sub (b, Idot (2, Shift 4))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, n, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Sub (n, Idot (1, Dot (Triv, Idot (0, Dot (Triv, Shift 2)))))))), App (m), ]) | _ => raise Arg.ExtractFailure)
fun muIndUniv a b i m = Arg.make "muIndUniv" [a, b, i, m, ] [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Var 2), App (Lam (NONE, Sub (b, Idot (0, Shift 4)))), ])), J.Tm (Elim (const_subtype, [App (Var 1), App (Elim (const_mu, [App (Lam (NONE, Sub (a, Idot (0, Shift 3)))), ])), ])), J.Tm (a), J.Tmh (Elim (const_univ, [App (i), ])), ], Elim (const_prod, [App (Sub (b, Idot (2, Shift 4))), App (Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 4)), ])), App (Sub (b, Idot (2, Shift 4))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, n, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Elim (Sub (n, Idot (1, Dot (Triv, Idot (0, Dot (Triv, Shift 2))))), [Pi1, ])))), App (m), ]) | _ => raise Arg.ExtractFailure)
val voidForm = Arg.make "voidForm" [] [] (Elim (const_istp, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val voidEq = Arg.make "voidEq" [] [] (Elim (const_eqtp, [App (const_void), App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun voidFormUniv i = Arg.make "voidFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_void), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidEqUniv i = Arg.make "voidEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_void), App (const_void), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidElim a = Arg.make "voidElim" [a, ] [] (a) [(Arg.Unhide, [], const_void), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun voidSub a = Arg.make "voidSub" [a, ] [] (Elim (const_subtype, [App (const_void), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val abortType = Arg.make "abortType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (const_void), App (Var 0), ]))), ]))), ])), App (const_abort), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitKind i = Arg.make "unitKind" [i, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitKindEq i = Arg.make "unitKindEq" [i, ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (const_unit), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitForm = Arg.make "unitForm" [] [] (Elim (const_istp, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitEq = Arg.make "unitEq" [] [] (Elim (const_eqtp, [App (const_unit), App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitFormUniv i = Arg.make "unitFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitEqUniv i = Arg.make "unitEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_unit), App (const_unit), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitIntroOf = Arg.make "unitIntroOf" [] [] (Elim (const_of, [App (const_unit), App (Triv), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitIntro = Arg.make "unitIntro" [] [] (const_unit) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitExt m n = Arg.make "unitExt" [m, n, ] [] (Elim (const_eq, [App (const_unit), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_unit), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (const_unit), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun unitLeft gsize b = Arg.lmake "unitLeft" [] gsize [J.Tm (const_unit), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
val boolForm = Arg.make "boolForm" [] [] (Elim (const_istp, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolEq = Arg.make "boolEq" [] [] (Elim (const_eqtp, [App (const_bool), App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolFormUniv i = Arg.make "boolFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_bool), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolEqUniv i = Arg.make "boolEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_bool), App (const_bool), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val boolIntro1Of = Arg.make "boolIntro1Of" [] [] (Elim (const_of, [App (const_bool), App (const_true), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolIntro2Of = Arg.make "boolIntro2Of" [] [] (Elim (const_of, [App (const_bool), App (const_false), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimOf a m p r = Arg.make "boolElimOf" [a, m, p, r, ] [] (Elim (const_of, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_ite, [App (m), App (p), App (r), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (const_true, Shift 0))), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (const_false, Shift 0))), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimOfNondep a m p r = Arg.make "boolElimOfNondep" [a, m, p, r, ] [] (Elim (const_of, [App (a), App (Elim (const_ite, [App (m), App (p), App (r), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (r), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimEq a m n p q r s = Arg.make "boolElimEq" [a, m, n, p, q, r, s, ] [] (Elim (const_eq, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_ite, [App (m), App (p), App (r), ])), App (Elim (const_ite, [App (n), App (q), App (s), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_true, Shift 0))), App (p), App (q), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_false, Shift 0))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElim a m = Arg.make "boolElim" [a, m, ] [m, ] (Sub (a, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Nothing, [], Sub (a, Dot (const_true, Shift 0))), (Arg.Nothing, [], Sub (a, Dot (const_false, Shift 0))), ] (fn [_, p, r, ] => Elim (const_ite, [App (m), App (p), App (r), ]) | _ => raise Arg.ExtractFailure)
fun boolElimIstype a c m = Arg.make "boolElimIstype" [a, c, m, ] [] (Elim (const_istp, [App (Elim (const_ite, [App (m), App (a), App (c), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolElimEqtype a b c d m n = Arg.make "boolElimEqtype" [a, b, c, d, m, n, ] [] (Elim (const_eqtp, [App (Elim (const_ite, [App (m), App (a), App (c), ])), App (Elim (const_ite, [App (n), App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun boolLeft gsize a = Arg.lmake "boolLeft" [] gsize [J.Tm (const_bool), ] (a) [(Arg.Nothing, [], SOME (Dot (const_true, Shift 0)), Sub (a, under gsize (Dot (const_true, Shift 0)))), (Arg.Nothing, [], SOME (Dot (const_false, Shift 0)), Sub (a, under gsize (Dot (const_false, Shift 0)))), ] (fn [m, n, ] => Elim (const_ite, [App (Var gsize ), App (Sub (m, under gsize (Shift 1))), App (Sub (n, under gsize (Shift 1))), ]) | _ => raise Arg.ExtractFailure)
fun boolContradiction a = Arg.make "boolContradiction" [a, ] [] (a) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (const_true), App (const_false), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val iteType = Arg.make "iteType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (const_bool), App (Elim (const_arrow, [App (Var 0), App (Elim (const_arrow, [App (Var 0), App (Var 0), ])), ])), ]))), ]))), ])), App (const_ite), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val natForm = Arg.make "natForm" [] [] (Elim (const_istp, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val natEq = Arg.make "natEq" [] [] (Elim (const_eqtp, [App (const_nat), App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun natFormUniv i = Arg.make "natFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_nat), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natEqUniv i = Arg.make "natEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_nat), App (const_nat), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natElimEq a m n p q r s = Arg.make "natElimEq" [a, m, n, p, q, r, s, ] [] (Elim (const_eq, [App (Sub (a, Dot (m, Shift 0))), App (Elim (const_nat_case, [App (m), App (p), App (Lam (NONE, r)), ])), App (Elim (const_nat_case, [App (n), App (q), App (Lam (NONE, s)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (const_zero, Shift 0))), App (p), App (q), ])), (Arg.Unhide, [J.Tm (const_nat), ], Elim (const_eq, [App (Sub (a, Dot (Elim (const_succ, [App (Var 0), ]), Shift 1))), App (r), App (s), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun natElimEqtype a b c d m n = Arg.make "natElimEqtype" [a, b, c, d, m, n, ] [] (Elim (const_eqtp, [App (Elim (const_nat_case, [App (m), App (a), App (Lam (NONE, c)), ])), App (Elim (const_nat_case, [App (n), App (b), App (Lam (NONE, d)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [J.Tm (const_nat), ], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val natUnroll = Arg.make "natUnroll" [] [] (Elim (const_eeqtp, [App (const_nat), App (Elim (const_sum, [App (const_unit), App (const_nat), ])), ])) [] (fn [] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun natContradiction a m = Arg.make "natContradiction" [a, m, ] [] (a) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (const_zero), App (Elim (const_succ, [App (m), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun natInjection m n = Arg.make "natInjection" [m, n, ] [] (Elim (const_eq, [App (const_nat), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_nat), App (Elim (const_succ, [App (m), ])), App (Elim (const_succ, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val zeroType = Arg.make "zeroType" [] [] (Elim (const_of, [App (const_nat), App (const_zero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val succType = Arg.make "succType" [] [] (Elim (const_of, [App (Elim (const_arrow, [App (const_nat), App (const_nat), ])), App (const_succ), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun univKind i j = Arg.make "univKind" [i, j, ] [] (Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univKindEq i j k = Arg.make "univKindEq" [i, j, k, ] [] (Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), App (Elim (const_univ, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (k), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (i), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForm i = Arg.make "univForm" [i, ] [] (Elim (const_istp, [App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univEq i j = Arg.make "univEq" [i, j, ] [] (Elim (const_eqtp, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormUniv i j = Arg.make "univFormUniv" [i, j, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (j), ])), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormUnivSucc i = Arg.make "univFormUnivSucc" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univEqUniv i j k = Arg.make "univEqUniv" [i, j, k, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), App (Elim (const_univ, [App (k), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (j), ])), App (i), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeOf a i j = Arg.make "univCumulativeOf" [a, i, j, ] [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeEq a b i j = Arg.make "univCumulativeEq" [a, b, i, j, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univCumulativeSuccOf a i = Arg.make "univCumulativeSuccOf" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univSub i j = Arg.make "univSub" [i, j, ] [] (Elim (const_subtype, [App (Elim (const_univ, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForgetOf a i = Arg.make "univForgetOf" [a, i, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univForgetEq a b i = Arg.make "univForgetEq" [a, b, i, ] [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univIntroEqtype a b i = Arg.make "univIntroEqtype" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun univFormInv i = Arg.make "univFormInv" [i, ] [] (Elim (const_of, [App (const_level), App (i), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_univ, [App (i), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForm i = Arg.make "kindForm" [i, ] [] (Elim (const_istp, [App (Elim (const_kind, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindEq i j = Arg.make "kindEq" [i, j, ] [] (Elim (const_eqtp, [App (Elim (const_kind, [App (i), ])), App (Elim (const_kind, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindFormUniv i k = Arg.make "kindFormUniv" [i, k, ] [] (Elim (const_of, [App (Elim (const_univ, [App (k), ])), App (Elim (const_kind, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (Elim (const_lsucc, [App (i), ])), ])), App (k), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindEqUniv i j k = Arg.make "kindEqUniv" [i, j, k, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (k), ])), App (Elim (const_kind, [App (i), ])), App (Elim (const_kind, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (j), ])), (Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (Elim (const_lsucc, [App (i), ])), ])), App (k), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForgetOf a i = Arg.make "kindForgetOf" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindForgetEq a b i = Arg.make "kindForgetEq" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (Elim (const_lsucc, [App (i), ])), ])), App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun kindUnivSub i j = Arg.make "kindUnivSub" [i, j, ] [] (Elim (const_subtype, [App (Elim (const_kind, [App (i), ])), App (Elim (const_univ, [App (j), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (Elim (const_lsucc, [App (i), ])), App (j), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val levelForm = Arg.make "levelForm" [] [] (Elim (const_istp, [App (const_level), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val levelEq = Arg.make "levelEq" [] [] (Elim (const_eqtp, [App (const_level), App (const_level), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun levelFormUniv i = Arg.make "levelFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_level), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun levelEqUniv i = Arg.make "levelEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_level), App (const_level), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqForm i j = Arg.make "lleqForm" [i, j, ] [] (Elim (const_istp, [App (Elim (const_lleq, [App (i), App (j), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (j), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqEq i i' j j' = Arg.make "lleqEq" [i, i', j, j', ] [] (Elim (const_eqtp, [App (Elim (const_lleq, [App (i), App (j), ])), App (Elim (const_lleq, [App (i'), App (j'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (i'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (j'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqFormUniv i j k = Arg.make "lleqFormUniv" [i, j, k, ] [] (Elim (const_of, [App (Elim (const_univ, [App (k), ])), App (Elim (const_lleq, [App (i), App (j), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (j), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (k), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqEqUniv i i' j j' k = Arg.make "lleqEqUniv" [i, i', j, j', k, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (k), ])), App (Elim (const_lleq, [App (i), App (j), ])), App (Elim (const_lleq, [App (i'), App (j'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (i), App (i'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (j), App (j'), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (k), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val lzeroLevel = Arg.make "lzeroLevel" [] [] (Elim (const_of, [App (const_level), App (const_lzero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccLevel m = Arg.make "lsuccLevel" [m, ] [] (Elim (const_of, [App (const_level), App (Elim (const_lsucc, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccEq m n = Arg.make "lsuccEq" [m, n, ] [] (Elim (const_eq, [App (const_level), App (Elim (const_lsucc, [App (m), ])), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lmaxLevel m n = Arg.make "lmaxLevel" [m, n, ] [] (Elim (const_of, [App (const_level), App (Elim (const_lmax, [App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lmaxEq m m' n n' = Arg.make "lmaxEq" [m, m', n, n', ] [] (Elim (const_eq, [App (const_level), App (Elim (const_lmax, [App (m), App (n), ])), App (Elim (const_lmax, [App (m'), App (n'), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (m'), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (n), App (n'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqRefl m = Arg.make "lleqRefl" [m, ] [] (Elim (const_lleq, [App (m), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqTrans m n p = Arg.make "lleqTrans" [m, n, p, ] [] (Elim (const_lleq, [App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_lleq, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqZero m = Arg.make "lleqZero" [m, ] [] (Elim (const_lleq, [App (const_lzero), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqSucc m n = Arg.make "lleqSucc" [m, n, ] [] (Elim (const_lleq, [App (Elim (const_lsucc, [App (m), ])), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqIncrease m n = Arg.make "lleqIncrease" [m, n, ] [] (Elim (const_lleq, [App (m), App (Elim (const_lsucc, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxL m n p = Arg.make "lleqMaxL" [m, n, p, ] [] (Elim (const_lleq, [App (Elim (const_lmax, [App (m), App (n), ])), App (p), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (p), ])), (Arg.Unhide, [], Elim (const_lleq, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxR1 m n p = Arg.make "lleqMaxR1" [m, n, p, ] [] (Elim (const_lleq, [App (m), App (Elim (const_lmax, [App (n), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqMaxR2 m n p = Arg.make "lleqMaxR2" [m, n, p, ] [] (Elim (const_lleq, [App (m), App (Elim (const_lmax, [App (n), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_lleq, [App (m), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (const_level), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lleqResp m m' n n' = Arg.make "lleqResp" [m, m', n, n', ] [] (Elim (const_lleq, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m'), App (m), ])), (Arg.Unhide, [], Elim (const_eq, [App (const_level), App (n'), App (n), ])), (Arg.Unhide, [], Elim (const_lleq, [App (m'), App (n'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lsuccMaxDistTrans m n p = Arg.make "lsuccMaxDistTrans" [m, n, p, ] [] (Elim (const_eq, [App (const_level), App (m), App (Elim (const_lsucc, [App (Elim (const_lmax, [App (n), App (p), ])), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_level), App (m), App (Elim (const_lmax, [App (Elim (const_lsucc, [App (n), ])), App (Elim (const_lsucc, [App (p), ])), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val lzeroType = Arg.make "lzeroType" [] [] (Elim (const_of, [App (const_level), App (const_lzero), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val lsuccType = Arg.make "lsuccType" [] [] (Elim (const_of, [App (Elim (const_arrow, [App (const_level), App (const_level), ])), App (const_lsucc), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val lmaxType = Arg.make "lmaxType" [] [] (Elim (const_of, [App (Elim (const_arrow, [App (const_level), App (Elim (const_arrow, [App (const_level), App (const_level), ])), ])), App (const_lmax), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun eqForm a m p = Arg.make "eqForm" [a, m, p, ] [] (Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqEq a b m n p q = Arg.make "eqEq" [a, b, m, n, p, q, ] [] (Elim (const_eqtp, [App (Elim (const_eq, [App (a), App (m), App (p), ])), App (Elim (const_eq, [App (b), App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormUniv a i m p = Arg.make "eqFormUniv" [a, i, m, p, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eq, [App (a), App (m), App (p), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqEqUniv a b i m n p q = Arg.make "eqEqUniv" [a, b, i, m, n, p, q, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eq, [App (a), App (m), App (p), ])), App (Elim (const_eq, [App (b), App (n), App (q), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (p), App (q), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqIntro a m n = Arg.make "eqIntro" [a, m, n, ] [] (Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqElim a m n p = Arg.make "eqElim" [a, m, n, p, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqTrivialize a m n = Arg.make "eqTrivialize" [a, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqExt a m n p q = Arg.make "eqExt" [a, m, n, p, q, ] [] (Elim (const_eq, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqLeft gsize a b p q = Arg.lmake "eqLeft" [] gsize [J.Tm (Elim (const_eq, [App (a), App (p), App (q), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun eqRefl a m = Arg.make "eqRefl" [a, m, ] [] (Elim (const_eq, [App (a), App (m), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqSymm a m n = Arg.make "eqSymm" [a, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (n), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqTrans a m n p = Arg.make "eqTrans" [a, m, n, p, ] [] (Elim (const_eq, [App (a), App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv1 a m n = Arg.make "eqFormInv1" [a, m, n, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv2 a m n = Arg.make "eqFormInv2" [a, m, n, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqFormInv3 a m n = Arg.make "eqFormInv3" [a, m, n, ] [] (Elim (const_of, [App (a), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofForm a m = Arg.make "ofForm" [a, m, ] [] (Elim (const_istp, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEq a b m n = Arg.make "ofEq" [a, b, m, n, ] [] (Elim (const_eqtp, [App (Elim (const_of, [App (a), App (m), ])), App (Elim (const_of, [App (b), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofFormUniv a i m = Arg.make "ofFormUniv" [a, i, m, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEqUniv a b i m n = Arg.make "ofEqUniv" [a, b, i, m, n, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_of, [App (a), App (m), ])), App (Elim (const_of, [App (b), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofIntro a m = Arg.make "ofIntro" [a, m, ] [] (Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofElim a m p = Arg.make "ofElim" [a, m, p, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofTrivialize a m = Arg.make "ofTrivialize" [a, m, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofExt a m p q = Arg.make "ofExt" [a, m, p, q, ] [] (Elim (const_eq, [App (Elim (const_of, [App (a), App (m), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_of, [App (a), App (m), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofLeft gsize a b p = Arg.lmake "ofLeft" [] gsize [J.Tm (Elim (const_of, [App (a), App (p), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun ofEquand1 a m n = Arg.make "ofEquand1" [a, m, n, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofEquand2 a m n = Arg.make "ofEquand2" [a, m, n, ] [] (Elim (const_of, [App (a), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpForm a b = Arg.make "eqtpForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpEq a b c d = Arg.make "eqtpEq" [a, b, c, d, ] [] (Elim (const_eqtp, [App (Elim (const_eqtp, [App (a), App (c), ])), App (Elim (const_eqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpFormUniv a b i = Arg.make "eqtpFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpEqUniv a b c d i = Arg.make "eqtpEqUniv" [a, b, c, d, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eqtp, [App (a), App (c), ])), App (Elim (const_eqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpIntro a b = Arg.make "eqtpIntro" [a, b, ] [] (Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpElim a b p = Arg.make "eqtpElim" [a, b, p, ] [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpExt a b p q = Arg.make "eqtpExt" [a, b, p, q, ] [] (Elim (const_eq, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_eqtp, [App (a), App (b), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpLeft gsize a b c = Arg.lmake "eqtpLeft" [] gsize [J.Tm (Elim (const_eqtp, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun eqtpFunct a b m n = Arg.make "eqtpFunct" [a, b, m, n, ] [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (b, Dot (n, Shift 0))), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpFunctType a b b' = Arg.make "eqtpFunctType" [a, b, b', ] [] (Elim (const_eqtp, [App (Sub (a, Dot (b, Shift 0))), App (Sub (a, Dot (b', Shift 0))), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalenceOf a b m = Arg.make "equivalenceOf" [a, b, m, ] [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalenceEq a b m n = Arg.make "equivalenceEq" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun equivalence a b = Arg.make "equivalence" [a, b, ] [] (b) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun equivalenceLeft gsize a b c = Arg.lmake "equivalenceLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_istp, [App (a), ])), ], NONE, Elim (const_eqtp, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun equivalenceLeftAlt gsize a b c = Arg.lmake "equivalenceLeftAlt" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eqtp, [App (Sub (a, Shift (gsize + 1))), App (Sub (b, Shift (gsize + 1))), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun eqtpRefl a = Arg.make "eqtpRefl" [a, ] [] (Elim (const_eqtp, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpSymm a b = Arg.make "eqtpSymm" [a, b, ] [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (b), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpTrans a b c = Arg.make "eqtpTrans" [a, b, c, ] [] (Elim (const_eqtp, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpForm a = Arg.make "istpForm" [a, ] [] (Elim (const_istp, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpEq a b = Arg.make "istpEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_istp, [App (a), ])), App (Elim (const_istp, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpFormUniv a i = Arg.make "istpFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpEqUniv a b i = Arg.make "istpEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_istp, [App (a), ])), App (Elim (const_istp, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpIntro a = Arg.make "istpIntro" [a, ] [] (Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpElim a p = Arg.make "istpElim" [a, p, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpExt a p q = Arg.make "istpExt" [a, p, q, ] [] (Elim (const_eq, [App (Elim (const_istp, [App (a), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_istp, [App (a), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpLeft gsize a b = Arg.lmake "istpLeft" [] gsize [J.Tm (Elim (const_istp, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun inhabitedForm a = Arg.make "inhabitedForm" [a, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeForm a b = Arg.make "subtypeForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeEq a b c d = Arg.make "subtypeEq" [a, b, c, d, ] [] (Elim (const_eqtp, [App (Elim (const_subtype, [App (a), App (c), ])), App (Elim (const_subtype, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeFormUniv a b i = Arg.make "subtypeFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeEqUniv a b c d i = Arg.make "subtypeEqUniv" [a, b, c, d, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_subtype, [App (a), App (c), ])), App (Elim (const_subtype, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIntro a b = Arg.make "subtypeIntro" [a, b, ] [] (Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeElim a b p = Arg.make "subtypeElim" [a, b, p, ] [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeExt a b p q = Arg.make "subtypeExt" [a, b, p, q, ] [] (Elim (const_eq, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_subtype, [App (a), App (b), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeLeft gsize a b c = Arg.lmake "subtypeLeft" [] gsize [J.Tm (Elim (const_subtype, [App (a), App (b), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun subtypeEstablish a b = Arg.make "subtypeEstablish" [a, b, ] [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (Var 0), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumptionOf a b m = Arg.make "subsumptionOf" [a, b, m, ] [] (Elim (const_of, [App (b), App (m), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumptionEq a b m n = Arg.make "subsumptionEq" [a, b, m, n, ] [] (Elim (const_eq, [App (b), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subsumption a b = Arg.make "subsumption" [a, b, ] [] (b) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionAlt a b = Arg.make "subsumptionAlt" [a, b, ] [] (b) [(Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (a), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLeft gsize a b c = Arg.lmake "subsumptionLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_istp, [App (a), ])), ], NONE, Elim (const_eeqtp, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLeftAlt gsize a b c = Arg.lmake "subsumptionLeftAlt" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eeqtp, [App (Sub (a, Shift (gsize + 1))), App (Sub (b, Shift (gsize + 1))), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun subsumptionLast gsize a b c = Arg.lmake "subsumptionLast" [] gsize [J.Tm (a), ] (Sub (c, Shift gsize )) [(Arg.Unhide, [J.Tm (a), ], NONE, Elim (const_subtype, [App (Sub (a, Shift 1)), App (Sub (b, Shift 1)), ])), (Arg.Nothing, [J.Tm (b), ], NONE, c), ] (fn [_, m, ] => Sub (m, Shift gsize ) | _ => raise Arg.ExtractFailure)
fun tighten gsize a b c = Arg.lmake "tighten" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_subtype, [App (Sub (b, Shift (gsize + 1))), App (Sub (a, Shift (gsize + 1))), ])), (Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_of, [App (Sub (b, Shift (gsize + 1))), App (Var gsize ), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, _, m, ] => m | _ => raise Arg.ExtractFailure)
fun subtypeRefl a = Arg.make "subtypeRefl" [a, ] [] (Elim (const_subtype, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeReflEqtype a b = Arg.make "subtypeReflEqtype" [a, b, ] [] (Elim (const_subtype, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeTrans a b c = Arg.make "subtypeTrans" [a, b, c, ] [] (Elim (const_subtype, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (c), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIstp1 a b = Arg.make "subtypeIstp1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeIstp2 a b = Arg.make "subtypeIstp2" [a, b, ] [] (Elim (const_istp, [App (b), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpForm a b = Arg.make "eeqtpForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_eeqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpEq a b c d = Arg.make "eeqtpEq" [a, b, c, d, ] [] (Elim (const_eqtp, [App (Elim (const_eeqtp, [App (a), App (c), ])), App (Elim (const_eeqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpFormUniv a b i = Arg.make "eeqtpFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eeqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpEqUniv a b c d i = Arg.make "eeqtpEqUniv" [a, b, c, d, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_eeqtp, [App (a), App (c), ])), App (Elim (const_eeqtp, [App (b), App (d), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (c), App (d), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setForm a b = Arg.make "setForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setEq a a' b b' = Arg.make "setEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setFormUniv a b i = Arg.make "setFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setEqUniv a a' b b' i = Arg.make "setEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeakenOf a b m = Arg.make "setWeakenOf" [a, b, m, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeakenEq a b m n = Arg.make "setWeakenEq" [a, b, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setWeaken a b = Arg.make "setWeaken" [a, b, ] [] (a) [(Arg.Nothing, [], Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun setIntroOf a b m = Arg.make "setIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntroEq a b m n = Arg.make "setIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntro a b m = Arg.make "setIntro" [a, b, m, ] [m, ] (Elim (const_set, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => m | _ => raise Arg.ExtractFailure)
fun setIntroOfSquash a b m = Arg.make "setIntroOfSquash" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setIntroEqSquash a b m n = Arg.make "setIntroEqSquash" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntroOfSquash a = Arg.make "squashIntroOfSquash" [a, ] [] (Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_squash, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setElim a b c m = Arg.make "setElim" [a, b, c, m, ] [] (c) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (m, Shift 0))), ], Sub (c, Shift 1)), ] (fn [_, _, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun setLeft gsize a b c = Arg.lmake "setLeft" [] gsize [J.Tm (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Unhide, [J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Nothing, [J.Tmh (b), J.Tm (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun setSquash a b = Arg.make "setSquash" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a), App (Lam (NONE, Elim (const_squash, [App (b), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setFormInv a b = Arg.make "setFormInv" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setSubElim a a' b = Arg.make "setSubElim" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (a'), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetForm a b = Arg.make "isetForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetEq a a' b b' = Arg.make "isetEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetFormUniv a b i = Arg.make "isetFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetEqUniv a a' b b' i = Arg.make "isetEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetWeakenOf a b m = Arg.make "isetWeakenOf" [a, b, m, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetWeakenEq a b m n = Arg.make "isetWeakenEq" [a, b, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetWeaken a b = Arg.make "isetWeaken" [a, b, ] [] (a) [(Arg.Nothing, [], Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, ] => m | _ => raise Arg.ExtractFailure)
fun isetIntroOf a b m = Arg.make "isetIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetIntroEq a b m n = Arg.make "isetIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetIntro a b m = Arg.make "isetIntro" [a, b, m, ] [m, ] (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Shift 0))), ] (fn [_, _, _, ] => m | _ => raise Arg.ExtractFailure)
fun isetIntroOfSquash a b m = Arg.make "isetIntroOfSquash" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetIntroEqSquash a b m n = Arg.make "isetIntroEqSquash" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (a), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_squash, [App (Sub (b, Dot (m, Shift 0))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetElim a b c m = Arg.make "isetElim" [a, b, c, m, ] [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (m), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (m, Shift 0))), ], Sub (c, Shift 1)), ] (fn [_, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun isetLeft gsize a b c = Arg.lmake "isetLeft" [] gsize [J.Tm (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ] (c) [(Arg.Nothing, [J.Tmh (b), J.Tm (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [m, ] => Sub (m, under gsize (Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun isetFormInv1 a b = Arg.make "isetFormInv1" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetFormInv2 a b m = Arg.make "isetFormInv2" [a, b, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetSubElim a a' b = Arg.make "isetSubElim" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (a'), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashForm a = Arg.make "squashForm" [a, ] [] (Elim (const_istp, [App (Elim (const_squash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashEq a b = Arg.make "squashEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_iff, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashFormUniv a i = Arg.make "squashFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_squash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashEqUniv a b i = Arg.make "squashEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), (Arg.Unhide, [], Elim (const_iff, [App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntroOf a = Arg.make "squashIntroOf" [a, ] [] (Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashIntro a = Arg.make "squashIntro" [a, ] [] (Elim (const_squash, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashElim a c m = Arg.make "squashElim" [a, c, m, ] [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (c, Shift 1)), ] (fn [_, _, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun squashExt a m n = Arg.make "squashExt" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_squash, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_squash, [App (a), ])), App (n), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun squashLeft gsize a c = Arg.lmake "squashLeft" [] gsize [J.Tm (Elim (const_squash, [App (a), ])), ] (c) [(Arg.Unhide, [], NONE, Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tmh (a), ], SOME (Dot (Triv, Shift 1)), Sub (c, under gsize (Dot (Triv, Shift 1)))), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun squashSub a b = Arg.make "squashSub" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_squash, [App (a), ])), App (Elim (const_squash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_arrow, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashForm a = Arg.make "isquashForm" [a, ] [] (Elim (const_istp, [App (Elim (const_isquash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashEq a b = Arg.make "isquashEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_isquash, [App (a), ])), App (Elim (const_isquash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashFormUniv a i = Arg.make "isquashFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_isquash, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashEqUniv a b i = Arg.make "isquashEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_isquash, [App (a), ])), App (Elim (const_isquash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashIntroOf a = Arg.make "isquashIntroOf" [a, ] [] (Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashIntro a = Arg.make "isquashIntro" [a, ] [] (Elim (const_isquash, [App (a), ])) [(Arg.Unhide, [], a), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashIntroOfIsquash a = Arg.make "isquashIntroOfIsquash" [a, ] [] (Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (Triv), ])) [(Arg.Unhide, [], Elim (const_isquash, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashElim a c m = Arg.make "isquashElim" [a, c, m, ] [] (c) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (m), ])), (Arg.Nothing, [J.Tmh (a), ], Sub (c, Shift 1)), ] (fn [_, n, ] => Sub (n, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun isquashExt a m n = Arg.make "isquashExt" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_isquash, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_isquash, [App (a), ])), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashLeft gsize a c = Arg.lmake "isquashLeft" [] gsize [J.Tm (Elim (const_isquash, [App (a), ])), ] (c) [(Arg.Nothing, [J.Tmh (a), ], SOME (Dot (Triv, Shift 1)), Sub (c, under gsize (Dot (Triv, Shift 1)))), ] (fn [m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun isquashSub a b = Arg.make "isquashSub" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_isquash, [App (a), ])), App (Elim (const_isquash, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_arrow, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isquashFormInv a = Arg.make "isquashFormInv" [a, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_isquash, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientForm a b = Arg.make "quotientForm" [a, b, ] [] (Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientEq a a' b b' = Arg.make "quotientEq" [a, a', b, b', ] [] (Elim (const_eqtp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (Elim (const_quotient, [App (a'), App (Lam (NONE, Lam (NONE, b'))), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientFormUniv a b i = Arg.make "quotientFormUniv" [a, b, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientEqUniv a a' b b' i = Arg.make "quotientEqUniv" [a, a', b, b', i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (Elim (const_quotient, [App (a'), App (Lam (NONE, Lam (NONE, b'))), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (a'), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 2)), ])), App (b'), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Unhide, [J.Tm (b'), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Idot (1, Shift 3)))), (Arg.Unhide, [J.Tm (Sub (b, Idot (1, Idot (2, Shift 4)))), J.Tm (Sub (b, Shift 1)), J.Tm (Sub (a, Shift 2)), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Sub (b, Idot (2, Shift 4))), ] (fn [_, _, _, _, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientIntroOf a b m = Arg.make "quotientIntroOf" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Sub (b, Dot (m, Dot (m, Shift 0)))), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientIntroEq a b m n = Arg.make "quotientIntroEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), (Arg.Unhide, [], Sub (b, Dot (n, Dot (m, Shift 0)))), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimOf a b c m p = Arg.make "quotientElimOf" [a, b, c, m, p, ] [] (Elim (const_of, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Shift 2)), App (Sub (p, Idot (1, Shift 3))), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimEq a b c m n p q = Arg.make "quotientElimEq" [a, b, c, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (c, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], Elim (const_istp, [App (c), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eq, [App (Sub (c, Shift 2)), App (Sub (p, Shift 2)), App (Sub (q, Idot (1, Shift 3))), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimIstype a b c m = Arg.make "quotientElimIstype" [a, b, c, m, ] [] (Elim (const_istp, [App (Sub (c, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Shift 2)), App (Sub (c, Idot (1, Shift 3))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientElimEqtype a b c d m n = Arg.make "quotientElimEqtype" [a, b, c, d, m, n, ] [] (Elim (const_eqtp, [App (Sub (c, Dot (m, Shift 0))), App (Sub (d, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_eqtp, [App (Sub (c, Shift 2)), App (Sub (d, Idot (1, Shift 3))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientDescent a b c m n = Arg.make "quotientDescent" [a, b, c, m, n, ] [] (c) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_istp, [App (c), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), App (m), App (n), ])), (Arg.Nothing, [J.Tmh (Sub (b, Dot (n, Dot (m, Shift 0)))), ], Sub (c, Shift 1)), ] (fn [_, _, _, _, _, p, ] => Sub (p, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun quotientLeft gsize a b c = Arg.lmake "quotientLeft" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (c) [(Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], SOME (Shift 0), Elim (const_istp, [App (c), ])), (Arg.Nothing, [J.Tmh (a), ], SOME (Shift 0), c), ] (fn [_, m, ] => Sub (m, under gsize (Dot (Triv, Shift 1))) | _ => raise Arg.ExtractFailure)
fun quotientLeftRefl gsize a b c = Arg.lmake "quotientLeftRefl" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (c) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ], SOME (Shift 0), Elim (const_istp, [App (c), ])), (Arg.Nothing, [J.Tmh (Sub (b, Idot (0, Shift 0))), J.Tmh (a), ], SOME (Shift 1), Sub (c, under gsize (Shift 1))), ] (fn [_, _, m, ] => Sub (m, under gsize (Dot (Triv, Dot (Triv, Shift 1)))) | _ => raise Arg.ExtractFailure)
fun quotientLeftIstype gsize a b c = Arg.lmake "quotientLeftIstype" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_istp, [App (c), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEqtype gsize a b c d = Arg.lmake "quotientLeftEqtype" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eqtp, [App (c), App (d), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (d, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftOf gsize a b c m = Arg.lmake "quotientLeftOf" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_of, [App (Sub (c, under gsize (Shift 1))), App (m), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 3))), App (Sub (m, under gsize (Shift 2))), App (Sub (m, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEq gsize a b c m n = Arg.lmake "quotientLeftEq" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eq, [App (Sub (c, under gsize (Shift 1))), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 3))), App (Sub (m, under gsize (Shift 2))), App (Sub (n, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftOfDep gsize a b c m = Arg.lmake "quotientLeftOfDep" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_of, [App (c), App (m), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 2))), App (Sub (m, under gsize (Shift 2))), App (Sub (m, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientLeftEqDep gsize a b c m n = Arg.lmake "quotientLeftEqDep" [] gsize [J.Tm (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ] (Elim (const_eq, [App (c), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], NONE, Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eqtp, [App (Sub (c, under gsize (Shift 2))), App (Sub (c, under gsize (Idot (1, Shift 3)))), ])), (Arg.Unhide, [J.Tm (b), J.Tm (Sub (a, Shift 1)), J.Tm (a), ], SOME (Shift 2), Elim (const_eq, [App (Sub (c, under gsize (Shift 2))), App (Sub (m, under gsize (Shift 2))), App (Sub (n, under gsize (Idot (1, Shift 3)))), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientFormInv a b = Arg.make "quotientFormInv" [a, b, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallForm a i k = Arg.make "iforallForm" [a, i, k, ] [] (Elim (const_istp, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallEq a b i k l = Arg.make "iforallEq" [a, b, i, k, l, ] [] (Elim (const_eqtp, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iforall, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallFormUniv a i j k = Arg.make "iforallFormUniv" [a, i, j, k, ] [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallEqUniv a b i j k l = Arg.make "iforallEqUniv" [a, b, i, j, k, l, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iforall, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntroOf a i k m = Arg.make "iforallIntroOf" [a, i, k, m, ] [] (Elim (const_of, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (a), App (Sub (m, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntroEq a i k m n = Arg.make "iforallIntroEq" [a, i, k, m, n, ] [] (Elim (const_eq, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (a), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallIntro a i k = Arg.make "iforallIntro" [a, i, k, ] [] (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Nothing, [J.Tmh (k), ], a), ] (fn [_, m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun iforallElimOf a i k m p = Arg.make "iforallElimOf" [a, i, k, m, p, ] [] (Elim (const_of, [App (Sub (a, Dot (p, Shift 0))), App (m), ])) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallElimEq a i k m n p = Arg.make "iforallElimEq" [a, i, k, m, n, p, ] [] (Elim (const_eq, [App (Sub (a, Dot (p, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iforallElim a i k p = Arg.make "iforallElim" [a, i, k, p, ] [] (Sub (a, Dot (p, Shift 0))) [(Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iforall, [App (i), App (k), App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (p), ])), ] (fn [_, m, _, ] => m | _ => raise Arg.ExtractFailure)
fun foralltpForm a = Arg.make "foralltpForm" [a, ] [] (Elim (const_istp, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpEq a b = Arg.make "foralltpEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (Elim (const_foralltp, [App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntroOf a m = Arg.make "foralltpIntroOf" [a, m, ] [] (Elim (const_of, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_of, [App (a), App (Sub (m, Shift 1)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntroEq a m n = Arg.make "foralltpIntroEq" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_eq, [App (a), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpIntro a = Arg.make "foralltpIntro" [a, ] [] (Elim (const_foralltp, [App (Lam (NONE, a)), ])) [(Arg.Nothing, [J.Tph, ], a), ] (fn [m, ] => Sub (m, Dot (Triv, Shift 0)) | _ => raise Arg.ExtractFailure)
fun foralltpElimOf a b m = Arg.make "foralltpElimOf" [a, b, m, ] [] (Elim (const_of, [App (Sub (a, Dot (b, Shift 0))), App (m), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpElimEq a b m n = Arg.make "foralltpElimEq" [a, b, m, n, ] [] (Elim (const_eq, [App (Sub (a, Dot (b, Shift 0))), App (m), App (n), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_foralltp, [App (Lam (NONE, a)), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun foralltpElim a b = Arg.make "foralltpElim" [a, b, ] [] (Sub (a, Dot (b, Shift 0))) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_foralltp, [App (Lam (NONE, a)), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, m, _, ] => m | _ => raise Arg.ExtractFailure)
fun iexistsForm a i k = Arg.make "iexistsForm" [a, i, k, ] [] (Elim (const_istp, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsEq a b i k l = Arg.make "iexistsEq" [a, b, i, k, l, ] [] (Elim (const_eqtp, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iexists, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsFormUniv a i j k = Arg.make "iexistsFormUniv" [a, i, j, k, ] [] (Elim (const_of, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsEqUniv a b i j k l = Arg.make "iexistsEqUniv" [a, b, i, j, k, l, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (j), ])), App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (Elim (const_iexists, [App (i), App (l), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_kind, [App (i), ])), App (k), App (l), ])), (Arg.Unhide, [], Elim (const_lleq, [App (i), App (j), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_eq, [App (Elim (const_univ, [App (Sub (j, Shift 1)), ])), App (a), App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntroOf a b i k m = Arg.make "iexistsIntroOf" [a, b, i, k, m, ] [] (Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Unhide, [], Elim (const_of, [App (Sub (a, Dot (b, Shift 0))), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntroEq a b i k m n = Arg.make "iexistsIntroEq" [a, b, i, k, m, n, ] [] (Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Unhide, [], Elim (const_eq, [App (Sub (a, Dot (b, Shift 0))), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsIntro a b i k = Arg.make "iexistsIntro" [a, b, i, k, ] [] (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_kind, [App (i), ])), App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (k), App (b), ])), (Arg.Nothing, [], Sub (a, Dot (b, Shift 0))), ] (fn [_, _, _, m, ] => m | _ => raise Arg.ExtractFailure)
fun iexistsElimOf a b i k m p = Arg.make "iexistsElimOf" [a, b, i, k, m, p, ] [] (Elim (const_of, [App (b), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_of, [App (Sub (b, Shift 2)), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEq a b i k m n p q = Arg.make "iexistsElimEq" [a, b, i, k, m, n, p, q, ] [] (Elim (const_eq, [App (b), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eq, [App (Sub (b, Shift 2)), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElim a b i k m = Arg.make "iexistsElim" [a, b, i, k, m, ] [m, ] (b) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), J.Tmh (k), ], Sub (b, Shift 2)), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun iexistsElimOfDep a b i k m p = Arg.make "iexistsElimOfDep" [a, b, i, k, m, p, ] [] (Elim (const_of, [App (Sub (b, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_of, [App (Sub (b, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEqDep a b i k m n p q = Arg.make "iexistsElimEqDep" [a, b, i, k, m, n, p, q, ] [] (Elim (const_eq, [App (Sub (b, Dot (m, Shift 0))), App (Sub (p, Dot (m, Shift 0))), App (Sub (q, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eq, [App (Sub (b, Idot (0, Shift 2))), App (Sub (p, Idot (0, Shift 2))), App (Sub (q, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimDep a b i k m = Arg.make "iexistsElimDep" [a, b, i, k, m, ] [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), J.Tmh (k), ], Sub (b, Idot (0, Shift 2))), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, p, _, ] => Sub (p, Dot (m, Dot (Triv, Shift 0))) | _ => raise Arg.ExtractFailure)
fun iexistsElimIstype a b i k m = Arg.make "iexistsElimIstype" [a, b, i, k, m, ] [] (Elim (const_istp, [App (Sub (b, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_istp, [App (Sub (b, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun iexistsElimEqtype a b c i k m n = Arg.make "iexistsElimEqtype" [a, b, c, i, k, m, n, ] [] (Elim (const_eqtp, [App (Sub (b, Dot (m, Shift 0))), App (Sub (c, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_istp, [App (k), ])), (Arg.Unhide, [J.Tm (k), ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), J.Tm (k), ], Elim (const_eqtp, [App (Sub (b, Idot (0, Shift 2))), App (Sub (c, Idot (0, Shift 2))), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_iexists, [App (i), App (k), App (Lam (NONE, a)), ])), App (m), App (n), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun substitution gsize a b m = Arg.lmake "substitution" [] gsize [J.Tm (a), ] (b) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_istp, [App (b), ])), (Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), Sub (b, under gsize (Dot (m, Shift 0)))), ] (fn [_, _, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun substitutionSimple gsize a b m = Arg.lmake "substitutionSimple" [] gsize [J.Tm (a), ] (Sub (b, under gsize (Shift 1))) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), b), ] (fn [_, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun substitutionLater gsize a b m = Arg.lmake "substitutionLater" [] gsize [J.Tml (a), ] (b) [(Arg.Unhide, [J.Tml (a), ], SOME (Shift 0), Elim (const_istp, [App (b), ])), (Arg.PromoteUnhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), Sub (b, under gsize (Dot (m, Shift 0)))), ] (fn [_, _, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun substitutionLaterSimple gsize a b m = Arg.lmake "substitutionLaterSimple" [] gsize [J.Tml (a), ] (Sub (b, under gsize (Shift 1))) [(Arg.PromoteUnhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_eq, [App (Sub (a, Shift (gsize + 1))), App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), b), ] (fn [_, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun generalize a b m = Arg.make "generalize" [a, b, m, ] [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Nothing, [J.Tm (a), ], b), ] (fn [_, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun assert a b = Arg.make "assert" [a, b, ] [] (b) [(Arg.Nothing, [], a), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Elim (const_let, [App (m), App (Lam (NONE, n)), ]) | _ => raise Arg.ExtractFailure)
fun assert' a b = Arg.make "assert'" [a, b, ] [] (b) [(Arg.Nothing, [], a), (Arg.Nothing, [J.Tm (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun assertLater a b = Arg.make "assertLater" [a, b, ] [] (b) [(Arg.Promote, [], a), (Arg.Nothing, [J.Tml (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Elim (const_let, [App (m), App (Lam (NONE, n)), ]) | _ => raise Arg.ExtractFailure)
fun assertLater' a b = Arg.make "assertLater'" [a, b, ] [] (b) [(Arg.Promote, [], a), (Arg.Nothing, [J.Tml (a), ], Sub (b, Shift 1)), ] (fn [m, n, ] => Sub (n, Dot (m, Shift 0)) | _ => raise Arg.ExtractFailure)
fun inhabitant a m = Arg.make "inhabitant" [a, m, ] [m, ] (a) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => m | _ => raise Arg.ExtractFailure)
fun letForm a b m n = Arg.make "letForm" [a, b, m, n, ] [] (Elim (const_of, [App (b), App (Elim (const_let, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun lethForm a b m n = Arg.make "lethForm" [a, b, m, n, ] [] (Elim (const_of, [App (b), App (Elim (const_leth, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun leteForm a b m n = Arg.make "leteForm" [a, b, m, n, ] [] (Elim (const_of, [App (b), App (Elim (const_lete, [App (m), App (Lam (NONE, n)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Sub (b, Shift 1)), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun accInd a b i m n r = Arg.make "accInd" [a, b, i, m, n, r, ] [m, ] (Sub (b, Dot (m, Shift 0))) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (Elim (const_arrow, [App (a), App (Elim (const_univ, [App (i), ])), ])), ])), App (r), ])), (Arg.Nothing, [J.Tm (Elim (const_forall, [App (Sub (a, Shift 1)), App (Lam (NONE, Elim (const_arrow, [App (Elim (Sub (r, Shift 2), [App (Var 0), App (Var 1), ])), App (Sub (b, Idot (0, Shift 2))), ]))), ])), J.Tm (a), ], Sub (b, Shift 1)), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_acc, [App (a), App (r), App (m), ])), App (n), ])), ] (fn [_, _, p, _, _, ] => Elim (const_fix, [App (Lam (NONE, Lam (NONE, Sub (p, Dot (Lam (NONE, Lam (NONE, Elim (Var 3, [App (Var 1), ]))), Idot (0, Shift 2)))))), App (m), ]) | _ => raise Arg.ExtractFailure)
fun sequalForm m = Arg.make "sequalForm" [m, ] [] (Elim (const_istp, [App (Elim (const_sequal, [App (m), App (m), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sequalIntroOf m = Arg.make "sequalIntroOf" [m, ] [] (Elim (const_of, [App (Elim (const_sequal, [App (m), App (m), ])), App (Triv), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sequalIntro m = Arg.make "sequalIntro" [m, ] [] (Elim (const_sequal, [App (m), App (m), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun sequalTrivialize m n = Arg.make "sequalTrivialize" [m, n, ] [] (Elim (const_sequal, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalExt m n p q = Arg.make "sequalExt" [m, n, p, q, ] [] (Elim (const_eq, [App (Elim (const_sequal, [App (m), App (n), ])), App (p), App (q), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sequal, [App (m), App (n), ])), App (p), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_sequal, [App (m), App (n), ])), App (q), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalLeft gsize c m n = Arg.lmake "sequalLeft" [] gsize [J.Tm (Elim (const_sequal, [App (m), App (n), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [p, ] => Sub (p, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun sequalEq a m n = Arg.make "sequalEq" [a, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalEqtp a b = Arg.make "sequalEqtp" [a, b, ] [] (Elim (const_eqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequivalence a b = Arg.make "sequivalence" [a, b, ] [] (b) [(Arg.Unhide, [], Elim (const_sequal, [App (a), App (b), ])), (Arg.Nothing, [], a), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun sequivalenceLeft gsize a b c = Arg.lmake "sequivalenceLeft" [] gsize [J.Tm (a), ] (c) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_sequal, [App (Sub (a, Shift (gsize + 1))), App (Sub (b, Shift (gsize + 1))), ])), (Arg.Nothing, [J.Tm (b), ], SOME (Shift 0), c), ] (fn [_, m, ] => m | _ => raise Arg.ExtractFailure)
fun substitutionSyntactic gsize a b m = Arg.lmake "substitutionSyntactic" [] gsize [J.Tm (a), ] (b) [(Arg.Unhide, [J.Tm (a), ], SOME (Shift 0), Elim (const_sequal, [App (Var gsize ), App (Sub (m, Shift (gsize + 1))), ])), (Arg.Nothing, [], SOME (Dot (m, Shift 0)), Sub (b, under gsize (Dot (m, Shift 0)))), ] (fn [_, n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun sequalSymm m n = Arg.make "sequalSymm" [m, n, ] [] (Elim (const_sequal, [App (n), App (m), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalTrans m n p = Arg.make "sequalTrans" [m, n, p, ] [] (Elim (const_sequal, [App (m), App (p), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), (Arg.Unhide, [], Elim (const_sequal, [App (n), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalCompat m n p = Arg.make "sequalCompat" [m, n, p, ] [] (Elim (const_sequal, [App (Sub (p, Dot (m, Shift 0))), App (Sub (p, Dot (n, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalCompatLam m n = Arg.make "sequalCompatLam" [m, n, ] [] (Elim (const_sequal, [App (Lam (NONE, m)), App (Lam (NONE, n)), ])) [(Arg.Unhide, [J.Tm (const_nonsense), ], Elim (const_sequal, [App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEtaSequal a b m = Arg.make "forallEtaSequal" [a, b, m, ] [] (Elim (const_sequal, [App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowEtaSequal a b m = Arg.make "arrowEtaSequal" [a, b, m, ] [] (Elim (const_sequal, [App (m), App (Lam (NONE, Elim (Sub (m, Shift 1), [App (Var 0), ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsEtaSequal a b m = Arg.make "existsEtaSequal" [a, b, m, ] [] (Elim (const_sequal, [App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodEtaSequal a b m = Arg.make "prodEtaSequal" [a, b, m, ] [] (Elim (const_sequal, [App (m), App (Pair (Elim (m, [Pi1, ]), Elim (m, [Pi2, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureEtaSequal a m = Arg.make "futureEtaSequal" [a, m, ] [] (Elim (const_sequal, [App (m), App (Next (Elim (m, [Prev, ]))), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialForm a = Arg.make "partialForm" [a, ] [] (Elim (const_istp, [App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialEq a b = Arg.make "partialEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialFormUniv a i = Arg.make "partialFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialEqUniv a b i = Arg.make "partialEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialSub a b = Arg.make "partialSub" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialStrict a = Arg.make "partialStrict" [a, ] [] (Elim (const_subtype, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (Elim (const_partial, [App (a), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialStrictConverse a = Arg.make "partialStrictConverse" [a, ] [] (Elim (const_subtype, [App (Elim (const_partial, [App (Elim (const_partial, [App (a), ])), ])), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialIdem a = Arg.make "partialIdem" [a, ] [] (Elim (const_eeqtp, [App (Elim (const_partial, [App (Elim (const_partial, [App (a), ])), ])), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun haltsForm a m = Arg.make "haltsForm" [a, m, ] [] (Elim (const_istp, [App (Elim (const_halts, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsEq a m n = Arg.make "haltsEq" [a, m, n, ] [] (Elim (const_eqtp, [App (Elim (const_halts, [App (m), ])), App (Elim (const_halts, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsFormUniv a i m = Arg.make "haltsFormUniv" [a, i, m, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_halts, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsEqUniv a i m n = Arg.make "haltsEqUniv" [a, i, m, n, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_halts, [App (m), ])), App (Elim (const_halts, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialIntroBottomOf a = Arg.make "partialIntroBottomOf" [a, ] [] (Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (const_bottom), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val bottomDiverges = Arg.make "bottomDiverges" [] [] (const_void) [(Arg.Unhide, [], Elim (const_halts, [App (const_bottom), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialExt a m n = Arg.make "partialExt" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_iff, [App (Elim (const_halts, [App (m), ])), App (Elim (const_halts, [App (n), ])), ])), (Arg.Unhide, [J.Tm (Elim (const_halts, [App (m), ])), ], Elim (const_eq, [App (Sub (a, Shift 1)), App (Sub (m, Shift 1)), App (Sub (n, Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialElimEq a m n = Arg.make "partialElimEq" [a, m, n, ] [] (Elim (const_eq, [App (a), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialElimOf a m = Arg.make "partialElimOf" [a, m, ] [] (Elim (const_of, [App (a), App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsTrivialize m = Arg.make "haltsTrivialize" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsExt m n p = Arg.make "haltsExt" [m, n, p, ] [] (Elim (const_eq, [App (Elim (const_halts, [App (m), ])), App (n), App (p), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_halts, [App (m), ])), App (n), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_halts, [App (m), ])), App (p), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsLeft gsize c m = Arg.lmake "haltsLeft" [] gsize [J.Tm (Elim (const_halts, [App (m), ])), ] (c) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (c, under gsize (Dot (Triv, Shift 0)))), ] (fn [n, ] => Sub (n, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun fixpointInductionEq a m n = Arg.make "fixpointInductionEq" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (Elim (const_fix, [App (m), ])), App (Elim (const_fix, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_arrow, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (a), ])), ])), App (m), App (n), ])), (Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun fixpointInductionOf a m = Arg.make "fixpointInductionOf" [a, m, ] [] (Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (Elim (const_fix, [App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (Elim (const_partial, [App (a), ])), App (Elim (const_partial, [App (a), ])), ])), App (m), ])), (Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialFormInv a = Arg.make "partialFormInv" [a, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_partial, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun seqBind a b m m' n n' = Arg.make "seqBind" [a, b, m, m', n, n', ] [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Elim (const_seq, [App (m'), App (Lam (NONE, n')), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_partial, [App (a), ])), App (m), App (m'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eq, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (n), App (n'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeApp a b m n = Arg.make "activeApp" [a, b, m, n, ] [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [App (Sub (n, Shift 1)), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeAppSeq a b m n = Arg.make "activeAppSeq" [a, b, m, n, ] [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [App (n), ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (Var 0, [App (Sub (n, Shift 1)), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [App (Sub (n, Shift 1)), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun appHaltsInv m n = Arg.make "appHaltsInv" [m, n, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi1 a b m = Arg.make "activePi1" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi1, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi1Seq a b m = Arg.make "activePi1Seq" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi1, ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (Var 0, [Pi1, ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi1, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun pi1HaltsInv m = Arg.make "pi1HaltsInv" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [Pi1, ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi2 a b m = Arg.make "activePi2" [a, b, m, ] [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi2, ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi2, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activePi2Seq a b m = Arg.make "activePi2Seq" [a, b, m, ] [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (m, [Pi2, ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (Var 0, [Pi2, ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (Var 0, [Pi2, ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun pi2HaltsInv m = Arg.make "pi2HaltsInv" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [Pi2, ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prevHaltsInv m = Arg.make "prevHaltsInv" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (m, [Prev, ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeCase a b m p r = Arg.make "activeCase" [a, b, m, p, r, ] [] (Elim (const_of, [App (Elim (const_partial, [App (b), ])), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Sub (p, Idot (0, Shift 2)))), App (Lam (NONE, Sub (r, Idot (0, Shift 2)))), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun activeCaseSeq a b m p r = Arg.make "activeCaseSeq" [a, b, m, p, r, ] [] (Elim (const_eq, [App (Elim (const_partial, [App (b), ])), App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), App (Elim (const_seq, [App (m), App (Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Sub (p, Idot (0, Shift 2)))), App (Lam (NONE, Sub (r, Idot (0, Shift 2)))), ]))), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_partial, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_of, [App (Elim (const_partial, [App (Sub (b, Shift 1)), ])), App (Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Sub (p, Idot (0, Shift 2)))), App (Lam (NONE, Sub (r, Idot (0, Shift 2)))), ])), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun caseHaltsInv m p r = Arg.make "caseHaltsInv" [m, p, r, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (const_sum_case, [App (m), App (Lam (NONE, p)), App (Lam (NONE, r)), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun seqHaltsSequal m n = Arg.make "seqHaltsSequal" [m, n, ] [] (Elim (const_sequal, [App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Sub (n, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_halts, [App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun seqHaltsInv m n = Arg.make "seqHaltsInv" [m, n, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_halts, [App (Elim (const_seq, [App (m), App (n), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sequalUnderSeq m m' n = Arg.make "sequalUnderSeq" [m, m', n, ] [] (Elim (const_sequal, [App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Sub (n, Dot (m', Shift 0))), ])) [(Arg.Unhide, [], Elim (const_seq, [App (m), App (Lam (NONE, Elim (const_sequal, [App (Var 0), App (Sub (m', Shift 1)), ]))), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun totalStrict a = Arg.make "totalStrict" [a, ] [] (Elim (const_subtype, [App (a), App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_halts, [App (Var 0), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
val voidTotal' = Arg.make "voidTotal'" [] [] (Elim (const_total, [App (const_void), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val voidStrict = Arg.make "voidStrict" [] [] (Elim (const_subtype, [App (const_void), App (Elim (const_partial, [App (const_void), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun unitTotal m = Arg.make "unitTotal" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_unit), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val unitTotal' = Arg.make "unitTotal'" [] [] (Elim (const_total, [App (const_unit), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val unitStrict = Arg.make "unitStrict" [] [] (Elim (const_subtype, [App (const_unit), App (Elim (const_partial, [App (const_unit), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun boolTotal m = Arg.make "boolTotal" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_bool), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val boolTotal' = Arg.make "boolTotal'" [] [] (Elim (const_total, [App (const_bool), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val boolStrict = Arg.make "boolStrict" [] [] (Elim (const_subtype, [App (const_bool), App (Elim (const_partial, [App (const_bool), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun forallTotal a b m = Arg.make "forallTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallTotal' a b = Arg.make "forallTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun forallStrict a b = Arg.make "forallStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutTotal a b m = Arg.make "forallfutTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutTotal' a b = Arg.make "forallfutTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun forallfutStrict a b = Arg.make "forallfutStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowTotal a b m = Arg.make "arrowTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_arrow, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowTotal' a b = Arg.make "arrowTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun arrowStrict a b = Arg.make "arrowStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_arrow, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricTotal a b m = Arg.make "parametricTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricTotal' a b = Arg.make "parametricTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun parametricStrict a b = Arg.make "parametricStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_parametric, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutTotal a b m = Arg.make "parametricfutTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun parametricfutTotal' a b = Arg.make "parametricfutTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun parametricfutStrict a b = Arg.make "parametricfutStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_parametricfut, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectStrict a b = Arg.make "intersectStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], a), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (Elim (const_partial, [App (b), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutStrict a b = Arg.make "intersectfutStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.PromoteUnhide, [], a), (Arg.Unhide, [J.Tml (a), ], Elim (const_subtype, [App (b), App (Elim (const_partial, [App (b), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsTotal a b m = Arg.make "existsTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsTotal' a b = Arg.make "existsTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun existsStrict a b = Arg.make "existsStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodTotal a b m = Arg.make "prodTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_prod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodTotal' a b = Arg.make "prodTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun prodStrict a b = Arg.make "prodStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_prod, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodTotal a b m = Arg.make "dprodTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_dprod, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodTotal' a b = Arg.make "dprodTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun dprodStrict a b = Arg.make "dprodStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_dprod, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumTotal a b m = Arg.make "sumTotal" [a, b, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_sum, [App (a), App (b), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumTotal' a b = Arg.make "sumTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun sumStrict a b = Arg.make "sumStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_partial, [App (Elim (const_sum, [App (a), App (b), ])), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureTotal a m = Arg.make "futureTotal" [a, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureTotal' a = Arg.make "futureTotal'" [a, ] [] (Elim (const_total, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun futureStrict a = Arg.make "futureStrict" [a, ] [] (Elim (const_subtype, [App (Elim (const_future, [App (a), ])), App (Elim (const_partial, [App (Elim (const_future, [App (a), ])), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun setTotal' a b = Arg.make "setTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun setStrict a b = Arg.make "setStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (a), App (Elim (const_partial, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetTotal' a b = Arg.make "isetTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun isetStrict a b = Arg.make "isetStrict" [a, b, ] [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_partial, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_subtype, [App (a), App (Elim (const_partial, [App (a), ])), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun quotientTotal' a b = Arg.make "quotientTotal'" [a, b, ] [] (Elim (const_total, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_quotient, [App (a), App (Lam (NONE, Lam (NONE, b))), ])), ])), (Arg.Unhide, [J.Tm (Sub (a, Shift 1)), J.Tm (a), ], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, _, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun natTotal m = Arg.make "natTotal" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_nat), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val natTotal' = Arg.make "natTotal'" [] [] (Elim (const_total, [App (const_nat), ])) [] (fn [] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
val natStrict = Arg.make "natStrict" [] [] (Elim (const_subtype, [App (const_nat), App (Elim (const_partial, [App (const_nat), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun typeHalts a = Arg.make "typeHalts" [a, ] [] (Elim (const_halts, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun univTotal' i = Arg.make "univTotal'" [i, ] [] (Elim (const_total, [App (Elim (const_univ, [App (i), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Pair (Triv, Lam (NONE, Triv)) | _ => raise Arg.ExtractFailure)
fun univStrict i = Arg.make "univStrict" [i, ] [] (Elim (const_subtype, [App (Elim (const_univ, [App (i), ])), App (Elim (const_partial, [App (Elim (const_univ, [App (i), ])), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun reduceSeqTotal a m n = Arg.make "reduceSeqTotal" [a, m, n, ] [] (Elim (const_sequal, [App (Elim (const_seq, [App (m), App (Lam (NONE, n)), ])), App (Sub (n, Dot (m, Shift 0))), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun haltsTotal a m = Arg.make "haltsTotal" [a, m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_total, [App (a), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeForm a = Arg.make "uptypeForm" [a, ] [] (Elim (const_istp, [App (Elim (const_uptype, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeEq a b = Arg.make "uptypeEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_uptype, [App (a), ])), App (Elim (const_uptype, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeFormUniv a i = Arg.make "uptypeFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_uptype, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeEqUniv a b i = Arg.make "uptypeEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_uptype, [App (a), ])), App (Elim (const_uptype, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeTrivialize a = Arg.make "uptypeTrivialize" [a, ] [] (Elim (const_uptype, [App (a), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeExt a m n = Arg.make "uptypeExt" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_uptype, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_uptype, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_uptype, [App (a), ])), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeLeft gsize a b = Arg.lmake "uptypeLeft" [] gsize [J.Tm (Elim (const_uptype, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun uptypeEeqtp a b = Arg.make "uptypeEeqtp" [a, b, ] [] (Elim (const_uptype, [App (b), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeUnitary a = Arg.make "uptypeUnitary" [a, ] [] (Elim (const_uptype, [App (a), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (const_unit), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val voidUptype = Arg.make "voidUptype" [] [] (Elim (const_uptype, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitUptype = Arg.make "unitUptype" [] [] (Elim (const_uptype, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolUptype = Arg.make "boolUptype" [] [] (Elim (const_uptype, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun forallUptype a b = Arg.make "forallUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutUptype a b = Arg.make "forallfutUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowUptype a b = Arg.make "arrowUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectUptype a b = Arg.make "intersectUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutUptype a b = Arg.make "intersectfutUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsUptype a b = Arg.make "existsUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodUptype a b = Arg.make "prodUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodUptype a b = Arg.make "dprodUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_uptype, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumUptype a b = Arg.make "sumUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [], Elim (const_uptype, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureUptype a = Arg.make "futureUptype" [a, ] [] (Elim (const_uptype, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_uptype, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqUptype a m n = Arg.make "eqUptype" [a, m, n, ] [] (Elim (const_uptype, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofUptype a m = Arg.make "ofUptype" [a, m, ] [] (Elim (const_uptype, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpUptype a b = Arg.make "eqtpUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpUptype a = Arg.make "istpUptype" [a, ] [] (Elim (const_uptype, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeUptype a b = Arg.make "subtypeUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun setUptype a b = Arg.make "setUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun isetUptype a b = Arg.make "isetUptype" [a, b, ] [] (Elim (const_uptype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUptype a = Arg.make "muUptype" [a, ] [] (Elim (const_uptype, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tp, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (Elim (const_uptype, [App (Var 0), ])), J.Tp, ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun muUptypeUniv a i = Arg.make "muUptypeUniv" [a, i, ] [] (Elim (const_uptype, [App (Elim (const_mu, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [J.Tm (Elim (const_uptype, [App (Var 0), ])), J.Tm (Elim (const_univ, [App (i), ])), ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), (Arg.Unhide, [], Elim (const_positive, [App (Lam (NONE, a)), ])), ] (fn [_, _, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUptype a = Arg.make "recUptype" [a, ] [] (Elim (const_uptype, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_uptype, [App (Var 0), ])), J.Tpl, ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recUptypeUniv a i = Arg.make "recUptypeUniv" [a, i, ] [] (Elim (const_uptype, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_uptype, [App (Var 0), ])), J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_uptype, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val natUptype = Arg.make "natUptype" [] [] (Elim (const_uptype, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeFormInv a = Arg.make "uptypeFormInv" [a, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_uptype, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissForm a = Arg.make "admissForm" [a, ] [] (Elim (const_istp, [App (Elim (const_admiss, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissEq a b = Arg.make "admissEq" [a, b, ] [] (Elim (const_eqtp, [App (Elim (const_admiss, [App (a), ])), App (Elim (const_admiss, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissFormUniv a i = Arg.make "admissFormUniv" [a, i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (Elim (const_admiss, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissEqUniv a b i = Arg.make "admissEqUniv" [a, b, i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (Elim (const_admiss, [App (a), ])), App (Elim (const_admiss, [App (b), ])), ])) [(Arg.Unhide, [], Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (a), App (b), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissTrivialize a = Arg.make "admissTrivialize" [a, ] [] (Elim (const_admiss, [App (a), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissExt a m n = Arg.make "admissExt" [a, m, n, ] [] (Elim (const_eq, [App (Elim (const_admiss, [App (a), ])), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_of, [App (Elim (const_admiss, [App (a), ])), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_admiss, [App (a), ])), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun admissLeft gsize a b = Arg.lmake "admissLeft" [] gsize [J.Tm (Elim (const_admiss, [App (a), ])), ] (b) [(Arg.Nothing, [], SOME (Dot (Triv, Shift 0)), Sub (b, under gsize (Dot (Triv, Shift 0)))), ] (fn [m, ] => Sub (m, under gsize (Shift 1)) | _ => raise Arg.ExtractFailure)
fun admissEeqtp a b = Arg.make "admissEeqtp" [a, b, ] [] (Elim (const_admiss, [App (b), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun uptypeAdmiss a = Arg.make "uptypeAdmiss" [a, ] [] (Elim (const_admiss, [App (a), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun partialAdmiss a = Arg.make "partialAdmiss" [a, ] [] (Elim (const_admiss, [App (Elim (const_partial, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val voidAdmiss = Arg.make "voidAdmiss" [] [] (Elim (const_admiss, [App (const_void), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val unitAdmiss = Arg.make "unitAdmiss" [] [] (Elim (const_admiss, [App (const_unit), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val boolAdmiss = Arg.make "boolAdmiss" [] [] (Elim (const_admiss, [App (const_bool), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun forallAdmiss a b = Arg.make "forallAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallfutAdmiss a b = Arg.make "forallfutAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_forallfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun arrowAdmiss a b = Arg.make "arrowAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_arrow, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectAdmiss a b = Arg.make "intersectAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun intersectfutAdmiss a b = Arg.make "intersectfutAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_intersectfut, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun existsAdmissUptype a b = Arg.make "existsAdmissUptype" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun prodAdmiss a b = Arg.make "prodAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_prod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), (Arg.Unhide, [], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun dprodAdmissUptype a b = Arg.make "dprodAdmissUptype" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_dprod, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_uptype, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_admiss, [App (Sub (b, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun sumAdmiss a b = Arg.make "sumAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_sum, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_admiss, [App (a), ])), (Arg.Unhide, [], Elim (const_admiss, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun futureAdmiss a = Arg.make "futureAdmiss" [a, ] [] (Elim (const_admiss, [App (Elim (const_future, [App (a), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_admiss, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqAdmiss a m n = Arg.make "eqAdmiss" [a, m, n, ] [] (Elim (const_admiss, [App (Elim (const_eq, [App (a), App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun ofAdmiss a m = Arg.make "ofAdmiss" [a, m, ] [] (Elim (const_admiss, [App (Elim (const_of, [App (a), App (m), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun eqtpAdmiss a b = Arg.make "eqtpAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_eqtp, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun istpAdmiss a = Arg.make "istpAdmiss" [a, ] [] (Elim (const_admiss, [App (Elim (const_istp, [App (a), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun subtypeAdmiss a b = Arg.make "subtypeAdmiss" [a, b, ] [] (Elim (const_admiss, [App (Elim (const_subtype, [App (a), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recAdmiss a = Arg.make "recAdmiss" [a, ] [] (Elim (const_admiss, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [J.Tpl, ], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_admiss, [App (Var 0), ])), J.Tpl, ], Elim (const_admiss, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun recAdmissUniv a i = Arg.make "recAdmissUniv" [a, i, ] [] (Elim (const_admiss, [App (Elim (const_rec, [App (Lam (NONE, a)), ])), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), (Arg.Unhide, [J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_of, [App (Elim (const_univ, [App (Sub (i, Shift 1)), ])), App (a), ])), (Arg.Unhide, [J.Tml (Elim (const_admiss, [App (Var 0), ])), J.Tml (Elim (const_univ, [App (i), ])), ], Elim (const_admiss, [App (Sub (a, Shift 1)), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
val natAdmiss = Arg.make "natAdmiss" [] [] (Elim (const_admiss, [App (const_nat), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun admissFormInv a = Arg.make "admissFormInv" [a, ] [] (Elim (const_istp, [App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (Elim (const_admiss, [App (a), ])), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val partialType = Arg.make "partialType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_univ, [App (Var 0), ])), App (Elim (const_univ, [App (Var 0), ])), ]))), ])), App (const_partial), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val haltsType = Arg.make "haltsType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_partial, [App (Var 0), ])), App (Elim (const_univ, [App (const_lzero), ])), ]))), ]))), ])), App (const_halts), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val admissType = Arg.make "admissType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_univ, [App (Var 0), ])), App (Elim (const_univ, [App (Var 0), ])), ]))), ])), App (const_admiss), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val uptypeType = Arg.make "uptypeType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_univ, [App (Var 0), ])), App (Elim (const_univ, [App (Var 0), ])), ]))), ])), App (const_uptype), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val seqType = Arg.make "seqType" [] [] (Elim (const_of, [App (Elim (const_intersect, [App (const_level), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 0), ])), App (Lam (NONE, Elim (const_intersect, [App (Elim (const_univ, [App (Var 1), ])), App (Lam (NONE, Elim (const_arrow, [App (Elim (const_partial, [App (Var 1), ])), App (Elim (const_arrow, [App (Elim (const_arrow, [App (Var 1), App (Elim (const_partial, [App (Var 0), ])), ])), App (Elim (const_partial, [App (Var 0), ])), ])), ]))), ]))), ]))), ])), App (const_seq), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun eeqtpRefl a = Arg.make "eeqtpRefl" [a, ] [] (Elim (const_eeqtp, [App (a), App (a), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eeqtpSymm a b = Arg.make "eeqtpSymm" [a, b, ] [] (Elim (const_eeqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (a), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eeqtpTrans a b c = Arg.make "eeqtpTrans" [a, b, c, ] [] (Elim (const_eeqtp, [App (a), App (c), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (c), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun weakenEqtpEeqtp a b = Arg.make "weakenEqtpEeqtp" [a, b, ] [] (Elim (const_eeqtp, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (b), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun weakenSubtypeArrow a b = Arg.make "weakenSubtypeArrow" [a, b, ] [] (Elim (const_arrow, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (b), ])), ] (fn [_, ] => Lam (NONE, Var 0) | _ => raise Arg.ExtractFailure)
fun weakenEeqtpIff a b = Arg.make "weakenEeqtpIff" [a, b, ] [] (Elim (const_iff, [App (a), App (b), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (b), ])), ] (fn [_, ] => Pair (Lam (NONE, Var 0), Lam (NONE, Var 0)) | _ => raise Arg.ExtractFailure)
fun compatGuardEqtp1 a b b' = Arg.make "compatGuardEqtp1" [a, b, b', ] [] (Elim (const_eqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatSetEqtp0 a a' b = Arg.make "compatSetEqtp0" [a, a', b, ] [] (Elim (const_eqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun forallEeq a a' b b' = Arg.make "forallEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun existsEeq a a' b b' = Arg.make "existsEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun arrowEeq a a' b b' = Arg.make "arrowEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun prodEeq a a' b b' = Arg.make "prodEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun dprodEeq a a' b b' = Arg.make "dprodEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (Sub (b, Shift 1)), App (Sub (b', Shift 1)), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun sumEeq a a' b b' = Arg.make "sumEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun futureEeq a a' = Arg.make "futureEeq" [a, a', ] [] (Elim (const_eeqtp, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (a'), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), ] (fn [_, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun letnextEeq a b b' m = Arg.make "letnextEeq" [a, b, b', m, ] [] (Elim (const_eeqtp, [App (Elim (const_letnext, [App (m), App (Lam (NONE, b)), ])), App (Elim (const_letnext, [App (m), App (Lam (NONE, b')), ])), ])) [(Arg.PromoteUnhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_of, [App (Elim (const_future, [App (a), ])), App (m), ])), (Arg.Unhide, [J.Tml (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun intersectEeq a a' b b' = Arg.make "intersectEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun unionEeq a a' b b' = Arg.make "unionEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eqEeq a a' m n = Arg.make "eqEeq" [a, a', m, n, ] [] (Elim (const_eeqtp, [App (Elim (const_eq, [App (a), App (m), App (n), ])), App (Elim (const_eq, [App (a'), App (m), App (n), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (m), ])), (Arg.Unhide, [], Elim (const_of, [App (a), App (n), ])), ] (fn [_, _, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun eeqEeq a a' b b' = Arg.make "eeqEeq" [a, a', b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_eeqtp, [App (a), App (b), ])), App (Elim (const_eeqtp, [App (a'), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatGuardEeq1 a b b' = Arg.make "compatGuardEeq1" [a, b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_eeqtp, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatSetEeq0 a a' b = Arg.make "compatSetEeq0" [a, a', b, ] [] (Elim (const_eeqtp, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatIsetEeq0 a a' b = Arg.make "compatIsetEeq0" [a, a', b, ] [] (Elim (const_eeqtp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_eeqtp, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatIsetIff1 a b b' = Arg.make "compatIsetIff1" [a, b, b', ] [] (Elim (const_eeqtp, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, _, ] => Pair (Triv, Triv) | _ => raise Arg.ExtractFailure)
fun compatForallSubtype0 a a' b = Arg.make "compatForallSubtype0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatForallSubtype1 a b b' = Arg.make "compatForallSubtype1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatExistsSubtype0 a a' b = Arg.make "compatExistsSubtype0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatExistsSubtype1 a b b' = Arg.make "compatExistsSubtype1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIntersectSubtype0 a a' b = Arg.make "compatIntersectSubtype0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a'), App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIntersectSubtype1 a b b' = Arg.make "compatIntersectSubtype1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_intersect, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_intersect, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatUnionSubtype0 a a' b = Arg.make "compatUnionSubtype0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatUnionSubtype1 a b b' = Arg.make "compatUnionSubtype1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_union, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_union, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatGuardArrow0 a a' b = Arg.make "compatGuardArrow0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Unhide, [], Elim (const_arrow, [App (a'), App (a), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatGuardSubtype1 a b b' = Arg.make "compatGuardSubtype1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_guard, [App (a), App (b), ])), App (Elim (const_guard, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_subtype, [App (b), App (b'), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatSetSubtype0 a a' b = Arg.make "compatSetSubtype0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatSetArrow1 a b b' = Arg.make "compatSetArrow1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_set, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_set, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIsetSubtype0 a a' b = Arg.make "compatIsetSubtype0" [a, a', b, ] [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a'), App (Lam (NONE, b)), ])), ])) [(Arg.Unhide, [], Elim (const_subtype, [App (a), App (a'), ])), (Arg.Unhide, [J.Tm (a'), ], Elim (const_istp, [App (b), ])), ] (fn [_, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatIsetArrow1 a b b' = Arg.make "compatIsetArrow1" [a, b, b', ] [] (Elim (const_subtype, [App (Elim (const_iset, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_iset, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, _, ] => Triv | _ => raise Arg.ExtractFailure)
fun compatForallIff1 a b b' = Arg.make "compatForallIff1" [a, b, b', ] [] (Elim (const_iff, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Lam (NONE, Elim (Sub (m, Idot (0, Shift 2)), [Pi1, App (Elim (Var 1, [App (Var 0), ])), ]))), Lam (NONE, Lam (NONE, Elim (Sub (m, Idot (0, Shift 2)), [Pi2, App (Elim (Var 1, [App (Var 0), ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatExistsIff1 a b b' = Arg.make "compatExistsIff1" [a, b, b', ] [] (Elim (const_iff, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Dot (Elim (Var 0, [Pi1, ]), Shift 1)), [Pi1, App (Elim (Var 0, [Pi2, ])), ]))), Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Dot (Elim (Var 0, [Pi1, ]), Shift 1)), [Pi2, App (Elim (Var 0, [Pi2, ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatArrowIff0 a a' b = Arg.make "compatArrowIff0" [a, a', b, ] [] (Elim (const_iff, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Lam (NONE, Elim (Var 1, [App (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])), ]))), Lam (NONE, Lam (NONE, Elim (Var 1, [App (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatArrowIff1 a b b' = Arg.make "compatArrowIff1" [a, b, b', ] [] (Elim (const_iff, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Lam (NONE, Elim (Sub (m, Shift 2), [Pi1, App (Elim (Var 1, [App (Var 0), ])), ]))), Lam (NONE, Lam (NONE, Elim (Sub (m, Shift 2), [Pi2, App (Elim (Var 1, [App (Var 0), ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatProdIff0 a a' b = Arg.make "compatProdIff0" [a, a', b, ] [] (Elim (const_iff, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))), Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ])))) | _ => raise Arg.ExtractFailure)
fun compatProdIff1 a b b' = Arg.make "compatProdIff1" [a, b, b', ] [] (Elim (const_iff, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi2, ])), ]))), Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi2, ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatDprodIff0 a a' b = Arg.make "compatDprodIff0" [a, a', b, ] [] (Elim (const_iff, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (Sub (b, Shift 1)), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))), Lam (NONE, Pair (Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ])))) | _ => raise Arg.ExtractFailure)
fun compatDprodIff1 a b b' = Arg.make "compatDprodIff1" [a, b, b', ] [] (Elim (const_iff, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi1, App (Elim (Var 0, [Pi2, ])), ]))), Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [Pi2, App (Elim (Var 0, [Pi2, ])), ])))) | _ => raise Arg.ExtractFailure)
fun compatSumIff0 a a' b = Arg.make "compatSumIff0" [a, a', b, ] [] (Elim (const_iff, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])), ]))), App (Lam (NONE, Elim (const_inr, [App (Var 0), ]))), ])), Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])), ]))), App (Lam (NONE, Elim (const_inr, [App (Var 0), ]))), ]))) | _ => raise Arg.ExtractFailure)
fun compatSumIff1 a b b' = Arg.make "compatSumIff1" [a, b, b', ] [] (Elim (const_iff, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_iff, [App (b), App (b'), ])), ] (fn [_, m, ] => Pair (Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Var 0), ]))), App (Lam (NONE, Elim (const_inr, [App (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])), ]))), ])), Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Var 0), ]))), App (Lam (NONE, Elim (const_inr, [App (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])), ]))), ]))) | _ => raise Arg.ExtractFailure)
fun compatFutureIff a a' = Arg.make "compatFutureIff" [a, a', ] [] (Elim (const_iff, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (a'), ])), ])) [(Arg.Promote, [], Elim (const_iff, [App (a), App (a'), ])), ] (fn [m, ] => Pair (Lam (NONE, Elim (const_letnext, [App (Var 0), App (Lam (NONE, Next (Elim (Sub (m, Shift 2), [Pi1, App (Var 0), ])))), ])), Lam (NONE, Elim (const_letnext, [App (Var 0), App (Lam (NONE, Next (Elim (Sub (m, Shift 2), [Pi2, App (Var 0), ])))), ]))) | _ => raise Arg.ExtractFailure)
fun compatForallArrow1 a b b' = Arg.make "compatForallArrow1" [a, b, b', ] [] (Elim (const_arrow, [App (Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Lam (NONE, Elim (Sub (m, Idot (0, Shift 2)), [App (Elim (Var 1, [App (Var 0), ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatExistsArrow1 a b b' = Arg.make "compatExistsArrow1" [a, b, b', ] [] (Elim (const_arrow, [App (Elim (const_exists, [App (a), App (Lam (NONE, b)), ])), App (Elim (const_exists, [App (a), App (Lam (NONE, b')), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [J.Tm (a), ], Elim (const_istp, [App (b'), ])), (Arg.Nothing, [J.Tm (a), ], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, m, ] => Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Dot (Elim (Var 0, [Pi1, ]), Shift 1)), [App (Elim (Var 0, [Pi2, ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatArrowArrow0 a a' b = Arg.make "compatArrowArrow0" [a, a', b, ] [] (Elim (const_arrow, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a'), App (a), ])), ] (fn [_, _, m, ] => Lam (NONE, Lam (NONE, Elim (Var 1, [App (Elim (Sub (m, Shift 2), [App (Var 0), ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatArrowArrow1 a b b' = Arg.make "compatArrowArrow1" [a, b, b', ] [] (Elim (const_arrow, [App (Elim (const_arrow, [App (a), App (b), ])), App (Elim (const_arrow, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Lam (NONE, Elim (Sub (m, Shift 2), [App (Elim (Var 1, [App (Var 0), ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatProdArrow0 a a' b = Arg.make "compatProdArrow0" [a, a', b, ] [] (Elim (const_arrow, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))) | _ => raise Arg.ExtractFailure)
fun compatProdArrow1 a b b' = Arg.make "compatProdArrow1" [a, b, b', ] [] (Elim (const_arrow, [App (Elim (const_prod, [App (a), App (b), ])), App (Elim (const_prod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi2, ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatDprodArrow0 a a' b = Arg.make "compatDprodArrow0" [a, a', b, ] [] (Elim (const_arrow, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi1, ])), ]), Elim (Var 0, [Pi2, ]))) | _ => raise Arg.ExtractFailure)
fun compatDprodArrow1 a b b' = Arg.make "compatDprodArrow1" [a, b, b', ] [] (Elim (const_arrow, [App (Elim (const_dprod, [App (a), App (b), ])), App (Elim (const_dprod, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, m, ] => Lam (NONE, Pair (Elim (Var 0, [Pi1, ]), Elim (Sub (m, Shift 1), [App (Elim (Var 0, [Pi2, ])), ]))) | _ => raise Arg.ExtractFailure)
fun compatSumArrow0 a a' b = Arg.make "compatSumArrow0" [a, a', b, ] [] (Elim (const_arrow, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a'), App (b), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a'), ])), (Arg.Unhide, [], Elim (const_istp, [App (b), ])), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [_, _, m, ] => Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Elim (Sub (m, Shift 2), [App (Var 0), ])), ]))), App (Lam (NONE, Elim (const_inr, [App (Var 0), ]))), ])) | _ => raise Arg.ExtractFailure)
fun compatSumArrow1 a b b' = Arg.make "compatSumArrow1" [a, b, b', ] [] (Elim (const_arrow, [App (Elim (const_sum, [App (a), App (b), ])), App (Elim (const_sum, [App (a), App (b'), ])), ])) [(Arg.Unhide, [], Elim (const_istp, [App (a), ])), (Arg.Unhide, [], Elim (const_istp, [App (b'), ])), (Arg.Nothing, [], Elim (const_arrow, [App (b), App (b'), ])), ] (fn [_, _, m, ] => Lam (NONE, Elim (const_sum_case, [App (Var 0), App (Lam (NONE, Elim (const_inl, [App (Var 0), ]))), App (Lam (NONE, Elim (const_inr, [App (Elim (Sub (m, Shift 2), [App (Var 0), ])), ]))), ])) | _ => raise Arg.ExtractFailure)
fun compatFutureArrow a a' = Arg.make "compatFutureArrow" [a, a', ] [] (Elim (const_arrow, [App (Elim (const_future, [App (a), ])), App (Elim (const_future, [App (a'), ])), ])) [(Arg.Promote, [], Elim (const_arrow, [App (a), App (a'), ])), ] (fn [m, ] => Lam (NONE, Elim (const_letnext, [App (Var 0), App (Lam (NONE, Next (Elim (Sub (m, Shift 2), [App (Var 0), ])))), ])) | _ => raise Arg.ExtractFailure)
fun compatForallEntails1 a b b' = Arg.make "compatForallEntails1" [a, b, b', ] [] (Elim (const_forall, [App (a), App (Lam (NONE, b')), ])) [(Arg.Nothing, [J.Tm (b), J.Tm (a), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_forall, [App (a), App (Lam (NONE, b)), ])), ] (fn [m, f, ] => Lam (NONE, Sub (m, Dot (Elim (Sub (f, Shift 1), [App (Var 0), ]), Shift 0))) | _ => raise Arg.ExtractFailure)
fun compatArrowEntails1 a b b' = Arg.make "compatArrowEntails1" [a, b, b', ] [] (Elim (const_arrow, [App (a), App (b'), ])) [(Arg.Nothing, [J.Tm (b), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_arrow, [App (a), App (b), ])), ] (fn [m, f, ] => Lam (NONE, Sub (m, Dot (Elim (Sub (f, Shift 1), [App (Var 0), ]), Shift 1))) | _ => raise Arg.ExtractFailure)
fun compatProdEntails0 a a' b = Arg.make "compatProdEntails0" [a, a', b, ] [] (Elim (const_prod, [App (a'), App (b), ])) [(Arg.Nothing, [J.Tm (a), ], Sub (a', Shift 1)), (Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Sub (m, Dot (Elim (p, [Pi1, ]), Shift 0)), Elim (p, [Pi2, ])) | _ => raise Arg.ExtractFailure)
fun compatProdEntails1 a b b' = Arg.make "compatProdEntails1" [a, b, b', ] [] (Elim (const_prod, [App (a), App (b'), ])) [(Arg.Nothing, [J.Tm (b), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_prod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Elim (p, [Pi1, ]), Sub (m, Dot (Elim (p, [Pi2, ]), Shift 0))) | _ => raise Arg.ExtractFailure)
fun compatDprodEntails0 a a' b = Arg.make "compatDprodEntails0" [a, a', b, ] [] (Elim (const_dprod, [App (a'), App (b), ])) [(Arg.Nothing, [J.Tm (a), ], Sub (a', Shift 1)), (Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Sub (m, Dot (Elim (p, [Pi1, ]), Shift 0)), Elim (p, [Pi2, ])) | _ => raise Arg.ExtractFailure)
fun compatDprodEntails1 a b b' = Arg.make "compatDprodEntails1" [a, b, b', ] [] (Elim (const_dprod, [App (a), App (b'), ])) [(Arg.Nothing, [J.Tm (b), ], Sub (b', Shift 1)), (Arg.Nothing, [], Elim (const_dprod, [App (a), App (b), ])), ] (fn [m, p, ] => Pair (Elim (p, [Pi1, ]), Sub (m, Dot (Elim (p, [Pi2, ]), Shift 0))) | _ => raise Arg.ExtractFailure)
val integerForm = Arg.make "integerForm" [] [] (Elim (const_istp, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerEq = Arg.make "integerEq" [] [] (Elim (const_eqtp, [App (const_integer), App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerFormUniv i = Arg.make "integerFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_integer), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun integerEqUniv i = Arg.make "integerEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_integer), App (const_integer), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val integerToDefType = Arg.make "integerToDefType" [] [] (Elim (const_of, [App (Elim (const_arrow, [App (const_integer), App (const_cInteger), ])), App (const_integer_to_Integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerFromDefType = Arg.make "integerFromDefType" [] [] (Elim (const_of, [App (Elim (const_arrow, [App (const_cInteger), App (const_integer), ])), App (const_integer_from_Integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerIsomorphism1 = Arg.make "integerIsomorphism1" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), App (Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_integer_to_Integer, [App (Var 0), ])), ]))), App (Lam (NONE, Var 0)), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerIsomorphism2 = Arg.make "integerIsomorphism2" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_cInteger), App (const_cInteger), ])), App (Lam (NONE, Elim (const_integer_to_Integer, [App (Elim (const_integer_from_Integer, [App (Var 0), ])), ]))), App (Lam (NONE, Var 0)), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val pluszSpec = Arg.make "pluszSpec" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), ])), App (const_plusz), App (Lam (NONE, Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_cPlusz, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val negzSpec = Arg.make "negzSpec" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), App (const_negz), App (Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_cNegz, [App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])), ]))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val eqzbSpec = Arg.make "eqzbSpec" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_bool), ])), ])), App (const_eqzb), App (Lam (NONE, Lam (NONE, Elim (const_cEqzb, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val leqzbSpec = Arg.make "leqzbSpec" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_bool), ])), ])), App (const_leqzb), App (Lam (NONE, Lam (NONE, Elim (const_cLeqzb, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val timeszSpec = Arg.make "timeszSpec" [] [] (Elim (const_eq, [App (Elim (const_arrow, [App (const_integer), App (Elim (const_arrow, [App (const_integer), App (const_integer), ])), ])), App (const_timesz), App (Lam (NONE, Lam (NONE, Elim (const_integer_from_Integer, [App (Elim (const_cTimesz, [App (Elim (const_integer_to_Integer, [App (Var 1), ])), App (Elim (const_integer_to_Integer, [App (Var 0), ])), ])), ])))), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerTotal m = Arg.make "integerTotal" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_integer), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val integerStrict = Arg.make "integerStrict" [] [] (Elim (const_subtype, [App (const_integer), App (Elim (const_partial, [App (const_integer), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerUptype = Arg.make "integerUptype" [] [] (Elim (const_uptype, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val integerAdmiss = Arg.make "integerAdmiss" [] [] (Elim (const_admiss, [App (const_integer), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun integerSequal m n = Arg.make "integerSequal" [m, n, ] [] (Elim (const_sequal, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_integer), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val symbolForm = Arg.make "symbolForm" [] [] (Elim (const_istp, [App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val symbolEq = Arg.make "symbolEq" [] [] (Elim (const_eqtp, [App (const_symbol), App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun symbolFormUniv i = Arg.make "symbolFormUniv" [i, ] [] (Elim (const_of, [App (Elim (const_univ, [App (i), ])), App (const_symbol), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun symbolEqUniv i = Arg.make "symbolEqUniv" [i, ] [] (Elim (const_eq, [App (Elim (const_univ, [App (i), ])), App (const_symbol), App (const_symbol), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_level), App (i), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val symbol_eqbType = Arg.make "symbol_eqbType" [] [] (Elim (const_of, [App (Elim (const_arrow, [App (const_symbol), App (Elim (const_arrow, [App (const_symbol), App (const_bool), ])), ])), App (const_symbol_eqb), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun symbol_eqbSpec1 m n = Arg.make "symbol_eqbSpec1" [m, n, ] [] (Elim (const_eq, [App (const_bool), App (Elim (const_symbol_eqb, [App (m), App (n), ])), App (const_true), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_symbol), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun symbol_eqbSpec2 m n = Arg.make "symbol_eqbSpec2" [m, n, ] [] (Elim (const_eq, [App (const_symbol), App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_bool), App (Elim (const_symbol_eqb, [App (m), App (n), ])), App (const_true), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
fun symbolTotal m = Arg.make "symbolTotal" [m, ] [] (Elim (const_halts, [App (m), ])) [(Arg.Unhide, [], Elim (const_of, [App (const_symbol), App (m), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)
val symbolStrict = Arg.make "symbolStrict" [] [] (Elim (const_subtype, [App (const_symbol), App (Elim (const_partial, [App (const_symbol), ])), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val symbolUptype = Arg.make "symbolUptype" [] [] (Elim (const_uptype, [App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
val symbolAdmiss = Arg.make "symbolAdmiss" [] [] (Elim (const_admiss, [App (const_symbol), ])) [] (fn [] => Triv | _ => raise Arg.ExtractFailure)
fun symbolSequal m n = Arg.make "symbolSequal" [m, n, ] [] (Elim (const_sequal, [App (m), App (n), ])) [(Arg.Unhide, [], Elim (const_eq, [App (const_symbol), App (m), App (n), ])), ] (fn [_, ] => Triv | _ => raise Arg.ExtractFailure)

end
