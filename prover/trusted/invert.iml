
signature INVERT =
   sig

      type term
      type sub

      datatype psub =
         Pshift  of int
       | Pidot   of int * psub
       | Pundef  of psub

      val psubstVar : int -> psub -> int option
      val punder : psub -> psub
      val subToPsub : sub -> psub
      val composePsub : psub -> psub -> psub
      val composeSubPsub : sub -> psub -> psub
      val composePsubSub : psub -> sub -> psub



      (* invert s

         if    s is a pattern substitution
         then  p o s <= id
               for all p', if p' o s <= id then p' <= p
               and
               return (SOME p)
         else  return NONE
      *)
      val invert : sub -> psub option

      val isPatternSub : sub -> bool  (* slightly cheaper if you don't need the inverse *)


      (* intersection p1 p2

         if    there exists a psub p such that p <= p1 and p <= p2
         then  returns SOME p where p is the maximum such
         else  returns NONE
      *)
      val intersection : psub -> psub -> psub option


      (* restriction p
       
         returns    (s, s')
         such that  s o p = s'
         and        s is injective
         and        s is maximal in the sense that it has the largest range of any such s
      *)
      val restriction : psub -> sub * sub

   end


functor InvertFun (structure Term : TERM
                   structure Normalize : NORMALIZE
                                         where type term = Term.term)
   :> INVERT
      where type term = Term.term
      where type sub = Term.sub
   =
   struct

      structure N = Normalize

      structure D = RedBlackDict (structure Key = IntOrdered)

      open Term


      datatype psub =
         Pshift  of int
       | Pidot   of int * psub
       | Pundef  of psub


      fun idot i s =
         (case s of
             Shift j =>
                if i+1 = j then
                   Shift i
                else
                   Idot (i, s)

           | _ =>
                Idot (i, s))


      fun pidot i p =
         (case p of
             Pshift j =>
                 if i+1 = j then
                    Pshift i
                 else
                    Pidot (i, p)

           | _ =>
                Pidot (i, p))


      fun pidotMaybe jo p =
         (case jo of
             NONE =>
                Pundef p

           | SOME j =>
                pidot j p)


      fun psubstVar i p =
         (case (i, p) of
             (0, Pidot (j, _)) => SOME j

           | (i, Pidot (_, p')) =>
                 psubstVar (i-1) p'

           | (0, Pundef _) => NONE

           | (i, Pundef p') =>
                psubstVar (i-1) p'

           | (i, Pshift j) =>
                SOME (i + j))


      fun undefs i p =
         if i = 0 then
            p
         else
            undefs (i-1) (Pundef p)


      fun shiftPsub p i =
         (case p of
             Pshift j =>
                Pshift (j + i)

           | Pidot (j, p') =>
                Pidot (j + i, shiftPsub p' i)

           | Pundef p' =>
                Pundef (shiftPsub p' i))


      fun punder p =
         (case p of
             Pshift 0 => p

           | _ => Pidot (0, shiftPsub p 1))



      (* truncatePsub i p

         returns ^i o p
      *)
      fun truncatePsub i p =
         if i = 0 then
            p
         else
            (case p of
                Pidot (_, p') => truncatePsub (i-1) p'

              | Pundef p' => truncatePsub (i-1) p'

              | Pshift j => Pshift (i + j))


      (* composeSubPsub s p

         returns    p'
         where      p' is the greatest (ie, most-defined) psub s.t. p' <= s o p

         Note that any dots in s (other than a variable) will become undefs, since
         a psub cannot have the form (m . p).

         This behavior is desired, because the because the alternative --
         letting (m . s) o p = (m[p] . s o p)) -- creates a branch point:
         Pruning m must restrict some evars, which might be a mistake if
         the variable in question is never actually used.  We don't want to
         backtrack.
      *)
      fun composeSubPsub s p =
         (case s of
             Dot (m, s') =>
                (case N.whnf m of
                    Elim (Var i, []) =>
                       pidotMaybe (psubstVar i p) (composeSubPsub s' p)

                  | _ =>
                       Pundef (composeSubPsub s' p))

           | Idot (i, s') =>
                pidotMaybe (psubstVar i p) (composeSubPsub s' p)

           | Shift i =>
                truncatePsub i p)


      fun composePsub p1 p2 =
         (case p1 of
             Pshift i =>
                truncatePsub i p2

           | Pidot (i, p1') =>
                pidotMaybe (psubstVar i p2) (composePsub p1' p2)

           | Pundef p1' =>
                Pundef (composePsub p1' p2))


      fun subToPsub s =
         (case s of
             Shift i => Pshift i

           | Dot (m, s') =>
                (case N.whnf m of
                    Elim (Var i, []) =>
                       pidot i (subToPsub s')

                  | _ =>
                       Pundef (subToPsub s'))

           | Idot (i, s') =>
                pidot i (subToPsub s'))


      fun composePsubSub p s =
         (case p of
             Pshift i =>
                subToPsub (compose (Shift i) s)

           | Pidot (i, p') =>
                (case substVar i s of
                    Idx j =>
                       pidot j (composePsubSub p' s)

                  | Term m =>
                       (case N.whnf m of
                           Elim (Var j, []) =>
                              pidot j (composePsubSub p' s)

                         | _ =>
                              Pundef (composePsubSub p' s)))

           | Pundef p' =>
                Pundef (composePsubSub p' s))



      exception Invert

      fun invertLoop d i s =
         (case s of
             Shift n => 
                (d, i, n)

           | Idot (j, s') =>
                let
                   val d' =
                      D.insertMerge d j i (fn _ => raise Invert)
                in
                   invertLoop d' (i+1) s'
                end

           | Dot (m, s') =>
                (case N.whnf m of
                    Elim (Var j, []) =>
                       let
                          val d' =
                             D.insertMerge d j i (fn _ => raise Invert)
                       in
                          invertLoop d' (i+1) s'
                       end

                  | _ =>
                       raise Invert))

      fun invert s =
         try
            let
               val (d, a, b) = invertLoop D.empty 0 s
   
               val () =
                  if
                     D.isEmpty d 
                     orelse 
                     fst (D.greatest d) < b
                  then
                     ()
                  else
                     raise Invert
   
               (* 1. domain(d) is all less than b
                  2. if d(j) = i then i[s] = j
                  3. ^a o s = ^b
               *)
   
               val (k, p) =
                  D.foldr
                  (fn (j, i, (k, p)) =>
                      (* ^k o desired-answer = p and j < k *)
                      (j,
                       pidot i (undefs (k-j-1) p)))
                  (b, Pshift a)
                  d
            in
               SOME (undefs k p)
            end
         with Invert => NONE



      fun isPatternSub s =
         try
            let
               val (d, _, b) = invertLoop D.empty 0 s
            in
               D.isEmpty d
               orelse
               fst (D.greatest d) < b
            end
         with Invert => false



      exception Intersection

      fun intersectionLoop p1 p2 =
         (case (p1, p2) of
             (Pidot (i, p1'), Pidot (j, p2')) =>
                let
                   val p = intersectionLoop p1' p2'
                in
                   if i = j then
                      pidot i p
                   else
                      Pundef p
                end

           | (Pundef p1', Pundef p2') =>
                let
                   val p = intersectionLoop p1' p2'
                in
                   Pundef p
                end

           | (Pundef p1', Pidot (_, p2')) =>
                let
                   val p = intersectionLoop p1' p2'
                in
                   Pundef p
                end

           | (Pidot (_, p1'), Pundef p2') =>
                let
                   val p = intersectionLoop p1' p2'
                in
                   Pundef p
                end

           | (Pidot (i, p1'), Pshift j) =>
                let
                   val p = intersectionLoop p1' (Pshift (j+1))
                in
                   if i = j then
                      pidot i p
                   else
                      Pundef p
                end

           | (Pshift j, Pidot (i, p2')) =>
                let
                   val p = intersectionLoop (Pshift (j+1)) p2'
                in
                   if i = j then
                      pidot i p
                   else
                      Pundef p
                end

           | (Pundef p1', Pshift j) =>
                let
                   val p = intersectionLoop p1' (Pshift (j+1))
                in
                   Pundef p
                end

           | (Pshift j, Pundef p2') =>
                let
                   val p = intersectionLoop (Pshift (j+1)) p2'
                in
                   Pundef p
                end

           | (Pshift i, Pshift j) =>
                if i = j then
                   p1
                else
                   raise Intersection)

      fun intersection p1 p2 =
         try
            SOME (intersectionLoop p1 p2)
         with
            Intersection => NONE



      (* restrictionLoop i p

         returns    (s, s')
         such that  s o (undef_1 ... undef_i . p) = s'
                    s and s' are everywhere defined
         and s is injective
         and s is maximal in the sense that it has the largest range of any such s
      *)
      fun restrictionLoop i p =
         (case p of
             Pidot (j, p') =>
                let
                   val (s, s') = restrictionLoop (i+1) p'
                   (* s o (undef_1 ... undef_i undef . p') = s'
                      so
                      (i . s) o (undef_1 ... undef_i . p)
                      = (i . s) o (undef_1 ... undef_i . j . p')
                      =  j . s o (undef_1 ... undef_i . j . p')
                      >= j . s o (undef_1 ... undef_i undef . p')
                      =  j . s'
                      but j . s' is fully defined, so
                      (i . s) o (undef_1 ... undef_i . p) = j . s'
                   *)
                in
                   (idot i s, idot j s')
                end

           | Pundef p' =>
                restrictionLoop (i+1) p'

           | Pshift j =>
                (* ^i o (undef_1 ... undef_i . p) = p = ^j *)
                (Shift i, Shift j))

      fun restriction p = restrictionLoop 0 p

   end