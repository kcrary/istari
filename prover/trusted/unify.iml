
signature UNIFY =
   sig

      type term

      val unify : term -> term -> unit
      val impossible : unit -> unit

      val solve : unit -> bool

      val unify1 : term -> term -> bool  (* unify followed by solve *)

      val errorMessage : string ref

      (* number of times solve has been called *)
      val count : int ref

   end


functor UnifyFun (structure Term : TERM
                  structure Constant : CONSTANT
                                       where type constant = Term.constant
                  structure Trail : TRAIL_PRIV
                                    where type term = Term.term
                                    where type ebind = Term.ebind
                  structure Normalize : NORMALIZE
                                        where type term = Term.term
                  structure Prune : PRUNE
                                    where type term = Term.term
                                    where type sub = Term.sub)
   :> UNIFY
      where type term = Term.term
   =
   struct

      structure T = Term
      structure N = Normalize
      
      structure Dict = Prune.Dict

      type term = Term.term

      exception Unify

      val errorMessage = ref ""



      fun isSoft opacity =
         (case opacity of
             Constant.SOFT => true
           | Constant.FIRM => true
           | _ => false)
         


      exception Different

      fun sameMain m n = sameWhnf (N.whnf m) (N.whnf n)

      (* m and n are both whnf, or they are both heads *)
      and sameWhnf m n =
         (case (m, n) of
             (T.Elim (T.Var i, spine), T.Elim (T.Var j, spine')) =>
                if i = j then
                   sameSpineMain spine spine'
                else
                   raise Different

           | (T.Elim (T.Const const, spine), T.Elim (T.Const const', spine')) =>
                if Constant.eq (const, const') then
                   sameSpineMain spine spine'
                else if isSoft (Constant.opacity const) then
                   sameWhnf (N.whnfHard m) n
                else if isSoft (Constant.opacity const') then
                   sameWhnf m (N.whnfHard n)
                else
                   raise Different

           | (T.Elim (T.Sub (T.Evar e1, s1), spine1), T.Elim (T.Sub (T.Evar e2, s2), spine2)) =>
                if T.eqEbind e1 e2 then
                   (
                   sameSubMain s1 s2;
                   sameSpineMain spine1 spine2
                   )
                else
                   raise Different

           | (T.Elim (T.Var _, _), _) => raise Different

           | (_, T.Elim (T.Var _, _)) => raise Different

           | (T.Elim (T.Const const, _), _) =>
                if isSoft (Constant.opacity const) then
                   sameWhnf (N.whnfHard m) n
                else
                   raise Different

           | (_, T.Elim (T.Const const, _)) =>
                if isSoft (Constant.opacity const) then
                   sameWhnf m (N.whnfHard n)
                else
                   raise Different

           | (T.Elim (T.Sub _, _), _) => raise Different

           | (_, T.Elim (T.Sub _, _)) => raise Different

           | (T.Elim (m1, spine), T.Elim (n1, spine')) =>
                (* We've eliminated all the cases in which m1 and n1 are heads,
                   so m1 and n1 are intros but do not match their spines.
                   (Thus m and n are ill-typed, but we still have to do something
                   with them.)  Note that intros are whnfs.
                *)
                (
                sameWhnf m1 n1;
                sameSpineMain spine spine'
                )

           | (T.Lam (_, m'), T.Lam (_, n')) =>
                sameMain m' n'

           | (T.Pair (m1, m2), T.Pair (n1, n2)) =>
                (
                sameMain m1 n1;
                sameMain m2 n2
                )

           | (T.Next m', T.Next n') =>
                sameMain m' n'

           | (T.Triv, T.Triv) => ()

           | (T.Native x, T.Native y) =>
                if T.sameNative x y then
                   ()
                else
                   raise Different

           | (T.Marker sym, T.Marker sym') =>
                if Symbol.eq (sym, sym') then
                   ()
                else
                   raise Different

           | (T.Var _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Var _) =>
                raise (Fail "should be whnf")

           | (T.Const _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Const _) =>
                raise (Fail "should be whnf")

           | (T.Evar _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Evar _) =>
                raise (Fail "should be whnf")

           | (T.Sub _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Sub _) =>
                raise (Fail "should be whnf")

           | _ => raise Different)

      and sameSpineMain spine spine' =
         (case (spine, spine') of
             ([], []) => ()

           | (elim :: rest, elim' :: rest') =>
                (
                sameElim elim elim';
                sameSpineMain rest rest'
                )

           | _ => raise Different)

      and sameElim elim elim' =
         (case (elim, elim') of
             (T.App m, T.App n) => sameMain m n

           | (T.Pi1, T.Pi1) => ()
           | (T.Pi2, T.Pi2) => ()
           | (T.Prev, T.Prev) => ()

           | _ => raise Different)

      and sameSubMain s t =
         (case (s, t) of
             (T.Shift i, T.Shift j) =>
                if i = j then
                   ()
                else
                   raise Different

           | (T.Dot (m, s'), T.Dot (n, t')) =>
                (
                sameMain m n;
                sameSubMain s' t'
                )

           | (T.Idot (i, s'), T.Idot (j, t')) =>
                if i = j then
                   sameSubMain s' t'
                else
                   raise Different

           | (T.Dot (m, s'), T.Idot (j, t')) =>
                (
                sameMain m (T.Var j);
                sameSubMain s' t'
                )

           | (T.Idot (i, s'), T.Dot (m, t')) =>
                (
                sameMain (T.Var i) m;
                sameSubMain s' t'
                )

           | (T.Dot (m, s'), T.Shift i) =>
                (
                sameMain m (T.Var i);
                sameSubMain s' (T.Shift (i+1))
                )

           | (T.Shift i, T.Dot (m, t')) =>
                (
                sameMain (T.Var i) m;
                sameSubMain (T.Shift (i+1)) t'
                )

           | (T.Idot (i, s'), T.Shift j) =>
                if i = j then
                   sameSubMain s' (T.Shift (j+1))
                else
                   raise Different

           | (T.Shift i, T.Idot (j, t')) =>
                if i = j then
                   sameSubMain (T.Shift (i+1)) t'
                else
                   raise Different)


      fun sameSpine spine spine' =
         try
            (sameSpineMain spine spine'; true)
         with Different => false


      fun sameSub s t =
         try
            (sameSubMain s t; true)
         with Different => false



      (* collectSpine n s spine =
          
         if    spine = i1 ... ij
         then  return SOME (n+j, ij . ... . i1 . s)
         else  return NONE
      *)
      fun collectSpine n s spine =
         (case spine of
             [] => 
                SOME (n, s)

           | T.App m :: rest =>
                (case N.whnf m of
                    T.Elim (T.Var i, []) =>
                       collectSpine (n+1) (T.Idot (i, s)) rest

                  | _ =>
                       collectSpine (n+1) (T.Dot (m, s)) rest)

           | _ :: _ =>
                (* We actually could handle the Prev case, but we would have to generalize a lot.
                   However, we can't handle Pi1 and Pi2, and Prev alone doesn't seem worth the trouble.
                *)
                NONE)



      fun prune e d m p =
         (case Prune.pruneGeneral e d m p of
             SOME m' => m'

           | NONE =>
                (
                errorMessage := "pruning failure";
                raise Unify
                ))


      (* pruneSpineEta c 0 sp p

         if    sp = rev spine
         then  n is the largest such that
                  n <= c, and 
                  spine = spine1 spine2, and 
                  spine2[p] = n-1 ... 0
               and
               return (n, rev spine1)
      *)
      fun pruneSpineEta c i sp p =
         if i = c then
            (i, sp)
         else
            (case sp of
                [] =>
                   (i, sp)

              | T.App m :: rest =>
                   (case N.whnf m of
                       T.Elim (T.Var j, []) =>
                          (case Prune.psubstVar j p of
                              NONE =>
                                 (i, sp)

                            | SOME j' =>
                                 if j' = i then
                                    pruneSpineEta c (i+1) rest p
                                 else
                                    (i, sp))

                     | _ =>
                          (i, sp))

              | _ :: _ =>
                   (i, sp))


      (* if    d(0) = NO, ..., d(i-1) = NO
         then  return SOME n
               where n is the largest such d(0)=NO, ..., d(n-1)=NO, and n=c or D(n)=YES
         or    return NONE if no such n exists (i.e., a MAYBE is encountered before a YES)
      *)
      fun confirmEta c d i =
         if i = c then
            SOME i
         else
            (case ! (Dict.lookup d i) of
                Prune.NO =>
                   confirmEta c d (i+1)

              | Prune.YES =>
                   SOME i

              | Prune.MAYBE =>
                   NONE)


      (* commonPrefix a i s1 s2

         if    i <= a
         then  return (i+b, s1', s2')
               where
               b is the largest such that i+b <= a and sk = j0 ... j_b-1 . sk' (for k = 1, 2)
      *)
      fun commonPrefix a i s1 s2 =
         if i = a then
            (i, s1, s2)
         else
            (case (s1, s2) of
                (T.Idot (j1, s1'), T.Idot (j2, s2')) =>
                   if j1 = j2 then
                      commonPrefix a (i+1) s1' s2'
                   else
                      (i, s1, s2)

              | _ =>
                   (i, s1, s2))



      fun iterateupLoop n f x i =
         if i = n then
            x
         else
            iterateupLoop n f (f i x) (i+1)

      fun iterateup n f x = iterateupLoop n f x 0



      val progress = ref false
      val queue : (T.term * T.term) list ref = ref []

      fun defer m n =
         queue := (m, n) :: !queue


      fun solveMain m n =
         solveWhnf (N.whnf m) (N.whnf n)

      and solveWhnf m n =
         (case (m, n) of
             (T.Elim (T.Var i, spine), T.Elim (T.Var j, spine')) =>
                if i = j then
                   (
                   progress := true;
                   solveSpine spine spine'
                   )
                else
                   (
                   errorMessage := "clash";
                   raise Unify
                   )

           | (T.Elim (T.Const const, spine), T.Elim (T.Const const', spine')) =>
                if Constant.eq (const, const') then
                   (
                   progress := true;
                   solveSpine spine spine'
                   )
                else if isSoft (Constant.opacity const) then
                   solveWhnf (N.whnfHard m) n
                else if isSoft (Constant.opacity const') then
                   solveWhnf m (N.whnfHard n)
                else
                   (
                   errorMessage := "clash";
                   raise Unify
                   )

           | (T.Elim (T.Sub (T.Evar e1, s1), spine1), T.Elim (T.Sub (T.Evar e2, s2), spine2)) =>
                if T.eqEbind e1 e2 then
                   (* flex-flex-same *)
                   if sameSub s1 s2 andalso sameSpine spine1 spine2 then
                      (* m and n are the same *)
                      progress := true
                   else
                      (case collectSpine 0 s1 spine1 of
                          NONE =>
                             (* not in the pattern fragment *)
                             defer m n

                        | SOME (a, s1') =>
                             (* a is the number of arguments E1 is given in M.
                                for any L, (fn ..a times.. fn . L)[s1] spine1 = L[s1']
                             *)
                             (case collectSpine 0 s2 spine2 of
                                 NONE =>
                                    defer m n

                               | SOME (a', s2') =>
                                    (* a' is the number of arguments E2 is given in N.
                                       for any L, (fn ..a' times.. fn . L)[s2] spine2 = L[s2']
                                    *)
                                    if a <> a' then
                                       (* The same evar can't take two different numbers of arguments. *)
                                       (
                                       errorMessage := "incompatible spines in evar";
                                       raise Unify
                                       )
                                    else if not (Prune.isPatternSub s1' andalso Prune.isPatternSub s2') then
                                       defer m n
                                    else
                                       let
                                          (* To avoid creating eta redices, take as few arguments as possible.

                                             We just constructed s1' and s2' from spine1 and spine2, so we can determine
                                             how much of spine1 and spine2's tail is in common by looking at s1' and s2'.
                                          *)

                                          val (b, s1'', s2'') = commonPrefix a 0 s1' s2'

                                          (* si' = j0 . ... . j_b-1 . si''  (for i = 1, 2)
                                             and b <= a

                                             That means spinei = spinei' j_b-1 ... j0 (for some spinei')
                                             with the js the same for both i.

                                             We can eliminate those last b arguments from consideration.

                                             So for any L, (fn ..a-b times.. fn . L)[si] spinei' = L[si''].
                                          *)

                                          val p1 =
                                             (case Prune.invert s1'' of
                                                 SOME p1 => p1

                                               | NONE =>
                                                    (* s1' is a pattern substitution, so s1'' must be *)
                                                    raise (Fail "impossible"))

                                          val p2 =
                                             (case Prune.invert s2'' of
                                                 SOME p2 => p2

                                               | NONE =>
                                                    (* s2' is a pattern substitution, so s2'' must be *)
                                                    raise (Fail "impossible"))

                                          (* p1 o s1'' <= id  and  p2 o s2'' <= id *)

                                          val p =
                                             (case Prune.intersection p1 p2 of
                                                 NONE =>
                                                    (* This can't happen in a well-formed constraint.

                                                       Suppose E1 = E2 = fn ..a-b times.. fn . E
                                                       Then    Ei[si] spinei' = E[si'']
                                                       So E[s1''] and E[s2''] must have the same type.

                                                       Suppose G |- E[s1''] : A
                                                       and     G |- E[s2''] : A
                                                       then    Gi |- E : Ai
                                                               Ai[si''] = A
                                                               G  |- si'' : Gi
                                                       so      Gi |- pi : G
                                                       
                                                       But note that G1 = G2, so p1 and p2 must
                                                       provide the same number of substitutions.
                                                    *)
                                                    (
                                                    errorMessage := "evar in incompatible scopes";
                                                    raise Unify
                                                    )

                                               | SOME p => p)

                                          (* p <= p1, p2 *)

                                          val (s, s') = Prune.restriction p

                                          (* s o p = s'

                                             so:
                                             s' o si'' = s o p o si'' <= s o pi o si'' <= s o id = s
                                             but s' o si'' is fully defined, so s' o si'' = s
                                             
                                             We bind:
                                             E1 = E2 := fn ..a-b times.. fn . E[s']
                                             for some fresh E

                                             Then:
                                               M
                                             = E1[s1] spine1
                                             = E1[s1] spine1' j_b-1 ... j_0
                                             = (fn ..a-b times.. fn . E[s'])[s1] spine1' j_b-1 ... j_0
                                             = E[s'][s1''] j_b-1 ... j_0
                                             = E[s] j_b-1 ... j_0
                                             = E[s'][s2''] j_b-1 ... j_0
                                             = (fn ..a-b times.. fn . E[s'])[s2] spine2' j_b-1 ... j_0
                                             = E2[s2] spine2' j_b-1 ... j_0
                                             = E2[s2] spine2
                                             = N
                                          *)
                                       in
                                          progress := true;

                                          Trail.setEbind e1
                                             (iterateup (a-b)
                                                 (fns _ l => T.Lam (NONE, l))
                                                 (T.Sub (T.evar (), s')))
                                       end))
                else
                   (* flex-flex-different *)
                   (case 
                       (case spine1 of
                           [] => Prune.invert s1
                         | _ => NONE)
                    of
                       SOME p =>
                          let
                             val n' = prune (T.ebindToInt e1) Dict.empty n p
                          in
                             progress := true;

                             Trail.setEbind e1 n'
                          end

                     | NONE =>
                          (case
                              (case spine2 of
                                  [] => Prune.invert s2
                                | _ => NONE)
                           of
                              SOME p =>
                                 let
                                    val m' = prune (T.ebindToInt e2) Dict.empty m p
                                 in
                                    progress := true;

                                    Trail.setEbind e2 m'
                                 end

                            | NONE =>
                                 (case collectSpine 0 s1 spine1 of
                                     NONE =>
                                        (* not in the pattern fragment *)
                                        defer m n
                        
                                   | SOME (a1, s1') =>
                                        (case collectSpine 0 s2 spine2 of
                                            NONE =>
                                               defer m n
                        
                                          | SOME (a2, s2') =>
                                               (* ai is the number of arguments Ei is given.
                                                  for any L, (fn ..ai times.. fn . L)[si] spinei = L[si']
                                               *)
                                               if not (Prune.isPatternSub s1' andalso Prune.isPatternSub s2') then
                                                  defer m n
                                               else
                                                  let
                                                     val a = Int.min a1 a2
                                                     
                                                     (* To avoid creating eta redices, take as few arguments as possible.
                        
                                                        We just constructed s1' and s2' from spine1 and spine2, so we can determine
                                                        how much of spine1 and spine2's tail is in common by looking at s1' and s2'.
                                                     *)
                        
                                                     val (b, s1'', s2'') = commonPrefix a 0 s1' s2'
                        
                                                     (* si' = j0 . ... . j_b-1 . si''  (for i = 1, 2)
                                                        and b <= a
                        
                                                        That means spinei = spinei' j_b-1 ... j0 (for some spinei')
                                                        with the js the same for both i.
                        
                                                        We can eliminate those last b arguments from consideration.
                        
                                                        So for any L, (fn ..ai-b times.. fn . L)[si] spinei' = L[si''].
                                                     *)
                        
                                                     val p1 =
                                                        (case Prune.invert s1'' of
                                                            SOME p1 => p1
                        
                                                          | NONE =>
                                                               (* s1' is a pattern substitution, so s1'' must be *)
                                                               raise (Fail "impossible"))
                        
                                                     (* p1 o s1'' <= id *)
                        
                                                     val (s, s') = Prune.restriction (Prune.composeSubPsub s2'' p1)
                        
                                                     (* s o (s2'' o p1) = s'
                        
                                                        so:
                                                        s o (s2'' o p1) = s'
                                                        s' o s1'' = s o (s2'' o p1) o s1'' <= s o s2''
                                                        but s' o s1'' is fully defined, so s' o s1'' = s o s2''
                                                        
                                                        We bind:
                                                        E1 := fn ..a1-b times.. fn . E[s']
                                                        E2 := fn ..a2-b times.. fn . E[s]
                                                        for some fresh E
                                                        
                                                        Then:
                                                          M
                                                        = E1[s1] spine1
                                                        = E1[s1] spine1' j_b-1 ... j0
                                                        = (fn ..a1-b times.. fn . E[s'])[s1] spine1' j_b_1 ... j0
                                                        = E[s'][s1''] j_b-1 ... j0
                                                        = E[s][s2''] j_b-1 ... j0
                                                        = (fn ..a2-b times.. fn . E[s])[s2] spine2' j_b_1 ... j0
                                                        = E2[s2] spine2' j_b-1 ... j0
                                                        = E2[s2] spine2
                                                        = N
                                                     *)
                        
                                                     val e = T.evar ()
                                                  in
                                                     progress := true;
                        
                                                     Trail.setEbind e1
                                                        (iterateup (a1-b)
                                                            (fns _ l => T.Lam (NONE, l))
                                                            (T.Sub (e, s')));
                        
                                                     Trail.setEbind e2
                                                        (iterateup (a2-b)
                                                            (fns _ l => T.Lam (NONE, l))
                                                            (T.Sub (e, s)))
                                                  end))))

           | (T.Elim (T.Sub (T.Evar e, s), spine), _) =>
                solveFlexRigid m e s spine n

           | (_, T.Elim (T.Sub (T.Evar e, s), spine)) =>
                (* This will turn the contraint around if we defer, but that probably doesn't matter. *)
                solveFlexRigid n e s spine m

           | (T.Elim (T.Const const, _), _) =>
                if isSoft (Constant.opacity const) then
                   solveWhnf (N.whnfHard m) n
                else
                   (
                   errorMessage := "clash";
                   raise Unify
                   )

           | (_, T.Elim (T.Const const, _)) =>
                if isSoft (Constant.opacity const) then
                   solveWhnf m (N.whnfHard n)
                else
                   (
                   errorMessage := "clash";
                   raise Unify
                   )

           | (T.Elim (T.Var _, _), _) =>
                (
                errorMessage := "clash";
                raise Unify
                )

           | (_, T.Elim (T.Var _, _)) => 
                (
                errorMessage := "clash";
                raise Unify
                )

           | (T.Elim (m1, spine), T.Elim (n1, spine')) =>
                (* We've eliminated all the cases in which m1 and n1 are heads,
                   so m1 and n1 are intros but do not match their spines.
                   (Thus m and n are ill-typed, but we still have to do something
                   with them.)  Note that intros are whnfs.
                *)
                (
                solveWhnf m1 n1;
                solveSpine spine spine'
                )

           | (T.Lam (_, m1), T.Lam (_, n1)) =>
                (
                progress := true;
                solveMain m1 n1
                )

           | (T.Pair (m1, m2), T.Pair (n1, n2)) =>
                (
                progress := true;
                solveMain m1 n1;
                solveMain m2 n2
                )

           | (T.Next m1, T.Next n1) =>
                (
                progress := true;
                solveMain m1 n1
                )

           | (T.Triv, T.Triv) =>
                progress := true

           | (T.Native x, T.Native y) =>
                if T.sameNative x y then
                   progress := true
                else
                   (
                   errorMessage := "clash";
                   raise Unify
                   )

           | (T.Marker sym, T.Marker sym') =>
                if Symbol.eq (sym, sym') then
                   progress := true
                else
                   (
                   errorMessage := "clash";
                   raise Unify
                   )

           | (T.Var _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Var _) =>
                raise (Fail "should be whnf")

           | (T.Const _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Const _) =>
                raise (Fail "should be whnf")

           | (T.Evar _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Evar _) =>
                raise (Fail "should be whnf")

           | (T.Sub _, _) =>
                raise (Fail "should be whnf")

           | (_, T.Sub _) =>
                raise (Fail "should be whnf")

           | _ =>
                (
                errorMessage := "clash";
                raise Unify
                ))


      and solveSpine spine spine' =
         (case (spine, spine') of
             ([], []) => ()

           | (elim :: rest, elim' :: rest') =>
                (
                solveElim elim elim';
                solveSpine rest rest'
                )

           | _ => 
                (
                errorMessage := "incompatible spines";
                raise Unify
                ))


      and solveElim elim elim' =
         (case (elim, elim') of
             (T.App m, T.App n) => solveMain m n

           | (T.Pi1, T.Pi1) => ()
           | (T.Pi2, T.Pi2) => ()
           | (T.Prev, T.Prev) => ()

           | _ =>
                (
                errorMessage := "elim clash";
                raise Unify
                ))

         
      (* solveFlexRigid M E s spine N

         if    M = E[s] spine
         then  attempts to unify M with N
      *)
      and solveFlexRigid m e s mspine n =
         (case collectSpine 0 s mspine of
             NONE =>
                (* not in the pattern fragment *)
                defer m n

           | SOME (a, s') =>
                (* a is the number of arguments E is given.
                   for any L, (fn ..a times.. fn . L)[s] mspine = L[s']
                *)
                (case Prune.invert s' of
                    NONE =>
                       (* not in the pattern fragment *)
                       defer m n

                  | SOME p =>
                       (* p o s' <= id

                          if n[p] is defined we probably want to bind:
                          E := fn ..a times.. fn . N[p]

                          Then:
                          M
                          = E[s] mspine
                          = (fn ..a times.. fn . N[p])[s] mspine
                          = N[p][s']
                          = N

                          But before we make the binding, we have to ensure we aren't creating
                          an eta redex.
                       *)
                       (case n of
                           T.Elim (h, nspine) =>
                              let
                                 val (b, nspine1rev) = pruneSpineEta a 0 (List.rev nspine) p

                                 (* nspine = nspine1 @ nspine2  
                                    and  nspine2[p] = b-1 ... 0
                                    and  b <= a
                                    and  nspine1rev = rev nspine1
                                 *)

                                 (* Use references to detect variable appearances. *)

                                 val d =
                                    iterateup b
                                       (fns i d => Dict.insert d i (ref Prune.NO))
                                       Dict.empty

                                 val enum = T.ebindToInt e
                                 val h' = prune enum d h p

                                 val nspine1' =
                                    List.revMap
                                       (fn T.App n => T.App (prune enum d n p)
                                         | elim => elim)
                                       nspine1rev

                                 (* N[p]
                                    = (h nspine)[p]
                                    = (h nspine1 nspine2)[p]
                                    = h[p] nspine1[p] b-1 ... 0
                                    = h' nspine1' b-1 ... 0

                                    If b > 0 we have a potential eta redex, taking b arguments.
                                    Now confirm those arguments don't appear in h' nspine1'.
                                 *)
                              in
                                 (case confirmEta b d 0 of
                                     NONE =>
                                        (* We can't tell if this is an eta redex, since a variable
                                           might or might not appear in the body.
                                        *)
                                        defer m n

                                   | SOME c =>
                                        (* N[p]
                                           = h' nspine1' b-1 ... c c-1 ... 0
                                           and c-1 ... 0 do not appear in h' nspine1'
                                           (nor in b-1 ... c, obviously)
 
                                           However, c does appear (or c=b), so the eta redex is no
                                           larger.

                                           By spec, c <= b since either c = b, or d(c) = YES where d's domain is {0 ... b-1}.
 
                                           So instead of binding:
                                           E := fn ..a times.. fn . h' nspine1' b-1 ... 0
 
                                           We bind:
                                           E := fn ..a-c times.. fn . (h' nspine1' b-1 ... c)[vc]  (where vc means unshift c)
                                              = fn ..a-c times.. fn . h'[vc] nspine1'[vc] b-1-c ... 0
 
                                           E[s] mspine
                                           = (fn ..a-c times.. fn . h'[vc] nspine1'[vc] b-1-c ... 0)[s] mspine
                                           = (fn ..a-c times.. fn . fn ..c times.. h' nspine1' b-1 ... c c-1 ... 0)[s] mspine
                                             (can eta expand because there are enough arguments in mspine)
                                           = (fn ..a times.. fn . h' nspine1' b-1 ... 0)[s] mspine
                                           = (h' nspine1' b-1 ... 0)[s']
                                           = N[p][s']
                                             (as above)
                                           = N
                                        *)
                                        let
                                           val unsh =
                                              iterateup c
                                                 (fns _ unsh => T.Dot (Prune.orphan, unsh))
                                                 T.id

                                           val n'' =
                                              iterateup (a-c)
                                                 (fns _ l => T.Lam (NONE, l))
                                                 (T.Elim (T.Sub (h', unsh),
                                                        T.ssubst nspine1' unsh
                                                        @
                                                        iterateup (b-c)
                                                           (fns i l => T.App (T.Var i) :: l)
                                                           []))
                                        in
                                           progress := true;

                                           Trail.setEbind e n''
                                        end)
                              end

                         | _ =>
                              (* This will clearly not create an eta redex, so do the simple thing. *)
                              let
                                 val n' = prune (T.ebindToInt e) Dict.empty n p

                                 (* N' = N[p]
                                    so (fn ..a times.. fn . N')[s] mspine = N'[s'] = N[p][s'] = N

                                    Thus bind:
                                    E := fn ..a times.. fn . N'
                                 *)

                                 val n'' =
                                    iterateup a
                                       (fns _ l => T.Lam (NONE, l)) 
                                       n'
                              in
                                 progress := true;

                                 Trail.setEbind e n''
                              end)))



      fun solveLoop l =
         (
         progress := false;
         queue := [];

         List.app (fn (m, n) => solveMain m n) l;

         (case !queue of
             [] => ()

           | l' =>
                if !progress then
                   solveLoop (List.rev l')
                else
                   (
                   errorMessage := "ambiguous unification";
                   raise Unify
                   ))
         )



      datatype constraints =
         Possible of (T.term * T.term) list
       | Impossible

      val constraints = ref (Possible [])

      fun unify m n =
         constraints :=
         (case !constraints of
             Impossible => Impossible

           | Possible l => Possible ((m, n) :: l))

      fun impossible () = constraints := Impossible

      val count = ref 0

      fun solve () =
         (
         count := 1 + !count;
         (case !constraints of
             Impossible =>
                (
                constraints := Possible [];
                false
                )

           | Possible c =>
                let
                   val mark = Trail.mark ()
                in
                   constraints := Possible [];
   
                   try
                      (
                      solveLoop c;
                      true
                      )
                   with Unify =>
                      (
                      queue := [];  (* gc it *)
                      Trail.rewind mark;
                      false
                      )
                end)
         )


      fun unify1 m n =
         (
         unify m n;
         solve ()
         )

   end
