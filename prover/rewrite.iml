
signature REWRITE =
   sig

      type constant = Constant.constant
      type symbol = Symbol.symbol
      type tactic = Tactic.tactic

      type rewrite
      type eterm = ETerm.eterm
      type ehead = Directory.idirectory -> Directory.head


      type captures = symbol option list

      (* In the rewrites that take a captures argument, say l, the rewrite captures
         the innermost |l| bindings, and uses l for their names.
      *)

      val identityRew       : rewrite
      val usingRew          : bool -> bool -> captures -> eterm -> rewrite  (* bool 1: strict, bool 2: reverse the direction *)
      val replaceRew        : captures -> eterm -> eterm -> eterm -> rewrite
      val convertRew        : captures -> eterm -> rewrite
      val convertHeadRew    : captures -> constant -> eterm -> rewrite
      val foldRew           : captures -> eterm -> rewrite
      val convertFoldRew    : captures -> eterm -> rewrite
      val foldsRew          : int -> captures -> eterm -> rewrite
      val unfoldRew         : ehead -> rewrite
      val unfoldHeadRew     : ehead -> rewrite
      val rollRew           : captures -> eterm -> rewrite
      val convertRollRew    : captures -> eterm -> rewrite
      val unrollRew         : ehead -> rewrite
      val unrollTypeRew     : constant -> rewrite
      val unrollTypeUnivRew : captures -> constant -> eterm -> rewrite
      val reduceUsingRew    : Reduction.reduction -> rewrite
      val unreduceUsingRew  : captures -> eterm -> Reduction.reduction -> rewrite
      val convertUnreduceUsingRew : captures -> eterm -> Reduction.reduction -> rewrite
      val reduceRew         : rewrite
      val whreduceRew       : rewrite
      val reduceHardRew     : rewrite
      val whreduceHardRew   : rewrite
      val reduceSeqRew      : rewrite
      val reduceParamRew    : rewrite
      val convertIrrRew     : captures -> eterm -> rewrite


      (* target: hypothesis and occurrences, where
         occurrences = NONE             means all
         occurrences = SOME (false, l)  means apply at hit numbers given by l
         occurrences = SOME (true , l)  means apply at positions given by l

         empty target list parses as concl at hit 0
      *)
      type targets = (Hyp.hypothesis * (bool * int list) option) list

      val rewrite           : (rewrite * targets) list -> tactic
      val rewriteRaw        : (rewrite * targets) list -> tactic
      val rewritePriority   : (rewrite * targets) list -> Tactic.priority Tactic.tacticm
      val rewriteThen       : (rewrite * targets) list -> tactic -> tactic

      val testRewrite       : (rewrite * targets) list -> unit
      val showPosition      : targets -> unit

      val convert           : ((captures * eterm) * targets) list -> tactic
      val convertHead       : ((captures * constant * eterm) * targets) list -> tactic
      val fold              : ((captures * eterm) * targets) list -> tactic
      val convertFold       : ((captures * eterm) * targets) list -> tactic
      val folds             : int -> ((captures * eterm) * targets) list -> tactic
      val unfold            : (ehead * targets) list -> tactic
      val unfoldHead        : (ehead * targets) list -> tactic
      val roll              : ((captures * eterm) * targets) list -> tactic
      val convertRoll       : ((captures * eterm) * targets) list -> tactic
      val unroll            : (ehead * targets) list -> tactic
      val unrollType        : (constant * targets) list -> tactic
      val unrollTypeUniv    : ((captures * constant * eterm) * targets) list -> tactic
      val reduceUsing       : (Reduction.reduction * targets) list -> tactic
      val unreduceUsing     : ((captures * eterm * Reduction.reduction) * targets) list -> tactic
      val convertUnreduceUsing : ((captures * eterm * Reduction.reduction) * targets) list -> tactic
      val reduce            : targets -> tactic
      val whreduce          : targets -> tactic
      val reduceHard        : targets -> tactic
      val whreduceHard      : targets -> tactic
      val reduceSeqPriority : targets -> Tactic.priority Tactic.tacticm
      val reduceSeqRaw      : targets -> tactic
      val reduceSeq         : targets -> tactic
      val reduceParam       : Hyp.hypothesis list -> tactic
      val convertIrr        : ((captures * eterm) * targets) list -> tactic

      val trace : bool ref

   end


(* The rewriting system
   ====================
   There are two forms of rewrite: computation rewrites and relation rewrites.

   A rewrite is a function that takes the hypothesis being rewritten and the current goal,
   and returns a general rewrite, where a general rewrite is a *rewrite core* that carries
   either a computation or relation rewrite.


   Cores
   -----
   A rewrite core serves to find where in a term that a rewrite acts and return the
   necessary information.  It consists of two functions, a tester and and actor.  Each of
   them takes the current number of bindings we have descended under, and the current term
   that we are looking at.  The current term is always in simple form, and if it is an
   elim, it carries the entire spine.

   NOTE: The core is *not* called multiple times on the same elim with progressively
   smaller spines.  It is the core's job to deal with any leftover spine.

   The tester returns true/false depending on whether the rewrite hits on current term.
   Either way, it retracts any evar bindings.  The actor returns SOME/NONE depending on
   whether the rewrite hits on the current term.  It retracts any evar bindings if it
   returns NONE.

   If the actor hits, it returns SOME (M, N, spine, method), where M is a prefix of the
   current term, spine is the leftover spine, and method rewrites M into N.  Thus, if the
   current term is P, and the actor returns (M, N, spine, method), then P = M spine.

   A computation rewrite always acts on an entire elim.  Thus, its actor always returns
   (P, N, [], method) where P is the current term.

   The function *find* uses a rewrite core and finds the desired place in a term for the
   rewrite to operate.  Thus, (find i P core) finds core's ith hit within P, and returns
   (M, N, C, method), where P = C{M} and method rewrites M into N.  Thus, the rewrite
   should turn P into C{N}.
   

   Computation rewrites
   --------------------
   A computation rewrite that takes M to N consists a small program which shows how to
   use direct computation rules to get from M to N.


   Relation rewrites
   -----------------
   A relation rewrite that takes M to N consists of a relation R and a coercion coe.
   The relation is either equality or something else.  In the case of equality, the
   relation contains the type at which terms are being compared.  In the case of a general
   relation, it contains only the head constant.

   (Equality is treated specially because equality is indexed by a type.  At present we do
   not use rewriting with any other indexed relation.  We could deal with indexed
   relations in general, but that would involve code complication and some performance
   cost which we prefer not to incur if it's not necessary.  The code does actually
   support other indexed relations provided the coercion does not require access to the
   indices, but for equality the type is indeed required.)

   A coercion is a tactic that is wrapped with a direction.  Suppose a coercion takes M to
   N.  Either the coercion is Forward, in which case the tactic takes M to N; or it is
   Backward, in which case it takes N to M.  Allowing coercions to go either direction
   facilitates dealing with contravariance.

   In notation, we say that tac :: A if tac proves the goal A, possibly generating
   subgoals.  If R is a relation, we say that coe :: R M N if:
   
   coe = Forward tac   and  tac :: R M N
   coe = Backward tac  and  tac :: R N M
   
   If the relation is equality, coe :: eq A M N.  We extract tac :: M = N : A (using
   symmetry if necessary).  We then elevate all way to C{M} = C{N} : type by generating
   a subgoal x : A |- C{x} : type and using functionality.  Then, for convenience, we
   weaken that to C{M} <:> C{N}.

   (We could similarly take M = N : type all the way to C{M} = C{N} : type, but we do not.
   The reason is the generated subgoal would be x : type |- C{x} : type.  This seems
   likely to fail often, since typing very often depends on the actual types being used.)

   For other relations, we use compatibility and weakening to work our way from R M N to
   some R' C{M} C{N}.  This is done using something like a forward-chaining logic
   programming algorithm (although we do not accumuate a database of proven facts).

   Suppose we are rewriting using R M N through C{h spine1 {} spine2}.  First we look for
   a compatibility rule for R though the ith position of h.  If there is one, in which R
   becomes R', we continue rewriting using R' (h spine1 M spine2) (h spine1 N spine2).  We
   also set a backtracking point.

   If there is no relevant compatibility rule (or if we have backtracked from one), we
   look for other relations we can weaken R into.  We try each one in turn, setting
   backtracking points each time.

   If there are no successful compatibility or weakening rules, we backtrack.

   When and if we reach the top level, we want R to be entailment (A |- B[^]), extensional
   type equality (A <:> B), or (in hypotheses) subtyping (A <: B).  If R is anything else,
   we backtrack.

   NOTE: Entailment is treated if it is a relation, even though it does not actually have
   that form.

   What follows depends on whether we are rewriting a hypothesis or the conclusion.
   Either way, the hypothesis/conclusion being rewritten is A.

   - In the conclusion:

     + If R is eeqtp, we can replace A by B (using symmetry if the coercion is backward).

     + If R is entailment, then the coercion must be backward.  If so, B entails A, so
       we can replace A by B.  Otherwise backtrack.

     (The first case is not strictly necessary, since eeqtp will eventually weaken to
     entailment.)

   - In a hypothesis, first ensure that B can be written in the same hypothesis position.
     (That is, ensure B does not depend on any later hypothesis.)  Then:

     + If R is eeqtp, we can replace A by B (using symmetry if the coercion is backward).

     + If R is subtype, then the corecion must be forward (so A <: B), AND no subsequent
       hypothesis may depend on the hypothesis.  If both are the case, we can replace A by
       B.  Otherwise backtrack.

     + If R is entailment, then the coercion must be forward (so A entails B), AND no
       subsequent hypothesis NOR the conclusion may depend on the hypothesis.  If both are
       the case, we can replace A by B.  (Since we are not actually turning A into B, we
       are replacing A by B, any dependencies would notice.)  Otherwise backtrack.


   Compatibility rules
   -------------------
   Compatibility rules are held by compatibilityTable.  It maps triples (const, i, rconst)
   to tuples (R', covariant, binds, tacfn).

   In such a rule, rconst is being mapped through the ith position of const.  The
   resulting relation is R', and the direction is reversed if covariant=false.
   If R' is equality, the type must be closed.

   The ith position resides under bound variables number binds.  (For example, in a
   compatibility rule for position 1 -- the second position -- of forall, binds would
   equal 1.)

   Thus, if tac :: R M N we should have:

      tacfn M N tac :: R' (const spine1 (fn ... fn . M') spine2) (const spine1 (fn ... fn . N') spine2)

   where |spine1| = i.  If covariant M' and N' are M and N (and vice versa if not covariant).


   Weakening rules
   ---------------
   Weakening rules are held by weakeningTable.  It maps rconst to a list of tuples 
   (rconst', covariant, tacfn).

   For each one, rconst can be weakened to rconst', reversing the direction if
   covariant=false.

   Thus, if tac :: R M N we should have:

      tacfn M N tac :: R' M N, if covariant
      tacfn M N tac :: R' N M, if not covariant
*)


(* All the type definitions are given here in case the user wants to craft a rewrite. *)
signature REWRITE_TYPES =
   sig

      type term = Term.term
      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority


      (* All the type definitions are given here in case the user wants to craft a rewrite. *)

      datatype computation_rewrite =
         Identity

       | Beta
         (* Beta :: M --> N  where  M is beta-equivalent to N *)

       | Reduce of Reduction.reduction
         (* Reduce red :: M --> N  where  M reduces to N by red *)

       | Unreduce of Reduction.reduction
         (* Unreduce red :: N --> M  where  M reduces to N by red *)

       | LetFold of int * term
         (* LetFold (i, M) :: M[N[^k] . id] --> M[i+k . id] 
            where i unfolds to N and rewriting is taking place under k bindings
         *)

       | LetUnfold of int * term
         (* LetFold (i, M) :: M[i+k . id] --> M[N[^k] . id] 
            where i unfolds to N and rewriting is taking place under k bindings
         *)

       | Seq of computation_rewrite * term * computation_rewrite
         (* Seq red1 M2 red2 :: M1 --> M3
            where red1 :: M1 --> M2 and red2 :: M2 --> M3
         *)


      datatype relation =
         Equality of Term.term         (* the type at which terms are being compared *)
       | General of Constant.constant

      datatype coercion =
         Forward of priority tacticm
       | Backward of priority tacticm

      (* We say tac :: A if tac proves A, possibly generating subgoals.

         We say that coe :: R M N if:
         coe = Forward tac   and  tac :: R M N
         coe = Backward tac  and  tac :: R N M

         The tactic in tac or coe expects a directory appropriate to M and N.
      *)

      type relation_rewrite = relation * coercion

      (* (R, coe) : relation_rewrite

         suppose M is being rewritten to N
         coe :: R M N
      *)


      type 'a rewrite_core =
         (int -> term -> bool) * (int -> term -> (term * term * Term.elim list * 'a) option)

      (* (test, act) : method rewrite_core

         test bvs P : tests whether the rewriter acts on P, when under bvs bound variables,
                      then (whether yes or no) retracts any bindings

         act bvs P  : tests whether the rewriter acts on P, when under bvs bound variables, then: 
                      if yes, returns (M, N, spine, method) where P = M spine and method relates M to N;
                      if no, retracts any bindings

         For each, P must be in simple form.
      *)


      datatype general_rewrite =
         Computation of computation_rewrite rewrite_core
       | Relation of relation_rewrite rewrite_core


      (* rewrites can raise this *)
      exception RewriteFailure of string


      (* hypothesis (NONE=concl) being rewritten, the goal *)
      type rewrite = int option -> Tactic.goal -> general_rewrite

   end


structure RewriteTypes :> REWRITE_TYPES =
   struct

      type term = Term.term
      type tactic = Tactic.tactic
      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority

      type 'a rewrite_core =
         (int -> term -> bool) * (int -> term -> (term * term * Term.elim list * 'a) option)

      datatype computation_rewrite =
         Identity
       | Beta
       | Reduce of Reduction.reduction
       | Unreduce of Reduction.reduction
       | LetFold of int * term
       | LetUnfold of int * term
       | Seq of computation_rewrite * term * computation_rewrite

      datatype relation =
         Equality of Term.term         (* the type at which terms are being compared *)
       | General of Constant.constant

      datatype coercion =
         Forward of priority tacticm
       | Backward of priority tacticm

      type relation_rewrite = relation * coercion

      datatype general_rewrite =
         Computation of computation_rewrite rewrite_core
       | Relation of relation_rewrite rewrite_core

      exception RewriteFailure of string

      type rewrite = int option -> Tactic.goal -> general_rewrite

   end


(* can't include a "where type" signature, so we'll name it *)
signature REWRITE_SPEC = REWRITE where type rewrite = RewriteTypes.rewrite


signature REWRITE_INTERNAL =
   sig

      include REWRITE_SPEC


      type 'a tacticm = 'a Tactic.tacticm
      type priority = Tactic.priority

      structure CICTable : CHECKPOINTED_TABLE where type key = constant * int * constant

      val compatibilityTable : 
         (RewriteTypes.relation 
           * bool 
           * int 
           * (Term.term -> Term.term -> priority tacticm -> priority tacticm)
         ) CICTable.table

      (* When (const, i, rconst) maps to (rconst', covariant, binds, tacfn),
         this is an entry that passes rconst through the ith position of const (under binds lambdas)
         to obtain rconst' (reversing the direction if covariant=false).

         More precisely:

         if    compatibilityTable maps (const, i, rconst) to (rel, covariant, binds, tacfn)
               R1 = rconst ...some spine...
         then  forall tac
               if    tac :: R1 M N
               then  M' = const spine1 (fn ... fn . M) spine2
                                        + binds +
                     N' = const spine1 (fn ... fn . N) spine2
                                        + binds +
                     |spine1| = i
                     R2 = rconst' ...some spine...  if rel = General rconst'
                     R2 = eq A  and  A is closed    if rel = Equality A
                     tacfn M N tac :: R2 M' N', if covariant=true
                     tacfn M N tac :: R2 N' M', if covariant=false

         Exception: if rconst is entailment, than R A B should be interpreted as A |- B[^].  As usual, the tactic expects a directory
         appropriate to A and B, so it is missing the extra binding.
      *)


      val weakeningTable : 
         (constant 
           * bool 
           * (Term.term -> Term.term -> priority tacticm -> priority tacticm)
         ) list ConstantTable.table

      (* if    weakeningTable maps rconst to a list containing (rconst', covariant, tacfn)
               R1 = rconst rspine
         then  forall tac
               if    tac :: R1 M N
               then  R2 = rconst' rspine'
                     tacfn M N tac :: R2 M N, if covariant=true
                     tacfn M N tac :: R2 N M, if covariant=false

         Exception: if rconst=entailment, than R A B should be interpreted as A |- B[^].  As usual, the tactic expects a directory
         appropriate to A and B, so it is missing the extra binding.
      *)

   end


structure RewriteContext =
   struct

      structure T = Term


      datatype frame =
         Felim1 of T.elim list
       | Felim2 of T.term * T.elim list * T.elim list
         (* Felim2 (h, left, right)  represents  h (rev left) (App {}) right
            h is head or intro
            (It would make sense to cache the length of left here.)
         *)
       | Flam of T.binder
       | Fpair1 of T.term
       | Fpair2 of T.term
       | Fnext


      fun contextToPath c path =
         (case c of
             [] => path

           | Felim1 _ :: rest =>
                contextToPath rest (0 :: path)

           | Felim2 (_, left, _) :: rest =>
                contextToPath rest (1 + List.length left :: path)

           | Flam _ :: rest =>
                contextToPath rest (0 :: path)

           | Fpair1 _ :: rest =>
                contextToPath rest (0 :: path)

           | Fpair2 _ :: rest =>
                contextToPath rest (1 :: path)

           | Fnext :: rest =>
                contextToPath rest (0 :: path))


      fun contextBindings c acc =
         (case c of
             [] => acc

           | Flam _ :: rest => contextBindings rest (acc+1)

           | _ :: rest => contextBindings rest acc)
         

      fun instantiate c m =
         (case c of
             [] => m

           | Felim1 spine :: rest =>
                instantiate rest (T.Elim (m, spine))

           | Felim2 (h, left, right) :: rest =>
                instantiate rest
                (T.Elim (h, List.revAppend left (T.App m :: right)))

           | Flam binder :: rest =>
                instantiate rest (T.Lam (binder, m))

           | Fpair1 m2 :: rest =>
                instantiate rest (T.Pair (m, m2))

           | Fpair2 m1 :: rest =>
                instantiate rest (T.Pair (m1, m))

           | Fnext :: rest =>
                instantiate rest (T.Next m))


      (* instantiateShift C M

         returns    N
         such that  for all P, N[P . id] = C{ M[P[^k] . id] }
         where      C binds k variables
      *)
      fun instantiateShift c m =
         (case c of
             [] => m

           | Felim1 spine :: rest =>
                instantiateShift rest (T.Elim (m, T.ssubst spine T.shift1))

           | Felim2 (h, left, right) :: rest =>
                instantiateShift rest
                (T.Elim (T.Sub (h, T.shift1),
                         List.foldl
                            (fns elim spine =>
                                (case elim of
                                    T.App n => T.App (T.Sub (n, T.shift1)) :: spine
                                  | _ => elim :: spine))
                            (T.App m ::
                             map 
                                (fn T.App n => T.App (T.Sub (n, T.shift1))
                                  | elim => elim) 
                                right)
                            left))

           | Flam binder :: rest =>
                (* the interesting case:

                   let C = C'{ \.{} }
                   and let N = instantiateShift C M = instantiateShift C' (\.M[1 . 0 . ^2])

                   N[P . id]
                   = C'{ (\.M[1 . 0 . ^2]) [P[^k] . id] }
                   = C'{ \. M[1 . 0 . ^2] [0 . (P[^k] . id) o ^] }
                   = C'{ \. M[1 . 0 . ^2] [0 . P[^k+1] . ^] }
                   = C'{ \. M[P[^k+1] . 0 . ^] }
                   = C'{ \. M[P[^k+1] . id] }
                   = C { M[P^k+1 . id] }
                *)
                instantiateShift rest (T.Lam (binder, T.Sub (m, T.Idot (1, T.Idot (0, T.Shift 2)))))

           | Fpair1 m2 :: rest =>
                (* a representative ordinary case:

                   let C = C'{ <{}, M2> }
                   and let N = instantiateShift C M = instantiateShift C' <M, M2[^]>

                   N[P . id]
                   = C'{ <M, M2[^]> [P[^k] . id] }
                   = C'{ <M[P^k . id], M2[^][P[^k] . id]> }
                   = C'{ <M[P^k . id], M2> }
                   = C { M[P^k . id] }
                *)
                instantiateShift rest (T.Pair (m, T.Sub (m2, T.shift1)))

           | Fpair2 m1 :: rest =>
                instantiateShift rest (T.Pair (T.Sub (m1, T.shift1), m))

           | Fnext :: rest =>
                instantiateShift rest (T.Next m))

   end


structure RewriteInternal :> REWRITE_INTERNAL =
   struct

      structure B = BackchainInternal
      structure D = Directory
      structure ET = ETerm
      structure H = ConstantTable
      structure P = Prefix
      structure J = Judgement
      structure N = Normalize
      structure R = Reduction
      structure T = Term
      structure TC = Typecheck

      open RewriteTypes
      open Tactic
      open CasePervasive

      type symbol = Symbol.symbol
      type constant = Constant.constant
      type eterm = ET.eterm
      type ehead = Directory.idirectory -> Directory.head

      exception InsufficientHits of string

      val trace = ref false

      val conclSym = Symbol.fromValue "concl"
      val hole = Symbol.fromValue "hole"


      open RewriteContext


      (* close binders dir A M N tac

         if    binders is a list of binders (outermost first)
               tac :: M = N : A
         then  k is the number of binders
               M' = fn ... fn . M  (k times)
               N' = fn ... fn . N  (k times)
               A' = forall E1 ... Ek . A
               tac' :: M' = N' : A'
               and
               return (k, A', M', N', tac')
      *)
      fun close binders dir a m n tac =
         (case binders of
             [] =>
                (0, a, m, n, chdir dir >>+ tac)

           | binder :: rest =>
                let
                   val dir' = D.bindVary dir binder

                   val (k, a', m', n', tac') = close rest dir' a m n tac
                   
                   (* tac' :: M' = N' : A' *)

                   val e = T.evar ()
                in
                   (k+1,
                    T.Elim (T.Const Prim.forall, [T.App e, T.App (T.Lam (binder, a'))]),
                    T.Lam (binder, m'),
                    T.Lam (binder, n'),
                    
                    (* (fn . M') = (fn . N') : forall E . A' *)
                    refine (Rule.forallIntroEq e a' m' n')
                    >>> [
                        (* E : type *)
                        chdir dir >>+ idtacM Secondary,

                        (* E |- M' = N' : A' *)
                        tac'
                        ])
                end)



      (* findMain i P bvs C test act fk

         if    P = C'{P'}
               C binds bvs variables
               C' binds bvs' variables
               (test, act) is a good rewrite core
               act (bvs+bvs') P' = SOME (M, N, spine, method)
               M is the ith hit within P
         then  P' = M spine
               returns (M, N, C{C'{ {} spine }}, method)
         else  calls fk (i - number of hits in P)
      *)
      fun findMain i p bvs c test act fk =
         let
            val p = N.simplify p
         in
            if i = 0 then
               (case act bvs p of
                   NONE =>
                      findTerm i p bvs c test act fk

                 | SOME (m, n, spine, method) =>
                      (case spine of
                          [] =>
                             (m, n, c, method)

                        | _ =>
                             (m, n, Felim1 spine :: c, method)))
            else
               if test bvs p then
                  findTerm (i-1) p bvs c test act fk
               else
                  findTerm i p bvs c test act fk
         end


      (* m in simple form *)
      and findTerm i p bvs c test act fk =
         (case p of
             T.Elim (h as T.Var _, spine) =>
                findSpine i spine bvs c h [] test act fk

           | T.Elim (h as T.Const _, spine) =>
                findSpine i spine bvs c h [] test act fk

           | T.Elim (h as T.Sub _, spine) =>
                findSpine i spine bvs c h [] test act fk

           | T.Elim (m1, spine) =>
                let
                   (* The check we already did should cover the head, so no need to check m1 again. *)
                   do i' = findTerm i m1 bvs (Felim1 spine :: c) test act
                in
                   findSpine i' spine bvs c m1 [] test act fk
                end

           | T.Lam (binder, m1) =>
                findMain i m1 (bvs + 1) (Flam binder :: c) test act fk

           | T.Pair (m1, m2) =>
                let
                   do i' = findMain i m1 bvs (Fpair1 m2 :: c) test act
                in
                   findMain i' m2 bvs (Fpair2 m1 :: c) test act fk
                end

           | T.Next m1 =>
                findMain i m1 bvs (Fnext :: c) test act fk

           | T.Triv => fk i

           | T.Native _ => fk i

           | T.Marker _ => fk i

           (* Other cases impossible for simple p. *)
           | _ => raise (Fail "impossible"))


      (* findSpine i spine bvs C h left test act fk

         if    h (rev left) spine = C'{P'}
               h is head or intro
               C binds bvs variables
               C' binds bvs' variables
               (test, act) is a good rewrite core
               act (bvs+bvs') P' = SOME (M, N, spine', method)
               M is the ith hit within spine
               bv' are bound by C'
         then  returns (M, N, C{C'{ {} spine' }}, method)
         else  calls fk (i - number of hits in spine)
      *)
      and findSpine i spine bvs c h left test act fk =
         (case spine of
             [] => fk i

           | (elim as T.App p) :: rest =>
                let
                   do i' = findMain i p bvs (Felim2 (h, left, rest) :: c) test act
                in
                   findSpine i' rest bvs c h (elim :: left) test act fk
                end

           | elim :: rest =>
                findSpine i rest bvs c h (elim :: left) test act fk)


      (* find i P (test, act)

         if    P = C{P'}
               C binds bvs variables
               (test, act) is a good rewrite core
               act bvs P' = SOME (M, N, spine, method)
               M is the ith hit within P
         then  P' = M spine
               returns (M, N, C{ {} spine }, method)
         else  raises (InsufficientHits <message>)
      *)
      fun find i p (test, act) =
         findMain i p 0 [] test act
         (fn i' =>
             let
                val hits = i - i'
             in
                if hits = 0 then
                   raise (InsufficientHits "no hits")
                else
                   raise (InsufficientHits (String.concat ["hits only ", Int.toString hits, " times"]))
             end)



      (* coe :: R M N *)
      fun mapCoercion covariant f m n coe =
         (case coe of
             Forward tac => 
                if covariant then
                   Forward (f m n tac)
                else
                   Backward (f m n tac)

           | Backward tac =>
                if covariant then
                   Backward (f n m tac)
                else
                   Forward (f n m tac))


      fun eqCoercionToTac coe =
         (case coe of
             Forward tac => tac

           | Backward tac =>
                refine (Rule.eqSymm (T.evar ()) (T.evar ()) (T.evar ()))
                >>+
                tac)


      fun eeqtpCoercionToTac coe =
         (case coe of
             Forward tac => tac

           | Backward tac =>
                refine (Rule.eeqtpSymm (T.evar ()) (T.evar ()))
                >>+
                tac)


      fun sequalCoercionToTac coe =
         (case coe of
             Forward tac => tac

           | Backward tac =>
                refine (Rule.sequalSymm (T.evar ()) (T.evar ()))
                >>+
                tac)



      (* Computation rewrites *)

      fun rewriteConclComputationLoop m n c rew =
         (case rew of
             Identity =>
                idtac
          
           | Beta =>
                replaceConcl (instantiate c n)

           | Reduce red =>
                refine (Rule.reduce (R.within (contextToPath c []) red))

           | Unreduce red =>
                refine (Rule.unreduce 
                           (instantiate c n) 
                           (R.within (contextToPath c []) red))

           | LetFold (j, p) =>
                (* suppose j unfolds to Q, and C binds k variables
                   then  M = P[Q[^k] . id]  and  N = P[j+k . id]

                   let instantiateShift C P = R
                   then  R[Q . id] = C{ P[Q[^k] . id] } = C{ M }
                         R[j . id] = C{ P[j[^k] . id] } = C{ P[j+k . id] } = C{ N }
                *)
                refine (Rule.letFold j (instantiateShift c p))

           | LetUnfold (j, p) =>
                refine (Rule.letUnfold j (instantiateShift c p))

           | Seq (rew1, p, rew2) =>
                rewriteConclComputationLoop m p c rew1 >>> [rewriteConclComputationLoop p n c rew2])


      fun rewriteHypComputationLoop hyp f m n c rew =
         (case rew of
             Identity =>
                idtac
          
           | Beta =>
                replaceHyp hyp (f (instantiate c n))

           | Reduce red =>
                refine (Rule.reduceHyp hyp (R.within (contextToPath c []) red))

           | Unreduce red =>
                refine (Rule.unreduceHyp hyp 
                           (instantiate c n) 
                           (R.within (contextToPath c []) red))

           | LetFold (j, p) =>
                if hyp < j then
                   refine (Rule.letFoldHyp j hyp (f (instantiateShift c p)))
                else
                   raise (RewriteFailure "hypothesis is out of scope of let binding")

           | LetUnfold (j, p) =>
                if hyp < j then
                   refine (Rule.letUnfoldHyp j hyp (f (instantiateShift c p)))
                else
                   raise (RewriteFailure "hypothesis is out of scope of let binding")

           | Seq (rew1, p, rew2) =>
                rewriteHypComputationLoop hyp f m p c rew1 >>> [rewriteHypComputationLoop hyp f p n c rew2])


      fun rewriteComputation i core hypopt (goal as (jud, _)) =
         (case hypopt of
             NONE =>
                (* concl *)
                let
                   val p = J.concl jud

                   val (m, n, c, cr) = find i p core

                   (* rewriting C{M} into C{N} using cr *)
                in
                   rewriteConclComputationLoop m n c cr
                end

           | SOME hyp =>
                let
                   val (p, f) =
                      (case J.hypOpt jud hyp of
                          SOME (J.Tm p) => (p, J.Tm)

                        | SOME (J.Tml p) => (p, J.Tml)

                        | SOME (J.Tmh p) => (p, J.Tmh)

                        | SOME (J.Tmlh p) => (p, J.Tmlh)

                        | SOME (J.Let p) => (p, J.Let)

                        | NONE =>
                             (* this shouldn't happen with a good directory *)
                             raise (RewriteFailure "nonexistent hypothesis")

                        | SOME _ =>
                             raise (RewriteFailure "hypothesis has the wrong sort"))
                
                   val (m, n, c, cr) = find i p core

                   (* rewriting C{M} into C{N} using cr *)
                in
                   rewriteHypComputationLoop hyp f m n c cr
                end)



      (* Relation rewrites *)

      (* propagateEquality dir C A M N tac =

         if    dir is the outer context (i.e., not including C's bindings)
               tac :: M = N : A
         then  tac' :: C{M} <:> C{N}
               and
               returns tac'
      *)
      fun propagateEquality dir c a m n tac =
         let
            val binders =
               List.foldl
                  (fns frame l =>
                      (case frame of
                          Flam binder => binder :: l
                        | _ => l))
                  [] c

            (* binders lists C's binders, outermost first *)
                  
            val (k, a', m', n', tac') = close binders dir a m n tac

            (* C binds k variables
               M' = fn ... fn . M  (k times)
               N' = fn ... fn . N  (k times)
               A' = forall E1 ... Ek . A
               tac' :: M' = N' : A'
            *)

            val spine =
               Int.natrecUp
                  (fns j l => T.App (T.Var (j+1)) :: l) 
                  [] k

            (* spine = k ... 1 *)

            val b = instantiateShift c (T.Elim (T.zero, spine))

            (* for all P, B[P . id] = C{ (0 k ... 1)[P[^k] . id] } = C{ P[^k] k-1 ... 0 }

               B[M' . id] = C{ M'[^k] k-1 ... 0 }
                          = C{ (fn ... fn . M)[^k] k-1 ... 0 }
                          = C{ (fn ... fn . M[0 ... k-1 . ^2k]) k-1 ... 0 }
                     =beta= C{ M[0 ... k-1 . ^2k][0 .... k-1 . id] }
                          = C{ M[0 ... k-1 . ^k] }
                          = C{ M }

               similarly B[N' . id] =beta= C{ N }
            *)
         in
            refine (Rule.weakenEqtpEeqtp (T.evar ()) (T.evar ()))
            >>+
            (* C{M} = C{N} : type
               that is:
               B[M' . id] = B[N' . id] : type
            *)
            refine (Rule.eqtpFunct a' b m' n')
            >>> [
                (* A' |- B : type *)
                chdir (D.bind0 dir) >>+ idtacM Secondary,

                (* M' = N' : A *)
                tac'
                ]
         end


      (* propagateSyntacticEquality dir C M N tac =

         if    dir is the outer context (i.e., not including C's bindings)
               tac :: sequal M N
         then  tac' :: sequal C{M} C{N}
               and
               returns SOME (sk tac')
               OR
               returns NONE

         There's no fundamental reason why we can't rewrite with syntactic equality under binders
         (as long as the equands don't mention the bound variable), but the rewriter's plumbing is
         wrong for it.  If we are rewriting C{M} to C{N} we need M = M'[^k] and N = N'[^k] (where k
         is the number of bindings in C), and we need to have sequal M' N'.  Instead, the coercion
         carries a tactic proving sequal M N.  We ought to be able to get sequal M' N', but only with
         different plumbing.  The plumbing is engineered for equalities (and relations) that are
         allowed to refer to bindings, and I don't want to bother implementing different plumbing for
         sequal when sequal is semi-deprecated anyway.
      *)
      fun propagateSyntacticEquality dir c m n tac =
         if 
            List.all
               (fn Flam _ => false
                 | _ => true)
               c
         then
            (* C contains no bindings *)
            let
               val b = instantiateShift c T.zero

               (* forall P, B[P . id] = C{ 0[P[^0] . id] } = C{ P }

                  so  B[M . id] = C{ M }
                  and B[N . id] = C{ N }
               *)

               val tac' =
                  (* sequal C{M} C{N}
                     that is:
                     sequal B[M . id] B[N . id]
                  *)
                  refine (Rule.sequalCompat m n b)
                  >>+
                  (* sequal M N *)
                  tac
            in
               SOME tac'
            end
         else
            (* C contains bindings, can't use syntactic equality *)
            NONE


      structure CICTable =
         CheckpointedHashTable 
         (structure Key =
             TripleHashable
             (structure X = Constant.Hashable
              structure Y = IntHashable
              structure Z = Constant.Hashable))

      val compatibilityTable : (relation * bool * int * (term -> term -> priority tacticm -> priority tacticm)) CICTable.table = CICTable.table ()
      val weakeningTable : (constant * bool * (term -> term -> priority tacticm -> priority tacticm)) list H.table = H.table ()


      (* returns the number of lambdas around C's hole, and gives their binders outermost first *)
      fun collectLambdas c n acc =
         (case c of
             Flam binder :: rest => collectLambdas rest (n + 1) (binder :: acc)

           | _ => (c, n, acc))


      fun tryRefl tc =
         first
            [
            EqualityTacticInternal.reflexivityPriority,
            idtacM tc
            ]


      fun diagnostic dir c rconst m n coe =
         let
            val dir' =
               List.foldr
                  (fns frame dir' =>
                      (case frame of
                          Flam binder =>
                             D.bindVary dir' binder

                        | _ =>
                             dir'))
                  dir
                  c
         in
            print "rewriting using ";
            print (Namespace.toString rconst);
            print "\n    ";
            Show.showIndent 4 dir' m;
            print
               (case coe of
                   Forward _ => "  ->\n    "
                 | Backward _ => "  <-\n    ");
            Show.showIndent 4 dir' n;
            print "  through:\n    ";
            Show.showIndent 4 dir (instantiate c (T.Marker hole))
         end
         

      (* propagateGeneral dir C rconst M N coe fk sk

         if    dir is the outer context (i.e., not including C's bindings)
               coe :: R M N
               R = rconst rspine
         then  either  calls sk (rconst', coe', fk')
                       where coe' :: R C{M} C{N}
                       and   R = rconst' rspine'
                       and   fk' is a backtracking opportunity
               or      calls fk ()
      *)
      fun propagateGeneral dir c rconst m n coe fk sk =
         let
            val () =
               if !trace then
                  diagnostic dir c rconst m n coe
               else
                  ()

            val (c', lams, binders) = collectLambdas c 0 []

            fun loopWeakenings l =
               (case l of
                   [] =>
                      (* nothing left to try; backtrack *)
                      fk ()

                 | (rconst', covariant, tacfn) :: rest =>
                      let
                         val coe' = mapCoercion covariant tacfn m n coe
                      in
                         propagateGeneral dir c rconst' m n coe'
                            (fn () => 
                                (
                                if !trace then
                                   (
                                   print "backtrack to ";
                                   diagnostic dir c rconst m n coe
                                   )
                                else
                                   ();

                                loopWeakenings rest
                                ))
                            sk
                      end)

            fun tryWeakenings () =
               (case H.find weakeningTable rconst of
                   NONE => fk ()

                 | SOME l => loopWeakenings l)
         in
            (case c' of
                [] =>
                   if lams = 0 then
                      (* top level *)
                      (
                      if !trace then
                         print "returning\n"
                      else
                         ();

                      sk (rconst, coe,
                          (fn () =>
                              (
                              if !trace then
                                 (
                                 print "backtrack to ";
                                 diagnostic dir [] rconst m n coe
                                 )
                              else
                                 ();

                              tryWeakenings ()
                              )))
                      )
                   else
                      (* Can't have bare lambdas at top level, it's a type error. *)
                      raise (RewriteFailure "type error propagating relation")
   
              | Felim2 (h as T.Const const, left, right) :: c'' =>
                   (* main engine here *)
                   let
                      val i = List.length left
                   in
                      (case CICTable.find compatibilityTable (const, i, rconst) of
                          NONE =>
                             tryWeakenings ()

                        | SOME (rel, covariant, binds, tacfn) =>
                             if binds = lams then
                                (* if    tac :: R M N
                                   then  tacfn m n tac :: R' (const left (fn ... fn . M) right) (const left (fn ... fn . N) right)
                                *)
                                let
                                   val m' =
                                      T.Elim (h,
                                              List.revAppend
                                                 left 
                                                 (T.App (List.foldr (fns binder m' => T.Lam (binder, m')) m binders)
                                                     :: right))

                                   val n' =
                                      T.Elim (h,
                                              List.revAppend
                                                 left
                                                 (T.App (List.foldr (fns binder n' => T.Lam (binder, n')) n binders)
                                                     :: right))

                                   val coe' = mapCoercion covariant tacfn m n coe
                                in
                                   (case rel of
                                       General rconst' =>
                                          if Constant.eq (rconst', Prim.sequal) then
                                             (case propagateSyntacticEquality dir c'' m' n' (sequalCoercionToTac coe') of
                                                 SOME tac =>
                                                    sk (Prim.sequal, Forward tac, fk)

                                               | NONE =>
                                                    fk ())
                                          else
                                             propagateGeneral dir c'' rconst' m' n' coe'
                                                (fn () =>
                                                    (
                                                    if !trace then
                                                       (
                                                       print "backtrack to ";
                                                       diagnostic dir c rconst m n coe
                                                       )
                                                    else
                                                       ();
             
                                                    tryWeakenings ()
                                                    ))
                                                sk
                                             
                                     | Equality a =>
                                          (* by invariant, A is closed *)
                                          let
                                             val tac = propagateEquality dir c'' a m' n' (eqCoercionToTac coe')
                                          in
                                             sk (Prim.eeqtp, Forward tac, fk)
                                          end)
                                end
                             else
                                raise (RewriteFailure "type error propagating relation"))
                   end

              | _ =>
                   (* Cannot propagate a non-equality relation through anything else.
                      (Note: if we make it possible to propagate into equality, we'll need
                      to backtrack here.)
                   *)
                   raise (RewriteFailure "cannot propagate relation"))
         end
      

      fun propagate dir c rel m n coe fk sk =
         (case rel of
             Equality a =>
                let
                   val tac = propagateEquality dir c a m n (eqCoercionToTac coe)
                in
                   sk (Prim.eeqtp, Forward tac, fk)
                end

           | General rconst =>
                if Constant.eq (rconst, Prim.sequal) then
                   (case propagateSyntacticEquality dir c m n (sequalCoercionToTac coe) of
                       SOME tac =>
                          sk (Prim.sequal, Forward tac, fk)
                          
                     | NONE =>
                          propagateGeneral dir c rconst m n coe fk sk)
                else
                   propagateGeneral dir c rconst m n coe fk sk)


      (* if f raises RewriteFailure, handle it *)
      fun liftRewrite f =
         lift
         (fn () =>
             try
                f ()
             with
                RewriteFailure msg => fail msg)


      fun rewriteRelation i core hypopt (jud, dir) sequel =
         (case hypopt of
             NONE =>
                let
                   val a = J.concl jud

                   val (m, n, c, (rel, coe)) = find i a core
       
                   (* rewriting A = C{M} into C{N} *)

                   do (rconst, coe', fk) =
                      propagate dir c rel m n coe
                      (fn () => raise (RewriteFailure "cannot propagate relation"))

                   val b = instantiate c n
                in
                   if Constant.eq (rconst, Prim.eeqtp) then
                      let
                         val tac = eeqtpCoercionToTac coe'

                         (* tac :: eeqtp C{M} C{N} = eeqtp A B *)
                      in
                         (* A *)
                         refine (Rule.subsumptionAlt b (T.evar ()))
                         >>> [
                             (* A <:> B *)
                             tac >>= tryRefl,

                             (* B *)
                             sequel
                             ]
                      end

                   else if Constant.eq (rconst, Prim.entailment) then
                      (case
                          (case coe' of
                              Backward tac => SOME tac
                            | Forward _ => NONE)
                       of
                          NONE =>
                             (* wrong direction *)
                             fk ()
                             
                        | SOME tac =>
                             (* tac :: B |- A[^] *)
                             (* A *)
                             refine (Rule.assert b (T.evar ()))
                             >>> [
                                 (* B *)
                                 sequel,

                                 (* B |- A[^] *)
                                 tac >>= tryRefl
                                 ])

                   else if Constant.eq (rconst, Prim.sequal) then
                      let
                         val tac = sequalCoercionToTac coe'

                         (* tac :: sequal C{M} C{N} = sequal A B *)
                      in
                         (* A *)
                         refine (Rule.sequivalence b (T.evar ()))
                         >>> [
                             (* sequal B A *)
                             refine (Rule.sequalSymm (T.evar ()) (T.evar ()))
                             >>+
                             (* sequal A B *)
                             tac >>= tryRefl,

                             (* B *)
                             sequel
                             ]
                      end

                   else
                      fk ()
                end

           | SOME hyp =>
                (case J.hypOpt jud hyp of
                    SOME (J.Tm a) =>
                       let
                          val ash = T.Sub (a, T.Shift (hyp+1))

                          val (m, n, c, (rel, coe)) = find i ash core

                          (* rewriting A[^hyp+1] = C{M} into C{N}
                             coe :: R M N
                             R = rconst rspine
                          *)

                          val bsh = instantiate c n

                          val b = T.evar ()
                       in
                          if not (Unify.unify1 (T.Sub (b, T.Shift (hyp+1))) bsh) then
                             fail "rewrite produces term out of scope"
                          else
                             let
                                do (rconst, coe', fk) =
                                   propagate dir c rel m n coe 
                                   (fn () => raise (RewriteFailure "cannot propagate relation"))
                             in
                                if Constant.eq (rconst, Prim.eeqtp) then
                                   let
                                      val tac = eeqtpCoercionToTac coe'
                                   in
                                      (* A, ... |- J *)
                                      refine (Rule.subsumptionLeftAlt hyp (T.evar ()) b (T.evar ()))
                                      >>> [
                                          (* A, ... |- |- A[^hyp+1] <:> B[^hyp+1] *)
                                          tac >>= tryRefl,
      
                                          (* B, ... |- J *)
                                          sequel
                                          ]
                                   end
      
                                else if Constant.eq (rconst, Prim.subtype) then
                                   (case coe' of
                                       Backward _ =>
                                          (* wrong direction *)
                                          fk ()

                                     | Forward tac =>
                                          (* tac :: A, ... |- A[^hyp+1] <: B[^hyp+1] *)
                                          (* A, ... |- J *)
                                          ifthen (refine (Rule.exchange 0 hyp 1))
                                             (
                                             (* ..., A[^hyp] |- J[..] *)
                                             refine (Rule.subsumptionLast 0 (T.evar ()) (T.Sub (b, T.Shift hyp)) (T.evar ()))
                                             >>> [
                                                 (* ..., A[^hyp] |- A[^hyp+1] <: B[^hyp+1] *)
                                                 refine (Rule.exchange 0 1 hyp)
                                                 >>+
                                                 (* A, ... |- A[^hyp+1] <: B[^hyp+1] *)
                                                 tac >>= tryRefl,

                                                 (* ..., B[^hyp] |- J[..] *)
                                                 refine (Rule.exchange 0 1 hyp)
                                                 >>+
                                                 (* B, ... |- J *)
                                                 sequel
                                                 ]
                                             )
                                             (* If the exchange failed, try to propagate a different way, in hopes that we might get to eetp. *)
                                             (liftRewrite fk))

                                else if Constant.eq (rconst, Prim.entailment) then
                                   (case coe' of
                                       Backward _ =>
                                          (* wrong direction *)
                                          fk ()
      
                                     | Forward tac =>
                                          (* tac :: A, ..., A[^hyp+1] |- B[^hyp+2] *)
                                          ifthenl
                                             (* A, ... |- J *)
                                             (refine (Rule.assert' ash (T.evar ()))
                                              >>> [
                                                  (* A, ... |- A[^hyp+1] *)
                                                  refine (Rule.hypothesis hyp) >> done,
      
                                                  (* A, ..., A[^hyp+1] |- J[^] *)
                                                  refine (Rule.assert (T.Sub (b, T.Shift (hyp+2))) (T.evar ()))
                                                  >>> [
                                                      (* A, ..., A[^hyp+1] |- B[^hyp+2] *)
                                                      idtac,
      
                                                      (* A, ..., A[^hyp+1], B[^hyp+2] |- J[^2] *)
                                                      (* This will fail if there are any dependencies on the original A. *)
                                                      refine (Rule.weaken (hyp+2) 1)
                                                      (* ..., A[^hyp], B[^hyp+1] |- J[..] *)
                                                      ]
                                                  ])
                                             [
                                             (* A, ..., A[^hyp+1] |- B[^hyp+2] *)
                                             tac >>= tryRefl,
      
                                             (* ..., A[^hyp], B[^hyp+1] |- J[..] *)
                                             refine (Rule.weaken 1 1)
                                             >>+
                                             (* ..., B[^hyp] |- J[..] *)
                                             refine (Rule.exchange 0 1 hyp)
                                             >>+
                                             (* B, ... |- J *)
                                             sequel
                                             ]
                                             (* If the weakening failed, try to propagate a different way, in hopes that we might get to eeqtp. *)
                                             (liftRewrite fk))
      
                                else if Constant.eq (rconst, Prim.sequal) then
                                   let
                                      val tac = sequalCoercionToTac coe'

                                      (* tac :: sequal C{M} C{N} = sequal A[^hyp+1] B[^hyp+1] *)
                                   in
                                      (* A, ... |- J *)
                                      refine (Rule.sequivalenceLeft hyp (T.evar ()) b (T.evar ()))
                                      >>> [
                                          (* A, ... |- sequal A[^hyp+1] B[^hyp+1] *)
                                          tac >>= tryRefl,

                                          (* B, ... |- J *)
                                          sequel
                                          ]
                                   end

                                else
                                   fk ()
                             end
                       end

                  | NONE =>
                       (* this shouldn't happen with a good directory *)
                       raise (RewriteFailure "nonexistent hypothesis")

                  | SOME _ =>
                       raise (RewriteFailure "hypothesis has the wrong sort")))



      (* Main entry point *)

      (* rewriteOnce rew h i nohits sequel

         Rewrite hypothesis/concl h using rew on the ith hit.  If there are fewer than i hits,
         call (nohits msg), where msg is an error message that could be used.
      *)

      fun rewriteOnce rew h i nohits sequel =
         let
            do hypopt = Hyp.findhypOrConcl h

            do goal = withgoal
         in
            try
               (case rew hypopt goal of
                   Computation core =>
                      rewriteComputation i core hypopt goal
                      >>+
                      sequel

                 | Relation core =>
                      rewriteRelation i core hypopt goal sequel)
            with
               RewriteFailure msg => fail msg
             | InsufficientHits msg => nohits msg
         end


      fun loosenCore (test, act) =
         let
            fun test' _ _ = true

            fun act' bvs m =
               (case act bvs m of
                   NONE =>
                      raise (RewriteFailure "rewrite fails at given position")

                 | res as SOME _ => res)
         in
            (test', act')
         end


      fun loosen rew hyp l =
         (case rew hyp l of
             Computation core => Computation (loosenCore core)
           | Relation core => Relation (loosenCore core))


      type captures = symbol option list
      type targets = (Hyp.hypothesis * (bool * int list) option) list


      fun rewriteLoop rew targets sequel =
         (case targets of
             [] =>
                sequel

           | (hyp, occ) :: rest =>
                (case occ of
                    NONE =>
                    (* rewrite until it fails *)
                       rewriteOnce rew hyp 0 
                          (fn _ => lift (fn () => rewriteLoop rew rest sequel))
                          (lift (fn () => rewriteLoop rew targets sequel))

                  | SOME (loose, l) =>
                       let
                          val rew' =
                             if loose then
                                loosen rew
                             else
                                rew

                          fun innerloop l () =
                             (case l of
                                 [] =>
                                    rewriteLoop rew rest sequel

                               | i :: resti =>
                                    rewriteOnce rew' hyp i fail
                                       (lift (innerloop resti)))
                       in
                          innerloop l ()
                       end))

      fun rewriteOuterLoop aims =
         (case aims of
             [] =>
                idtacM Primary

           | (rew, targets) :: rest =>
                (rewriteLoop rew targets
                    (lift (fn () => rewriteOuterLoop rest))))

      fun rewritePriority aims =
         cut $
         transformFailure 
            (fn msg => "rewrite failed: " ^ msg)
            (rewriteOuterLoop aims)


      fun rewriteRaw targets = rewritePriority targets >> idtac

      fun rewrite targets = Typecheck.withTypecheckSnd $ rewritePriority targets

      fun rewriteThen targets tac = andthenlPad (rewrite targets) [tac] idtac



      (* Matching testers *)

      (* Need this for typing purposes *)
      fun find' i a core =
         let
            val (m, n, c, _) = find i a core
         in
            (m, n, c)
         end

      fun testRewriteMain rew h i f =
         try
            let
               val goal as (jud, dir) = Prover.currentGoal ()
   
               val (a, hyp) =
                  (case Hyp.hypothesisToHypOrConcl goal h of
                      NONE =>
                         (Judgement.concl jud, NONE)

                    | SOME h =>
                         let
                            val a = 
                               (case J.hypOpt jud h of
                                    SOME (J.Tm a) => a
                                  | SOME (J.Tml a) => a
                                  | SOME (J.Tmh a) => a
                                  | SOME (J.Tmlh a) => a
                                  | _ => raise (Invalid "hypothesis has wrong sort"))
                         in
                            (T.Sub (a, T.Shift (h+1)), SOME h)
                         end)
   
               val mark = Trail.mark ()
   
               val (m, n, c) =
                  (case rew hyp goal of
                      Computation core => find' i a core
                    | Relation core => find' i a core)
   
               val dir' =
                  List.foldr
                     (fns frame d => 
                         (case frame of
                             Flam binder => D.bindVary d binder

                           | _ => d))
                     dir
                     c
            in
               f dir' m n dir c;
               Trail.rewind mark
            end
         with
            exn as RewriteFailure msg =>
               (
               print "Rewrite failed: ";
               print msg;
               print "\n";
               raise exn
               )
          | exn as D.Unbound sym =>
               (
               print "Unbound identifier ";
               print (Symbol.toValue sym);
               print "\n";
               raise exn
               )

      val hole = T.Marker (Symbol.fromValue "hole")

      fun testRewrite rews =
         List.app
            (fn (rew, targets) =>
                List.app
                   (fn (sym, occ) =>
                       (case occ of
                           NONE =>
                              (* all doesn't make sense in this context, skip *)
                              ()

                         | SOME (loose, l) =>
                              let
                                 val rew' = if loose then loosen rew else rew
                                 
                                 val str = if loose then "position" else "hit"
                              in
                                 List.app
                                    (fn i =>
                                        testRewriteMain rew' sym i
                                        (fns dir m n outerdir c =>
                                            Message.message 0 0
                                               (fn () =>
                                                   (
                                                   print "Rewriting ";
                                                   print str;
                                                   print " ";
                                                   print (Int.toString i);
                                                   print "\n";
                                                   Show.show dir m;
                                                   print "-->\n";
                                                   Show.show dir n;
                                                   print "within:\n";
                                                   Show.show outerdir (instantiate c hole);
                                                   print "\n"
                                                   ))))
                                    l
                              end))
                   targets)
            rews
                                     

      fun identityRew _ _ = Computation ((fns _ _ => true), (fns _ m => SOME (m, m, [], Identity)))

      fun showPosition targets =
         List.app
            (fn (sym, occ) =>
                (case occ of
                    NONE =>
                       (* all doesn't make sense in this context, skip *)
                       ()

                  | SOME (_, l) =>
                       List.app
                          (fn i =>
                              testRewriteMain identityRew sym i
                              (fns dir m _ outerdir c =>
                                  Message.message 0 0
                                     (fn () =>
                                         (
                                         print "Position ";
                                         print (Int.toString i);
                                         print ":\n";
                                         Show.show outerdir (instantiate c hole);
                                         print "containing:\n";
                                         Show.show dir m;
                                         print "\n"
                                         ))))
                          l))
            targets



      (* A rough-and-ready categorization of terms.
         Slightly different from the one in typecheck.
      *)

      datatype pseudohead =
         Pvar of int
       | Pconst of Constant.constant
       | Plam
       | Ppair
       | Pnext
       | Ptriv
       | Pweird

      (* m simple *)
      fun pseudohead m =
         (case m of
             T.Elim (T.Var i, _) => Pvar i
           | T.Elim (T.Const const, _) => Pconst const
           | T.Elim (T.Sub _, _) => Pweird

           | T.Lam _ => Plam
           | T.Elim (T.Lam _, _) => Plam

           | T.Pair _ => Ppair
           | T.Elim (T.Pair _, _) => Ppair

           | T.Next _ => Pnext
           | T.Elim (T.Next _, _) => Pnext

           | T.Triv => Ptriv

           | T.Elim (T.Triv, _) =>
                (* this is always a type error, but might as well be uniform about it *)
                Ptriv

           | T.Native _ => Pweird
           | T.Marker _ => Pweird
           | T.Elim (T.Native _, _) => Pweird
           | T.Elim (T.Marker _, _) => Pweird

           | _ =>
                raise (Fail "precondition"))

      fun pseudoheadEq ps under shift ps' =
         (case (ps, ps') of
             (Pvar i, Pvar j) =>
                (i < under andalso i = j)
                orelse
                (i >= under andalso i + shift = j)

           | (Pconst k, Pconst k') => Constant.eq (k, k')

           | (Plam, Plam) => true
           | (Ppair, Ppair) => true
           | (Pnext, Pnext) => true
           | (Ptriv, Ptriv) => true
           | (Pweird, Pweird) => true

           | _ => false)



      (* Rewriters *)

      (* replace p with n, p in whnf *)
      fun replaceComputation cond added m p crew =
         let
            val cond' = cond p

            fun test bvs n =
               let
                  val bvs' = bvs - added
               in
                  if
                     bvs' >= 0
                     andalso
                     cond' added bvs' n
                  then
                     let
                        val mark = Trail.mark ()

                        val p' =
                           if bvs' = 0 then
                              p
                           else
                              (* underShift does not disturb weak-head normal form, modulo simplification *)
                              N.simplify (T.Sub (p, T.underShift added bvs'))

                        val b = Option.isSome (P.unifyPrefix p' n)
                     in
                        Trail.rewind mark;
                        b
                     end
                  else
                     false
               end

            fun act bvs n =
               let
                  val bvs' = bvs - added
               in
                  if
                     bvs' >= 0
                     andalso
                     cond' added bvs' n
                  then
                     let
                        val mark = Trail.mark ()

                        val s = T.underShift added bvs'

                        val p' =
                           if bvs' = 0 then
                              p
                           else
                              (* underShift does not disturb weak-head normal form, modulo simplification *)
                              N.simplify (T.Sub (p, s))
                     in
                        (case P.unifyPrefix p' n of
                            NONE =>
                               (
                               Trail.rewind mark;
                               NONE
                               )
   
                          | SOME spine' =>
                               SOME (n, T.Elim (T.Sub (m, s), spine'), [],
                                     crew s spine'))
                     end
                  else
                     NONE
               end
         in
            Computation (test, act)
         end


      (* always proceed, for "xConv" rewrites *)
      fun condYes _ _ _ _ = true

      (* proceed only if pseudoheads match *)
      fun condMaybe p =
         let
            val ps = pseudohead p
         in
            fns added bvs' n => pseudoheadEq ps added bvs' (pseudohead n)
         end



      fun unreduceMain cond added m red =
         replaceComputation cond added m 
            (try 
                N.whnf (R.reduce red m)
             with
                R.Reduce => raise (RewriteFailure "reduction fails on term"))
            (fns _ _ => Unreduce red)
             
      val unreduceMainNoconv = unreduceMain condMaybe
      val unreduceMainConv = unreduceMain condYes

            

      fun letFoldMain cond added varglobal varlocal n spine =
         replaceComputation cond added 
            (T.Elim (T.Var varlocal, spine))
            (N.whnf (T.Elim (n, spine)))
            (fns s spine' =>
                LetFold (varglobal, T.Elim (T.zero,
                                            T.ssubst spine (T.compose s T.shift1)
                                            @ T.ssubst spine' T.shift1)))

      val letFoldMainNoconv = letFoldMain condMaybe
      val letFoldMainConv = letFoldMain condYes
         
            

      fun letrecRollMain cond added varglobal varlocal body spine =
         replaceComputation cond added
            (T.Elim (T.Var varlocal, spine))
            (N.whnf (T.Elim (T.Sub (body, T.Idot (varlocal, T.id)), spine)))
            (fns s spine' =>
                let
                   val spine_s = T.ssubst spine s
                   val spines = spine_s @ spine'
                   val spines_sh = T.ssubst spines T.shift1
                in
                   Seq (LetUnfold (varglobal,
                                   T.Elim (T.Sub (body, T.Idot (0, T.compose s T.shift1)), spines_sh)),
                        T.Elim (T.Sub (body,
                                       T.Dot (T.apply1 Prim.fix (T.Lam (NONE, T.Sub (body, T.under 1 s))), 
                                              s)),
                                spines),
                        Seq (Unreduce (R.user PrimReduction.unroll_fix),
                             T.Elim (T.Const Prim.fix,
                                     T.App (T.Lam (NONE, T.Sub (body, T.under 1 s))) :: spines),
                             LetFold (varglobal,
                                      T.Elim (T.Var 0, spines_sh))))
                end)

      val letrecRollMainNoconv = letrecRollMain condMaybe
      val letrecRollMainConv = letrecRollMain condYes



      fun foldMain main letmain capture em hyp (jud, dir) =
         let
            val sh =
               (case hyp of
                   NONE => 0

                 | SOME i => i+1)
               
            val dir' = D.shift dir sh

            val m = N.simplify (ET.withdir dir' (ET.additional capture em))
            val added = List.length capture
         in
            (case m of
                T.Elim (T.Const const, _) =>
                   (case Constant.definition const of
                       NONE =>
                          raise (RewriteFailure "head constant is opaque")

                     | SOME _ =>
                          main added m R.unfold)

              | T.Elim (T.Var j, spine) =>
                   (case J.hyp jud (j+sh-added) of
                       J.Let n =>
                          letmain added (j+sh-added) j (T.Sub (n, T.Shift (j+1))) spine

                     | _ =>
                          raise (RewriteFailure "head variable is not let bound"))

              | _ => raise (RewriteFailure "term is not rigid"))
         end

      val foldRew : symbol option list -> eterm -> rewrite = foldMain unreduceMainNoconv letFoldMainNoconv
      val convertFoldRew : symbol option list -> eterm -> rewrite = foldMain unreduceMainConv letFoldMainConv

      fun fold aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (foldRew capture em, targets))
                aims)

      fun convertFold aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (convertFoldRew capture em, targets))
                aims)



      fun multipleUnfold i m acc =
         if i = 0 then
            (m, R.trans acc)
         else
            multipleUnfold
               (i-1)
               (try
                   R.reduce (R.trans [R.unfold, R.betas]) m
                with
                   R.Reduce => 
                      raise (RewriteFailure "target term cannot be unfolded enough times"))
               (R.unfold :: R.betas :: acc)


      fun foldsRew i capture em hyp (jud, dir) =
         if i < 0 then
            raise (RewriteFailure "negative folds count")
         else
            let
               val sh =
                  (case hyp of
                      NONE => 0
   
                    | SOME i => i+1)

               val dir' = D.shift dir sh
   
               val m = N.simplify (ET.withdir dir' (ET.additional capture em))
               val added = List.length capture

               val (n, red) = multipleUnfold i m []
            in
               replaceComputation condMaybe added m n (fns _ _ => Unreduce red)
            end

      fun folds i aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (foldsRew i capture em, targets))
                aims)




      fun unreduceUsingMain main capture em red hyp (_, dir) =
         let
            val dir' =
               (case hyp of
                   NONE => dir
                 | SOME i => D.shift dir (i+1))

            val m = N.simplify (ET.withdir dir' (ET.additional capture em))
         in
            main (List.length capture) m red
         end

      val unreduceUsingRew : symbol option list -> eterm -> Reduction.reduction -> rewrite = unreduceUsingMain unreduceMainNoconv
      val convertUnreduceUsingRew : symbol option list -> eterm -> Reduction.reduction -> rewrite = unreduceUsingMain unreduceMainConv

      fun unreduceUsing aims =
         rewriteRaw
            (List.map
                (fn ((capture, em, red), targets) => (unreduceUsingRew capture em red, targets))
                aims)

      fun convertUnreduceUsing aims =
         rewriteRaw
            (List.map
                (fn ((capture, em, red), targets) => (convertUnreduceUsingRew capture em red, targets))
                aims)



      fun unfoldMain reduce head hyp (jud, dir) =
         (case head (D.idir dir) of
             D.Hvar varglobal =>
                let
                   val varlocal =
                      (case hyp of
                          NONE => varglobal
       
                        | SOME i =>
                             if i < varglobal then
                                varglobal - i - 1
                             else
                                raise (RewriteFailure "hypothesis is out of scope of let binding"))
                in
                   (case J.hyp jud varglobal of
                       J.Let m =>
                          let
                             fun test bvs n =
                                (case n of
                                    T.Elim (T.Var v, _) => v = varlocal+bvs
          
                                  | _ => false)
          
                             fun act bvs n =
                                (case n of
                                    T.Elim (T.Var v, spine) =>
                                       if v = varlocal+bvs then
                                          let
                                             val n' = T.Elim (T.Sub (m, T.Shift (varlocal+bvs+1)), spine)
                                             val cr = LetUnfold (varglobal, T.Elim (T.zero, T.ssubst spine T.shift1))
                                          in
                                             if reduce then
                                                SOME (n, N.whnf n', [], Seq (cr, n', Beta))
                                             else
                                                SOME (n, n', [], cr)
                                          end
                                       else
                                          NONE
          
                                  | _ => NONE)
                          in
                             Computation (test, act)
                          end

                     | _ => raise (RewriteFailure "variable is not let bound"))
                end

           | D.Hconst const =>
                (case Constant.definition const of
                    NONE =>
                       raise (RewriteFailure "constant is opaque")
       
                  | SOME m =>
                       let
                          fun test _ n =
                             (case n of
                                 T.Elim (T.Const const', _) =>
                                    Constant.eq (const, const')
       
                               | _ => false)
       
                          fun act _ n =
                             (case n of
                                 T.Elim (T.Const const', spine) =>
                                    if Constant.eq (const, const') then
                                       let
                                          val n' = T.Elim (m, spine)
                                       in
                                          if reduce then
                                             SOME (n, N.whnf n', [], Seq (Reduce R.unfold, n', Beta))
                                          else
                                             SOME (n, n', [], Reduce R.unfold)
                                       end
                                    else
                                       NONE
       
                               | _ => NONE)
                       in
                          Computation (test, act)
                       end))

      val unfoldRew = unfoldMain true
      val unfoldHeadRew = unfoldMain false

      fun unfold aims =
         rewriteRaw
            (List.map
                (fn (head, targets) => (unfoldRew head, targets))
                aims)

      fun unfoldHead aims =
         rewriteRaw
            (List.map
                (fn (head, targets) => (unfoldHeadRew head, targets))
                aims)



      fun reduceUsingRew red hyp _ =
         let
            fun test _ m =
               (try
                   let
                      val _ = Reduction.reduce red m
                   in
                      true
                   end
                with
                   Reduction.Reduce => false)

            fun act _ m =
               (try
                   let
                      val n = Reduction.reduce red m
                   in
                      SOME (m, n, [], Reduce red)
                   end
                with
                   Reduction.Reduce => NONE)
         in
            Computation (test, act)
         end

      fun reduceUsing aims =
         rewriteRaw
            (List.map
                (fn (red, targets) => (reduceUsingRew red, targets))
                aims)



      fun rollMain main letrecMain capture em hyp (jud, dir) =
         let
            val dir' =
               (case hyp of
                   NONE => dir
                 | SOME i => D.shift dir (i+1))

            val m = N.simplify (ET.withdir dir' (ET.additional capture em))
         in
            (case m of
                T.Elim (T.Const const, _) =>
                   (case Database.findUnroll const of
                       NONE =>
                          raise (RewriteFailure "term is not unrollable")

                     | SOME red =>
                          main (List.length capture) m red)

              | T.Elim (T.Var varlocal, spine) =>
                   let
                      val added = List.length capture

                      val varglobal =
                         (case hyp of
                             NONE => varlocal - added

                           | SOME i => varlocal - added + i + 1)
                   in
                      (case J.hypOpt jud varglobal of
                          SOME (J.Let n) =>
                             termCase n
                             /| \Prim.fix\ (fn . ?) =>
                                \(fnc body =>
                                     letrecMain added varglobal varlocal (T.Sub (body, T.underShift 1 (varlocal+1))) spine)\

                              | _ =>
                                \(fnc => raise (RewriteFailure "term is not unrollable"))\
                             /

                        | _ => raise (RewriteFailure "term is not unrollable"))
                   end

              | _ => raise (RewriteFailure "term has no head constant/variable"))
         end

      val rollRew : symbol option list -> eterm -> rewrite = rollMain unreduceMainNoconv letrecRollMainNoconv
      val convertRollRew : symbol option list -> eterm -> rewrite = rollMain unreduceMainConv letrecRollMainConv

      fun roll aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (rollRew capture em, targets))
                aims)

      fun convertRoll aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (convertRollRew capture em, targets))
                aims)



      fun unrollRew head hyp (jud, dir) =
         (case head (D.idir dir) of
             D.Hvar varglobal =>
                let
                   val varlocal =
                      (case hyp of
                          NONE => varglobal

                        | SOME i =>
                             if i < varglobal then
                                varglobal - i - 1
                             else
                                raise (RewriteFailure "hypothesis is out of scope of letrec binding"))
                in
                   (case J.hypOpt jud varglobal of
                       SOME (J.Let m) =>
                          termCase m
                          /| \Prim.fix\ (fn . ?) =>
                             \(fnc body =>
                                  let
                                     fun test bvs n =
                                        (case n of
                                            T.Elim (T.Var v, _) => v = varlocal+bvs
    
                                          | _ => false)
    
                                     fun act bvs n =
                                        (case n of
                                            T.Elim (T.Var v, spine) =>
                                               if v = varlocal+bvs then
                                                  let
                                                     val m' = T.Sub (m, T.Shift (varlocal+bvs+1))
                                                     val n' = T.Elim (T.Sub (body, T.Idot (varlocal+bvs, T.Shift (varlocal+bvs+1))), spine)
   
                                                     val cr =
                                                        Seq (LetUnfold (varglobal, T.Elim (T.zero, T.ssubst spine T.shift1)),
                                                             T.Elim (m', spine),
                                                             Seq (Reduce (R.user PrimReduction.unroll_fix),
                                                                  T.Elim (T.Sub (body, T.Dot (m', T.Shift (varlocal+bvs+1))), spine),
                                                                  Seq (LetFold (varglobal, 
                                                                                T.Elim (T.Sub (body, T.Idot (0, T.Shift (varlocal+bvs+2))),
                                                                                        T.ssubst spine T.shift1)),
                                                                       n',
                                                                       Beta)))
                                                  in
                                                     SOME (n, N.whnf n', [], cr)
                                                  end
                                               else
                                                  NONE
    
                                          | _ => NONE)
                                  in
                                     Computation (test, act)
                                  end)\
    
                           | _ =>
                             \(fnc => raise (RewriteFailure "variable is not unrollable"))\
                          /
   
                     | _ =>
                          raise (RewriteFailure "variable is not unrollable"))
                end

           | D.Hconst const =>
                let
                   val red =
                      (case Database.findUnroll const of
                          NONE =>
                             raise (RewriteFailure "constant is not unrollable")
       
                        | SOME red => red)
       
                   fun test _ m =
                      (case m of
                          T.Elim (T.Const const', _) =>
                             if Constant.eq (const, const') then
                                (try
                                    (
                                    R.reduce red m;
                                    true
                                    )
                                 with R.Reduce => false)
                             else
                                false
       
                        | _ => false)
       
                   fun act _ m =
                      (case m of
                          T.Elim (T.Const const', _) =>
                             if Constant.eq (const, const') then
                                (try
                                    let
                                       val n = R.reduce red m
                                    in
                                       SOME (m, n, [], Reduce red)
                                    end
                                 with R.Reduce => NONE)
                             else
                                NONE
       
                        | _ => NONE)
                in
                   Computation (test, act)
                end)

      fun unroll aims =
         rewriteRaw
            (List.map
                (fn (head, targets) => (unrollRew head, targets))
                aims)


            
      fun unrollTypeMain const elevopt hyp (_, dir) =
         let
            val levopt =
               (case elevopt of
                   NONE => NONE

                 | SOME (capture, elev) => 
                      SOME (ET.withdir dir (ET.additional capture elev)))

            val (arity, red, root) =
               if Constant.eq (const, Prim.mu) then
                  (1, R.refl, Prim.mu)
               else if Constant.eq (const, Prim.rec) then
                  (1, R.refl, Prim.rec)
               else
                  (case Constant.definition const of
                      NONE =>
                         raise (RewriteFailure "type is not unrollable")

                    | SOME a =>
                         let
                            fun loop n a =
                               termCase a
                               /| fn . ? =>
                                  \(fnc b => loop (n+1) b)\

                                | \Prim.mu\ (fn . _) =>
                                  \(fnc => (n, Prim.mu))\

                                | \Prim.rec\ (fn . _) =>
                                  \(fnc => (n, Prim.rec))\

                                | _ =>
                                  \(fnc => raise (RewriteFailure "type is not unrollable"))\
                               /

                            val (arity, root) = loop 0 a
                         in
                            (arity, R.trans [R.unfold, R.beta arity], root)
                         end)

            fun arityMatch i spine =
               if i = 0 then
                  List.null spine
               else
                  (case spine of
                      T.App _ :: rest => arityMatch (i-1) rest

                    | _ => false)

            fun test _ m =
               (case m of
                   T.Elim (T.Const const', spine) =>
                      Constant.eq (const', const)
                      andalso
                      arityMatch arity spine

                 | _ => false)
         in
            if Constant.eq (root, Prim.mu) then
               let            
                  fun act _ m =
                     (case m of
                         T.Elim (T.Const const', spine) =>
                            if 
                               Constant.eq (const', const)
                               andalso
                               arityMatch arity spine
                            then
                               termCase (R.reduce red m)
                               / \Prim.mu\ (fn ? . ?) =>
                                 \(fnc binder body =>
                                      let
                                         val tac =
                                            (* M <:> Body[M . id] *)
                                            replaceConcl 
                                               (T.apply2 Prim.eeqtp m (T.app (T.Lam (NONE, body)) m))
                                            >>
                                            (* M <:> (fn . Body) M *)
                                            refine (Rule.reduce (R.compat [red, R.trans [R.compat [red], R.beta 1]]))
                                            >>
                                            (* mu (fn . Body) <:> Body[mu (fn . Body) . id] *)
                                            (case levopt of
                                                NONE =>
                                                   refine (Rule.muUnroll body)
                                                   >>> [
                                                       (* Type |- Body : Type *)
                                                       chdir (D.bindVary dir binder) >> idtacM Secondary,
                       
                                                       (* positive (fn . Body) *)
                                                       chdir dir
                                                       >>
                                                       idtacM Secondary
                                                       ]
      
                                              | SOME lev =>
                                                   refine (Rule.muUnrollUniv body lev)
                                                   >>> [
                                                       (* lev : level *)
                                                       chdir dir
                                                       >>
                                                       idtacM Secondary,
      
                                                       (* U lev |- Body : U lev *)
                                                       chdir (D.bindVary dir binder) >> idtacM Secondary,
      
                                                       (* positive (fn . Body) *)
                                                       chdir dir
                                                       >>
                                                       idtacM Secondary
                                                       ])
                                      in
                                         SOME (m, T.Sub (body, T.Dot (m, T.id)), [],
                                               (General Prim.eeqtp, Forward tac))
                                      end)\
                               /
                            else
                               NONE
      
                       | _ => NONE)
               in
                  Relation (test, act)
               end

            else
               (* by construction, root is Prim.rec *)
               (case levopt of
                   NONE =>
                      let
                         fun act _ m =
                            (case m of
                                T.Elim (T.Const const', spine) =>
                                   if 
                                      Constant.eq (const', const)
                                      andalso
                                      arityMatch arity spine
                                   then
                                      termCase (R.reduce red m)
                                      / \Prim.rec\ (fn ? . ?) =>
                                        \(fnc binder body =>
                                             let
                                                val tac =
                                                   (* M = Body[M . id] : type *)
                                                   replaceConcl 
                                                      (T.apply2 Prim.eqtp m (T.app (T.Lam (NONE, body)) m))
                                                   >>
                                                   (* M = (fn . Body) M : type *)
                                                   refine (Rule.reduce (R.compat [red, R.trans [R.compat [red], R.beta 1]]))
                                                   >>
                                                   (* rec (fn . Body) = Body[rec (fn . Body) . id] : type *)
                                                   refine (Rule.recUnroll body)
                                                   >>
                                                   (* later Type |- Body : Type *)
                                                   chdir (D.bindVary dir binder) >> idtacM Secondary
                                             in
                                                SOME (m, T.Sub (body, T.Dot (m, T.id)), [],
                                                      (General Prim.eqtp, Forward tac))
                                             end)\
                                      /
                                   else
                                      NONE
             
                              | _ => NONE)
                      in
                         Relation (test, act)
                      end

                 | SOME lev =>
                      let
                         fun act _ m =
                            (case m of
                                T.Elim (T.Const const', spine) =>
                                   if 
                                      Constant.eq (const', const)
                                      andalso
                                      arityMatch arity spine
                                   then
                                      termCase (R.reduce red m)
                                      / \Prim.rec\ (fn ? . ?) =>
                                        \(fnc binder body =>
                                             let
                                                val u = T.apply1 Prim.univ lev

                                                val tac =
                                                   (* M = Body[M . id] : U lev *)
                                                   replaceConcl 
                                                      (T.apply3 Prim.eq u m (T.app (T.Lam (NONE, body)) m))
                                                   >>
                                                   (* M = (fn . Body) M : U lev *)
                                                   refine (Rule.reduce (R.compat [R.refl, red, R.trans [R.compat [red], R.beta 1]]))
                                                   >>
                                                   (* rec (fn . Body) = Body[rec (fn . Body) . id] : U lev *)
                                                   refine (Rule.recUnrollUniv body lev)
                                                   >>> [
                                                       (* lev : level *)
                                                       chdir dir
                                                       >>
                                                       idtacM Secondary,
      
                                                       (* later (U lev) |- Body : U lev *)
                                                       chdir (D.bindVary dir binder) >> idtacM Secondary
                                                       ]
                                             in
                                                SOME (m, T.Sub (body, T.Dot (m, T.id)), [],
                                                      (Equality u, Forward tac))
                                             end)\
                                      /
                                   else
                                      NONE
             
                              | _ => NONE)
                      in
                         Relation (test, act)
                      end)
         end


      fun unrollTypeRew const hyp goal = unrollTypeMain const NONE hyp goal

      fun unrollTypeUnivRew capture const lev hyp goal = unrollTypeMain const (SOME (capture, lev)) hyp goal

      fun unrollType aims =
         rewrite
            (List.map
                (fn (const, targets) => (unrollTypeRew const, targets))
                aims)

      fun unrollTypeUniv aims =
         rewrite
            (List.map
                (fn ((capture, const, lev), targets) => (unrollTypeUnivRew capture const lev, targets))
                aims)



      fun convertRew capture em hyp (_, dir) =
         let
            val dir' =
               (case hyp of
                   NONE => dir
                 | SOME i => D.shift dir (i+1))

            val m = ET.withdir dir' (ET.additional capture em)
            val m' = N.whnf m

            val added = List.length capture

            fun test bvs n =
               if bvs < added then
                  false
               else
                  let
                     val mark = Trail.mark ()
   
                     val s = T.underShift added (bvs-added)
   
                     val res = P.unifyPrefix (N.simplify (T.Sub (m', s))) n
                  in
                     Trail.rewind mark;
                     Option.isSome res
                  end

            fun act bvs n =
               if bvs < added then
                  NONE
               else
                  let
                     val mark = Trail.mark ()
   
                     val s = T.underShift added (bvs-added)
                  in
                     (case P.unifyPrefix (N.simplify (T.Sub (m', s))) n of
                         NONE => 
                            (
                            Trail.rewind mark;
                            NONE
                            )
      
                       | SOME spine => SOME (n, T.Elim (T.Sub (m, s), spine), [], Beta))
                  end
            in
               Computation (test, act)
            end

      fun convert aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (convertRew capture em, targets))
                aims)



      fun convertHeadRew capture const em hyp (_, dir) =
         let
            val dir' =
               (case hyp of
                   NONE => dir
                 | SOME i => D.shift dir (i+1))

            val m = ET.withdir dir' (ET.additional capture em)
            val m' = N.whnf m

            val added = List.length capture

            fun test bvs n =
               if bvs < added then
                  false
               else
                  (case n of
                      T.Elim (T.Const const', _) =>
                         Constant.eq (const, const')
                         andalso
                         let
                            val mark = Trail.mark ()
          
                            val s = T.underShift added (bvs-added)
          
                            val res = P.unifyPrefix (N.simplify (T.Sub (m', s))) n
                         in
                            Trail.rewind mark;
                            Option.isSome res
                         end

                    | _ => false)

            fun act bvs n =
               if bvs < added then
                  NONE
               else
                  (case n of
                      T.Elim (T.Const const', _) =>
                         if Constant.eq (const, const') then
                            let
                               val mark = Trail.mark ()
             
                               val s = T.underShift added (bvs-added)
                            in
                               (case P.unifyPrefix (N.simplify (T.Sub (m', s))) n of
                                   NONE => 
                                      (
                                      Trail.rewind mark;
                                      NONE
                                      )
                
                                 | SOME spine =>
                                      SOME (n, T.Elim (T.Sub (m, s), spine), [], Beta))
                            end
                         else
                            NONE

                    | _ => NONE)
         in
            Computation (test, act)
         end

      fun convertHead aims =
         rewriteRaw
            (List.map
                (fn ((capture, const, em), targets) => (convertHeadRew capture const em, targets))
                aims)





      fun reduceRew _ _ =
         let
            fun act _ n =
               SOME (n, N.normalize n, [], Beta)
         in
            Computation ((fns _ _ => true), act)
         end

      fun whreduceRew _ _ =
         let
            fun act _ n =
               SOME (n, N.whnf n, [], Beta)
         in
            Computation ((fns _ _ => true), act)
         end

      fun reduceHardRew _ _ =
         let
            fun act _ n =
               SOME (n, N.normalizeHard n, [], Beta)
         in
            Computation ((fns _ _ => true), act)
         end

      fun whreduceHardRew _ _ =
         let
            fun act _ n =
               SOME (n, N.whnfHard n, [], Beta)
         in
            Computation ((fns _ _ => true), act)
         end

      fun reduce targets = rewriteRaw [(reduceRew, targets)]

      fun whreduce targets = rewriteRaw [(whreduceRew, targets)]

      fun reduceHard targets = rewriteRaw [(reduceHardRew, targets)]

      fun whreduceHard targets = rewriteRaw [(whreduceHardRew, targets)]



      fun reduceParamRew _ _ =
         let
            fun test _ n =
               (case n of
                   T.Elim (T.Const const, T.App func :: T.App _ :: _) =>
                      Constant.eq (const, Prim.paramapp)
                      andalso
                      (case N.simplify func of
                          T.Lam _ => true

                        | _ => false)

                 | _ =>
                      false)

            fun act _ n =
               (case n of
                   T.Elim (T.Const const, T.App func :: T.App arg :: spine) =>
                      if Constant.eq (const, Prim.paramapp) then
                         (case N.simplify func of
                             T.Lam (_, body) =>
                                (case Irrelevance.irrelevance (Irrelevance.IntSet.singleton 0) body of
                                    SOME red =>
                                       let
                                          val body' = R.reduce red body

                                          (* red : body --> body' and body' does not contain 0 *)

                                          val red1 =
                                             R.trans
                                                [
                                                (* paramapp (fn . body) arg spine *)
                                                R.unfold,
                                                (* (fn . fn . 1 unavailable) (fn . body) arg spine *)
                                                R.beta 2,
                                                (* (fn . body) unavailable spine *)
                                                R.within [0, 0] red,
                                                (* (fn . body') unavailable spine *)
                                                R.beta 1
                                                (* body' [unavailable . id] spine *)
                                                ]

                                          val red2 =
                                             R.trans
                                                [
                                                (* (fn . body) arg spine *)
                                                R.within [0, 0] red,
                                                (* (fn . body') arg spine *)
                                                R.beta 1
                                                (* body' [arg . id] spine = body' [unavailable . id] spine *)
                                                ]

                                          val red3 =
                                             (* (fn . body) arg spine *)
                                             R.beta 1
                                             (* body [arg . id] spine *)

                                          val n12 = T.Elim (T.Sub (body', T.Dot (T.Const Prim.unavailable, T.id)), spine)
                                          val n23 = T.Elim (T.Lam (NONE, body), T.App arg :: spine)
                                             
                                          (* red1 : paramapp (fn . body) arg spine --> N12
                                             red2 : N23 --> N12
                                             red3 : N23 --> body [arg . id] spine
                                          *)
                                          
                                          val rew =
                                             Seq (Reduce red1, n12, Seq (Unreduce red2, n23, Reduce red3))
                                       in
                                          SOME (n, T.Elim (T.Sub (body, T.Dot (arg, T.id)), spine), [], rew)
                                       end

                                  | NONE => NONE)

                           | _ => NONE)
                      else
                         NONE

                 | _ => NONE)
         in
            Computation (test, act)
         end

      fun reduceParamLoop hyps =
         (case hyps of
             [] => idtacM Primary

           | hyp :: resthyps =>
                let
                   do ho = Hyp.findhypOrConcl hyp

                   fun loop () =
                      (case ho of
                          SOME h => refine (Rule.normalizeHyp h)
   
                        | NONE => refine Rule.normalizeConcl)
                      >>+
                      rewriteOnce reduceParamRew hyp 0
                         (fn _ => reduceParamLoop resthyps)
                         (lift loop)
                in
                   loop ()
                end)

      fun reduceParam hyps =
         (case hyps of
             [] => reduceParamLoop [Hyp.NAME conclSym]
           | _ => reduceParamLoop hyps)
         >>+ idtac



      val maxInt =
         (case Int.maxInt of
             NONE => raise (Fail "impossible")

           | SOME x => x)

      fun matchIrrLoop i irrl mspine nspine lastred =
         (case (mspine, nspine) of
             ([], _) =>
                SOME (nspine, lastred)

           | (T.App m :: mrest, T.App n :: nrest) =>
                let
                   val (j, red_j, irrl') =
                      (case irrl of
                          [] => (maxInt, R.refl, [])

                        | (i, red) :: rest => (i, red, rest))
                in
                   if i = j then
                      (
                      (* if an argument is an evar, unify it in even if it's irrelevant *)
                      (case N.simplify m of
                          T.Elim (T.Sub (T.Evar eb, s), []) =>
                             (* Normally s is id, so this can't fail.  Failure means something weird is going on.
                                We'll ignore it.
                             *)
                             (Prune.setEbindSub eb s n; ())

                        | _ => 
                             ());

                      matchIrrLoop (i+1) irrl' mrest nrest red_j
                      )
                   else if Unify.unify1 m n then
                      matchIrrLoop (i+1) irrl mrest nrest lastred
                   else
                      NONE
                end

           | (T.Pi1 :: mrest, T.Pi1 :: nrest) =>
                matchIrrLoop i irrl mrest nrest lastred

           | (T.Pi2 :: mrest, T.Pi2 :: nrest) =>
                matchIrrLoop i irrl mrest nrest lastred

           | (T.Prev :: mrest, T.Prev :: nrest) =>
                matchIrrLoop i irrl mrest nrest lastred

           | _ => NONE)
                

      fun convertIrrRew capture em hyp (jud, dir) =
         let
            val sh =
               (case hyp of
                   NONE => 0

                 | SOME i => i+1)

            val dir' = D.shift dir sh

            val m = N.simplify (ET.withdir dir' (ET.additional capture em))
            val added = List.length capture
         in
            (case m of
                T.Elim (T.Const const, mspine) =>
                   (case Database.findIrrelevance const of
                       NONE =>
                          raise (RewriteFailure "no irrelevance information for head")

                     | SOME irrl =>
                          let
                             fun test bvs n =
                                let
                                   val bvs' = bvs - added
                                in
                                   bvs' >= 0
                                   andalso
                                   (case n of
                                       T.Elim (T.Const const', nspine) =>
                                          Constant.eq (const, const')
                                          andalso
                                          let
                                             val mspine' =
                                                if bvs' = 0 then
                                                   mspine
                                                else
                                                   T.ssubst mspine (T.underShift added bvs')

                                             val mark = Trail.mark ()

                                             val b = Option.isSome $ matchIrrLoop 0 irrl mspine' nspine R.refl
                                          in
                                             Trail.rewind mark;
                                             b
                                          end

                                     | _ => false)
                                end

                             fun act bvs n =
                                let
                                   val bvs' = bvs - added
                                in
                                   if bvs' >= 0 then
                                      (case n of
                                          T.Elim (T.Const const', nspine) =>
                                             if Constant.eq (const, const') then
                                                let
                                                   val mspine' =
                                                      if bvs' = 0 then
                                                         mspine
                                                      else
                                                         T.ssubst mspine (T.underShift added bvs')

                                                   val mark = Trail.mark ()
                                                in
                                                   (case matchIrrLoop 0 irrl mspine' nspine R.refl of
                                                       SOME (leftover, red) =>
                                                          let
                                                             val m' = T.Elim (T.Const const, mspine' @ leftover)
                                                             val p = R.reduce red n
                                                          in
                                                             SOME (n, m', [], Seq (Reduce red, p, Unreduce red))
                                                          end

                                                     | NONE =>
                                                          (
                                                          Trail.rewind mark;
                                                          NONE
                                                          ))
                                                end
                                             else
                                                NONE
   
                                        | _ => NONE)
                                   else
                                      NONE
                                end
                          in
                             Computation (test, act)
                          end)

              | T.Elim (T.Var _, _) =>
                   raise (RewriteFailure "term head is a variable")

              | _ =>
                   raise (RewriteFailure "term is not rigid"))
         end
                   
      fun convertIrr aims =
         rewriteRaw
            (List.map
                (fn ((capture, em), targets) => (convertIrrRew capture em, targets))
                aims)



      fun replaceRew capture em en ea hyp (_, dir) =
         let
            val idir = D.idir dir

            val (idir', added) =
               List.foldl
                  (fns symopt (idir, added) =>
                      (case symopt of
                          NONE => (D.ibind0 idir, added+1)

                        | SOME sym => (D.ibind idir sym, added+1)))
                  (idir, 0)
                  capture

            val m = N.simplify (ET.withidir idir' em)
            val n = ET.withidir idir' en
            val a = ET.withidir idir' ea

            val () =
               (case m of
                   T.Elim (T.Sub _, _) =>
                      raise (RewriteFailure "term being rewritten has an evar head")

                 | _ => ())

            fun test bvs p =
               let
                  val bvs' = bvs - added
               in
                  bvs' >= 0
                  andalso
                  let
                     val mark = Trail.mark ()

                     val m' =
                        if bvs' = 0 then
                           m
                        else
                           N.simplify (T.Sub (m, T.underShift added bvs'))

                     val hit = Option.isSome (P.identicalPrefix m' p)
                  in
                     Trail.rewind mark;
                     hit
                  end
               end

            fun act bvs p =
               let
                  val bvs' = bvs - added
               in
                  if bvs' >= 0 then
                     let
                        val mark = Trail.mark ()
   
                        val s = T.underShift added bvs'

                        val ms = N.simplify (T.Sub (m, s))
                     in
                        (case P.identicalPrefix ms p of
                            NONE =>
                               (
                               Trail.rewind mark;
                               NONE
                               )

                          | SOME spine =>
                               SOME 
                               (ms, T.Sub (n, s), spine,
                                (Equality (T.Sub (a, s)),
                                
                                 Forward
                                    (
                                    (* M[s] = N[s] : A[s] *)
                                    idtacM Primary
                                    ))))
                     end
                  else
                     NONE
               end
         in
            Relation (test, act)
         end



      fun usingRew strict reverse capture elem hyp (jud, dir) =
         let
            val (ctx, dir, added) =
               List.foldl
               (fns symopt (ctx, dir, added) =>
                   let
                      val dir' = D.bindh dir symopt
                   in
                      (Seq.cons (J.Tm (T.evar ())) ctx, dir', added+1)
                   end)
               (J.context jud, dir, 0)
               capture

            val lem = ET.withdir dir elem

            do (c, ctac) =
               B.soMain ctx lem
               (fn "" => raise (RewriteFailure "type inference failed")
                 | msg => raise (RewriteFailure ("type inference failed: " ^ msg)))

            (* ctac :: G |- C *)

            do (b, btac) = B.exploitMain true c ctac
               
            (* btac :: G |- B *)
         in
            (case N.whnf b of
                T.Elim (T.Const rconst, rspine) =>
                   (case List.rev rspine of
                       T.App nPre :: T.App mPre :: restSpineRev =>
                          (* btac :: R Mpre Npre *)
                          let
                             val (m, n) =
                                if reverse then
                                   (nPre, mPre)
                                else
                                   (mPre, nPre)
                                
                             val m = N.simplify m
                             
                             val prefix = if strict then P.identicalPrefix else P.intermediatePrefix

                             val () =
                                (case m of
                                    T.Elim (T.Sub _, _) =>
                                       raise (RewriteFailure "term being rewritten has an evar head")

                                  | _ => ())
                             
                             fun test bvs p =
                                let
                                   val bvs' = bvs - added
                                in
                                   bvs' >= 0
                                   andalso
                                   let
                                      val mark = Trail.mark ()

                                      val m' =
                                         if bvs' = 0 then
                                            m
                                         else
                                            N.simplify (T.Sub (m, T.underShift added bvs'))

                                      val hit = Option.isSome (prefix m' p)
                                   in
                                      Trail.rewind mark;
                                      hit
                                   end
                                end

                             fun act bvs p =
                                let
                                   val bvs' = bvs - added
                                in
                                   if bvs' >=  0 then
                                      let
                                         val mark = Trail.mark ()

                                         val s = T.underShift added bvs'
                                         val ms = N.simplify (T.Sub (m, s))
                                      in
                                         (case prefix ms p of
                                             NONE =>
                                                (
                                                Trail.rewind mark;
                                                NONE
                                                )

                                           | SOME spine =>
                                                let
                                                   val rel =
                                                      if Constant.eq (rconst, Prim.eq) then
                                                         (case restSpineRev of
                                                             [T.App a] =>
                                                                Equality (T.Sub (a, s))

                                                           | _ =>
                                                                raise (RewriteFailure "type error propagating relation"))
                                                      else
                                                         General rconst

                                                   val tac =
                                                      if bvs' = 0 then
                                                         btac
                                                      else
                                                         refine (Rule.weaken added bvs')
                                                         >>+ chdir dir
                                                         >>+ btac

                                                   val coe =
                                                      if reverse then
                                                         Backward tac
                                                      else
                                                         Forward tac
                                                in
                                                   SOME (ms, T.Sub (n, s), spine, (rel, coe))
                                                end)
                                      end
                                   else
                                      NONE
                                end

                          in
                             Relation (test, act)
                          end

                     | _ =>
                          raise (RewriteFailure "lemma conclusion is not a relation"))
                   
              | _ =>
                   raise (RewriteFailure "lemma conclusion does not have constant head"))
         end



      fun reduceSeqRew hyp (jud, dir) =
         let
            fun test _ n =
               (case n of
                   T.Elim (T.Const const, spine) =>
                      (Constant.eq (const, Prim.seq)
                       orelse
                       Constant.eq (const, Prim.seqt))
                      andalso
                      (case spine of
                          T.App _ :: T.App bodylam :: _ =>
                             (case N.whnf bodylam of
                                 T.Lam _ => true
                               | _ => false)

                        | _ => false)

                 | _ => false)

            fun act _ n =
               (case n of
                   T.Elim (T.Const const, spine) =>
                      if
                         Constant.eq (const, Prim.seq)
                         orelse
                         Constant.eq (const, Prim.seqt)
                      then
                         (case spine of
                             T.App arg :: T.App bodylam :: rest =>
                                (case N.whnf bodylam of
                                    T.Lam (_, body) =>
                                       if Valuability.valuability arg > 0 then
                                          let
                                             val pretac =
                                                if Constant.eq (const, Prim.seq) then
                                                   idtac
                                                else
                                                   refine (Rule.reduce (R.within [1] R.unfold))

                                             (* pretac turns seqt into seq, if necessary *)

                                             val tac =
                                                pretac
                                                >>+
                                                (* sequal (seq Arg (fn . Body)) (Body [Arg . id]) *)
                                                (* since Arg is valuable, these will unify *)
                                                refine (Rule.sequalIntro (T.evar ()))
                                                >> done
                                          in
                                             SOME (T.Elim (T.Const const, [T.App arg, T.App bodylam]),
                                                   T.Sub (body, T.Dot (arg, T.id)),
                                                   rest,
                                                   (General Prim.sequal, Forward tac))
                                          end
                                       else
                                          let
                                             val a = T.evar ()

                                             val pretac =
                                                if Constant.eq (const, Prim.seq) then
                                                   idtac
                                                else
                                                   refine (Rule.reduce (R.within [1] R.unfold))

                                             (* pretac turns seqt into seq, if necessary *)
                                             val tac =
                                                pretac
                                                >>+
                                                (* sequal (seq Arg (fn . Body)) (Body [Arg . id]) *)
                                                refine (Rule.reduceSeqTotal a (T.evar ()) (T.evar ()))
                                                >>> [
                                                    (* Arg : A *)
                                                    idtacM Secondary,

                                                    (* total A *)
                                                    idtacM Secondary
                                                    ]
                                          in
                                             SOME (T.Elim (T.Const const, [T.App arg, T.App bodylam]),
                                                   T.Sub (body, T.Dot (arg, T.id)),
                                                   rest,
                                                   (General Prim.sequal, Forward tac))
                                          end

                                  | _ => NONE)

                           | _ => NONE)
                      else
                         NONE

                 | _ => NONE)
         in
            Relation (test, act)
         end

      fun reduceSeqPriority targets = rewritePriority [(reduceSeqRew, targets)]
      fun reduceSeqRaw targets = reduceSeqPriority targets >> idtac
      fun reduceSeq targets = Typecheck.withTypecheckSnd $ reduceSeqPriority targets



      (* Weakenings *)

      fun weakenEqtpEeqtp a b tac =
         (* A <:> B *)
         refine (Rule.weakenEqtpEeqtp a b)
         >>+
         (* A = B : type *)
         tac


      fun weakenEeqtpSubtype a b tac =
         (* A <: B *)
         refine (Rule.prodElim1 (T.evar ()) (T.apply2 Prim.subtype b a))
         >>+
         (* A <: B & B <: A *)
         refine (Rule.unreduce (T.apply2 Prim.eeqtp a b) Reduction.unfold)
         >>+
         (* A <:> B *)
         tac


      (* contravariant *)
      fun weakenEeqtpSubtype' a b tac =
         (* B <: A *)
         refine (Rule.prodElim2 (T.apply2 Prim.subtype a b) (T.evar ()))
         >>+
         (* A <: B & B <: A *)
         refine (Rule.unreduce (T.apply2 Prim.eeqtp a b) Reduction.unfold)
         >>+
         (* A <:> B *)
         tac


      fun weakenSubtypeArrow a b tac =
         (* A -> B *)
         refine (Rule.weakenSubtypeArrow (T.evar ()) (T.evar ()))
         >>+
         (* A <: B *)
         tac


      fun weakenArrowEntailment a b tac =
         (* A |- B[^] *)
         refine (Rule.arrowElim (T.Sub (a, T.shift1)) (T.evar ()))
         >>> [
             (* A |- A[^] -> B[^] *)
             refine (Rule.weaken 0 1)
             >>+
             (* |- A -> B *)
             tac,

             (* A |- A[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun weakenImpliesArrow a b tac =
         (* A -> B *)
         refine (Rule.unreduce (T.apply2 Prim.implies a b) R.unfold)
         >>+
         (* implies A B *)
         tac


      fun weakenEeqtpIff a b tac =
         (* A <-> B *)
         refine (Rule.weakenEeqtpIff a b)
         >>+
         (* A <:> B *)
         tac


      fun weakenIffArrow a b tac =
         (* A -> B *)
         refine (Rule.prodElim1 (T.evar ()) (T.evar ()))
         >>+
         (* (A -> B) & (B -> A) *)
         refine (Rule.unreduce (T.apply2 Prim.iff a b) (R.trans [R.unfold, R.beta 2]))
         >>+
         (* iff A B *)
         tac


      fun weakenIffArrow' a b tac =
         (* B -> A *)
         refine (Rule.prodElim2 (T.evar ()) (T.evar ()))
         >>+
         (* (A -> B) & (B -> A) *)
         refine (Rule.unreduce (T.apply2 Prim.iff a b) (R.trans [R.unfold, R.beta 2]))
         >>+
         (* iff A B *)
         tac


      val () = 
         List.app
            (fn (const, const', cov, f) =>
                let
                   val entry = (const', cov, f)
                in
                   H.insertMerge weakeningTable const [entry] (fn l => entry :: l)
                end)
            [
            (Prim.eqtp, Prim.eeqtp, true, weakenEqtpEeqtp),
            (Prim.eeqtp, Prim.subtype, true, weakenEeqtpSubtype),
            (Prim.eeqtp, Prim.subtype, false, weakenEeqtpSubtype'),
            (Prim.subtype, Prim.arrow, true, weakenSubtypeArrow),
            (Prim.arrow, Prim.entailment, true, weakenArrowEntailment),
            (Prim.implies, Prim.arrow, true, weakenImpliesArrow),
            (Prim.eeqtp, Prim.iff, true, weakenEeqtpIff),
            (Prim.iff, Prim.arrow, true, weakenIffArrow),
            (Prim.iff, Prim.arrow, false, weakenIffArrow'),
            ]



      (* Compatibilities *)

      fun compatForallEqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A = A' : type
                    forall A . B = forall A' . B : type
                 *)
                 refine (Rule.forallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A' : type *)
                     tac,
        
                     (* A |- B = B : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatForallEqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B = B' : type 
                    forall A . B = forall A . B' : type 
                 *)
                 refine (Rule.forallEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B = B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatExistsEqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A = A' : type
                    exists A . B = exists A' . B : type
                 *)
                 refine (Rule.existsEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A' : type *)
                     tac,
        
                     (* A |- B = B : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatExistsEqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B = B' : type
                    exists A . B = exists A . B' : type
                 *)
                 refine (Rule.existsEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B = B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatArrowEqtp0 a a' tac =
         (* tac :: A = A' : type
            A -> B = A' -> B : type
         *)
         refine (Rule.arrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A' : type *)
             tac,

             (* A |- B[^] = B[^] : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* A |- B[^] : type *)
             let
                do (_, dir) = withgoal
             in
                chdir (D.bind0 dir) >>+ idtacM Secondary
             end
             ]


      fun compatArrowEqtp1 b b' tac =
         (* tac :: B = B' : type
            A -> B = A -> B' : type
         *)
         refine (Rule.arrowEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* A |- B[^] = B'[^] : type *)
             refine (Rule.weaken 0 1)
             >>+
             (* B = B' : type *)
             tac,
             ]


      fun compatProdEqtp0 a a' tac =
         (* tac :: A = A' : type
            A & B = A' & B : type
         *)
         refine (Rule.prodEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A' : type *)
             tac,

             (* B = B : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatProdEqtp1 b b' tac =
         (* tac :: B = B' : type
            A & B = A & B' : type
         *)
         refine (Rule.prodEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B = B' : type *)
             tac,
             ]


      fun compatDprodEqtp0 a a' tac =
         (* tac :: A = A' : type
            A &d B = A' &d B : type
         *)
         refine (Rule.dprodEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A' : type *)
             tac,

             (* B = B : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatDprodEqtp1 b b' tac =
         (* tac :: B[^] = B'[^] : type
            A &d B = A &d B' : type
         *)
         refine (Rule.dprodEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* A |- B[^] = B'[^] : type *)
             refine (Rule.weaken 0 1)
             >>+
             (* B = B' : type *)
             tac
             ]


      fun compatSumEqtp0 a a' tac =
         (* tac :: A = A' : type
            A -> B = A' -> B : type
         *)
         refine (Rule.sumEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A' : type *)
             tac,

             (* B = B : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatSumEqtp1 b b' tac =
         (* tac :: B = B'
            A -> B = A -> B'
         *)
         refine (Rule.sumEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B = B' : type *)
             tac,
             ]


      fun compatFutureEqtp a a' tac =
         (* tac :: A = A' : type
            future A = future A' : type
         *)
         refine (Rule.futureEq (T.evar ()) (T.evar ()))
         >>+
         (* promote |- A = A' : type *)
         tac


      fun compatIntersectEqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.intersect\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A = A' : type
                    intersect A . B = intersect A' . B : type
                 *)
                 refine (Rule.intersectEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A' : type *)
                     tac,
        
                     (* A |- B = B : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatIntersectEqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.intersect\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B = B' : type 
                    intersect A . B = intersect A . B' : type 
                 *)
                 refine (Rule.intersectEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B = B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatUnionEqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.union\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A = A' : type
                    union A . B = union A' . B : type
                 *)
                 refine (Rule.unionEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A' : type *)
                     tac,
        
                     (* A |- B = B : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatUnionEqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.union\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B = B' : type 
                    union A . B = union A . B' : type 
                 *)
                 refine (Rule.unionEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B = B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatGuardIff0 a a' tac =
         (* tac :: A <-> A'
            A -g> B = A' -g> B : type
         *)
         refine (Rule.guardEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <-> A' *)
             tac,

             (* A |- B[^] = B[^] : type *)
             let
                do (_, dir) = withgoal
             in
                refine (Rule.eqtpRefl (T.evar ()))
                >>+
                chdir (D.bind0 dir) >>+ idtacM Secondary
             end
             ]


      fun compatGuardEqtp1 b b' tac =
         (* tac :: B = B' : type
            A -g> B = A -g> B' : type
         *)
         refine (Rule.compatGuardEqtp1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B = B' : type *)
             tac,
             ]


      fun compatSetEqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.set\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A = A' : type
                    { A | B } = { A' | B } : type
                 *)
                 refine (Rule.compatSetEqtp0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A' : type *)
                     tac,
        
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatSetIff1 b b' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.set\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <-> B'
                    set A . B = set A . B' : type
                 *)
                 refine (Rule.setEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A : type *)
                     refine (Rule.eqtpSymm (T.evar ()) (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B <-> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatIsetEqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.iset\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A = A' : type
                    iset A . B = iset A' . B : type
                 *)
                 refine (Rule.isetEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A' : type *)
                     tac,
        
                     (* A |- B = B : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatIsetEqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eqtp\ _ (\Prim.iset\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B = B' : type
                    iset A . B = iset A . B' : type
                 *)
                 refine (Rule.isetEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A = A : type *)
                     refine (Rule.eqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B = B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatSquashIff a a' tac =
         (* tac :: A <-> A'
            squash A = squash A' : type
         *)
         refine (Rule.squashEq (T.evar ()) (T.evar ()))
         >>+
         (* A <-> A' *)
         tac


      fun compatEqtpEqtp0 _ _ tac =
         (* tac :: A = A' : type *)
         (* (A = B : type) = (A' = B : type) : type *)
         refine (Rule.eqtpEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A' : type *)
             tac,
      
             (* B = B : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>
             (* B : type *)
             idtacM Secondary
             ]
      

      fun compatEqtpEqtp1 _ _ tac =
         (* tac :: B = B' : type *)
         (* (A = B : type) = (A = B' : type) : type *)
         refine (Rule.eqtpEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>
             (* B : type *)
             idtacM Secondary,
             
             (* B = B' : type *)
             tac
             ]


      fun compatEqEqtp0 _ _ tac =
         (* tac :: A = A' : type *)
         (* (M = N : A) = (M = N : A') : type *)
         refine (Rule.eqEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A = A' : type *)
             tac,

             (* M = M : A *)
             refine (Rule.eqRefl (T.evar ()) (T.evar ()))
             >>+
             (* M : A *)
             idtacM Secondary,

             (* N = N : A *)
             refine (Rule.eqRefl (T.evar ()) (T.evar ()))
             >>+
             (* N : A *)
             idtacM Secondary,
             ]


      fun compatEqUnivEqtp1 _ _ tac =
         (* tac :: A = A' : type *)
         (* (A = B : Ui) = (A' = B : U i) : type *)
         refine (Rule.eqEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* Ui = Ui : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>
             (* Ui : type *)
             refine (Rule.univForm (T.evar ()))
             >>
             (* I : level *)
             idtacM Secondary,

             (* A = A' : Ui *)
             refine (Rule.univIntroEqtype (T.evar ()) (T.evar ()) (T.evar ()))
             >>> [
                 (* A = A' : type *)
                 tac,

                 (* A : Ui *)
                 idtacM Secondary,

                 (* A' : Ui *)
                 idtacM Secondary
                 ],

             (* B = B : Ui *)
             refine (Rule.eqRefl (T.evar ()) (T.evar ()))
             >>
             (* B : Ui *)
             idtacM Secondary
             ]


      fun compatEqUnivEqtp2 _ _ tac =
         (* tac :: B = B' : type *)
         (* (A = B : Ui) = (A = B' : U i) : type *)
         refine (Rule.eqEq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* Ui = Ui : type *)
             refine (Rule.eqtpRefl (T.evar ()))
             >>
             (* Ui : type *)
             refine (Rule.univForm (T.evar ()))
             >>
             (* I : level *)
             idtacM Secondary,

             (* A = A : Ui *)
             refine (Rule.eqRefl (T.evar ()) (T.evar ()))
             >>
             (* A : Ui *)
             idtacM Secondary,

             (* B = B' : Ui *)
             refine (Rule.univIntroEqtype (T.evar ()) (T.evar ()) (T.evar ()))
             >>> [
                 (* B = B' : type *)
                 tac,

                 (* B : Ui *)
                 idtacM Secondary,

                 (* B' : Ui *)
                 idtacM Secondary
                 ],
             ]


      fun compatForallEeqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <:> A'
                    forall A . B <:> forall A' . B
                 *)
                 refine (Rule.forallEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A' *)
                     tac,
        
                     (* A |- B <:> B *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatForallEeqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B <:> B'
                    forall A . B <:> forall A . B'
                 *)
                 refine (Rule.forallEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B <:> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatExistsEeqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <:> A'
                    exists A . B <:> exists A' . B
                 *)
                 refine (Rule.existsEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A' *)
                     tac,
        
                     (* A |- B <:> B *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatExistsEeqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B <:> B'
                    exists A . B <:> exists A . B'
                 *)
                 refine (Rule.existsEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B <:> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatArrowEeqtp0 a a' tac =
         (* tac :: A <:> A'
            A -> B <:> A' -> B
         *)
         refine (Rule.arrowEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A' *)
             tac,

             (* B <:> B *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatArrowEeqtp1 b b' tac =
         (* tac :: B <:> B'
            A -> B <:> A -> B'
         *)
         refine (Rule.arrowEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <:> B' *)
             tac,
             ]


      fun compatProdEeqtp0 a a' tac =
         (* tac :: A <:> A'
            A & B <:> A' & B
         *)
         refine (Rule.prodEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A' *)
             tac,

             (* B <:> B *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatProdEeqtp1 b b' tac =
         (* tac :: B <:> B'
            A & B <:> A & B'
         *)
         refine (Rule.prodEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <:> B' *)
             tac,
             ]


      fun compatDprodEeqtp0 a a' tac =
         (* tac :: A <:> A'
            A &d B <:> A' &d B
         *)
         refine (Rule.dprodEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A' *)
             tac,

             (* A |- B[^] <:> B[^] *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* A |- B[^] : type *)
             let
                do (_, dir) = withgoal
             in
                chdir (D.bind0 dir) >>+ idtacM Secondary
             end
             ]


      fun compatDprodEeqtp1 b b' tac =
         (* tac :: B[^] <:> B'[^]
            A &d B <:> A &d B'
         *)
         refine (Rule.dprodEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* A |- B[^] <:> B'[^] *)
             refine (Rule.weaken 0 1)
             >>+
             (* B <:> B' *)
             tac
             ]


      fun compatSumEeqtp0 a a' tac =
         (* tac :: A <:> A'
            A -> B <:> A' -> B
         *)
         refine (Rule.sumEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A' *)
             tac,

             (* B <:> B *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatSumEeqtp1 b b' tac =
         (* tac :: B <:> B'
            A -> B <:> A -> B'
         *)
         refine (Rule.sumEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <:> B' *)
             tac,
             ]


      fun compatFutureEeqtp a a' tac =
         (* tac :: promote |- A <:> A'
            future A <:> future A'
         *)
         refine (Rule.futureEeq (T.evar ()) (T.evar ()))
         >>+
         (* promote |- A <:> A' *)
         tac


      fun compatLetnextEeqtp b b' tac =
         goalCaseT
         /| \Prim.eeqtp\ (\Prim.letnext\ _ (fn ? . _)) _ =>
            \(fnc binder =>
                 let
                    do (_, dir) = withgoal
                    val dir' = D.bindVary dir binder
                 in
                    (* tac :: B <:> B'
                       letnext M (fn . B) <:> letnext M (fn . B')
                    *)
                    refine (Rule.letnextEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                    >>> [
                        (* promote |- A : type *)
                        idtacM Secondary,

                        (* M : future A *)
                        idtacM Secondary,
                        
                        (* later A |- B <:> B' *)
                        chdir dir' >>+ tac
                        ]
                 end)\
         /


      fun compatIntersectEeqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.intersect\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <:> A'
                    intersect A . B <:> intersect A' . B
                 *)
                 refine (Rule.intersectEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A' *)
                     tac,
        
                     (* A |- B <:> B *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatIntersectEeqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.intersect\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B <:> B'
                    intersect A . B <:> intersect A . B'
                 *)
                 refine (Rule.intersectEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B <:> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatUnionEeqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.union\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <:> A'
                    union A . B <:> union A' . B
                 *)
                 refine (Rule.unionEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A' *)
                     tac,
        
                     (* A |- B <:> B *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatUnionEeqtp1 b b' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.union\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: B <:> B'
                    union A . B <:> union A . B'
                 *)
                 refine (Rule.unionEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A *)
                     refine (Rule.eeqtpRefl (T.evar ()))
                     >>+
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B <:> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatGuardEeqtp1 _ _ tac =
         (* tac :: B <:> B'
            A -g> B <:> A -g> B'
         *)
         refine (Rule.compatGuardEeq1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B <:> B' *)
             tac
             ]


      fun compatSetEeqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.set\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <:> A'
                    set A . B <:> set A' . B
                 *)
                 refine (Rule.compatSetEeq0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A' *)
                     tac,
        
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatIsetEeqtp0 a a' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.iset\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <:> A'
                    iset A . B <:> iset A' . B
                 *)
                 refine (Rule.compatIsetEeq0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <:> A' *)
                     tac,
        
                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatEqEeq0 _ _ tac =
         (* tac :: A <:> A' *)
         (* (M = N : A) <:> (M = N : A') *)
         refine (Rule.eqEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A' *)
             tac,

             (* M : A *)
             idtacM Secondary,

             (* N : A *)
             idtacM Secondary,
             ]


      fun compatEeqtpEeqtp0 a a' tac =
         (* tac : A <:> A' *)
         (* (A <:> B) <:> (A' <:> B) *)
         refine (Rule.eeqEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A' *)
             tac,

             (* B <:> B *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]
             

      fun compatEeqtpEeqtp1 b b' tac =
         (* tac : B <:> B' *)
         (* (A <:> B) <:> (A <:> B') *)
         refine (Rule.eeqEeq (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <:> A *)
             refine (Rule.eeqtpRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <:> B' *)
             tac
             ]
             

      fun compatIsetIff1 b b' tac =
         goalCaseT
         /
         \Prim.eeqtp\ _ (\Prim.iset\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <-> B'
                    iset A . B = iset A . B' : type
                 *)
                 refine (Rule.compatIsetIff1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,
        
                     (* A |- B <-> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatOfSubtype0 a b tac =
         (* tac :: A <: B
            M : A |- M[^] : B[^]
         *)
         refine (Rule.subsumptionOf (T.evar ()) (T.Sub (b, T.shift1)) (T.evar ()))
         >>> [
             (* M : A |- A[^] <: B[^] *)
             refine (Rule.weaken 0 1)
             >>+
             (* A <: B *)
             tac,

             (* M : A |- M[^] : A[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun compatEqSubtype0 a b tac =
         (* tac :: A <: B
            M = N : A |- M[^] = N[^] : B[^]
         *)
         refine (Rule.subsumptionEq (T.evar ()) (T.Sub (b, T.shift1)) (T.evar ()) (T.evar ()))
         >>> [
             (* M = N : A |- A[^] <: B[^] *)
             refine (Rule.weaken 0 1)
             >>+
             (* A <: B *)
             tac,

             (* M = N : A |- M[^] = N[^] : A[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun compatForallSubtype0 a' a tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A' <: A
                    forall A . B <: forall A' . B
                 *)
                 refine (Rule.compatForallSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A' <: A *)
                     tac,

                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /
          

      fun compatForallSubtype1 b b' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <: B'
                    forall A . B <: forall A . B'
                 *)
                 refine (Rule.compatForallSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B <: B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatExistsSubtype0 a a' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.exists\ _ (fn ? . _)) => 
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <: A'
                    exists A . B <: exists A' . B
                 *)
                 refine (Rule.compatExistsSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <: A' *)
                     tac,

                     (* A' |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /
          

      fun compatExistsSubtype1 b b' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <: B'
                    exists A . B <: exists A . B'
                 *)
                 refine (Rule.compatExistsSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B <: B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatArrowSubtype0 a' a tac =
         (* tac :: A' <: A
            A -> B <: A' -> B
         *)
         refine (Rule.arrowSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A' <: A *)
             tac,

             (* B <: B *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatArrowSubtype1 b b' tac =
         (* tac :: B <: B'
            A -> B <: A -> B'
         *)
         refine (Rule.arrowSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <: B' *)
             tac
             ]


      fun compatProdSubtype0 a a' tac =
         (* tac :: A <: A'
            A & B <: A' & B
         *)
         refine (Rule.prodSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A' *)
             tac,

             (* B <: B *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatProdSubtype1 b b' tac =
         (* tac :: B <: B'
            A & B <: A & B'
         *)
         refine (Rule.prodSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <: B' *)
             tac
             ]


      fun compatDprodSubtype0 a a' tac =
         (* tac :: A <: A'
            A &d B <: A' &d B
         *)
         refine (Rule.dprodSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A' *)
             tac,

             (* A |- B[^] <: B[^] *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* A |- B : type *)
             let
                do (_, dir) = withgoal
             in
                chdir (D.bind0 dir) >>+ idtacM Secondary
             end,

             (* A' |- B'[^] : type *)
             let
                do (_, dir) = withgoal
             in
                chdir (D.bind0 dir) >>+ idtacM Secondary
             end
             ]


      fun compatDprodSubtype1 b b' tac =
         (* tac :: B <: B'
            A &d B <: A &d B'
         *)
         refine (Rule.dprodSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* A |- B[^] <: B'[^] *)
             refine (Rule.weaken 0 1)
             >>+
             (* B <: B' *)
             tac,

             (* A |- B'[^] : type *)
             let
                do (_, dir) = withgoal
             in
                chdir (D.bind0 dir) >>+ idtacM Secondary
             end
             ]


      fun compatSumSubtype0 a a' tac =
         (* tac :: A <: A'
            A % B <: A' % B
         *)
         refine (Rule.sumSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A' *)
             tac,

             (* B <: B *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* B : type *)
             idtacM Secondary
             ]


      fun compatSumSubtype1 b b' tac =
         (* tac :: B <: B'
            A % B <: A % B'
         *)
         refine (Rule.sumSub (T.evar ()) (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A <: A *)
             refine (Rule.subtypeRefl (T.evar ()))
             >>+
             (* A : type *)
             idtacM Secondary,

             (* B <: B' *)
             tac
             ]


      fun compatFutureSubtype a a' tac =
         (* tac :: promote |- A <: A'
            future A <: future A'
         *)
         refine (Rule.futureSub (T.evar ()) (T.evar ()))
         >>+
         (* promote |- A <: A' *)
         tac


      fun compatIntersectSubtype0 a' a tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.intersect\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A' <: A
                    intersect A . B <: intersect A' . B
                 *)
                 refine (Rule.compatIntersectSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A' <: A *)
                     tac,

                     (* A |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /
          

      fun compatIntersectSubtype1 b b' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.intersect\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <: B'
                    intersect A . B <: intersect A . B'
                 *)
                 refine (Rule.compatIntersectSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B <: B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatUnionSubtype0 a a' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.union\ _ (fn ? . _)) => 
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <: A'
                    union A . B <: union A' . B
                 *)
                 refine (Rule.compatUnionSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <: A' *)
                     tac,

                     (* A' |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /
          

      fun compatUnionSubtype1 b b' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.union\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <: B'
                    union A . B <: union A . B'
                 *)
                 refine (Rule.compatUnionSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B <: B' : type *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      (* contravariant *)
      fun compatGuardArrow0 a' a tac =
         (* tac :: A' -> A
            (A -g> B) <: (A' -g> B)
         *)
         refine (Rule.compatGuardArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B : type *)
             idtacM Secondary,
             
             (* A' -> A *)
             tac
             ]


      fun compatGuardSubtype1 b b' tac =
         (* tac :: B <: B'
            A -g> B <: A -g> B'
         *)
         refine (Rule.compatGuardSubtype1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B <: B' *)
             tac
             ]


      fun compatSetSubtype0 a a' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.set\ _ (fn ? . _)) => 
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <: A'
                    set A . B <: set A' . B
                 *)
                 refine (Rule.compatSetSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <: A' *)
                     tac,

                     (* A' |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatSetArrow1 b b' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.set\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B -> B'
                    (set A . B) -> <: (set A . B')
                    (dir is appropriate to current terms, so it does not include the binder that tac expects)
                 *)
                 refine (Rule.compatSetArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B' : type *)
                     chdir dir' >>+ idtacM Secondary,
                     
                     (* A |- B -> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatIsetSubtype0 a a' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.iset\ _ (fn ? . _)) => 
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A <: A'
                    set A . B <: set A' . B
                 *)
                 refine (Rule.compatIsetSubtype0 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A <: A' *)
                     tac,

                     (* A' |- B : type *)
                     chdir dir' >>+ idtacM Secondary
                     ]
              end)\
         /


      fun compatSquashArrow a a' tac =
         (* tac :: A -> A'
            squash A <: squash A'
         *)
         refine (Rule.squashSub (T.evar ()) (T.evar ()))
         >>> [
             (* A' : type *)
             idtacM Secondary,

             (* A -> A' *)
             tac
             ]


      fun compatIsetArrow1 b b' tac =
         goalCaseT
         /
         \Prim.subtype\ _ (\Prim.iset\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B -> B'
                    (iset A . B) -> <: (iset A . B')
                    (dir is appropriate to current terms, so it does not include the binder that tac expects)
                 *)
                 refine (Rule.compatIsetArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B' : type *)
                     chdir dir' >>+ idtacM Secondary,
                     
                     (* A |- B -> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      (* contravariant, relation becomes arrow *)
      fun compatSubtypeSubtype0 a' a tac =
         (* tac :: A' <: A *)
         (* A <: B -> A' <: B *)
         refine (Rule.arrowIntro (T.evar ()) (T.evar ()))
         >>> [
             (* A <: B : type *)
             idtacM Secondary,

             (* A <: B |- A'[^] <: B[^] *)
             refine (Rule.subtypeTrans (T.Sub (a', T.shift1)) (T.Sub (a, T.shift1)) (T.evar ()))
             >>> [
                 (* A <: B |- A'[^] <: A[^] *)
                 refine (Rule.weaken 0 1)
                 >>+
                 (* A' <: A *)
                 tac,

                 (* A <: B |- A <: B *)
                 refine (Rule.hypothesis 0) >> done
                 ]
             ]


      (* relation becomes arrow *)
      fun compatSubtypeSubtype1 b b' tac =
         (* tac :: B <: B' *)
         (* A <: B -> A <: B' *)
         refine (Rule.arrowIntro (T.evar ()) (T.evar ()))
         >>> [
             (* A <: B : type *)
             idtacM Secondary,

             (* A <: B |- A[^] <: B'[^] *)
             refine (Rule.subtypeTrans (T.evar ()) (T.Sub (b, T.shift1)) (T.Sub (b', T.shift1)))
             >>> [
                 (* A <: B |- A <: B *)
                 refine (Rule.hypothesis 0) >> done,

                 (* A <: B |- B[^] <: B'[^] *)
                 refine (Rule.weaken 0 1)
                 >>+
                 (* B <: B' *)
                 tac
                 ]
             ]


      fun compatForallIff1 b b' tac =
         goalCaseT
         /
         \Prim.iff\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <-> B'
                    (forall A . B) <-> (forall A . B')
                    (dir is appropriate to current terms, so it does not include the binder that tac expects)
                 *)
                 refine (Rule.compatForallIff1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B <-> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatExistsIff1 b b' tac =
         goalCaseT
         /
         \Prim.iff\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B <-> B'
                    (exists A . B) <-> (exists A . B')
                    (dir is appropriate to current terms, so it does not include the binder that tac expects)
                 *)
                 refine (Rule.compatExistsIff1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B <-> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatArrowIff0 a a' tac =
         (* tac :: A <-> A
            (A -> B) -> (A' -> B)
         *)
         refine (Rule.compatArrowIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* B : type *)
             idtacM Secondary,
             
             (* A <-> A' *)
             tac
             ]


      fun compatArrowIff1 b b' tac =
         (* tac : B <-> B'
            (A -> B) <-> (A -> B')
         *)
         refine (Rule.compatArrowIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B <-> B' *)
             tac
             ]


      fun compatProdIff0 a a' tac =
         (* tac :: A <-> A'
            (A & B) <-> (A' & B)
         *)
         refine (Rule.compatProdIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* B : type *)
             idtacM Secondary,
             
             (* A <-> A' *)
             tac
             ]


      fun compatProdIff1 b b' tac =
         (* tac :: B <-> B'
            (A & B) <-> (A & B')
         *)
         refine (Rule.compatProdIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,
             
             (* B <-> B' *)
             tac
             ]


      fun compatDprodIff0 a a' tac =
         (* tac :: A <-> A'
            (A &d B) <-> (A' &d B)
         *)
         refine (Rule.compatDprodIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A |- B[^] : type *)
             idtacM Secondary,
             
             (* A <-> A' *)
             tac
             ]


      fun compatDprodIff1 b b' tac =
         (* tac :: B <-> B'
            (A &d B) <-> (A &d B')
         *)
         refine (Rule.compatDprodIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,
             
             (* B <-> B' *)
             tac
             ]


      fun compatSumIff0 a a' tac =
         (* tac :: A <-> A'
            (A % B) <-> (A' % B)
         *)
         refine (Rule.compatSumIff0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* B : type *)
             idtacM Secondary,
             
             (* A <-> A' *)
             tac
             ]


      fun compatSumIff1 b b' tac =
         (* tac :: B <-> B'
            (A % B) <-> (A % B')
         *)
         refine (Rule.compatSumIff1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,
             
             (* B <-> B' *)
             tac
             ]


      fun compatFutureIff a a' tac =
         (* tac :: promote |- A <-> A'
            future A <-> future A'
         *)
         refine (Rule.compatFutureIff (T.evar ()) (T.evar ()))
         >>+
         (* promote |- A <-> A' *)
         tac


      fun compatForallArrow1 b b' tac =
         goalCaseT
         /
         \Prim.arrow\ _ (\Prim.forall\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B -> B'
                    (forall A . B) -> (forall A . B')
                    (dir is appropriate to current terms, so it does not include the binder that tac expects)
                 *)
                 refine (Rule.compatForallArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B -> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      fun compatExistsArrow1 b b' tac =
         goalCaseT
         /
         \Prim.arrow\ _ (\Prim.exists\ _ (fn ? . _)) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A |- B -> B'
                    (exists A . B) -> (exists A . B')
                    (dir is appropriate to current terms, so it does not include the binder that tac expects)
                 *)
                 refine (Rule.compatExistsArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
                 >>> [
                     (* A : type *)
                     idtacM Secondary,

                     (* A |- B' : type *)
                     chdir dir' >>+ idtacM Secondary,
                     
                     (* A |- B -> B' *)
                     chdir dir' >>+ tac
                     ]
              end)\
         /


      (* contravariant *)
      fun compatArrowArrow0 a' a tac =
         (* tac :: A' -> A
            (A -> B) -> (A' -> B)
         *)
         refine (Rule.compatArrowArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B : type *)
             idtacM Secondary,
             
             (* A' -> A *)
             tac
             ]


      fun compatArrowArrow1 b b' tac =
         (* tac : B -> B'
            (A -> B) -> (A -> B')
         *)
         refine (Rule.compatArrowArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B -> B' *)
             tac
             ]


      fun compatProdArrow0 a a' tac =
         (* tac :: A -> A'
            (A & B) -> (A' & B)
         *)
         refine (Rule.compatProdArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* B : type *)
             idtacM Secondary,
             
             (* A -> A' *)
             tac
             ]


      fun compatProdArrow1 b b' tac =
         (* tac :: B -> B'
            (A & B) -> (A & B')
         *)
         refine (Rule.compatProdArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,
             
             (* B -> B' *)
             tac
             ]


      fun compatDprodArrow0 a a' tac =
         (* tac :: A -> A'
            (A &d B) -> (A' &d B)
         *)
         refine (Rule.compatDprodArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* B : type *)
             idtacM Secondary,
             
             (* A -> A' *)
             tac
             ]


      fun compatDprodArrow1 b b' tac =
         (* tac :: B -> B'
            (A & B) -> (A & B')
         *)
         refine (Rule.compatDprodArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,

             (* B -> B' *)
             tac
             ]


      fun compatSumArrow0 a a' tac =
         (* tac :: A -> A'
            (A % B) -> (A' % B)
         *)
         refine (Rule.compatSumArrow0 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A' : type *)
             idtacM Secondary,

             (* B : type *)
             idtacM Secondary,
             
             (* A -> A' *)
             tac
             ]


      fun compatSumArrow1 b b' tac =
         (* tac :: B -> B'
            (A % B) -> (A % B')
         *)
         refine (Rule.compatSumArrow1 (T.evar ()) (T.evar ()) (T.evar ()))
         >>> [
             (* A : type *)
             idtacM Secondary,
             
             (* B' : type *)
             idtacM Secondary,

             (* B -> B' *)
             tac
             ]


      fun compatFutureArrow a a' tac =
         (* tac :: promote |- A -> A'
            future A -> future A'
         *)
         refine (Rule.compatFutureArrow (T.evar ()) (T.evar ()))
         >>+
         (* promote |- A -> A' *)
         tac


      fun compatForallEntails1 b b' tac =
         goalCaseT
         /
         (* mis-shifted but it doesn't matter because we're only looking for the binder *)
         \Prim.forall\ _ (fn ? . _) =>
         \(fnc binder =>
              let
                 do (_, dir) = withgoal
                 val dir' = D.bindVary dir binder
              in
                 (* tac :: A, B |- B'[^]
                    forall A . B |- forall A[^] . B'[0 . ^2]
                    (dir is appropriate to current terms, so it does not include the A binder that tac expects)
                    (tac does not expect a B binder, since it expects a directory appropriate to B and B')
                 *)
                 refine (Rule.compatForallEntails1 (T.evar ()) (T.Sub (b, T.underShift 1 1)) (T.evar ()))
                 >>> [
                     (* (forall A . B), A[^], B[0 . ^2] |- B'[1 . ^3] *)
                     refine (Rule.weaken 2 1)
                     >>+
                     (* A, B |- B'[^] *)
                     chdir dir' >>+ tac,

                     (* forall A . B |- forall A[^] . B[0 . ^2] *)
                     refine (Rule.hypothesis 0) >> done
                     ]
              end)\
         /


      fun compatArrowEntails1 b b' tac =
         (* tac :: B |- B'[^]
            A -> B |- A[^] -> B'[^]
         *)
         refine (Rule.compatArrowEntails1 (T.evar ()) (T.Sub (b, T.shift1)) (T.evar ()))
         >>> [
             (* A -> B, B[^] |- B'[^2] *)
             refine (Rule.weaken 1 1)
             >>+
             (* B |- B'[^] *)
             tac,

             (* A -> B |- A[^] -> B[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun compatProdEntails0 a a' tac =
         (* tac :: A |- A'[^]
            A & B |- A'[^] & B[^]
         *)
         refine (Rule.compatProdEntails0 (T.Sub (a, T.shift1)) (T.evar ()) (T.evar ()))
         >>> [
             (* A & B, A[^] |- A'[^2] *)
             refine (Rule.weaken 1 1)
             >>+
             (* A |- A'[^] *)
             tac,

             (* A & B |- A[^] & B[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun compatProdEntails1 b b' tac =
         (* tac :: B |- B'[^]
            A & B |- A[^] & B'[^]
         *)
         refine (Rule.compatProdEntails1 (T.evar ()) (T.Sub (b, T.shift1)) (T.evar ()))
         >>> [
             (* A & B, B[^] |- B'[^2] *)
             refine (Rule.weaken 1 1)
             >>+
             (* B |- B'[^] *)
             tac,

             (* A & B |- A[^] & B[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun compatDprodEntails0 a a' tac =
         (* tac :: A |- A'[^]
            A &d B |- A'[^] &d B[^]
         *)
         refine (Rule.compatDprodEntails0 (T.Sub (a, T.shift1)) (T.evar ()) (T.evar ()))
         >>> [
             (* A &d B, A[^] |- A'[^2] *)
             refine (Rule.weaken 1 1)
             >>+
             (* A |- A'[^] *)
             tac,

             (* A &d B |- A[^] &d B[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      fun compatDprodEntails1 b b' tac =
         (* tac :: B |- B'[^]
            A &d B |- A[^] &d B'[^]
         *)
         refine (Rule.compatDprodEntails1 (T.evar ()) (T.Sub (b, T.shift1)) (T.evar ()))
         >>> [
             (* A &d B, B[^] |- B'[^2] *)
             refine (Rule.weaken 1 1)
             >>+
             (* B |- B'[^] *)
             tac,

             (* A &d B |- A[^] &d B[^] *)
             refine (Rule.hypothesis 0) >> done
             ]


      val () = 
         List.app
            (fn (const, i, binds, rconst, rconst', cov, tac) =>
                CICTable.insert compatibilityTable (const, i, rconst) (General rconst', cov, binds, tac))
            [
            (* eqtp *)
            (Prim.forall, 0, 0, Prim.eqtp, Prim.eqtp, true, compatForallEqtp0),
            (Prim.forall, 1, 1, Prim.eqtp, Prim.eqtp, true, compatForallEqtp1),
            (Prim.exists, 0, 0, Prim.eqtp, Prim.eqtp, true, compatExistsEqtp0),
            (Prim.exists, 1, 1, Prim.eqtp, Prim.eqtp, true, compatExistsEqtp1),
            (Prim.arrow, 0, 0, Prim.eqtp, Prim.eqtp, true, compatArrowEqtp0),
            (Prim.arrow, 1, 0, Prim.eqtp, Prim.eqtp, true, compatArrowEqtp1),
            (Prim.prod, 0, 0, Prim.eqtp, Prim.eqtp, true, compatProdEqtp0),
            (Prim.prod, 1, 0, Prim.eqtp, Prim.eqtp, true, compatProdEqtp1),
            (Prim.dprod, 0, 0, Prim.eqtp, Prim.eqtp, true, compatDprodEqtp0),
            (Prim.dprod, 1, 0, Prim.eqtp, Prim.eqtp, true, compatDprodEqtp1),
            (Prim.sum, 0, 0, Prim.eqtp, Prim.eqtp, true, compatSumEqtp0),
            (Prim.sum, 1, 0, Prim.eqtp, Prim.eqtp, true, compatSumEqtp1),
            (Prim.future, 0, 0, Prim.eqtp, Prim.eqtp, true, compatFutureEqtp),
            (Prim.intersect, 0, 0, Prim.eqtp, Prim.eqtp, true, compatIntersectEqtp0),
            (Prim.intersect, 1, 1, Prim.eqtp, Prim.eqtp, true, compatIntersectEqtp1),
            (Prim.union, 0, 0, Prim.eqtp, Prim.eqtp, true, compatUnionEqtp0),
            (Prim.union, 1, 1, Prim.eqtp, Prim.eqtp, true, compatUnionEqtp1),
            (Prim.guard, 0, 0, Prim.iff, Prim.eqtp, true, compatGuardIff0),
            (Prim.guard, 1, 0, Prim.eqtp, Prim.eqtp, true, compatGuardEqtp1),
            (Prim.set, 0, 0, Prim.eqtp, Prim.eqtp, true, compatSetEqtp0),
            (Prim.set, 1, 1, Prim.iff, Prim.eqtp, true, compatSetIff1),
            (Prim.iset, 0, 0, Prim.eqtp, Prim.eqtp, true, compatIsetEqtp0),
            (Prim.iset, 1, 1, Prim.eqtp, Prim.eqtp, true, compatIsetEqtp1),
            (Prim.squash, 0, 0, Prim.iff, Prim.eqtp, true, compatSquashIff),
            (Prim.eqtp, 0, 0, Prim.eqtp, Prim.eqtp, true, compatEqtpEqtp0),
            (Prim.eqtp, 1, 0, Prim.eqtp, Prim.eqtp, true, compatEqtpEqtp1),
            (Prim.eq, 0, 0, Prim.eqtp, Prim.eqtp, true, compatEqEqtp0),
            (Prim.eq, 1, 0, Prim.eqtp, Prim.eqtp, true, compatEqUnivEqtp1),
            (Prim.eq, 2, 0, Prim.eqtp, Prim.eqtp, true, compatEqUnivEqtp2),

            (* eeqtp *)
            (Prim.forall, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatForallEeqtp0),
            (Prim.forall, 1, 1, Prim.eeqtp, Prim.eeqtp, true, compatForallEeqtp1),
            (Prim.exists, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatExistsEeqtp0),
            (Prim.exists, 1, 1, Prim.eeqtp, Prim.eeqtp, true, compatExistsEeqtp1),
            (Prim.arrow, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatArrowEeqtp0),
            (Prim.arrow, 1, 0, Prim.eeqtp, Prim.eeqtp, true, compatArrowEeqtp1),
            (Prim.prod, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatProdEeqtp0),
            (Prim.prod, 1, 0, Prim.eeqtp, Prim.eeqtp, true, compatProdEeqtp1),
            (Prim.dprod, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatDprodEeqtp0),
            (Prim.dprod, 1, 0, Prim.eeqtp, Prim.eeqtp, true, compatDprodEeqtp1),
            (Prim.sum, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatSumEeqtp0),
            (Prim.sum, 1, 0, Prim.eeqtp, Prim.eeqtp, true, compatSumEeqtp1),
            (Prim.future, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatFutureEeqtp),
            (Prim.letnext, 1, 1, Prim.eeqtp, Prim.eeqtp, true, compatLetnextEeqtp),
            (Prim.intersect, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatIntersectEeqtp0),
            (Prim.intersect, 1, 1, Prim.eeqtp, Prim.eeqtp, true, compatIntersectEeqtp1),
            (Prim.union, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatUnionEeqtp0),
            (Prim.union, 1, 1, Prim.eeqtp, Prim.eeqtp, true, compatUnionEeqtp1),
            (Prim.guard, 1, 0, Prim.eeqtp, Prim.eeqtp, true, compatGuardEeqtp1),
            (Prim.set, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatSetEeqtp0),
            (Prim.iset, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatIsetEeqtp0),
            (Prim.iset, 1, 1, Prim.iff, Prim.eeqtp, true, compatIsetIff1),
            (Prim.eq, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatEqEeq0),
            (Prim.eeqtp, 0, 0, Prim.eeqtp, Prim.eeqtp, true, compatEeqtpEeqtp0),
            (Prim.eeqtp, 1, 0, Prim.eeqtp, Prim.eeqtp, true, compatEeqtpEeqtp1),

            (* subtype *)
            (Prim.forall, 0, 0, Prim.subtype, Prim.subtype, false, compatForallSubtype0),
            (Prim.forall, 1, 1, Prim.subtype, Prim.subtype, true, compatForallSubtype1),
            (Prim.exists, 0, 0, Prim.subtype, Prim.subtype, true, compatExistsSubtype0),
            (Prim.exists, 1, 1, Prim.subtype, Prim.subtype, true, compatExistsSubtype1),
            (Prim.arrow, 0, 0, Prim.subtype, Prim.subtype, false, compatArrowSubtype0),
            (Prim.arrow, 1, 0, Prim.subtype, Prim.subtype, true, compatArrowSubtype1),
            (Prim.prod, 0, 0, Prim.subtype, Prim.subtype, true, compatProdSubtype0),
            (Prim.prod, 1, 0, Prim.subtype, Prim.subtype, true, compatProdSubtype1),
            (Prim.dprod, 0, 0, Prim.subtype, Prim.subtype, true, compatDprodSubtype0),
            (Prim.dprod, 1, 0, Prim.subtype, Prim.subtype, true, compatDprodSubtype1),
            (Prim.sum, 0, 0, Prim.subtype, Prim.subtype, true, compatSumSubtype0),
            (Prim.sum, 1, 0, Prim.subtype, Prim.subtype, true, compatSumSubtype1),
            (Prim.future, 0, 0, Prim.subtype, Prim.subtype, true, compatFutureSubtype),
            (Prim.intersect, 0, 0, Prim.subtype, Prim.subtype, false, compatIntersectSubtype0),
            (Prim.intersect, 1, 1, Prim.subtype, Prim.subtype, true, compatIntersectSubtype1),
            (Prim.union, 0, 0, Prim.subtype, Prim.subtype, true, compatUnionSubtype0),
            (Prim.union, 1, 1, Prim.subtype, Prim.subtype, true, compatUnionSubtype1),
            (Prim.guard, 0, 0, Prim.arrow, Prim.subtype, false, compatGuardArrow0),
            (Prim.guard, 1, 0, Prim.subtype, Prim.subtype, true, compatGuardSubtype1),
            (Prim.set, 0, 0, Prim.subtype, Prim.subtype, true, compatSetSubtype0),
            (Prim.set, 1, 1, Prim.arrow, Prim.subtype, true, compatSetArrow1),
            (Prim.iset, 0, 0, Prim.subtype, Prim.subtype, true, compatIsetSubtype0),
            (Prim.iset, 1, 1, Prim.arrow, Prim.subtype, true, compatIsetArrow1),
            (Prim.squash, 0, 0, Prim.arrow, Prim.subtype, true, compatSquashArrow),

            (* iff *)
            (Prim.forall, 1, 1, Prim.iff, Prim.iff, true, compatForallIff1),
            (Prim.exists, 1, 1, Prim.iff, Prim.iff, true, compatExistsIff1),
            (Prim.arrow, 0, 0, Prim.iff, Prim.iff, true, compatArrowIff0),
            (Prim.arrow, 1, 0, Prim.iff, Prim.iff, true, compatArrowIff1),
            (Prim.prod, 0, 0, Prim.iff, Prim.iff, true, compatProdIff0),
            (Prim.prod, 1, 0, Prim.iff, Prim.iff, true, compatProdIff1),
            (Prim.dprod, 0, 0, Prim.iff, Prim.iff, true, compatDprodIff0),
            (Prim.dprod, 1, 0, Prim.iff, Prim.iff, true, compatDprodIff1),
            (Prim.sum, 0, 0, Prim.iff, Prim.iff, true, compatSumIff0),
            (Prim.sum, 1, 0, Prim.iff, Prim.iff, true, compatSumIff1),
            (Prim.future, 0, 0, Prim.iff, Prim.iff, true, compatFutureIff),

            (* arrow *)
            (Prim.forall, 1, 1, Prim.arrow, Prim.arrow, true, compatForallArrow1),
            (Prim.exists, 1, 1, Prim.arrow, Prim.arrow, true, compatExistsArrow1),
            (Prim.arrow, 0, 0, Prim.arrow, Prim.arrow, false, compatArrowArrow0),
            (Prim.arrow, 1, 0, Prim.arrow, Prim.arrow, true, compatArrowArrow1),
            (Prim.prod, 0, 0, Prim.arrow, Prim.arrow, true, compatProdArrow0),
            (Prim.prod, 1, 0, Prim.arrow, Prim.arrow, true, compatProdArrow1),
            (Prim.dprod, 1, 0, Prim.arrow, Prim.arrow, true, compatDprodArrow1),
            (Prim.sum, 0, 0, Prim.arrow, Prim.arrow, true, compatSumArrow0),
            (Prim.sum, 1, 0, Prim.arrow, Prim.arrow, true, compatSumArrow1),
            (Prim.future, 0, 0, Prim.arrow, Prim.arrow, true, compatFutureArrow),
            (Prim.subtype, 0, 0, Prim.subtype, Prim.arrow, false, compatSubtypeSubtype0),
            (Prim.subtype, 1, 0, Prim.subtype, Prim.arrow, true, compatSubtypeSubtype1),

            (* entailment *)
            (Prim.forall, 1, 1, Prim.entailment, Prim.entailment, true, compatForallEntails1),
            (Prim.arrow, 1, 0, Prim.entailment, Prim.entailment, true, compatArrowEntails1),
            (Prim.prod, 0, 0, Prim.entailment, Prim.entailment, true, compatProdEntails0),
            (Prim.prod, 1, 0, Prim.entailment, Prim.entailment, true, compatProdEntails1),
            (Prim.dprod, 0, 0, Prim.entailment, Prim.entailment, true, compatDprodEntails0),
            (Prim.dprod, 1, 0, Prim.entailment, Prim.entailment, true, compatDprodEntails1),
            (Prim.ov, 0, 0, Prim.subtype, Prim.entailment, true, compatOfSubtype0),
            (Prim.eq, 0, 0, Prim.subtype, Prim.entailment, true, compatEqSubtype0),
            ]

   end


structure Rewrite :> REWRITE where type rewrite = RewriteInternal.rewrite = RewriteInternal


structure ParseRewrite =
   struct

      fun id x = x
      val null = []
      fun sing x = [x]
      fun cons h t = h :: t

      val conclHyp = Hyp.NAME (Symbol.fromValue "concl")

      fun occurNums l = SOME (false, l)
      fun occurPos l = SOME (true, l)
      val occurAll = NONE

      fun targetInAt h occ = (h, occ)
      fun targetIn h = (h, SOME (false, [0]))

      fun targetsAt occ = [(conclHyp, occ)]
      val targetsEmpty = [(conclHyp, SOME (false, [0]))]

      val withinNone = []
      val withinSome = id

      fun rewriteForward m capture = Rewrite.usingRew false false capture m
      fun rewriteBackward m capture = Rewrite.usingRew false true capture m
      fun rewriteRepl m n a capture = Rewrite.replaceRew capture m n a
      fun rewriteForwardStrict m capture = Rewrite.usingRew true false capture m
      fun rewriteBackwardStrict m capture = Rewrite.usingRew true true capture m

      fun head longid dir = Directory.lookupLong dir longid

      fun rewriteAim rew targets = (rew, targets)
      fun termAim m capture targets = ((capture, m), targets)
      fun constantAim const targets = (const, targets)
      fun headAim head targets = (head, targets)
      fun constantTermAim const m capture targets = ((capture, const, m), targets)
      fun reductionAim r targets = (r, targets)
      fun reductionTermAim r m capture targets = ((capture, m, r), targets)
      
   end


grammardef Rewrite

   open ParseRewrite

   rule Occurrences      ::= Numbersn => occurNums
   rule Occurrences      ::= "pos" Numbersn => occurPos
   rule Occurrences      ::= "all" => occurAll

   rule Target           ::= "in" Hypothesis "at" Occurrences => targetInAt
   rule Target           ::= "in" Hypothesis => targetIn

   rule Targetsn         ::= Target => sing
   rule Targetsn         ::= Target Targetsn => cons
   rule Targets          ::= "at" Occurrences => targetsAt
   rule Targets          ::= => targetsEmpty
   rule Targets          ::= Targetsn => id

   rule ShortTarget      ::= Target => id
   rule ShortTarget      ::= Hypothesis "at" Occurrences => targetInAt
   rule ShortTarget      ::= Hypothesis => targetIn
   
   rule ShortTargetsn    ::= ShortTarget => sing
   rule ShortTargetsn    ::= ShortTarget ShortTargetsn => cons
   rule ShortTargets     ::= "at" Occurrences => targetsAt
   rule ShortTargets     ::= => targetsEmpty
   rule ShortTargets     ::= ShortTargetsn => id

   rule Within           ::= => withinNone
   rule Within           ::= "within" OIdents => withinSome

   rule Rewrite          ::= EMBED => id
   rule Rewrite          ::= "->" Term Within => rewriteForward
   rule Rewrite          ::= "<-" Term Within => rewriteBackward
   rule Rewrite          ::= Term(31) "=" Term(31) ":" Term(31) Within => rewriteRepl
   rule Rewrite          ::= "-->" Term Within => rewriteForwardStrict
   rule Rewrite          ::= "<--" Term Within => rewriteBackwardStrict

   rule Head             ::= Longident => head

   rule RewriteAim       ::= Rewrite Targets => rewriteAim
   rule TermAim          ::= Term Within Targets => termAim
   rule ConstantAim      ::= Constant Targets => constantAim
   rule HeadAim          ::= Head Targets => headAim
   rule ConstantTermAim  ::= Constant "with" Term Within Targets => constantTermAim
   rule ReductionAim     ::= EMBED Targets => reductionAim
   rule ReductionTermAim ::= EMBED "with" Term Within Targets => reductionTermAim

   rule RewriteAims      ::= RewriteAim => sing
   rule RewriteAims      ::= RewriteAim "," RewriteAims => cons

   rule TermAims         ::= TermAim => sing
   rule TermAims         ::= TermAim "," TermAims => cons

   rule ConstantAims     ::= ConstantAim => sing
   rule ConstantAims     ::= ConstantAim "," ConstantAims => cons

   rule HeadAims         ::= HeadAim => sing
   rule HeadAims         ::= HeadAim "," HeadAims => cons

   rule ConstantTermAims ::= ConstantTermAim => sing
   rule ConstantTermAims ::= ConstantTermAim "," ConstantTermAims => cons

   rule ReductionAims    ::= ReductionAim => sing
   rule ReductionAims    ::= ReductionAim "," ReductionAims => cons

   rule ReductionTermAims ::= ReductionTermAim => sing
   rule ReductionTermAims ::= ReductionTermAim "," ReductionTermAims => cons

   reserved "at" "in" "within" : Ident

end


grammaron Rewrite
