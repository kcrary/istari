
File.import "acc-load.iml";
File.import "logic-load.iml";

File.import "partial-aux.iml";



openModule /Acc/;


(* Partial types *)

beginModule "Partial";


aliasExport /partial/ Prim.partial;
aliasExport /halts/ Prim.halts;
aliasExport /admiss/ Prim.admiss;
aliasExport /padmiss/ Prim.padmiss;
aliasExport /uptype/ Prim.uptype;
aliasExport (Symbol.fromValue "seq") Prim.seq;
aliasExport /bottom/ Prim.bottom;
aliasExport /strict/ Prim.strict;
aliasExport /total/ Prim.total;
aliasExport /haltsand/ Prim.haltsand;


lemma "partial_type"
/
  partial : intersect i . U i -> U i
/;

inference.
RuleTactic.partialType.
qed ();
recordTyping "partial_type";



lemma "halts_type"
/
  halts : intersect i (a : U i) . partial a -> U 0
/;

inference.
RuleTactic.haltsType.
qed ();
recordTyping "halts_type";



lemma "admiss_type"
/
  admiss : intersect i . U i -> U i
/;

inference.
RuleTactic.admissType.
qed ();
recordTyping "admiss_type";



lemma "uptype_type"
/
  uptype : intersect i . U i -> U i
/;

inference.
RuleTactic.uptypeType.
qed ();
recordTyping "uptype_type";



lemma "padmiss_type"
/
  `padmiss : intersect i . forall (a : U i) . (a -> U i) -> U i
/;

inference.
RuleTactic.padmissType.
qed ();
recordTyping "padmiss_type";



lemma "seq_type"
/
  `seq : intersect i (a b : U i) . partial a -> (a -> partial b) -> partial b
/;

inference.
RuleTactic.seqType.
qed ();
recordTyping "seq_type";



lemma "bottom_type"
/
  bottom : intersect i (a : U i) . partial a
/;

inference.
introOf /i a/.
RuleTactic.partialIntroBottomOf.
typecheck.
qed ();
recordTyping "bottom_type";



lemma "partial_elim"
/
  forall i (a : U i) (x : partial a) . halts x -> x : a
/;

inference.
intro /i a x H/.
RuleTactic.partialElimOf >> auto.
qed ();



lemma "uptype_impl_admiss"
/
  forall i (a : U i) . uptype a -> admiss a
/;

inference.
intro /i a H/.
RuleTactic.uptypeAdmiss.
hyp /H/.
qed ();



lemma "halts_uptype"
/
  forall i (a : U i) (x : partial a) . uptype (halts x)
/;

inference.
intro /i a x/.
RuleTactic.uptypeUnitary.
intro /y/.
RuleTactic.haltsLeft 0.
typecheck.
qed ();



(*
Built-in:

defineRaw /strict a/
/
  a <: partial a
/;
*)


lemma "strict_type"
/
  strict : intersect i . U i -> U i
/;

inference.
unfold /strict/.
typecheck.
qed ();
recordTyping "strict_type";



(*
Built-in:

defineRaw /total a/
/
  strict a &d (forall (x : a) . halts x)
/;

The first conjunct is needed because we need to know
that a is strict for halts x to be well-formed.
*)


lemma "total_type"
/
  total : intersect i . U i -> U i
/;

inference.
unfold /total/.
typecheck.
qed ();
recordTyping "total_type";



define /inpar m/
/
  m
//
  intersect i (a : U i) . forall (m : a) . strict a -g> partial a
/;

inference.
introOf /i a m Hstrict/.
unfold /inpar/.
partiality /concl/ >> auto.
qed ();

setOpacity /inpar/ Constant.FIRM_STRICT;



define /outpar m/
/
  m
//
  intersect i (a : U i) . forall (m : partial a) . halts m -g> a
/;

inference.
introOf /i a m Hhalt/.
unfold /outpar/.
partiality /concl/ >> auto.
qed ();

setOpacity /outpar/ Constant.FIRM_STRICT;



lemma "outpar_compat"
/
  forall i (a : U i) (x y : partial a) .
    halts x
    -> x = y : partial a
    -> outpar x = outpar y : a
/;

inference.
intro /i a x y Hhalt Heq/.
compat >> auto.
qed ();



(*
Built-in:

defineRaw /haltsand a/
/
  halts a &d a
/;

*)



lemma "haltsand_type"
/
  haltsand : intersect i . partial (U i) -> U i
/;

inference.
unfold /haltsand/.
introOf /i a/.
reduce //.
fold /outpar a at 1/.
typecheck.
qed ();
recordTyping "haltsand_type";



lemma "fixpoint_formation"
/
  forall i (a : U i) (f : partial a -> partial a) .
    admiss a
    -> fix f : partial a
/;

inference.
intro /i a f Hadmiss/.
RuleTactic.fixpointInductionOf >> auto.
qed ();



lemma "fixpoint_induction"
/
  forall i (a : U i) (P : partial a -> U i) (f : partial a -> partial a) .
    admiss a
    -> (padmiss (x : partial a) . P x)
    -> (forall (x : partial a) . (halts x -> P x) -> P x)
    -> (forall (x : partial a) . P x -> P (f x))
    -> P (fix f)
/;

inference.
intro /i a P f Hadma HadmP Hbase Hind/.
(* Do a little extra work here for a clean extract. *)
exactRaw /Hbase (fix f) (fn _ . fix (fn y . (f (y #1), Hind (y #1) (Hbase (y #1) (fn _ . y #2)))) #2)/.
set /F/ /fn y . (f (y #1), Hind (y #1) (Hbase (y #1) (fn _ . y #2)))/.
fold /F/.
assert /fix f : partial a/ /Hoffixf/.
  {
  RuleTactic.fixpointInductionOf >> auto.
  }
assert /F : partial (exists (x : partial a) . P x) -> partial (exists (x : partial a) . P x)/ /HofF/.
  {
  unfold /F/.
  introOf /x/.
  reduce //.
  typecheck.
  reintro /Hhalt/.
  termination /Hhalt/.
  reintro /Hhaltx/.
  fold /outpar x at 1/.
  typecheck.
  }
assert /admiss (exists (x : partial a) . P x)/ /Hadmiss/.
  {
  Partiality.proveAdmiss.
  }
assert /fix F : partial (exists (x : partial a) . P x)/ /HoffixF/.
  {
  RuleTactic.fixpointInductionOf >> auto.
  }
assert /fix F #1 = fix f : partial a/ /Heq/.
  {
  RuleTactic.fixpointInductionShift (parseCurr /exists (x : partial a) . P x/) (parseCurr /F/) (parseCurr /fn x . x #1/) >> auto.
    {
    reduce //.
    folds 2 /bottom ap i ap (exists (x : partial a) . P x)/.
    intro /Hhalt/.
    unfold /ap in Hhalt at all/.
    termination /Hhalt/.
    reintro /Hhalt'/.
    termination /Hhalt'/.
    }

    {
    reintro /x/.
    reduce //.
    unfold /F/.
    reflexivity.
    }
  }
typecheck1 >> auto.
introOf /Hhaltfixf/.
reduce //.
subsume /P (fix F #1)/.
  {
  typecheck.
  }
rewrite /<- Heq in Hhaltfixf/.
termination /Hhaltfixf/.
reintro /HhaltfixF/.
partiality /HoffixF/ >> auto.
reintro /HoffixF'/.
inferSpine /HoffixF'/ /__ #2/ /H/.
hyp /H/.
qed ();



alias /sequal/ Prim.sequal;

lemma "seqt_type"
/
  `seqt : intersect i (a b : U i) . total a -g> a -> (a -> b) -> b
/;

inference.
unfold /seqt/.
introOf /i a b Htotal/.
destruct /Htotal/ /Hstrict Htotal/.
unhide.
introOfRaw /x/ >> auto.
  {
  subsume /partial a -> (a -> partial b) -> partial b/ >> typecheck.
  }
introOfRaw /m/ >> auto.
  {
  subsume /(a -> partial b) -> partial b/ >> typecheck.
  }
assert /sequal m (fn y . m y)/ /Heq/.
  {
  RuleTactic.forallEtaSequal (parseCurr /a/) (Term.Sub (parseCurr /b/, Term.shift1)).
  unfold /arrow in m/.
  hypof.
  }
rewrite /-> Heq/.
assert /sequal (seq y = x in m y) (m x)/ /Heq'/.
  {
  RuleTactic.seqHaltsSequal.
  apply /Htotal/.
  }
rewrite /-> Heq'/.
typecheck.
qed ();
recordTyping "seqt_type";



(* Inducement *)

lemma "Acc_uptype"
/
  forall i (a : U i) (P : a -> a -> U i) (x : a) .
    uptype a
    -> uptype (Acc a P x)
/;

inference.
intro /i a P x Ha/.
unfold /Acc/.
RuleTactic.existsUptype.
  {
  Partiality.proveAdmiss.
  }
reintro /y/.
revert /x/.
sinduction /y/.
reintro /t y Hsub IH/.
intro /x/.
unroll /fix/.
reduce //.
RuleTactic.existsUptype.
  {
  Partiality.proveAdmiss.
  }
RuleTactic.forallUptype >> auto.
RuleTactic.forallUptype >> auto.
qed ();



ConstantTable.insert Partiality.uptypeTactics Prim.acc (Backchain.witnessRaw /\Term.Const (parseConstant /Acc_uptype/)\ _ _ _ _ __/);


define /approx {a b c} f p q/
/
  forall (x : b) . halts (f p x) -> f p x = f q x : partial (c x)
//
  intersect i . forall (a b : U i) (c : b -> U i) .
    (partial a -> forall (x : b) . partial (c x))
    -> partial a -> partial a -> U i
/;

unfold /approx/.
typecheck.
qed ();



define /induce {a b c} f g x y/
/
  forall (p : partial a) .
    approx f p (fix g)
    -> halts (f (g p) y)
    -> halts (f p x)
//
  intersect i . forall (a b : U i) (c : b -> U i) .
    admiss a
    -g> (partial a -> forall (x : b) . partial (c x))
    -> (partial a -> partial a)
    -> b -> b -> U i
/;

inference.
introOf /i a b c Hadmiss f g x y/.
unfold /induce/.
typecheck.
RuleTactic.fixpointInductionOf >> auto.
qed ();



lemma "induce_well_founded"
/
  forall i (a b : U i) (c : b -> U i)
    (f : partial a -> forall (x : b) . partial (c x))
    (g : partial a -> partial a) .
      admiss a
      -> uptype b
      -> (forall (x : b) . admiss (c x))
      -> (forall p x . halts (f p x) -> halts p)
      -> (forall p q . approx f p q -> approx f (g p) (g q))
      -> forall (x : b) . halts (f (fix g) x) -> Acc b (induce f g) x
/;

inference.
intro /i a b c f g Ha Hb Hc Hstrict Hmono/.
assert /fix g : partial a/ /Hoffix/.
  {
  RuleTactic.fixpointInductionOf >> auto.
  }
assert /forall (x : b) . 
          halts (f (fix g) x) 
          -> Acc b (induce f g) x & f (fix g) x = f (fix g) x : partial (c x)/ /H/.
1:{
  intro /x Hx/.
  apply /H/ >> auto.
  }
abstractOverAt /fix g/ /concl/ /0 1/.
goalCaseT
  /| ? @ _ =>
     \(fnc p =>
         apply /fixpoint_induction (lsucc i) a \p\ g/ >> auto)\
  /.

(* admissibility *)
{
reduce //.
RuleTactic.forallPadmissDomainClosed (parseCurr /b/) >> auto.
RuleTactic.arrowPadmissDomainHalts (parseCurr /additional` _ . (c x)/) >> auto.
RuleTactic.prodPadmiss.
  {
  Partiality.proveAdmiss.
  }

  {
  RuleTactic.eqPadmiss >> auto.
  RuleTactic.padmissClosed (Term.evar ()) >> auto.
  RuleTactic.partialAdmiss.
  auto.
  }
}

(* base case *)
{
reduce //.
intro /p Hif x Hhalt/.
apply /Hif/ >> auto.
}

(* inductive case *)
{
reduce //.
intro /p IH x Hhalt/.
split.
  {
  apply /Acc_intro/.
  intro /y Hyx/.
  apply /IH/.
  unfold /induce in Hyx/.
  apply /Hyx/ >> auto.
  }

  {
  unroll /fix/.
  witness /Hmono p (fix g) __ x Hhalt/.
  auto.
  }
}
qed ();



structure PartialTactic = PartialTacticFun ();
structure PartialTacticPervasive =
   struct
      val fixpointInductionRaw = PartialTactic.fixpointInductionRaw
      val fixpointInduction = PartialTactic.fixpointInduction
      val reduceSeqOutparRaw = PartialTactic.reduceSeqOutparRaw
      val reduceSeqOutpar = PartialTactic.reduceSeqOutpar
      val seqTerminationRaw = PartialTactic.seqTerminationRaw
      val seqTermination = PartialTactic.seqTermination
   end;

open PartialTacticPervasive;

grammaron PartialTactic;



lemma "seq_unit_left"
/
  forall i (a b : U i) (m : a) (f : a -> partial b) .
    strict a
    -> halts m
    -> (seq x = m in f x) = f m : partial b
/;

inference.
intro /i a b m f Ha Hhalt/.
reduceSeq // >> auto.
qed ();

  

lemma "seq_unit_right"
/
  forall i (a : U i) (m : partial a) .
    strict a
    -> (seq x = m in x) = m : partial a
/;

inference.
intro /i a m Ha/.
symmetry.
extensionality.
  {
  split.
    {
    intro /H/.
    reduceSeq // >> auto.
    }

    {
    intro /H/.
    seqTermination /H/ >> auto.
    }
  }

  {
  reintro /H/.
  reduceSeq // >> auto.
  partiality /concl/ >> auto.
  }
qed ();

  

lemma "seq_assoc"
/
  forall i (a b c : U i) (m : partial a) (f : a -> partial b) (g : b -> partial c) .
    (seq y = (seq x = m in f x) in g y)
    =
    (seq x = m in seq y = (f x) in g y)
    : partial c
/;

inference.
intro /i a b c m f g/.
symmetry.
extensionality.
  {
  split.
    {
    intro /H/.
    seqTermination /H/.
    reintro /H1 H2/.
    reduceSeqOutpar /at 1 0/ >> auto.
    }

    {
    intro /H/.
    seqTermination /H/.
    reintro /H1/.
    seqTermination /H1/.
    reintro /H2/.
    reduceSeqOutpar /at 0 0/ >> auto.
    reduceSeqOutpar /in H/ >> auto.
    }
  }

  {
  reintro /Hhalt/.
  seqTermination /Hhalt/.
  reintro /H1 H2/.
  reduceSeqOutpar /at 0 1 0 0/ >> auto.
    {
    reduceSeqOutpar // >> auto.
    }
  partiality /concl/ >> auto.
  }
qed ();



endModule ();
