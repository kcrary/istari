
File.import "misc-load.iml";
File.import "logic-load.iml";
File.import "sqstable-load.iml";

File.import "eventually-aux.iml";


Namespace.beginModule "Eventually";


lemma "pause_type"
/
  pause :
  intersect i (a : U i) .
    a -> a
/;

introOf /i a/.
unfoldHead /pause/.
typecheck.
qed ();
recordTyping "pause_type";



define /ffix f/
/
  pause
    (fn x . f (let next x' = x in next (pause x' x)))
    (next
       (fn x . f (let next x' = x in next (pause x' x))))
//
  intersect (i : level) (a : U i) .
    (future a -> a) -> a
/;

introOf /i a f/.
unfold /ffix/.
goalCaseT /of _ (pause ? _) => \(fnc m => set /g/ /\m\/)\ /.
assert /g : rec t . (future t -> a)/ /Hof/.
  {
  unfold /g/.
  unrollType /rec/.
  typecheck.
  reintro /x/.
  unroll /pause/.
  fold /manual (next x)/.
  unrollType /rec in x/.
  typecheck.
  unrollType /rec/.
  typecheck.
  }
fold /g , g/.
convert /pause ap _ ap (future (rec t . (future t -> a)) -> a)/.
typecheck.
unrollType /rec/.
reflexivity.
qed ();


val unroll_ffix = makeReduction
/
ffix f --> f (next (ffix f)) ;
unfolding ffix letnext
unrolling pause
/;

Database.setUnroll (parseConstant /ffix/) (Reduction.user unroll_ffix);
writeRegistry /unroll_ffix/ /ureduction/ unroll_ffix;



define /ev a/
/
  rec t . a % future t
//
  intersect i . U i -> U i
/;

inference.
introOf /i/.
unfoldHead /ev/.
typecheck.
qed ();



lemma "ev_unroll" 
/
  forall (i : level) (a : U i) . ev a = (a % future (ev a)) : type
/;

intro /i a/.
unrollType /ev/.
reflexivity.
qed ();



define /now x/
/
  inl x
//
  intersect i (a : U i) .
    a -> ev a
/;

inference.
introOf /i a x/.
unfold /now/.
rewrite /-> ev_unroll/.
typecheck.
qed ();



define /laterf x/
/
  inr x
//
  intersect i (a : U i) .
    future (ev a) -> ev a
/;

inference.
introOf /i a x/.
unfold /laterf/.
rewrite /-> ev_unroll/.
typecheck.
qed ();



define /later x/
/
  laterf (next x)
//
  intersect i (a : U i) .
    ev a -> ev a
/;

inference.
introOf /i a x/.
unfold /later/.
typecheck.
qed ();

Constant.setOpacity (parseConstant /later/) Constant.SOFT_STRICT;



define /bindev x f/
/
  ffix
    (fn g x .
       (case x of
        | inl y . f y
        | inr y .
            let next g' = g
            in
            let next y' = y
            in
              inr (next (g' y'))))
    x
//
  intersect i (a b : U i) .
    ev a
    -> (a -> ev b)
    -> ev b
/;

inference.
introOf /i a b x f/.
unfold /bindev/.
folds 2 /ffix ap i ap (ev a -> ev b)/.
so /ev_unroll i a/ /Heq/.
typecheck.
unrollType /ev/.
typecheck.
qed ();



reductions 
/
bindev (now x) f --> f x ;
bindev (laterf x) f --> let next y = x in later (bindev y f) ;
bindev (later x) f --> later (bindev x f) ;
unfolding letnext bindev now later laterf
unrolling ffix
/;



define /bindevt x t/
/
  ffix
    (fn g x .
       (case x of
        | inl y . t y
        | inr y .
            let next g' = g
            in
            let next y' = y
            in
              future (g' y')))
    x
//
  intersect i (a : U i) .
    ev a 
    -> (a -> U i)
    -> U i
/;

inference.
introOf /i a x t/.
unfold /bindevt/.
folds 2 /ffix ap (lsucc i) ap (ev a -> U i)/.
typecheck.
unrollType /ev/.
typecheck.
qed ();



reductions
/
  bindevt (now x) t --> t x ;
  bindevt (laterf x) t --> let next y = x in future (bindevt y t) ;
  bindevt (later x) t --> future (bindevt x t) ;
  unfolding letnext bindevt now later laterf
  unrolling ffix
/;



structure Nothing = AfterBindev ();
grammaron Eventually;



lemma "ev_subtype"
/
  forall i (a b : U i) .
    a <: b
    -> ev a <: ev b
/;

inference.
intro /i a b Hsub/.
apply /ffix/.
intro /Hsubev x/.
rewrite /-> ev_unroll in x in concl/.
destruct /x/ /x | [x]/.
  {
  typecheck.
  }

  {
  destruct /Hsubev/ /[Hsubev]/.
  (* The typechecker won't find Hsubev because it's in the future when we start.
     We need to do this in two stages so it refreshes its table after moving into
     the future.
  *)
  fold /manual x/.
  typecheck.
  typecheck.
  }
qed ();



lemma "ev_eeqtp"
/
  forall i (a b : U i) .
    a <:> b
    -> ev a <:> ev b
/;

inference.
intro /i/.
apply /Misc.eeqtp_compat_covariant/.
apply /ev_subtype/.
qed ();



define /efix f/
/
  ffix (fn x . f (laterf x))
//
  intersect i (a : U i) .
    (ev a -> ev a) -> ev a
/;

inference.
introOf /i a f/.
unfold /efix/.
typecheck.
qed ();



val unroll_efix = makeReduction
/
efix f --> f (later (efix f)) ;
unfolding efix later
unrolling ffix
/;

Database.setUnroll (parseConstant /efix/) (Reduction.user unroll_efix);
writeRegistry /unroll_efix/ /ureduction/ unroll_efix;



(* At this point we'd like to follow the development in Smith [1988]
   and define a termination predicate.  Alas, we cannot.  Istari's
   step-indexed semantics is unable to express liveness properties
   such as termination.  If it could express termination, we would be
   able to draw a contradiction, because the fixed-point typing rule
   above (efix_type) does not have Smith's admissibility requirement.
   (See Smith [1988], theorem 60.)
*)



define /ev_iter hn hl y/
/
  ffix
    (fn iterf y .
       (case y of
        | inl x . hn x
 
        | inr xf .
            let next iter = iterf
            in
            let next x = xf
            in
              hl (next x) (next (iter x))))
    y
//
  intersect i (a : U i) (P : ev a -> U i) .
    (forall (x : a) . P (now x))
    -> (forall (xf : future (ev a)) .
          let next x = xf
          in
            future (P x) -> P (later x))
    -> forall (x : ev a) . P x
/;

inference.
introOf /i a P hn hl y/.
unfold /ev_iter/.
folds 2 /ffix ap i ap (forall (y : ev a) . P y)/.
fold /manual (sum_case _ _ _) within _ _/.
typecheck.
reintro /_ IH z/.
unrollType /ev in z/.
destruct /z/ /x | [x]/.
  {
  reduce //.
  typecheck.
  fold /now _/.
  reflexivity.
  }

  {
  reduce //.
  fold /laterf (next x)/.
  typecheck.
  }
qed ();



reductions
/
  ev_iter hn _ (now x) --> hn x ;
  ev_iter hn hl (laterf x) --> let next y = x in hl (next y) (next (ev_iter hn hl y)) ;
  ev_iter hn hl (later x) --> hl (next x) (next (ev_iter hn hl x)) ;
  unfolding ev_iter now laterf later letnext
  unrolling ffix
/;



lemma "bindev_id_left"
/
  forall i (a b : U i) (e : a) (f : a -> ev b) .
    (bindev x = now e in f x) = f e : ev b
/;

inference.
intro /i a b e f/.
reduce //.
reflexivity.
qed ();



lemma "bindev_id_right"
/
  forall i (a : U i) (m : ev a) .
    (bindev x = m in now x) = m : ev a
/;

inference.
intro /i a/.
apply /ev_iter/ >> reduce // >> auto.
(* later *)
intro /[x] [IH]/.
unfold /later at 0 0/.
compat.
compat.
hyp /IH/.
qed ();



lemma "bindev_assoc"
/
  forall i (a b c : U i) (e : ev a) (f : a -> ev b) (g : b -> ev c) .
    (bindev y = (bindev x = e in f x) in g y)
    =
    (bindev x = e in bindev y = f x in g y)
    : ev c
/;

inference.
intro /i a b c e f g/.
revert /e/.
apply /ev_iter/ >> reduce // >> auto.
(* later *)
intro /[x] [IH]/.
unfold /later at 0 0/.
compat.
compat.
hyp /IH/.
qed ();



lemma "bindevt_id_left"
/
  forall i (a : U i) (e : a) (t : a -> U i) .
    bindevt x = now e in t x = t e : U i
/;

inference.
intro /i a e t/.
reduce //.
reflexivity.
qed ();



lemma "bindevt_assoc"
/
  forall i (a b : U i) (e : ev a) (f : a -> ev b) (t : b -> U i) .
    (bindevt y = (bindev x = e in f x) in t y)
    =
    (bindevt x = e in bindevt y = f x in t y)
    : U i
/;

inference.
intro /i a b e f t/.
revert /e/.
apply /ev_iter/ >> reduce // >> auto.
(* later *)
intro /[x] [IH]/.
RuleTactic.futureEqUniv >> auto.
qed ();
  
  

lemma "bindevt_simple"
/
  parametric i (a : U i) . forall (e : ev a) . parametric (t : a -> U i) .
    (forall x . t x)
    -> bindevt x = e in t x
/;

inference.
intro /i a e t Hall/.
revert /e/.
apply /ev_iter/ >> reduce //.

(* now *)
{
apply /Hall/.
}

(* later *)
{
intro /[e] [IH]/.
split.
hyp /IH/.
}
qed ();



lemma "bindevt_map"
/
  forall i (a : U i) (b c : a -> U i) (e : ev a) .
    (forall (x : a) . b x -> c x)
    -> (bindevt x = e in b x)
    -> (bindevt x = e in c x)
/;

inference.
intro /i a b c e Himpl/.
revert /e/.
apply /ev_iter/ >> reduce // >> auto.
(* later *)
intro /[x] [IH] [H]/.
split.
apply /IH/ >> auto.
qed ();



lemma "bindevt_shift_future_out"
/
  forall i (a : U i) . forallfut (b : a -> U i) . forall (e : ev a) .
    (bindevt x = e in future (b x))
    -> future (bindevt x = e in b x)
/;

inference.
intro /i a b/.
apply /ev_iter/ >> reduce // >> auto.
intro /[xb] [IH] [H]/.
split.
apply /IH/ >> auto.
qed ();



lemma "bindevt_shift_future_in"
/
  forall i (a : U i) . forallfut (b : a -> U i) . forall (e : ev a) .
    future (bindevt x = e in b x)
    -> bindevt x = e in future (b x)
/;

inference.
intro /i a b/.
apply /ev_iter/ >> reduce // >> auto.
intro /[xb] [IH] [H]/.
split.
apply /IH/ >> auto.
qed ();



lemma "bindevt_shift_future_iff"
/
  forall i (a : U i) . forallfut (b : a -> U i) . forall (e : ev a) .
    (bindevt x = e in future (b x))
    <->
    future (bindevt x = e in b x)
/;

inference.
intro /i a b e/.
split >> autoWith /bindevt_shift_future_in bindevt_shift_future_out/.
qed ();



lemma "bindevt_commute"
/
  forall i (a b : U i) (c : a -> b -> U i) (e1 : ev a) (e2 : ev b) .
    (bindevt x = e1 in bindevt y = e2 in c x y)
    -> bindevt y = e2 in bindevt x = e1 in c x y
/;

inference.
intro /i a b c e1/.
apply /ev_iter/ >> reduce // >> auto.
intro /[yb] [IH] Hc/.
rewrite /-> bindevt_shift_future_iff in Hc/.
destruct /Hc/ /[H]/.
split.
apply /IH/ >> auto.
qed ();



lemma "bindevt_commute_iff"
/
  forall i (a b : U i) (c : a -> b -> U i) (e1 : ev a) (e2 : ev b) .
    (bindevt x = e1 in bindevt y = e2 in c x y)
    <->
    (bindevt y = e2 in bindevt x = e1 in c x y)
/;

inference.
intro /i a b c e1 e2/.
split >> autoWith /bindevt_commute/.
qed ();



lemma "sqstable_bindevt"
/
  intersect i (a : U i) (b : a -> U i) . forall (e : ev a) .
    (forall (x : a) . Sqstable.sqstable (b x))
    -> Sqstable.sqstable (`bindevt e b)
/;

inference.
intro /i a b e Hb/.
assert /SyntacticEquality.sequal b (fn x . b x)/ /Heq/.
  {
  RuleTactic.arrowEtaSequal (Term.evar ()) (Term.evar ()) >> auto.
  }
rewrite /-> Heq/.
revert /e/.
apply /ev_iter/ >> reduce // >> auto.
intro /[x]/.
reduce //.
intro /[H]/.
apply /Sqstable.sqstable_future/.
split.
hyp /H/.
qed ();
    


endModule ();
